#include "td/telegram/td_tdc_api_inner.h"

#include "td/utils/format.h"
#include "td/utils/logging.h"
#include "td/utils/misc.h"
#include "td/utils/Slice.h"
#include "td/utils/tl_storers.h"

td::td_api::object_ptr<td::td_api::Object> TdConvertToInternal (struct TdObject *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AccountTtl: return TdConvertToInternal ((struct TdAccountTtl *)var);
    case CODE_Address: return TdConvertToInternal ((struct TdAddress *)var);
    case CODE_Animation: return TdConvertToInternal ((struct TdAnimation *)var);
    case CODE_Animations: return TdConvertToInternal ((struct TdAnimations *)var);
    case CODE_Audio: return TdConvertToInternal ((struct TdAudio *)var);
    case CODE_AuthenticationCodeInfo: return TdConvertToInternal ((struct TdAuthenticationCodeInfo *)var);
    case CODE_AuthenticationCodeTypeTelegramMessage: return TdConvertToInternal ((struct TdAuthenticationCodeTypeTelegramMessage *)var);
    case CODE_AuthenticationCodeTypeSms: return TdConvertToInternal ((struct TdAuthenticationCodeTypeSms *)var);
    case CODE_AuthenticationCodeTypeCall: return TdConvertToInternal ((struct TdAuthenticationCodeTypeCall *)var);
    case CODE_AuthenticationCodeTypeFlashCall: return TdConvertToInternal ((struct TdAuthenticationCodeTypeFlashCall *)var);
    case CODE_AuthorizationStateWaitTdlibParameters: return TdConvertToInternal ((struct TdAuthorizationStateWaitTdlibParameters *)var);
    case CODE_AuthorizationStateWaitEncryptionKey: return TdConvertToInternal ((struct TdAuthorizationStateWaitEncryptionKey *)var);
    case CODE_AuthorizationStateWaitPhoneNumber: return TdConvertToInternal ((struct TdAuthorizationStateWaitPhoneNumber *)var);
    case CODE_AuthorizationStateWaitCode: return TdConvertToInternal ((struct TdAuthorizationStateWaitCode *)var);
    case CODE_AuthorizationStateWaitPassword: return TdConvertToInternal ((struct TdAuthorizationStateWaitPassword *)var);
    case CODE_AuthorizationStateReady: return TdConvertToInternal ((struct TdAuthorizationStateReady *)var);
    case CODE_AuthorizationStateLoggingOut: return TdConvertToInternal ((struct TdAuthorizationStateLoggingOut *)var);
    case CODE_AuthorizationStateClosing: return TdConvertToInternal ((struct TdAuthorizationStateClosing *)var);
    case CODE_AuthorizationStateClosed: return TdConvertToInternal ((struct TdAuthorizationStateClosed *)var);
    case CODE_BasicGroup: return TdConvertToInternal ((struct TdBasicGroup *)var);
    case CODE_BasicGroupFullInfo: return TdConvertToInternal ((struct TdBasicGroupFullInfo *)var);
    case CODE_BotCommand: return TdConvertToInternal ((struct TdBotCommand *)var);
    case CODE_BotInfo: return TdConvertToInternal ((struct TdBotInfo *)var);
    case CODE_Call: return TdConvertToInternal ((struct TdCall *)var);
    case CODE_CallConnection: return TdConvertToInternal ((struct TdCallConnection *)var);
    case CODE_CallDiscardReasonEmpty: return TdConvertToInternal ((struct TdCallDiscardReasonEmpty *)var);
    case CODE_CallDiscardReasonMissed: return TdConvertToInternal ((struct TdCallDiscardReasonMissed *)var);
    case CODE_CallDiscardReasonDeclined: return TdConvertToInternal ((struct TdCallDiscardReasonDeclined *)var);
    case CODE_CallDiscardReasonDisconnected: return TdConvertToInternal ((struct TdCallDiscardReasonDisconnected *)var);
    case CODE_CallDiscardReasonHungUp: return TdConvertToInternal ((struct TdCallDiscardReasonHungUp *)var);
    case CODE_CallId: return TdConvertToInternal ((struct TdCallId *)var);
    case CODE_CallProtocol: return TdConvertToInternal ((struct TdCallProtocol *)var);
    case CODE_CallStatePending: return TdConvertToInternal ((struct TdCallStatePending *)var);
    case CODE_CallStateExchangingKeys: return TdConvertToInternal ((struct TdCallStateExchangingKeys *)var);
    case CODE_CallStateReady: return TdConvertToInternal ((struct TdCallStateReady *)var);
    case CODE_CallStateHangingUp: return TdConvertToInternal ((struct TdCallStateHangingUp *)var);
    case CODE_CallStateDiscarded: return TdConvertToInternal ((struct TdCallStateDiscarded *)var);
    case CODE_CallStateError: return TdConvertToInternal ((struct TdCallStateError *)var);
    case CODE_CallbackQueryAnswer: return TdConvertToInternal ((struct TdCallbackQueryAnswer *)var);
    case CODE_CallbackQueryPayloadData: return TdConvertToInternal ((struct TdCallbackQueryPayloadData *)var);
    case CODE_CallbackQueryPayloadGame: return TdConvertToInternal ((struct TdCallbackQueryPayloadGame *)var);
    case CODE_Chat: return TdConvertToInternal ((struct TdChat *)var);
    case CODE_ChatActionTyping: return TdConvertToInternal ((struct TdChatActionTyping *)var);
    case CODE_ChatActionRecordingVideo: return TdConvertToInternal ((struct TdChatActionRecordingVideo *)var);
    case CODE_ChatActionUploadingVideo: return TdConvertToInternal ((struct TdChatActionUploadingVideo *)var);
    case CODE_ChatActionRecordingVoiceNote: return TdConvertToInternal ((struct TdChatActionRecordingVoiceNote *)var);
    case CODE_ChatActionUploadingVoiceNote: return TdConvertToInternal ((struct TdChatActionUploadingVoiceNote *)var);
    case CODE_ChatActionUploadingPhoto: return TdConvertToInternal ((struct TdChatActionUploadingPhoto *)var);
    case CODE_ChatActionUploadingDocument: return TdConvertToInternal ((struct TdChatActionUploadingDocument *)var);
    case CODE_ChatActionChoosingLocation: return TdConvertToInternal ((struct TdChatActionChoosingLocation *)var);
    case CODE_ChatActionChoosingContact: return TdConvertToInternal ((struct TdChatActionChoosingContact *)var);
    case CODE_ChatActionStartPlayingGame: return TdConvertToInternal ((struct TdChatActionStartPlayingGame *)var);
    case CODE_ChatActionRecordingVideoNote: return TdConvertToInternal ((struct TdChatActionRecordingVideoNote *)var);
    case CODE_ChatActionUploadingVideoNote: return TdConvertToInternal ((struct TdChatActionUploadingVideoNote *)var);
    case CODE_ChatActionCancel: return TdConvertToInternal ((struct TdChatActionCancel *)var);
    case CODE_ChatEvent: return TdConvertToInternal ((struct TdChatEvent *)var);
    case CODE_ChatEventMessageEdited: return TdConvertToInternal ((struct TdChatEventMessageEdited *)var);
    case CODE_ChatEventMessageDeleted: return TdConvertToInternal ((struct TdChatEventMessageDeleted *)var);
    case CODE_ChatEventMessagePinned: return TdConvertToInternal ((struct TdChatEventMessagePinned *)var);
    case CODE_ChatEventMessageUnpinned: return TdConvertToInternal ((struct TdChatEventMessageUnpinned *)var);
    case CODE_ChatEventMemberJoined: return TdConvertToInternal ((struct TdChatEventMemberJoined *)var);
    case CODE_ChatEventMemberLeft: return TdConvertToInternal ((struct TdChatEventMemberLeft *)var);
    case CODE_ChatEventMemberInvited: return TdConvertToInternal ((struct TdChatEventMemberInvited *)var);
    case CODE_ChatEventMemberPromoted: return TdConvertToInternal ((struct TdChatEventMemberPromoted *)var);
    case CODE_ChatEventMemberRestricted: return TdConvertToInternal ((struct TdChatEventMemberRestricted *)var);
    case CODE_ChatEventTitleChanged: return TdConvertToInternal ((struct TdChatEventTitleChanged *)var);
    case CODE_ChatEventDescriptionChanged: return TdConvertToInternal ((struct TdChatEventDescriptionChanged *)var);
    case CODE_ChatEventUsernameChanged: return TdConvertToInternal ((struct TdChatEventUsernameChanged *)var);
    case CODE_ChatEventPhotoChanged: return TdConvertToInternal ((struct TdChatEventPhotoChanged *)var);
    case CODE_ChatEventInvitesToggled: return TdConvertToInternal ((struct TdChatEventInvitesToggled *)var);
    case CODE_ChatEventSignMessagesToggled: return TdConvertToInternal ((struct TdChatEventSignMessagesToggled *)var);
    case CODE_ChatEventStickerSetChanged: return TdConvertToInternal ((struct TdChatEventStickerSetChanged *)var);
    case CODE_ChatEventIsAllHistoryAvailableToggled: return TdConvertToInternal ((struct TdChatEventIsAllHistoryAvailableToggled *)var);
    case CODE_ChatEventLogFilters: return TdConvertToInternal ((struct TdChatEventLogFilters *)var);
    case CODE_ChatEvents: return TdConvertToInternal ((struct TdChatEvents *)var);
    case CODE_ChatInviteLink: return TdConvertToInternal ((struct TdChatInviteLink *)var);
    case CODE_ChatInviteLinkInfo: return TdConvertToInternal ((struct TdChatInviteLinkInfo *)var);
    case CODE_ChatMember: return TdConvertToInternal ((struct TdChatMember *)var);
    case CODE_ChatMemberStatusCreator: return TdConvertToInternal ((struct TdChatMemberStatusCreator *)var);
    case CODE_ChatMemberStatusAdministrator: return TdConvertToInternal ((struct TdChatMemberStatusAdministrator *)var);
    case CODE_ChatMemberStatusMember: return TdConvertToInternal ((struct TdChatMemberStatusMember *)var);
    case CODE_ChatMemberStatusRestricted: return TdConvertToInternal ((struct TdChatMemberStatusRestricted *)var);
    case CODE_ChatMemberStatusLeft: return TdConvertToInternal ((struct TdChatMemberStatusLeft *)var);
    case CODE_ChatMemberStatusBanned: return TdConvertToInternal ((struct TdChatMemberStatusBanned *)var);
    case CODE_ChatMembers: return TdConvertToInternal ((struct TdChatMembers *)var);
    case CODE_ChatMembersFilterAdministrators: return TdConvertToInternal ((struct TdChatMembersFilterAdministrators *)var);
    case CODE_ChatMembersFilterMembers: return TdConvertToInternal ((struct TdChatMembersFilterMembers *)var);
    case CODE_ChatMembersFilterRestricted: return TdConvertToInternal ((struct TdChatMembersFilterRestricted *)var);
    case CODE_ChatMembersFilterBanned: return TdConvertToInternal ((struct TdChatMembersFilterBanned *)var);
    case CODE_ChatMembersFilterBots: return TdConvertToInternal ((struct TdChatMembersFilterBots *)var);
    case CODE_ChatNotificationSettings: return TdConvertToInternal ((struct TdChatNotificationSettings *)var);
    case CODE_ChatPhoto: return TdConvertToInternal ((struct TdChatPhoto *)var);
    case CODE_ChatReportReasonSpam: return TdConvertToInternal ((struct TdChatReportReasonSpam *)var);
    case CODE_ChatReportReasonViolence: return TdConvertToInternal ((struct TdChatReportReasonViolence *)var);
    case CODE_ChatReportReasonPornography: return TdConvertToInternal ((struct TdChatReportReasonPornography *)var);
    case CODE_ChatReportReasonCopyright: return TdConvertToInternal ((struct TdChatReportReasonCopyright *)var);
    case CODE_ChatReportReasonCustom: return TdConvertToInternal ((struct TdChatReportReasonCustom *)var);
    case CODE_ChatReportSpamState: return TdConvertToInternal ((struct TdChatReportSpamState *)var);
    case CODE_ChatTypePrivate: return TdConvertToInternal ((struct TdChatTypePrivate *)var);
    case CODE_ChatTypeBasicGroup: return TdConvertToInternal ((struct TdChatTypeBasicGroup *)var);
    case CODE_ChatTypeSupergroup: return TdConvertToInternal ((struct TdChatTypeSupergroup *)var);
    case CODE_ChatTypeSecret: return TdConvertToInternal ((struct TdChatTypeSecret *)var);
    case CODE_Chats: return TdConvertToInternal ((struct TdChats *)var);
    case CODE_CheckChatUsernameResultOk: return TdConvertToInternal ((struct TdCheckChatUsernameResultOk *)var);
    case CODE_CheckChatUsernameResultUsernameInvalid: return TdConvertToInternal ((struct TdCheckChatUsernameResultUsernameInvalid *)var);
    case CODE_CheckChatUsernameResultUsernameOccupied: return TdConvertToInternal ((struct TdCheckChatUsernameResultUsernameOccupied *)var);
    case CODE_CheckChatUsernameResultPublicChatsTooMuch: return TdConvertToInternal ((struct TdCheckChatUsernameResultPublicChatsTooMuch *)var);
    case CODE_CheckChatUsernameResultPublicGroupsUnavailable: return TdConvertToInternal ((struct TdCheckChatUsernameResultPublicGroupsUnavailable *)var);
    case CODE_ConnectedWebsite: return TdConvertToInternal ((struct TdConnectedWebsite *)var);
    case CODE_ConnectedWebsites: return TdConvertToInternal ((struct TdConnectedWebsites *)var);
    case CODE_ConnectionStateWaitingForNetwork: return TdConvertToInternal ((struct TdConnectionStateWaitingForNetwork *)var);
    case CODE_ConnectionStateConnectingToProxy: return TdConvertToInternal ((struct TdConnectionStateConnectingToProxy *)var);
    case CODE_ConnectionStateConnecting: return TdConvertToInternal ((struct TdConnectionStateConnecting *)var);
    case CODE_ConnectionStateUpdating: return TdConvertToInternal ((struct TdConnectionStateUpdating *)var);
    case CODE_ConnectionStateReady: return TdConvertToInternal ((struct TdConnectionStateReady *)var);
    case CODE_Contact: return TdConvertToInternal ((struct TdContact *)var);
    case CODE_Count: return TdConvertToInternal ((struct TdCount *)var);
    case CODE_CustomRequestResult: return TdConvertToInternal ((struct TdCustomRequestResult *)var);
    case CODE_Date: return TdConvertToInternal ((struct TdDate *)var);
    case CODE_DatedFile: return TdConvertToInternal ((struct TdDatedFile *)var);
    case CODE_DeepLinkInfo: return TdConvertToInternal ((struct TdDeepLinkInfo *)var);
    case CODE_DeviceTokenGoogleCloudMessaging: return TdConvertToInternal ((struct TdDeviceTokenGoogleCloudMessaging *)var);
    case CODE_DeviceTokenApplePush: return TdConvertToInternal ((struct TdDeviceTokenApplePush *)var);
    case CODE_DeviceTokenApplePushVoIP: return TdConvertToInternal ((struct TdDeviceTokenApplePushVoIP *)var);
    case CODE_DeviceTokenWindowsPush: return TdConvertToInternal ((struct TdDeviceTokenWindowsPush *)var);
    case CODE_DeviceTokenMicrosoftPush: return TdConvertToInternal ((struct TdDeviceTokenMicrosoftPush *)var);
    case CODE_DeviceTokenMicrosoftPushVoIP: return TdConvertToInternal ((struct TdDeviceTokenMicrosoftPushVoIP *)var);
    case CODE_DeviceTokenWebPush: return TdConvertToInternal ((struct TdDeviceTokenWebPush *)var);
    case CODE_DeviceTokenSimplePush: return TdConvertToInternal ((struct TdDeviceTokenSimplePush *)var);
    case CODE_DeviceTokenUbuntuPush: return TdConvertToInternal ((struct TdDeviceTokenUbuntuPush *)var);
    case CODE_DeviceTokenBlackBerryPush: return TdConvertToInternal ((struct TdDeviceTokenBlackBerryPush *)var);
    case CODE_DeviceTokenTizenPush: return TdConvertToInternal ((struct TdDeviceTokenTizenPush *)var);
    case CODE_Document: return TdConvertToInternal ((struct TdDocument *)var);
    case CODE_DraftMessage: return TdConvertToInternal ((struct TdDraftMessage *)var);
    case CODE_EmailAddressAuthenticationCodeInfo: return TdConvertToInternal ((struct TdEmailAddressAuthenticationCodeInfo *)var);
    case CODE_EncryptedCredentials: return TdConvertToInternal ((struct TdEncryptedCredentials *)var);
    case CODE_EncryptedPassportElement: return TdConvertToInternal ((struct TdEncryptedPassportElement *)var);
    case CODE_Error: return TdConvertToInternal ((struct TdError *)var);
    case CODE_File: return TdConvertToInternal ((struct TdFile *)var);
    case CODE_FileTypeNone: return TdConvertToInternal ((struct TdFileTypeNone *)var);
    case CODE_FileTypeAnimation: return TdConvertToInternal ((struct TdFileTypeAnimation *)var);
    case CODE_FileTypeAudio: return TdConvertToInternal ((struct TdFileTypeAudio *)var);
    case CODE_FileTypeDocument: return TdConvertToInternal ((struct TdFileTypeDocument *)var);
    case CODE_FileTypePhoto: return TdConvertToInternal ((struct TdFileTypePhoto *)var);
    case CODE_FileTypeProfilePhoto: return TdConvertToInternal ((struct TdFileTypeProfilePhoto *)var);
    case CODE_FileTypeSecret: return TdConvertToInternal ((struct TdFileTypeSecret *)var);
    case CODE_FileTypeSecretThumbnail: return TdConvertToInternal ((struct TdFileTypeSecretThumbnail *)var);
    case CODE_FileTypeSecure: return TdConvertToInternal ((struct TdFileTypeSecure *)var);
    case CODE_FileTypeSticker: return TdConvertToInternal ((struct TdFileTypeSticker *)var);
    case CODE_FileTypeThumbnail: return TdConvertToInternal ((struct TdFileTypeThumbnail *)var);
    case CODE_FileTypeUnknown: return TdConvertToInternal ((struct TdFileTypeUnknown *)var);
    case CODE_FileTypeVideo: return TdConvertToInternal ((struct TdFileTypeVideo *)var);
    case CODE_FileTypeVideoNote: return TdConvertToInternal ((struct TdFileTypeVideoNote *)var);
    case CODE_FileTypeVoiceNote: return TdConvertToInternal ((struct TdFileTypeVoiceNote *)var);
    case CODE_FileTypeWallpaper: return TdConvertToInternal ((struct TdFileTypeWallpaper *)var);
    case CODE_FormattedText: return TdConvertToInternal ((struct TdFormattedText *)var);
    case CODE_FoundMessages: return TdConvertToInternal ((struct TdFoundMessages *)var);
    case CODE_Game: return TdConvertToInternal ((struct TdGame *)var);
    case CODE_GameHighScore: return TdConvertToInternal ((struct TdGameHighScore *)var);
    case CODE_GameHighScores: return TdConvertToInternal ((struct TdGameHighScores *)var);
    case CODE_Hashtags: return TdConvertToInternal ((struct TdHashtags *)var);
    case CODE_IdentityDocument: return TdConvertToInternal ((struct TdIdentityDocument *)var);
    case CODE_ImportedContacts: return TdConvertToInternal ((struct TdImportedContacts *)var);
    case CODE_InlineKeyboardButton: return TdConvertToInternal ((struct TdInlineKeyboardButton *)var);
    case CODE_InlineKeyboardButtonTypeUrl: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeUrl *)var);
    case CODE_InlineKeyboardButtonTypeCallback: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeCallback *)var);
    case CODE_InlineKeyboardButtonTypeCallbackGame: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeCallbackGame *)var);
    case CODE_InlineKeyboardButtonTypeSwitchInline: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeSwitchInline *)var);
    case CODE_InlineKeyboardButtonTypeBuy: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeBuy *)var);
    case CODE_InlineQueryResultArticle: return TdConvertToInternal ((struct TdInlineQueryResultArticle *)var);
    case CODE_InlineQueryResultContact: return TdConvertToInternal ((struct TdInlineQueryResultContact *)var);
    case CODE_InlineQueryResultLocation: return TdConvertToInternal ((struct TdInlineQueryResultLocation *)var);
    case CODE_InlineQueryResultVenue: return TdConvertToInternal ((struct TdInlineQueryResultVenue *)var);
    case CODE_InlineQueryResultGame: return TdConvertToInternal ((struct TdInlineQueryResultGame *)var);
    case CODE_InlineQueryResultAnimation: return TdConvertToInternal ((struct TdInlineQueryResultAnimation *)var);
    case CODE_InlineQueryResultAudio: return TdConvertToInternal ((struct TdInlineQueryResultAudio *)var);
    case CODE_InlineQueryResultDocument: return TdConvertToInternal ((struct TdInlineQueryResultDocument *)var);
    case CODE_InlineQueryResultPhoto: return TdConvertToInternal ((struct TdInlineQueryResultPhoto *)var);
    case CODE_InlineQueryResultSticker: return TdConvertToInternal ((struct TdInlineQueryResultSticker *)var);
    case CODE_InlineQueryResultVideo: return TdConvertToInternal ((struct TdInlineQueryResultVideo *)var);
    case CODE_InlineQueryResultVoiceNote: return TdConvertToInternal ((struct TdInlineQueryResultVoiceNote *)var);
    case CODE_InlineQueryResults: return TdConvertToInternal ((struct TdInlineQueryResults *)var);
    case CODE_InputCredentialsSaved: return TdConvertToInternal ((struct TdInputCredentialsSaved *)var);
    case CODE_InputCredentialsNew: return TdConvertToInternal ((struct TdInputCredentialsNew *)var);
    case CODE_InputCredentialsAndroidPay: return TdConvertToInternal ((struct TdInputCredentialsAndroidPay *)var);
    case CODE_InputCredentialsApplePay: return TdConvertToInternal ((struct TdInputCredentialsApplePay *)var);
    case CODE_InputFileId: return TdConvertToInternal ((struct TdInputFileId *)var);
    case CODE_InputFileRemote: return TdConvertToInternal ((struct TdInputFileRemote *)var);
    case CODE_InputFileLocal: return TdConvertToInternal ((struct TdInputFileLocal *)var);
    case CODE_InputFileGenerated: return TdConvertToInternal ((struct TdInputFileGenerated *)var);
    case CODE_InputIdentityDocument: return TdConvertToInternal ((struct TdInputIdentityDocument *)var);
    case CODE_InputInlineQueryResultAnimatedGif: return TdConvertToInternal ((struct TdInputInlineQueryResultAnimatedGif *)var);
    case CODE_InputInlineQueryResultAnimatedMpeg4: return TdConvertToInternal ((struct TdInputInlineQueryResultAnimatedMpeg4 *)var);
    case CODE_InputInlineQueryResultArticle: return TdConvertToInternal ((struct TdInputInlineQueryResultArticle *)var);
    case CODE_InputInlineQueryResultAudio: return TdConvertToInternal ((struct TdInputInlineQueryResultAudio *)var);
    case CODE_InputInlineQueryResultContact: return TdConvertToInternal ((struct TdInputInlineQueryResultContact *)var);
    case CODE_InputInlineQueryResultDocument: return TdConvertToInternal ((struct TdInputInlineQueryResultDocument *)var);
    case CODE_InputInlineQueryResultGame: return TdConvertToInternal ((struct TdInputInlineQueryResultGame *)var);
    case CODE_InputInlineQueryResultLocation: return TdConvertToInternal ((struct TdInputInlineQueryResultLocation *)var);
    case CODE_InputInlineQueryResultPhoto: return TdConvertToInternal ((struct TdInputInlineQueryResultPhoto *)var);
    case CODE_InputInlineQueryResultSticker: return TdConvertToInternal ((struct TdInputInlineQueryResultSticker *)var);
    case CODE_InputInlineQueryResultVenue: return TdConvertToInternal ((struct TdInputInlineQueryResultVenue *)var);
    case CODE_InputInlineQueryResultVideo: return TdConvertToInternal ((struct TdInputInlineQueryResultVideo *)var);
    case CODE_InputInlineQueryResultVoiceNote: return TdConvertToInternal ((struct TdInputInlineQueryResultVoiceNote *)var);
    case CODE_InputMessageText: return TdConvertToInternal ((struct TdInputMessageText *)var);
    case CODE_InputMessageAnimation: return TdConvertToInternal ((struct TdInputMessageAnimation *)var);
    case CODE_InputMessageAudio: return TdConvertToInternal ((struct TdInputMessageAudio *)var);
    case CODE_InputMessageDocument: return TdConvertToInternal ((struct TdInputMessageDocument *)var);
    case CODE_InputMessagePhoto: return TdConvertToInternal ((struct TdInputMessagePhoto *)var);
    case CODE_InputMessageSticker: return TdConvertToInternal ((struct TdInputMessageSticker *)var);
    case CODE_InputMessageVideo: return TdConvertToInternal ((struct TdInputMessageVideo *)var);
    case CODE_InputMessageVideoNote: return TdConvertToInternal ((struct TdInputMessageVideoNote *)var);
    case CODE_InputMessageVoiceNote: return TdConvertToInternal ((struct TdInputMessageVoiceNote *)var);
    case CODE_InputMessageLocation: return TdConvertToInternal ((struct TdInputMessageLocation *)var);
    case CODE_InputMessageVenue: return TdConvertToInternal ((struct TdInputMessageVenue *)var);
    case CODE_InputMessageContact: return TdConvertToInternal ((struct TdInputMessageContact *)var);
    case CODE_InputMessageGame: return TdConvertToInternal ((struct TdInputMessageGame *)var);
    case CODE_InputMessageInvoice: return TdConvertToInternal ((struct TdInputMessageInvoice *)var);
    case CODE_InputMessageForwarded: return TdConvertToInternal ((struct TdInputMessageForwarded *)var);
    case CODE_InputPassportElementPersonalDetails: return TdConvertToInternal ((struct TdInputPassportElementPersonalDetails *)var);
    case CODE_InputPassportElementPassport: return TdConvertToInternal ((struct TdInputPassportElementPassport *)var);
    case CODE_InputPassportElementDriverLicense: return TdConvertToInternal ((struct TdInputPassportElementDriverLicense *)var);
    case CODE_InputPassportElementIdentityCard: return TdConvertToInternal ((struct TdInputPassportElementIdentityCard *)var);
    case CODE_InputPassportElementInternalPassport: return TdConvertToInternal ((struct TdInputPassportElementInternalPassport *)var);
    case CODE_InputPassportElementAddress: return TdConvertToInternal ((struct TdInputPassportElementAddress *)var);
    case CODE_InputPassportElementUtilityBill: return TdConvertToInternal ((struct TdInputPassportElementUtilityBill *)var);
    case CODE_InputPassportElementBankStatement: return TdConvertToInternal ((struct TdInputPassportElementBankStatement *)var);
    case CODE_InputPassportElementRentalAgreement: return TdConvertToInternal ((struct TdInputPassportElementRentalAgreement *)var);
    case CODE_InputPassportElementPassportRegistration: return TdConvertToInternal ((struct TdInputPassportElementPassportRegistration *)var);
    case CODE_InputPassportElementTemporaryRegistration: return TdConvertToInternal ((struct TdInputPassportElementTemporaryRegistration *)var);
    case CODE_InputPassportElementPhoneNumber: return TdConvertToInternal ((struct TdInputPassportElementPhoneNumber *)var);
    case CODE_InputPassportElementEmailAddress: return TdConvertToInternal ((struct TdInputPassportElementEmailAddress *)var);
    case CODE_InputPassportElementError: return TdConvertToInternal ((struct TdInputPassportElementError *)var);
    case CODE_InputPassportElementErrorSourceUnspecified: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceUnspecified *)var);
    case CODE_InputPassportElementErrorSourceDataField: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceDataField *)var);
    case CODE_InputPassportElementErrorSourceFrontSide: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceFrontSide *)var);
    case CODE_InputPassportElementErrorSourceReverseSide: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceReverseSide *)var);
    case CODE_InputPassportElementErrorSourceSelfie: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceSelfie *)var);
    case CODE_InputPassportElementErrorSourceTranslationFile: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceTranslationFile *)var);
    case CODE_InputPassportElementErrorSourceTranslationFiles: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceTranslationFiles *)var);
    case CODE_InputPassportElementErrorSourceFile: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceFile *)var);
    case CODE_InputPassportElementErrorSourceFiles: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceFiles *)var);
    case CODE_InputPersonalDocument: return TdConvertToInternal ((struct TdInputPersonalDocument *)var);
    case CODE_InputSticker: return TdConvertToInternal ((struct TdInputSticker *)var);
    case CODE_InputThumbnail: return TdConvertToInternal ((struct TdInputThumbnail *)var);
    case CODE_Invoice: return TdConvertToInternal ((struct TdInvoice *)var);
    case CODE_KeyboardButton: return TdConvertToInternal ((struct TdKeyboardButton *)var);
    case CODE_KeyboardButtonTypeText: return TdConvertToInternal ((struct TdKeyboardButtonTypeText *)var);
    case CODE_KeyboardButtonTypeRequestPhoneNumber: return TdConvertToInternal ((struct TdKeyboardButtonTypeRequestPhoneNumber *)var);
    case CODE_KeyboardButtonTypeRequestLocation: return TdConvertToInternal ((struct TdKeyboardButtonTypeRequestLocation *)var);
    case CODE_LabeledPricePart: return TdConvertToInternal ((struct TdLabeledPricePart *)var);
    case CODE_LanguagePackInfo: return TdConvertToInternal ((struct TdLanguagePackInfo *)var);
    case CODE_LanguagePackString: return TdConvertToInternal ((struct TdLanguagePackString *)var);
    case CODE_LanguagePackStringValueOrdinary: return TdConvertToInternal ((struct TdLanguagePackStringValueOrdinary *)var);
    case CODE_LanguagePackStringValuePluralized: return TdConvertToInternal ((struct TdLanguagePackStringValuePluralized *)var);
    case CODE_LanguagePackStringValueDeleted: return TdConvertToInternal ((struct TdLanguagePackStringValueDeleted *)var);
    case CODE_LanguagePackStrings: return TdConvertToInternal ((struct TdLanguagePackStrings *)var);
    case CODE_LinkStateNone: return TdConvertToInternal ((struct TdLinkStateNone *)var);
    case CODE_LinkStateKnowsPhoneNumber: return TdConvertToInternal ((struct TdLinkStateKnowsPhoneNumber *)var);
    case CODE_LinkStateIsContact: return TdConvertToInternal ((struct TdLinkStateIsContact *)var);
    case CODE_LocalFile: return TdConvertToInternal ((struct TdLocalFile *)var);
    case CODE_LocalizationTargetInfo: return TdConvertToInternal ((struct TdLocalizationTargetInfo *)var);
    case CODE_Location: return TdConvertToInternal ((struct TdLocation *)var);
    case CODE_MaskPointForehead: return TdConvertToInternal ((struct TdMaskPointForehead *)var);
    case CODE_MaskPointEyes: return TdConvertToInternal ((struct TdMaskPointEyes *)var);
    case CODE_MaskPointMouth: return TdConvertToInternal ((struct TdMaskPointMouth *)var);
    case CODE_MaskPointChin: return TdConvertToInternal ((struct TdMaskPointChin *)var);
    case CODE_MaskPosition: return TdConvertToInternal ((struct TdMaskPosition *)var);
    case CODE_Message: return TdConvertToInternal ((struct TdMessage *)var);
    case CODE_MessageText: return TdConvertToInternal ((struct TdMessageText *)var);
    case CODE_MessageAnimation: return TdConvertToInternal ((struct TdMessageAnimation *)var);
    case CODE_MessageAudio: return TdConvertToInternal ((struct TdMessageAudio *)var);
    case CODE_MessageDocument: return TdConvertToInternal ((struct TdMessageDocument *)var);
    case CODE_MessagePhoto: return TdConvertToInternal ((struct TdMessagePhoto *)var);
    case CODE_MessageExpiredPhoto: return TdConvertToInternal ((struct TdMessageExpiredPhoto *)var);
    case CODE_MessageSticker: return TdConvertToInternal ((struct TdMessageSticker *)var);
    case CODE_MessageVideo: return TdConvertToInternal ((struct TdMessageVideo *)var);
    case CODE_MessageExpiredVideo: return TdConvertToInternal ((struct TdMessageExpiredVideo *)var);
    case CODE_MessageVideoNote: return TdConvertToInternal ((struct TdMessageVideoNote *)var);
    case CODE_MessageVoiceNote: return TdConvertToInternal ((struct TdMessageVoiceNote *)var);
    case CODE_MessageLocation: return TdConvertToInternal ((struct TdMessageLocation *)var);
    case CODE_MessageVenue: return TdConvertToInternal ((struct TdMessageVenue *)var);
    case CODE_MessageContact: return TdConvertToInternal ((struct TdMessageContact *)var);
    case CODE_MessageGame: return TdConvertToInternal ((struct TdMessageGame *)var);
    case CODE_MessageInvoice: return TdConvertToInternal ((struct TdMessageInvoice *)var);
    case CODE_MessageCall: return TdConvertToInternal ((struct TdMessageCall *)var);
    case CODE_MessageBasicGroupChatCreate: return TdConvertToInternal ((struct TdMessageBasicGroupChatCreate *)var);
    case CODE_MessageSupergroupChatCreate: return TdConvertToInternal ((struct TdMessageSupergroupChatCreate *)var);
    case CODE_MessageChatChangeTitle: return TdConvertToInternal ((struct TdMessageChatChangeTitle *)var);
    case CODE_MessageChatChangePhoto: return TdConvertToInternal ((struct TdMessageChatChangePhoto *)var);
    case CODE_MessageChatDeletePhoto: return TdConvertToInternal ((struct TdMessageChatDeletePhoto *)var);
    case CODE_MessageChatAddMembers: return TdConvertToInternal ((struct TdMessageChatAddMembers *)var);
    case CODE_MessageChatJoinByLink: return TdConvertToInternal ((struct TdMessageChatJoinByLink *)var);
    case CODE_MessageChatDeleteMember: return TdConvertToInternal ((struct TdMessageChatDeleteMember *)var);
    case CODE_MessageChatUpgradeTo: return TdConvertToInternal ((struct TdMessageChatUpgradeTo *)var);
    case CODE_MessageChatUpgradeFrom: return TdConvertToInternal ((struct TdMessageChatUpgradeFrom *)var);
    case CODE_MessagePinMessage: return TdConvertToInternal ((struct TdMessagePinMessage *)var);
    case CODE_MessageScreenshotTaken: return TdConvertToInternal ((struct TdMessageScreenshotTaken *)var);
    case CODE_MessageChatSetTtl: return TdConvertToInternal ((struct TdMessageChatSetTtl *)var);
    case CODE_MessageCustomServiceAction: return TdConvertToInternal ((struct TdMessageCustomServiceAction *)var);
    case CODE_MessageGameScore: return TdConvertToInternal ((struct TdMessageGameScore *)var);
    case CODE_MessagePaymentSuccessful: return TdConvertToInternal ((struct TdMessagePaymentSuccessful *)var);
    case CODE_MessagePaymentSuccessfulBot: return TdConvertToInternal ((struct TdMessagePaymentSuccessfulBot *)var);
    case CODE_MessageContactRegistered: return TdConvertToInternal ((struct TdMessageContactRegistered *)var);
    case CODE_MessageWebsiteConnected: return TdConvertToInternal ((struct TdMessageWebsiteConnected *)var);
    case CODE_MessagePassportDataSent: return TdConvertToInternal ((struct TdMessagePassportDataSent *)var);
    case CODE_MessagePassportDataReceived: return TdConvertToInternal ((struct TdMessagePassportDataReceived *)var);
    case CODE_MessageUnsupported: return TdConvertToInternal ((struct TdMessageUnsupported *)var);
    case CODE_MessageForwardedFromUser: return TdConvertToInternal ((struct TdMessageForwardedFromUser *)var);
    case CODE_MessageForwardedPost: return TdConvertToInternal ((struct TdMessageForwardedPost *)var);
    case CODE_MessageSendingStatePending: return TdConvertToInternal ((struct TdMessageSendingStatePending *)var);
    case CODE_MessageSendingStateFailed: return TdConvertToInternal ((struct TdMessageSendingStateFailed *)var);
    case CODE_Messages: return TdConvertToInternal ((struct TdMessages *)var);
    case CODE_NetworkStatistics: return TdConvertToInternal ((struct TdNetworkStatistics *)var);
    case CODE_NetworkStatisticsEntryFile: return TdConvertToInternal ((struct TdNetworkStatisticsEntryFile *)var);
    case CODE_NetworkStatisticsEntryCall: return TdConvertToInternal ((struct TdNetworkStatisticsEntryCall *)var);
    case CODE_NetworkTypeNone: return TdConvertToInternal ((struct TdNetworkTypeNone *)var);
    case CODE_NetworkTypeMobile: return TdConvertToInternal ((struct TdNetworkTypeMobile *)var);
    case CODE_NetworkTypeMobileRoaming: return TdConvertToInternal ((struct TdNetworkTypeMobileRoaming *)var);
    case CODE_NetworkTypeWiFi: return TdConvertToInternal ((struct TdNetworkTypeWiFi *)var);
    case CODE_NetworkTypeOther: return TdConvertToInternal ((struct TdNetworkTypeOther *)var);
    case CODE_NotificationSettingsScopePrivateChats: return TdConvertToInternal ((struct TdNotificationSettingsScopePrivateChats *)var);
    case CODE_NotificationSettingsScopeGroupChats: return TdConvertToInternal ((struct TdNotificationSettingsScopeGroupChats *)var);
    case CODE_Ok: return TdConvertToInternal ((struct TdOk *)var);
    case CODE_OptionValueBoolean: return TdConvertToInternal ((struct TdOptionValueBoolean *)var);
    case CODE_OptionValueEmpty: return TdConvertToInternal ((struct TdOptionValueEmpty *)var);
    case CODE_OptionValueInteger: return TdConvertToInternal ((struct TdOptionValueInteger *)var);
    case CODE_OptionValueString: return TdConvertToInternal ((struct TdOptionValueString *)var);
    case CODE_OrderInfo: return TdConvertToInternal ((struct TdOrderInfo *)var);
    case CODE_PageBlockTitle: return TdConvertToInternal ((struct TdPageBlockTitle *)var);
    case CODE_PageBlockSubtitle: return TdConvertToInternal ((struct TdPageBlockSubtitle *)var);
    case CODE_PageBlockAuthorDate: return TdConvertToInternal ((struct TdPageBlockAuthorDate *)var);
    case CODE_PageBlockHeader: return TdConvertToInternal ((struct TdPageBlockHeader *)var);
    case CODE_PageBlockSubheader: return TdConvertToInternal ((struct TdPageBlockSubheader *)var);
    case CODE_PageBlockParagraph: return TdConvertToInternal ((struct TdPageBlockParagraph *)var);
    case CODE_PageBlockPreformatted: return TdConvertToInternal ((struct TdPageBlockPreformatted *)var);
    case CODE_PageBlockFooter: return TdConvertToInternal ((struct TdPageBlockFooter *)var);
    case CODE_PageBlockDivider: return TdConvertToInternal ((struct TdPageBlockDivider *)var);
    case CODE_PageBlockAnchor: return TdConvertToInternal ((struct TdPageBlockAnchor *)var);
    case CODE_PageBlockList: return TdConvertToInternal ((struct TdPageBlockList *)var);
    case CODE_PageBlockBlockQuote: return TdConvertToInternal ((struct TdPageBlockBlockQuote *)var);
    case CODE_PageBlockPullQuote: return TdConvertToInternal ((struct TdPageBlockPullQuote *)var);
    case CODE_PageBlockAnimation: return TdConvertToInternal ((struct TdPageBlockAnimation *)var);
    case CODE_PageBlockAudio: return TdConvertToInternal ((struct TdPageBlockAudio *)var);
    case CODE_PageBlockPhoto: return TdConvertToInternal ((struct TdPageBlockPhoto *)var);
    case CODE_PageBlockVideo: return TdConvertToInternal ((struct TdPageBlockVideo *)var);
    case CODE_PageBlockCover: return TdConvertToInternal ((struct TdPageBlockCover *)var);
    case CODE_PageBlockEmbedded: return TdConvertToInternal ((struct TdPageBlockEmbedded *)var);
    case CODE_PageBlockEmbeddedPost: return TdConvertToInternal ((struct TdPageBlockEmbeddedPost *)var);
    case CODE_PageBlockCollage: return TdConvertToInternal ((struct TdPageBlockCollage *)var);
    case CODE_PageBlockSlideshow: return TdConvertToInternal ((struct TdPageBlockSlideshow *)var);
    case CODE_PageBlockChatLink: return TdConvertToInternal ((struct TdPageBlockChatLink *)var);
    case CODE_PassportAuthorizationForm: return TdConvertToInternal ((struct TdPassportAuthorizationForm *)var);
    case CODE_PassportElementPersonalDetails: return TdConvertToInternal ((struct TdPassportElementPersonalDetails *)var);
    case CODE_PassportElementPassport: return TdConvertToInternal ((struct TdPassportElementPassport *)var);
    case CODE_PassportElementDriverLicense: return TdConvertToInternal ((struct TdPassportElementDriverLicense *)var);
    case CODE_PassportElementIdentityCard: return TdConvertToInternal ((struct TdPassportElementIdentityCard *)var);
    case CODE_PassportElementInternalPassport: return TdConvertToInternal ((struct TdPassportElementInternalPassport *)var);
    case CODE_PassportElementAddress: return TdConvertToInternal ((struct TdPassportElementAddress *)var);
    case CODE_PassportElementUtilityBill: return TdConvertToInternal ((struct TdPassportElementUtilityBill *)var);
    case CODE_PassportElementBankStatement: return TdConvertToInternal ((struct TdPassportElementBankStatement *)var);
    case CODE_PassportElementRentalAgreement: return TdConvertToInternal ((struct TdPassportElementRentalAgreement *)var);
    case CODE_PassportElementPassportRegistration: return TdConvertToInternal ((struct TdPassportElementPassportRegistration *)var);
    case CODE_PassportElementTemporaryRegistration: return TdConvertToInternal ((struct TdPassportElementTemporaryRegistration *)var);
    case CODE_PassportElementPhoneNumber: return TdConvertToInternal ((struct TdPassportElementPhoneNumber *)var);
    case CODE_PassportElementEmailAddress: return TdConvertToInternal ((struct TdPassportElementEmailAddress *)var);
    case CODE_PassportElementError: return TdConvertToInternal ((struct TdPassportElementError *)var);
    case CODE_PassportElementErrorSourceUnspecified: return TdConvertToInternal ((struct TdPassportElementErrorSourceUnspecified *)var);
    case CODE_PassportElementErrorSourceDataField: return TdConvertToInternal ((struct TdPassportElementErrorSourceDataField *)var);
    case CODE_PassportElementErrorSourceFrontSide: return TdConvertToInternal ((struct TdPassportElementErrorSourceFrontSide *)var);
    case CODE_PassportElementErrorSourceReverseSide: return TdConvertToInternal ((struct TdPassportElementErrorSourceReverseSide *)var);
    case CODE_PassportElementErrorSourceSelfie: return TdConvertToInternal ((struct TdPassportElementErrorSourceSelfie *)var);
    case CODE_PassportElementErrorSourceTranslationFile: return TdConvertToInternal ((struct TdPassportElementErrorSourceTranslationFile *)var);
    case CODE_PassportElementErrorSourceTranslationFiles: return TdConvertToInternal ((struct TdPassportElementErrorSourceTranslationFiles *)var);
    case CODE_PassportElementErrorSourceFile: return TdConvertToInternal ((struct TdPassportElementErrorSourceFile *)var);
    case CODE_PassportElementErrorSourceFiles: return TdConvertToInternal ((struct TdPassportElementErrorSourceFiles *)var);
    case CODE_PassportElementTypePersonalDetails: return TdConvertToInternal ((struct TdPassportElementTypePersonalDetails *)var);
    case CODE_PassportElementTypePassport: return TdConvertToInternal ((struct TdPassportElementTypePassport *)var);
    case CODE_PassportElementTypeDriverLicense: return TdConvertToInternal ((struct TdPassportElementTypeDriverLicense *)var);
    case CODE_PassportElementTypeIdentityCard: return TdConvertToInternal ((struct TdPassportElementTypeIdentityCard *)var);
    case CODE_PassportElementTypeInternalPassport: return TdConvertToInternal ((struct TdPassportElementTypeInternalPassport *)var);
    case CODE_PassportElementTypeAddress: return TdConvertToInternal ((struct TdPassportElementTypeAddress *)var);
    case CODE_PassportElementTypeUtilityBill: return TdConvertToInternal ((struct TdPassportElementTypeUtilityBill *)var);
    case CODE_PassportElementTypeBankStatement: return TdConvertToInternal ((struct TdPassportElementTypeBankStatement *)var);
    case CODE_PassportElementTypeRentalAgreement: return TdConvertToInternal ((struct TdPassportElementTypeRentalAgreement *)var);
    case CODE_PassportElementTypePassportRegistration: return TdConvertToInternal ((struct TdPassportElementTypePassportRegistration *)var);
    case CODE_PassportElementTypeTemporaryRegistration: return TdConvertToInternal ((struct TdPassportElementTypeTemporaryRegistration *)var);
    case CODE_PassportElementTypePhoneNumber: return TdConvertToInternal ((struct TdPassportElementTypePhoneNumber *)var);
    case CODE_PassportElementTypeEmailAddress: return TdConvertToInternal ((struct TdPassportElementTypeEmailAddress *)var);
    case CODE_PassportElements: return TdConvertToInternal ((struct TdPassportElements *)var);
    case CODE_PassportRequiredElement: return TdConvertToInternal ((struct TdPassportRequiredElement *)var);
    case CODE_PassportSuitableElement: return TdConvertToInternal ((struct TdPassportSuitableElement *)var);
    case CODE_PasswordState: return TdConvertToInternal ((struct TdPasswordState *)var);
    case CODE_PaymentForm: return TdConvertToInternal ((struct TdPaymentForm *)var);
    case CODE_PaymentReceipt: return TdConvertToInternal ((struct TdPaymentReceipt *)var);
    case CODE_PaymentResult: return TdConvertToInternal ((struct TdPaymentResult *)var);
    case CODE_PaymentsProviderStripe: return TdConvertToInternal ((struct TdPaymentsProviderStripe *)var);
    case CODE_PersonalDetails: return TdConvertToInternal ((struct TdPersonalDetails *)var);
    case CODE_PersonalDocument: return TdConvertToInternal ((struct TdPersonalDocument *)var);
    case CODE_Photo: return TdConvertToInternal ((struct TdPhoto *)var);
    case CODE_PhotoSize: return TdConvertToInternal ((struct TdPhotoSize *)var);
    case CODE_ProfilePhoto: return TdConvertToInternal ((struct TdProfilePhoto *)var);
    case CODE_Proxies: return TdConvertToInternal ((struct TdProxies *)var);
    case CODE_Proxy: return TdConvertToInternal ((struct TdProxy *)var);
    case CODE_ProxyTypeSocks5: return TdConvertToInternal ((struct TdProxyTypeSocks5 *)var);
    case CODE_ProxyTypeHttp: return TdConvertToInternal ((struct TdProxyTypeHttp *)var);
    case CODE_ProxyTypeMtproto: return TdConvertToInternal ((struct TdProxyTypeMtproto *)var);
    case CODE_PublicMessageLink: return TdConvertToInternal ((struct TdPublicMessageLink *)var);
    case CODE_RecoveryEmailAddress: return TdConvertToInternal ((struct TdRecoveryEmailAddress *)var);
    case CODE_RemoteFile: return TdConvertToInternal ((struct TdRemoteFile *)var);
    case CODE_ReplyMarkupRemoveKeyboard: return TdConvertToInternal ((struct TdReplyMarkupRemoveKeyboard *)var);
    case CODE_ReplyMarkupForceReply: return TdConvertToInternal ((struct TdReplyMarkupForceReply *)var);
    case CODE_ReplyMarkupShowKeyboard: return TdConvertToInternal ((struct TdReplyMarkupShowKeyboard *)var);
    case CODE_ReplyMarkupInlineKeyboard: return TdConvertToInternal ((struct TdReplyMarkupInlineKeyboard *)var);
    case CODE_RichTextPlain: return TdConvertToInternal ((struct TdRichTextPlain *)var);
    case CODE_RichTextBold: return TdConvertToInternal ((struct TdRichTextBold *)var);
    case CODE_RichTextItalic: return TdConvertToInternal ((struct TdRichTextItalic *)var);
    case CODE_RichTextUnderline: return TdConvertToInternal ((struct TdRichTextUnderline *)var);
    case CODE_RichTextStrikethrough: return TdConvertToInternal ((struct TdRichTextStrikethrough *)var);
    case CODE_RichTextFixed: return TdConvertToInternal ((struct TdRichTextFixed *)var);
    case CODE_RichTextUrl: return TdConvertToInternal ((struct TdRichTextUrl *)var);
    case CODE_RichTextEmailAddress: return TdConvertToInternal ((struct TdRichTextEmailAddress *)var);
    case CODE_RichTexts: return TdConvertToInternal ((struct TdRichTexts *)var);
    case CODE_SavedCredentials: return TdConvertToInternal ((struct TdSavedCredentials *)var);
    case CODE_ScopeNotificationSettings: return TdConvertToInternal ((struct TdScopeNotificationSettings *)var);
    case CODE_SearchMessagesFilterEmpty: return TdConvertToInternal ((struct TdSearchMessagesFilterEmpty *)var);
    case CODE_SearchMessagesFilterAnimation: return TdConvertToInternal ((struct TdSearchMessagesFilterAnimation *)var);
    case CODE_SearchMessagesFilterAudio: return TdConvertToInternal ((struct TdSearchMessagesFilterAudio *)var);
    case CODE_SearchMessagesFilterDocument: return TdConvertToInternal ((struct TdSearchMessagesFilterDocument *)var);
    case CODE_SearchMessagesFilterPhoto: return TdConvertToInternal ((struct TdSearchMessagesFilterPhoto *)var);
    case CODE_SearchMessagesFilterVideo: return TdConvertToInternal ((struct TdSearchMessagesFilterVideo *)var);
    case CODE_SearchMessagesFilterVoiceNote: return TdConvertToInternal ((struct TdSearchMessagesFilterVoiceNote *)var);
    case CODE_SearchMessagesFilterPhotoAndVideo: return TdConvertToInternal ((struct TdSearchMessagesFilterPhotoAndVideo *)var);
    case CODE_SearchMessagesFilterUrl: return TdConvertToInternal ((struct TdSearchMessagesFilterUrl *)var);
    case CODE_SearchMessagesFilterChatPhoto: return TdConvertToInternal ((struct TdSearchMessagesFilterChatPhoto *)var);
    case CODE_SearchMessagesFilterCall: return TdConvertToInternal ((struct TdSearchMessagesFilterCall *)var);
    case CODE_SearchMessagesFilterMissedCall: return TdConvertToInternal ((struct TdSearchMessagesFilterMissedCall *)var);
    case CODE_SearchMessagesFilterVideoNote: return TdConvertToInternal ((struct TdSearchMessagesFilterVideoNote *)var);
    case CODE_SearchMessagesFilterVoiceAndVideoNote: return TdConvertToInternal ((struct TdSearchMessagesFilterVoiceAndVideoNote *)var);
    case CODE_SearchMessagesFilterMention: return TdConvertToInternal ((struct TdSearchMessagesFilterMention *)var);
    case CODE_SearchMessagesFilterUnreadMention: return TdConvertToInternal ((struct TdSearchMessagesFilterUnreadMention *)var);
    case CODE_Seconds: return TdConvertToInternal ((struct TdSeconds *)var);
    case CODE_SecretChat: return TdConvertToInternal ((struct TdSecretChat *)var);
    case CODE_SecretChatStatePending: return TdConvertToInternal ((struct TdSecretChatStatePending *)var);
    case CODE_SecretChatStateReady: return TdConvertToInternal ((struct TdSecretChatStateReady *)var);
    case CODE_SecretChatStateClosed: return TdConvertToInternal ((struct TdSecretChatStateClosed *)var);
    case CODE_Session: return TdConvertToInternal ((struct TdSession *)var);
    case CODE_Sessions: return TdConvertToInternal ((struct TdSessions *)var);
    case CODE_ShippingOption: return TdConvertToInternal ((struct TdShippingOption *)var);
    case CODE_Sticker: return TdConvertToInternal ((struct TdSticker *)var);
    case CODE_StickerEmojis: return TdConvertToInternal ((struct TdStickerEmojis *)var);
    case CODE_StickerSet: return TdConvertToInternal ((struct TdStickerSet *)var);
    case CODE_StickerSetInfo: return TdConvertToInternal ((struct TdStickerSetInfo *)var);
    case CODE_StickerSets: return TdConvertToInternal ((struct TdStickerSets *)var);
    case CODE_Stickers: return TdConvertToInternal ((struct TdStickers *)var);
    case CODE_StorageStatistics: return TdConvertToInternal ((struct TdStorageStatistics *)var);
    case CODE_StorageStatisticsByChat: return TdConvertToInternal ((struct TdStorageStatisticsByChat *)var);
    case CODE_StorageStatisticsByFileType: return TdConvertToInternal ((struct TdStorageStatisticsByFileType *)var);
    case CODE_StorageStatisticsFast: return TdConvertToInternal ((struct TdStorageStatisticsFast *)var);
    case CODE_Supergroup: return TdConvertToInternal ((struct TdSupergroup *)var);
    case CODE_SupergroupFullInfo: return TdConvertToInternal ((struct TdSupergroupFullInfo *)var);
    case CODE_SupergroupMembersFilterRecent: return TdConvertToInternal ((struct TdSupergroupMembersFilterRecent *)var);
    case CODE_SupergroupMembersFilterAdministrators: return TdConvertToInternal ((struct TdSupergroupMembersFilterAdministrators *)var);
    case CODE_SupergroupMembersFilterSearch: return TdConvertToInternal ((struct TdSupergroupMembersFilterSearch *)var);
    case CODE_SupergroupMembersFilterRestricted: return TdConvertToInternal ((struct TdSupergroupMembersFilterRestricted *)var);
    case CODE_SupergroupMembersFilterBanned: return TdConvertToInternal ((struct TdSupergroupMembersFilterBanned *)var);
    case CODE_SupergroupMembersFilterBots: return TdConvertToInternal ((struct TdSupergroupMembersFilterBots *)var);
    case CODE_TMeUrl: return TdConvertToInternal ((struct TdTMeUrl *)var);
    case CODE_TMeUrlTypeUser: return TdConvertToInternal ((struct TdTMeUrlTypeUser *)var);
    case CODE_TMeUrlTypeSupergroup: return TdConvertToInternal ((struct TdTMeUrlTypeSupergroup *)var);
    case CODE_TMeUrlTypeChatInvite: return TdConvertToInternal ((struct TdTMeUrlTypeChatInvite *)var);
    case CODE_TMeUrlTypeStickerSet: return TdConvertToInternal ((struct TdTMeUrlTypeStickerSet *)var);
    case CODE_TMeUrls: return TdConvertToInternal ((struct TdTMeUrls *)var);
    case CODE_TdlibParameters: return TdConvertToInternal ((struct TdTdlibParameters *)var);
    case CODE_TemporaryPasswordState: return TdConvertToInternal ((struct TdTemporaryPasswordState *)var);
    case CODE_TermsOfService: return TdConvertToInternal ((struct TdTermsOfService *)var);
    case CODE_TestBytes: return TdConvertToInternal ((struct TdTestBytes *)var);
    case CODE_TestInt: return TdConvertToInternal ((struct TdTestInt *)var);
    case CODE_TestString: return TdConvertToInternal ((struct TdTestString *)var);
    case CODE_TestVectorInt: return TdConvertToInternal ((struct TdTestVectorInt *)var);
    case CODE_TestVectorIntObject: return TdConvertToInternal ((struct TdTestVectorIntObject *)var);
    case CODE_TestVectorString: return TdConvertToInternal ((struct TdTestVectorString *)var);
    case CODE_TestVectorStringObject: return TdConvertToInternal ((struct TdTestVectorStringObject *)var);
    case CODE_Text: return TdConvertToInternal ((struct TdText *)var);
    case CODE_TextEntities: return TdConvertToInternal ((struct TdTextEntities *)var);
    case CODE_TextEntity: return TdConvertToInternal ((struct TdTextEntity *)var);
    case CODE_TextEntityTypeMention: return TdConvertToInternal ((struct TdTextEntityTypeMention *)var);
    case CODE_TextEntityTypeHashtag: return TdConvertToInternal ((struct TdTextEntityTypeHashtag *)var);
    case CODE_TextEntityTypeCashtag: return TdConvertToInternal ((struct TdTextEntityTypeCashtag *)var);
    case CODE_TextEntityTypeBotCommand: return TdConvertToInternal ((struct TdTextEntityTypeBotCommand *)var);
    case CODE_TextEntityTypeUrl: return TdConvertToInternal ((struct TdTextEntityTypeUrl *)var);
    case CODE_TextEntityTypeEmailAddress: return TdConvertToInternal ((struct TdTextEntityTypeEmailAddress *)var);
    case CODE_TextEntityTypeBold: return TdConvertToInternal ((struct TdTextEntityTypeBold *)var);
    case CODE_TextEntityTypeItalic: return TdConvertToInternal ((struct TdTextEntityTypeItalic *)var);
    case CODE_TextEntityTypeCode: return TdConvertToInternal ((struct TdTextEntityTypeCode *)var);
    case CODE_TextEntityTypePre: return TdConvertToInternal ((struct TdTextEntityTypePre *)var);
    case CODE_TextEntityTypePreCode: return TdConvertToInternal ((struct TdTextEntityTypePreCode *)var);
    case CODE_TextEntityTypeTextUrl: return TdConvertToInternal ((struct TdTextEntityTypeTextUrl *)var);
    case CODE_TextEntityTypeMentionName: return TdConvertToInternal ((struct TdTextEntityTypeMentionName *)var);
    case CODE_TextEntityTypePhoneNumber: return TdConvertToInternal ((struct TdTextEntityTypePhoneNumber *)var);
    case CODE_TextParseModeMarkdown: return TdConvertToInternal ((struct TdTextParseModeMarkdown *)var);
    case CODE_TextParseModeHTML: return TdConvertToInternal ((struct TdTextParseModeHTML *)var);
    case CODE_TopChatCategoryUsers: return TdConvertToInternal ((struct TdTopChatCategoryUsers *)var);
    case CODE_TopChatCategoryBots: return TdConvertToInternal ((struct TdTopChatCategoryBots *)var);
    case CODE_TopChatCategoryGroups: return TdConvertToInternal ((struct TdTopChatCategoryGroups *)var);
    case CODE_TopChatCategoryChannels: return TdConvertToInternal ((struct TdTopChatCategoryChannels *)var);
    case CODE_TopChatCategoryInlineBots: return TdConvertToInternal ((struct TdTopChatCategoryInlineBots *)var);
    case CODE_TopChatCategoryCalls: return TdConvertToInternal ((struct TdTopChatCategoryCalls *)var);
    case CODE_UpdateAuthorizationState: return TdConvertToInternal ((struct TdUpdateAuthorizationState *)var);
    case CODE_UpdateNewMessage: return TdConvertToInternal ((struct TdUpdateNewMessage *)var);
    case CODE_UpdateMessageSendAcknowledged: return TdConvertToInternal ((struct TdUpdateMessageSendAcknowledged *)var);
    case CODE_UpdateMessageSendSucceeded: return TdConvertToInternal ((struct TdUpdateMessageSendSucceeded *)var);
    case CODE_UpdateMessageSendFailed: return TdConvertToInternal ((struct TdUpdateMessageSendFailed *)var);
    case CODE_UpdateMessageContent: return TdConvertToInternal ((struct TdUpdateMessageContent *)var);
    case CODE_UpdateMessageEdited: return TdConvertToInternal ((struct TdUpdateMessageEdited *)var);
    case CODE_UpdateMessageViews: return TdConvertToInternal ((struct TdUpdateMessageViews *)var);
    case CODE_UpdateMessageContentOpened: return TdConvertToInternal ((struct TdUpdateMessageContentOpened *)var);
    case CODE_UpdateMessageMentionRead: return TdConvertToInternal ((struct TdUpdateMessageMentionRead *)var);
    case CODE_UpdateNewChat: return TdConvertToInternal ((struct TdUpdateNewChat *)var);
    case CODE_UpdateChatTitle: return TdConvertToInternal ((struct TdUpdateChatTitle *)var);
    case CODE_UpdateChatPhoto: return TdConvertToInternal ((struct TdUpdateChatPhoto *)var);
    case CODE_UpdateChatLastMessage: return TdConvertToInternal ((struct TdUpdateChatLastMessage *)var);
    case CODE_UpdateChatOrder: return TdConvertToInternal ((struct TdUpdateChatOrder *)var);
    case CODE_UpdateChatIsPinned: return TdConvertToInternal ((struct TdUpdateChatIsPinned *)var);
    case CODE_UpdateChatIsMarkedAsUnread: return TdConvertToInternal ((struct TdUpdateChatIsMarkedAsUnread *)var);
    case CODE_UpdateChatIsSponsored: return TdConvertToInternal ((struct TdUpdateChatIsSponsored *)var);
    case CODE_UpdateChatDefaultDisableNotification: return TdConvertToInternal ((struct TdUpdateChatDefaultDisableNotification *)var);
    case CODE_UpdateChatReadInbox: return TdConvertToInternal ((struct TdUpdateChatReadInbox *)var);
    case CODE_UpdateChatReadOutbox: return TdConvertToInternal ((struct TdUpdateChatReadOutbox *)var);
    case CODE_UpdateChatUnreadMentionCount: return TdConvertToInternal ((struct TdUpdateChatUnreadMentionCount *)var);
    case CODE_UpdateChatNotificationSettings: return TdConvertToInternal ((struct TdUpdateChatNotificationSettings *)var);
    case CODE_UpdateScopeNotificationSettings: return TdConvertToInternal ((struct TdUpdateScopeNotificationSettings *)var);
    case CODE_UpdateChatReplyMarkup: return TdConvertToInternal ((struct TdUpdateChatReplyMarkup *)var);
    case CODE_UpdateChatDraftMessage: return TdConvertToInternal ((struct TdUpdateChatDraftMessage *)var);
    case CODE_UpdateDeleteMessages: return TdConvertToInternal ((struct TdUpdateDeleteMessages *)var);
    case CODE_UpdateUserChatAction: return TdConvertToInternal ((struct TdUpdateUserChatAction *)var);
    case CODE_UpdateUserStatus: return TdConvertToInternal ((struct TdUpdateUserStatus *)var);
    case CODE_UpdateUser: return TdConvertToInternal ((struct TdUpdateUser *)var);
    case CODE_UpdateBasicGroup: return TdConvertToInternal ((struct TdUpdateBasicGroup *)var);
    case CODE_UpdateSupergroup: return TdConvertToInternal ((struct TdUpdateSupergroup *)var);
    case CODE_UpdateSecretChat: return TdConvertToInternal ((struct TdUpdateSecretChat *)var);
    case CODE_UpdateUserFullInfo: return TdConvertToInternal ((struct TdUpdateUserFullInfo *)var);
    case CODE_UpdateBasicGroupFullInfo: return TdConvertToInternal ((struct TdUpdateBasicGroupFullInfo *)var);
    case CODE_UpdateSupergroupFullInfo: return TdConvertToInternal ((struct TdUpdateSupergroupFullInfo *)var);
    case CODE_UpdateServiceNotification: return TdConvertToInternal ((struct TdUpdateServiceNotification *)var);
    case CODE_UpdateFile: return TdConvertToInternal ((struct TdUpdateFile *)var);
    case CODE_UpdateFileGenerationStart: return TdConvertToInternal ((struct TdUpdateFileGenerationStart *)var);
    case CODE_UpdateFileGenerationStop: return TdConvertToInternal ((struct TdUpdateFileGenerationStop *)var);
    case CODE_UpdateCall: return TdConvertToInternal ((struct TdUpdateCall *)var);
    case CODE_UpdateUserPrivacySettingRules: return TdConvertToInternal ((struct TdUpdateUserPrivacySettingRules *)var);
    case CODE_UpdateUnreadMessageCount: return TdConvertToInternal ((struct TdUpdateUnreadMessageCount *)var);
    case CODE_UpdateUnreadChatCount: return TdConvertToInternal ((struct TdUpdateUnreadChatCount *)var);
    case CODE_UpdateOption: return TdConvertToInternal ((struct TdUpdateOption *)var);
    case CODE_UpdateInstalledStickerSets: return TdConvertToInternal ((struct TdUpdateInstalledStickerSets *)var);
    case CODE_UpdateTrendingStickerSets: return TdConvertToInternal ((struct TdUpdateTrendingStickerSets *)var);
    case CODE_UpdateRecentStickers: return TdConvertToInternal ((struct TdUpdateRecentStickers *)var);
    case CODE_UpdateFavoriteStickers: return TdConvertToInternal ((struct TdUpdateFavoriteStickers *)var);
    case CODE_UpdateSavedAnimations: return TdConvertToInternal ((struct TdUpdateSavedAnimations *)var);
    case CODE_UpdateLanguagePackStrings: return TdConvertToInternal ((struct TdUpdateLanguagePackStrings *)var);
    case CODE_UpdateConnectionState: return TdConvertToInternal ((struct TdUpdateConnectionState *)var);
    case CODE_UpdateTermsOfService: return TdConvertToInternal ((struct TdUpdateTermsOfService *)var);
    case CODE_UpdateNewInlineQuery: return TdConvertToInternal ((struct TdUpdateNewInlineQuery *)var);
    case CODE_UpdateNewChosenInlineResult: return TdConvertToInternal ((struct TdUpdateNewChosenInlineResult *)var);
    case CODE_UpdateNewCallbackQuery: return TdConvertToInternal ((struct TdUpdateNewCallbackQuery *)var);
    case CODE_UpdateNewInlineCallbackQuery: return TdConvertToInternal ((struct TdUpdateNewInlineCallbackQuery *)var);
    case CODE_UpdateNewShippingQuery: return TdConvertToInternal ((struct TdUpdateNewShippingQuery *)var);
    case CODE_UpdateNewPreCheckoutQuery: return TdConvertToInternal ((struct TdUpdateNewPreCheckoutQuery *)var);
    case CODE_UpdateNewCustomEvent: return TdConvertToInternal ((struct TdUpdateNewCustomEvent *)var);
    case CODE_UpdateNewCustomQuery: return TdConvertToInternal ((struct TdUpdateNewCustomQuery *)var);
    case CODE_User: return TdConvertToInternal ((struct TdUser *)var);
    case CODE_UserFullInfo: return TdConvertToInternal ((struct TdUserFullInfo *)var);
    case CODE_UserPrivacySettingShowStatus: return TdConvertToInternal ((struct TdUserPrivacySettingShowStatus *)var);
    case CODE_UserPrivacySettingAllowChatInvites: return TdConvertToInternal ((struct TdUserPrivacySettingAllowChatInvites *)var);
    case CODE_UserPrivacySettingAllowCalls: return TdConvertToInternal ((struct TdUserPrivacySettingAllowCalls *)var);
    case CODE_UserPrivacySettingRuleAllowAll: return TdConvertToInternal ((struct TdUserPrivacySettingRuleAllowAll *)var);
    case CODE_UserPrivacySettingRuleAllowContacts: return TdConvertToInternal ((struct TdUserPrivacySettingRuleAllowContacts *)var);
    case CODE_UserPrivacySettingRuleAllowUsers: return TdConvertToInternal ((struct TdUserPrivacySettingRuleAllowUsers *)var);
    case CODE_UserPrivacySettingRuleRestrictAll: return TdConvertToInternal ((struct TdUserPrivacySettingRuleRestrictAll *)var);
    case CODE_UserPrivacySettingRuleRestrictContacts: return TdConvertToInternal ((struct TdUserPrivacySettingRuleRestrictContacts *)var);
    case CODE_UserPrivacySettingRuleRestrictUsers: return TdConvertToInternal ((struct TdUserPrivacySettingRuleRestrictUsers *)var);
    case CODE_UserPrivacySettingRules: return TdConvertToInternal ((struct TdUserPrivacySettingRules *)var);
    case CODE_UserProfilePhotos: return TdConvertToInternal ((struct TdUserProfilePhotos *)var);
    case CODE_UserStatusEmpty: return TdConvertToInternal ((struct TdUserStatusEmpty *)var);
    case CODE_UserStatusOnline: return TdConvertToInternal ((struct TdUserStatusOnline *)var);
    case CODE_UserStatusOffline: return TdConvertToInternal ((struct TdUserStatusOffline *)var);
    case CODE_UserStatusRecently: return TdConvertToInternal ((struct TdUserStatusRecently *)var);
    case CODE_UserStatusLastWeek: return TdConvertToInternal ((struct TdUserStatusLastWeek *)var);
    case CODE_UserStatusLastMonth: return TdConvertToInternal ((struct TdUserStatusLastMonth *)var);
    case CODE_UserTypeRegular: return TdConvertToInternal ((struct TdUserTypeRegular *)var);
    case CODE_UserTypeDeleted: return TdConvertToInternal ((struct TdUserTypeDeleted *)var);
    case CODE_UserTypeBot: return TdConvertToInternal ((struct TdUserTypeBot *)var);
    case CODE_UserTypeUnknown: return TdConvertToInternal ((struct TdUserTypeUnknown *)var);
    case CODE_Users: return TdConvertToInternal ((struct TdUsers *)var);
    case CODE_ValidatedOrderInfo: return TdConvertToInternal ((struct TdValidatedOrderInfo *)var);
    case CODE_Venue: return TdConvertToInternal ((struct TdVenue *)var);
    case CODE_Video: return TdConvertToInternal ((struct TdVideo *)var);
    case CODE_VideoNote: return TdConvertToInternal ((struct TdVideoNote *)var);
    case CODE_VoiceNote: return TdConvertToInternal ((struct TdVoiceNote *)var);
    case CODE_Wallpaper: return TdConvertToInternal ((struct TdWallpaper *)var);
    case CODE_Wallpapers: return TdConvertToInternal ((struct TdWallpapers *)var);
    case CODE_WebPage: return TdConvertToInternal ((struct TdWebPage *)var);
    case CODE_WebPageInstantView: return TdConvertToInternal ((struct TdWebPageInstantView *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdObject *TdConvertFromInternal (const td::td_api::Object &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_AccountTtl: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::accountTtl &>(from));
    case CODE_Address: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::address &>(from));
    case CODE_Animation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::animation &>(from));
    case CODE_Animations: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::animations &>(from));
    case CODE_Audio: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::audio &>(from));
    case CODE_AuthenticationCodeInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeInfo &>(from));
    case CODE_AuthenticationCodeTypeTelegramMessage: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeTypeTelegramMessage &>(from));
    case CODE_AuthenticationCodeTypeSms: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeTypeSms &>(from));
    case CODE_AuthenticationCodeTypeCall: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeTypeCall &>(from));
    case CODE_AuthenticationCodeTypeFlashCall: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeTypeFlashCall &>(from));
    case CODE_AuthorizationStateWaitTdlibParameters: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitTdlibParameters &>(from));
    case CODE_AuthorizationStateWaitEncryptionKey: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitEncryptionKey &>(from));
    case CODE_AuthorizationStateWaitPhoneNumber: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitPhoneNumber &>(from));
    case CODE_AuthorizationStateWaitCode: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitCode &>(from));
    case CODE_AuthorizationStateWaitPassword: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitPassword &>(from));
    case CODE_AuthorizationStateReady: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateReady &>(from));
    case CODE_AuthorizationStateLoggingOut: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateLoggingOut &>(from));
    case CODE_AuthorizationStateClosing: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateClosing &>(from));
    case CODE_AuthorizationStateClosed: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateClosed &>(from));
    case CODE_BasicGroup: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::basicGroup &>(from));
    case CODE_BasicGroupFullInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::basicGroupFullInfo &>(from));
    case CODE_BotCommand: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::botCommand &>(from));
    case CODE_BotInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::botInfo &>(from));
    case CODE_Call: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::call &>(from));
    case CODE_CallConnection: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callConnection &>(from));
    case CODE_CallDiscardReasonEmpty: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonEmpty &>(from));
    case CODE_CallDiscardReasonMissed: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonMissed &>(from));
    case CODE_CallDiscardReasonDeclined: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonDeclined &>(from));
    case CODE_CallDiscardReasonDisconnected: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonDisconnected &>(from));
    case CODE_CallDiscardReasonHungUp: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonHungUp &>(from));
    case CODE_CallId: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callId &>(from));
    case CODE_CallProtocol: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callProtocol &>(from));
    case CODE_CallStatePending: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callStatePending &>(from));
    case CODE_CallStateExchangingKeys: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callStateExchangingKeys &>(from));
    case CODE_CallStateReady: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callStateReady &>(from));
    case CODE_CallStateHangingUp: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callStateHangingUp &>(from));
    case CODE_CallStateDiscarded: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callStateDiscarded &>(from));
    case CODE_CallStateError: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callStateError &>(from));
    case CODE_CallbackQueryAnswer: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callbackQueryAnswer &>(from));
    case CODE_CallbackQueryPayloadData: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callbackQueryPayloadData &>(from));
    case CODE_CallbackQueryPayloadGame: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::callbackQueryPayloadGame &>(from));
    case CODE_Chat: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chat &>(from));
    case CODE_ChatActionTyping: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionTyping &>(from));
    case CODE_ChatActionRecordingVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionRecordingVideo &>(from));
    case CODE_ChatActionUploadingVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingVideo &>(from));
    case CODE_ChatActionRecordingVoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionRecordingVoiceNote &>(from));
    case CODE_ChatActionUploadingVoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingVoiceNote &>(from));
    case CODE_ChatActionUploadingPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingPhoto &>(from));
    case CODE_ChatActionUploadingDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingDocument &>(from));
    case CODE_ChatActionChoosingLocation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionChoosingLocation &>(from));
    case CODE_ChatActionChoosingContact: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionChoosingContact &>(from));
    case CODE_ChatActionStartPlayingGame: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionStartPlayingGame &>(from));
    case CODE_ChatActionRecordingVideoNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionRecordingVideoNote &>(from));
    case CODE_ChatActionUploadingVideoNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingVideoNote &>(from));
    case CODE_ChatActionCancel: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatActionCancel &>(from));
    case CODE_ChatEvent: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEvent &>(from));
    case CODE_ChatEventMessageEdited: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMessageEdited &>(from));
    case CODE_ChatEventMessageDeleted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMessageDeleted &>(from));
    case CODE_ChatEventMessagePinned: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMessagePinned &>(from));
    case CODE_ChatEventMessageUnpinned: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMessageUnpinned &>(from));
    case CODE_ChatEventMemberJoined: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberJoined &>(from));
    case CODE_ChatEventMemberLeft: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberLeft &>(from));
    case CODE_ChatEventMemberInvited: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberInvited &>(from));
    case CODE_ChatEventMemberPromoted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberPromoted &>(from));
    case CODE_ChatEventMemberRestricted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberRestricted &>(from));
    case CODE_ChatEventTitleChanged: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventTitleChanged &>(from));
    case CODE_ChatEventDescriptionChanged: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventDescriptionChanged &>(from));
    case CODE_ChatEventUsernameChanged: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventUsernameChanged &>(from));
    case CODE_ChatEventPhotoChanged: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventPhotoChanged &>(from));
    case CODE_ChatEventInvitesToggled: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventInvitesToggled &>(from));
    case CODE_ChatEventSignMessagesToggled: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventSignMessagesToggled &>(from));
    case CODE_ChatEventStickerSetChanged: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventStickerSetChanged &>(from));
    case CODE_ChatEventIsAllHistoryAvailableToggled: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventIsAllHistoryAvailableToggled &>(from));
    case CODE_ChatEventLogFilters: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEventLogFilters &>(from));
    case CODE_ChatEvents: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatEvents &>(from));
    case CODE_ChatInviteLink: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatInviteLink &>(from));
    case CODE_ChatInviteLinkInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatInviteLinkInfo &>(from));
    case CODE_ChatMember: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMember &>(from));
    case CODE_ChatMemberStatusCreator: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusCreator &>(from));
    case CODE_ChatMemberStatusAdministrator: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusAdministrator &>(from));
    case CODE_ChatMemberStatusMember: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusMember &>(from));
    case CODE_ChatMemberStatusRestricted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusRestricted &>(from));
    case CODE_ChatMemberStatusLeft: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusLeft &>(from));
    case CODE_ChatMemberStatusBanned: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusBanned &>(from));
    case CODE_ChatMembers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMembers &>(from));
    case CODE_ChatMembersFilterAdministrators: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterAdministrators &>(from));
    case CODE_ChatMembersFilterMembers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterMembers &>(from));
    case CODE_ChatMembersFilterRestricted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterRestricted &>(from));
    case CODE_ChatMembersFilterBanned: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterBanned &>(from));
    case CODE_ChatMembersFilterBots: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterBots &>(from));
    case CODE_ChatNotificationSettings: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatNotificationSettings &>(from));
    case CODE_ChatPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatPhoto &>(from));
    case CODE_ChatReportReasonSpam: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonSpam &>(from));
    case CODE_ChatReportReasonViolence: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonViolence &>(from));
    case CODE_ChatReportReasonPornography: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonPornography &>(from));
    case CODE_ChatReportReasonCopyright: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonCopyright &>(from));
    case CODE_ChatReportReasonCustom: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonCustom &>(from));
    case CODE_ChatReportSpamState: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatReportSpamState &>(from));
    case CODE_ChatTypePrivate: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatTypePrivate &>(from));
    case CODE_ChatTypeBasicGroup: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatTypeBasicGroup &>(from));
    case CODE_ChatTypeSupergroup: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatTypeSupergroup &>(from));
    case CODE_ChatTypeSecret: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chatTypeSecret &>(from));
    case CODE_Chats: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::chats &>(from));
    case CODE_CheckChatUsernameResultOk: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultOk &>(from));
    case CODE_CheckChatUsernameResultUsernameInvalid: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultUsernameInvalid &>(from));
    case CODE_CheckChatUsernameResultUsernameOccupied: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultUsernameOccupied &>(from));
    case CODE_CheckChatUsernameResultPublicChatsTooMuch: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultPublicChatsTooMuch &>(from));
    case CODE_CheckChatUsernameResultPublicGroupsUnavailable: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultPublicGroupsUnavailable &>(from));
    case CODE_ConnectedWebsite: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::connectedWebsite &>(from));
    case CODE_ConnectedWebsites: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::connectedWebsites &>(from));
    case CODE_ConnectionStateWaitingForNetwork: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateWaitingForNetwork &>(from));
    case CODE_ConnectionStateConnectingToProxy: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateConnectingToProxy &>(from));
    case CODE_ConnectionStateConnecting: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateConnecting &>(from));
    case CODE_ConnectionStateUpdating: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateUpdating &>(from));
    case CODE_ConnectionStateReady: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateReady &>(from));
    case CODE_Contact: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::contact &>(from));
    case CODE_Count: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::count &>(from));
    case CODE_CustomRequestResult: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::customRequestResult &>(from));
    case CODE_Date: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::date &>(from));
    case CODE_DatedFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::datedFile &>(from));
    case CODE_DeepLinkInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deepLinkInfo &>(from));
    case CODE_DeviceTokenGoogleCloudMessaging: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenGoogleCloudMessaging &>(from));
    case CODE_DeviceTokenApplePush: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenApplePush &>(from));
    case CODE_DeviceTokenApplePushVoIP: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenApplePushVoIP &>(from));
    case CODE_DeviceTokenWindowsPush: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenWindowsPush &>(from));
    case CODE_DeviceTokenMicrosoftPush: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenMicrosoftPush &>(from));
    case CODE_DeviceTokenMicrosoftPushVoIP: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenMicrosoftPushVoIP &>(from));
    case CODE_DeviceTokenWebPush: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenWebPush &>(from));
    case CODE_DeviceTokenSimplePush: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenSimplePush &>(from));
    case CODE_DeviceTokenUbuntuPush: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenUbuntuPush &>(from));
    case CODE_DeviceTokenBlackBerryPush: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenBlackBerryPush &>(from));
    case CODE_DeviceTokenTizenPush: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenTizenPush &>(from));
    case CODE_Document: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::document &>(from));
    case CODE_DraftMessage: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::draftMessage &>(from));
    case CODE_EmailAddressAuthenticationCodeInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::emailAddressAuthenticationCodeInfo &>(from));
    case CODE_EncryptedCredentials: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::encryptedCredentials &>(from));
    case CODE_EncryptedPassportElement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::encryptedPassportElement &>(from));
    case CODE_Error: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::error &>(from));
    case CODE_File: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::file &>(from));
    case CODE_FileTypeNone: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeNone &>(from));
    case CODE_FileTypeAnimation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeAnimation &>(from));
    case CODE_FileTypeAudio: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeAudio &>(from));
    case CODE_FileTypeDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeDocument &>(from));
    case CODE_FileTypePhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypePhoto &>(from));
    case CODE_FileTypeProfilePhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeProfilePhoto &>(from));
    case CODE_FileTypeSecret: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeSecret &>(from));
    case CODE_FileTypeSecretThumbnail: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeSecretThumbnail &>(from));
    case CODE_FileTypeSecure: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeSecure &>(from));
    case CODE_FileTypeSticker: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeSticker &>(from));
    case CODE_FileTypeThumbnail: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeThumbnail &>(from));
    case CODE_FileTypeUnknown: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeUnknown &>(from));
    case CODE_FileTypeVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeVideo &>(from));
    case CODE_FileTypeVideoNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeVideoNote &>(from));
    case CODE_FileTypeVoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeVoiceNote &>(from));
    case CODE_FileTypeWallpaper: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeWallpaper &>(from));
    case CODE_FormattedText: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::formattedText &>(from));
    case CODE_FoundMessages: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::foundMessages &>(from));
    case CODE_Game: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::game &>(from));
    case CODE_GameHighScore: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::gameHighScore &>(from));
    case CODE_GameHighScores: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::gameHighScores &>(from));
    case CODE_Hashtags: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::hashtags &>(from));
    case CODE_IdentityDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::identityDocument &>(from));
    case CODE_ImportedContacts: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::importedContacts &>(from));
    case CODE_InlineKeyboardButton: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButton &>(from));
    case CODE_InlineKeyboardButtonTypeUrl: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeUrl &>(from));
    case CODE_InlineKeyboardButtonTypeCallback: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeCallback &>(from));
    case CODE_InlineKeyboardButtonTypeCallbackGame: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeCallbackGame &>(from));
    case CODE_InlineKeyboardButtonTypeSwitchInline: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeSwitchInline &>(from));
    case CODE_InlineKeyboardButtonTypeBuy: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeBuy &>(from));
    case CODE_InlineQueryResultArticle: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultArticle &>(from));
    case CODE_InlineQueryResultContact: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultContact &>(from));
    case CODE_InlineQueryResultLocation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultLocation &>(from));
    case CODE_InlineQueryResultVenue: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultVenue &>(from));
    case CODE_InlineQueryResultGame: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultGame &>(from));
    case CODE_InlineQueryResultAnimation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultAnimation &>(from));
    case CODE_InlineQueryResultAudio: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultAudio &>(from));
    case CODE_InlineQueryResultDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultDocument &>(from));
    case CODE_InlineQueryResultPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultPhoto &>(from));
    case CODE_InlineQueryResultSticker: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultSticker &>(from));
    case CODE_InlineQueryResultVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultVideo &>(from));
    case CODE_InlineQueryResultVoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultVoiceNote &>(from));
    case CODE_InlineQueryResults: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResults &>(from));
    case CODE_InputCredentialsSaved: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputCredentialsSaved &>(from));
    case CODE_InputCredentialsNew: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputCredentialsNew &>(from));
    case CODE_InputCredentialsAndroidPay: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputCredentialsAndroidPay &>(from));
    case CODE_InputCredentialsApplePay: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputCredentialsApplePay &>(from));
    case CODE_InputFileId: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputFileId &>(from));
    case CODE_InputFileRemote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputFileRemote &>(from));
    case CODE_InputFileLocal: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputFileLocal &>(from));
    case CODE_InputFileGenerated: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputFileGenerated &>(from));
    case CODE_InputIdentityDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputIdentityDocument &>(from));
    case CODE_InputInlineQueryResultAnimatedGif: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultAnimatedGif &>(from));
    case CODE_InputInlineQueryResultAnimatedMpeg4: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultAnimatedMpeg4 &>(from));
    case CODE_InputInlineQueryResultArticle: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultArticle &>(from));
    case CODE_InputInlineQueryResultAudio: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultAudio &>(from));
    case CODE_InputInlineQueryResultContact: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultContact &>(from));
    case CODE_InputInlineQueryResultDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultDocument &>(from));
    case CODE_InputInlineQueryResultGame: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultGame &>(from));
    case CODE_InputInlineQueryResultLocation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultLocation &>(from));
    case CODE_InputInlineQueryResultPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultPhoto &>(from));
    case CODE_InputInlineQueryResultSticker: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultSticker &>(from));
    case CODE_InputInlineQueryResultVenue: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultVenue &>(from));
    case CODE_InputInlineQueryResultVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultVideo &>(from));
    case CODE_InputInlineQueryResultVoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultVoiceNote &>(from));
    case CODE_InputMessageText: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageText &>(from));
    case CODE_InputMessageAnimation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageAnimation &>(from));
    case CODE_InputMessageAudio: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageAudio &>(from));
    case CODE_InputMessageDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageDocument &>(from));
    case CODE_InputMessagePhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessagePhoto &>(from));
    case CODE_InputMessageSticker: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageSticker &>(from));
    case CODE_InputMessageVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageVideo &>(from));
    case CODE_InputMessageVideoNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageVideoNote &>(from));
    case CODE_InputMessageVoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageVoiceNote &>(from));
    case CODE_InputMessageLocation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageLocation &>(from));
    case CODE_InputMessageVenue: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageVenue &>(from));
    case CODE_InputMessageContact: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageContact &>(from));
    case CODE_InputMessageGame: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageGame &>(from));
    case CODE_InputMessageInvoice: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageInvoice &>(from));
    case CODE_InputMessageForwarded: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageForwarded &>(from));
    case CODE_InputPassportElementPersonalDetails: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementPersonalDetails &>(from));
    case CODE_InputPassportElementPassport: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementPassport &>(from));
    case CODE_InputPassportElementDriverLicense: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementDriverLicense &>(from));
    case CODE_InputPassportElementIdentityCard: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementIdentityCard &>(from));
    case CODE_InputPassportElementInternalPassport: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementInternalPassport &>(from));
    case CODE_InputPassportElementAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementAddress &>(from));
    case CODE_InputPassportElementUtilityBill: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementUtilityBill &>(from));
    case CODE_InputPassportElementBankStatement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementBankStatement &>(from));
    case CODE_InputPassportElementRentalAgreement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementRentalAgreement &>(from));
    case CODE_InputPassportElementPassportRegistration: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementPassportRegistration &>(from));
    case CODE_InputPassportElementTemporaryRegistration: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementTemporaryRegistration &>(from));
    case CODE_InputPassportElementPhoneNumber: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementPhoneNumber &>(from));
    case CODE_InputPassportElementEmailAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementEmailAddress &>(from));
    case CODE_InputPassportElementError: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementError &>(from));
    case CODE_InputPassportElementErrorSourceUnspecified: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceUnspecified &>(from));
    case CODE_InputPassportElementErrorSourceDataField: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceDataField &>(from));
    case CODE_InputPassportElementErrorSourceFrontSide: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceFrontSide &>(from));
    case CODE_InputPassportElementErrorSourceReverseSide: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceReverseSide &>(from));
    case CODE_InputPassportElementErrorSourceSelfie: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceSelfie &>(from));
    case CODE_InputPassportElementErrorSourceTranslationFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceTranslationFile &>(from));
    case CODE_InputPassportElementErrorSourceTranslationFiles: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceTranslationFiles &>(from));
    case CODE_InputPassportElementErrorSourceFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceFile &>(from));
    case CODE_InputPassportElementErrorSourceFiles: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceFiles &>(from));
    case CODE_InputPersonalDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputPersonalDocument &>(from));
    case CODE_InputSticker: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputSticker &>(from));
    case CODE_InputThumbnail: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::inputThumbnail &>(from));
    case CODE_Invoice: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::invoice &>(from));
    case CODE_KeyboardButton: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::keyboardButton &>(from));
    case CODE_KeyboardButtonTypeText: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::keyboardButtonTypeText &>(from));
    case CODE_KeyboardButtonTypeRequestPhoneNumber: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::keyboardButtonTypeRequestPhoneNumber &>(from));
    case CODE_KeyboardButtonTypeRequestLocation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::keyboardButtonTypeRequestLocation &>(from));
    case CODE_LabeledPricePart: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::labeledPricePart &>(from));
    case CODE_LanguagePackInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::languagePackInfo &>(from));
    case CODE_LanguagePackString: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::languagePackString &>(from));
    case CODE_LanguagePackStringValueOrdinary: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::languagePackStringValueOrdinary &>(from));
    case CODE_LanguagePackStringValuePluralized: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::languagePackStringValuePluralized &>(from));
    case CODE_LanguagePackStringValueDeleted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::languagePackStringValueDeleted &>(from));
    case CODE_LanguagePackStrings: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::languagePackStrings &>(from));
    case CODE_LinkStateNone: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::linkStateNone &>(from));
    case CODE_LinkStateKnowsPhoneNumber: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::linkStateKnowsPhoneNumber &>(from));
    case CODE_LinkStateIsContact: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::linkStateIsContact &>(from));
    case CODE_LocalFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::localFile &>(from));
    case CODE_LocalizationTargetInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::localizationTargetInfo &>(from));
    case CODE_Location: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::location &>(from));
    case CODE_MaskPointForehead: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::maskPointForehead &>(from));
    case CODE_MaskPointEyes: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::maskPointEyes &>(from));
    case CODE_MaskPointMouth: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::maskPointMouth &>(from));
    case CODE_MaskPointChin: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::maskPointChin &>(from));
    case CODE_MaskPosition: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::maskPosition &>(from));
    case CODE_Message: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::message &>(from));
    case CODE_MessageText: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageText &>(from));
    case CODE_MessageAnimation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageAnimation &>(from));
    case CODE_MessageAudio: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageAudio &>(from));
    case CODE_MessageDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageDocument &>(from));
    case CODE_MessagePhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messagePhoto &>(from));
    case CODE_MessageExpiredPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageExpiredPhoto &>(from));
    case CODE_MessageSticker: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageSticker &>(from));
    case CODE_MessageVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageVideo &>(from));
    case CODE_MessageExpiredVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageExpiredVideo &>(from));
    case CODE_MessageVideoNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageVideoNote &>(from));
    case CODE_MessageVoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageVoiceNote &>(from));
    case CODE_MessageLocation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageLocation &>(from));
    case CODE_MessageVenue: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageVenue &>(from));
    case CODE_MessageContact: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageContact &>(from));
    case CODE_MessageGame: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageGame &>(from));
    case CODE_MessageInvoice: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageInvoice &>(from));
    case CODE_MessageCall: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageCall &>(from));
    case CODE_MessageBasicGroupChatCreate: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageBasicGroupChatCreate &>(from));
    case CODE_MessageSupergroupChatCreate: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageSupergroupChatCreate &>(from));
    case CODE_MessageChatChangeTitle: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatChangeTitle &>(from));
    case CODE_MessageChatChangePhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatChangePhoto &>(from));
    case CODE_MessageChatDeletePhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatDeletePhoto &>(from));
    case CODE_MessageChatAddMembers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatAddMembers &>(from));
    case CODE_MessageChatJoinByLink: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatJoinByLink &>(from));
    case CODE_MessageChatDeleteMember: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatDeleteMember &>(from));
    case CODE_MessageChatUpgradeTo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatUpgradeTo &>(from));
    case CODE_MessageChatUpgradeFrom: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatUpgradeFrom &>(from));
    case CODE_MessagePinMessage: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messagePinMessage &>(from));
    case CODE_MessageScreenshotTaken: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageScreenshotTaken &>(from));
    case CODE_MessageChatSetTtl: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageChatSetTtl &>(from));
    case CODE_MessageCustomServiceAction: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageCustomServiceAction &>(from));
    case CODE_MessageGameScore: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageGameScore &>(from));
    case CODE_MessagePaymentSuccessful: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messagePaymentSuccessful &>(from));
    case CODE_MessagePaymentSuccessfulBot: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messagePaymentSuccessfulBot &>(from));
    case CODE_MessageContactRegistered: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageContactRegistered &>(from));
    case CODE_MessageWebsiteConnected: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageWebsiteConnected &>(from));
    case CODE_MessagePassportDataSent: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messagePassportDataSent &>(from));
    case CODE_MessagePassportDataReceived: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messagePassportDataReceived &>(from));
    case CODE_MessageUnsupported: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageUnsupported &>(from));
    case CODE_MessageForwardedFromUser: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageForwardedFromUser &>(from));
    case CODE_MessageForwardedPost: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageForwardedPost &>(from));
    case CODE_MessageSendingStatePending: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageSendingStatePending &>(from));
    case CODE_MessageSendingStateFailed: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messageSendingStateFailed &>(from));
    case CODE_Messages: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::messages &>(from));
    case CODE_NetworkStatistics: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::networkStatistics &>(from));
    case CODE_NetworkStatisticsEntryFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::networkStatisticsEntryFile &>(from));
    case CODE_NetworkStatisticsEntryCall: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::networkStatisticsEntryCall &>(from));
    case CODE_NetworkTypeNone: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeNone &>(from));
    case CODE_NetworkTypeMobile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeMobile &>(from));
    case CODE_NetworkTypeMobileRoaming: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeMobileRoaming &>(from));
    case CODE_NetworkTypeWiFi: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeWiFi &>(from));
    case CODE_NetworkTypeOther: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeOther &>(from));
    case CODE_NotificationSettingsScopePrivateChats: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::notificationSettingsScopePrivateChats &>(from));
    case CODE_NotificationSettingsScopeGroupChats: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::notificationSettingsScopeGroupChats &>(from));
    case CODE_Ok: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::ok &>(from));
    case CODE_OptionValueBoolean: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::optionValueBoolean &>(from));
    case CODE_OptionValueEmpty: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::optionValueEmpty &>(from));
    case CODE_OptionValueInteger: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::optionValueInteger &>(from));
    case CODE_OptionValueString: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::optionValueString &>(from));
    case CODE_OrderInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::orderInfo &>(from));
    case CODE_PageBlockTitle: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockTitle &>(from));
    case CODE_PageBlockSubtitle: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockSubtitle &>(from));
    case CODE_PageBlockAuthorDate: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockAuthorDate &>(from));
    case CODE_PageBlockHeader: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockHeader &>(from));
    case CODE_PageBlockSubheader: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockSubheader &>(from));
    case CODE_PageBlockParagraph: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockParagraph &>(from));
    case CODE_PageBlockPreformatted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockPreformatted &>(from));
    case CODE_PageBlockFooter: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockFooter &>(from));
    case CODE_PageBlockDivider: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockDivider &>(from));
    case CODE_PageBlockAnchor: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockAnchor &>(from));
    case CODE_PageBlockList: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockList &>(from));
    case CODE_PageBlockBlockQuote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockBlockQuote &>(from));
    case CODE_PageBlockPullQuote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockPullQuote &>(from));
    case CODE_PageBlockAnimation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockAnimation &>(from));
    case CODE_PageBlockAudio: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockAudio &>(from));
    case CODE_PageBlockPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockPhoto &>(from));
    case CODE_PageBlockVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockVideo &>(from));
    case CODE_PageBlockCover: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockCover &>(from));
    case CODE_PageBlockEmbedded: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockEmbedded &>(from));
    case CODE_PageBlockEmbeddedPost: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockEmbeddedPost &>(from));
    case CODE_PageBlockCollage: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockCollage &>(from));
    case CODE_PageBlockSlideshow: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockSlideshow &>(from));
    case CODE_PageBlockChatLink: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockChatLink &>(from));
    case CODE_PassportAuthorizationForm: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportAuthorizationForm &>(from));
    case CODE_PassportElementPersonalDetails: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementPersonalDetails &>(from));
    case CODE_PassportElementPassport: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementPassport &>(from));
    case CODE_PassportElementDriverLicense: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementDriverLicense &>(from));
    case CODE_PassportElementIdentityCard: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementIdentityCard &>(from));
    case CODE_PassportElementInternalPassport: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementInternalPassport &>(from));
    case CODE_PassportElementAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementAddress &>(from));
    case CODE_PassportElementUtilityBill: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementUtilityBill &>(from));
    case CODE_PassportElementBankStatement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementBankStatement &>(from));
    case CODE_PassportElementRentalAgreement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementRentalAgreement &>(from));
    case CODE_PassportElementPassportRegistration: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementPassportRegistration &>(from));
    case CODE_PassportElementTemporaryRegistration: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTemporaryRegistration &>(from));
    case CODE_PassportElementPhoneNumber: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementPhoneNumber &>(from));
    case CODE_PassportElementEmailAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementEmailAddress &>(from));
    case CODE_PassportElementError: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementError &>(from));
    case CODE_PassportElementErrorSourceUnspecified: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceUnspecified &>(from));
    case CODE_PassportElementErrorSourceDataField: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceDataField &>(from));
    case CODE_PassportElementErrorSourceFrontSide: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceFrontSide &>(from));
    case CODE_PassportElementErrorSourceReverseSide: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceReverseSide &>(from));
    case CODE_PassportElementErrorSourceSelfie: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceSelfie &>(from));
    case CODE_PassportElementErrorSourceTranslationFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceTranslationFile &>(from));
    case CODE_PassportElementErrorSourceTranslationFiles: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceTranslationFiles &>(from));
    case CODE_PassportElementErrorSourceFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceFile &>(from));
    case CODE_PassportElementErrorSourceFiles: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceFiles &>(from));
    case CODE_PassportElementTypePersonalDetails: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypePersonalDetails &>(from));
    case CODE_PassportElementTypePassport: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypePassport &>(from));
    case CODE_PassportElementTypeDriverLicense: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeDriverLicense &>(from));
    case CODE_PassportElementTypeIdentityCard: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeIdentityCard &>(from));
    case CODE_PassportElementTypeInternalPassport: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeInternalPassport &>(from));
    case CODE_PassportElementTypeAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeAddress &>(from));
    case CODE_PassportElementTypeUtilityBill: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeUtilityBill &>(from));
    case CODE_PassportElementTypeBankStatement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeBankStatement &>(from));
    case CODE_PassportElementTypeRentalAgreement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeRentalAgreement &>(from));
    case CODE_PassportElementTypePassportRegistration: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypePassportRegistration &>(from));
    case CODE_PassportElementTypeTemporaryRegistration: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeTemporaryRegistration &>(from));
    case CODE_PassportElementTypePhoneNumber: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypePhoneNumber &>(from));
    case CODE_PassportElementTypeEmailAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeEmailAddress &>(from));
    case CODE_PassportElements: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportElements &>(from));
    case CODE_PassportRequiredElement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportRequiredElement &>(from));
    case CODE_PassportSuitableElement: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passportSuitableElement &>(from));
    case CODE_PasswordState: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::passwordState &>(from));
    case CODE_PaymentForm: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::paymentForm &>(from));
    case CODE_PaymentReceipt: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::paymentReceipt &>(from));
    case CODE_PaymentResult: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::paymentResult &>(from));
    case CODE_PaymentsProviderStripe: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::paymentsProviderStripe &>(from));
    case CODE_PersonalDetails: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::personalDetails &>(from));
    case CODE_PersonalDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::personalDocument &>(from));
    case CODE_Photo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::photo &>(from));
    case CODE_PhotoSize: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::photoSize &>(from));
    case CODE_ProfilePhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::profilePhoto &>(from));
    case CODE_Proxies: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::proxies &>(from));
    case CODE_Proxy: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::proxy &>(from));
    case CODE_ProxyTypeSocks5: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::proxyTypeSocks5 &>(from));
    case CODE_ProxyTypeHttp: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::proxyTypeHttp &>(from));
    case CODE_ProxyTypeMtproto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::proxyTypeMtproto &>(from));
    case CODE_PublicMessageLink: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::publicMessageLink &>(from));
    case CODE_RecoveryEmailAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::recoveryEmailAddress &>(from));
    case CODE_RemoteFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::remoteFile &>(from));
    case CODE_ReplyMarkupRemoveKeyboard: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::replyMarkupRemoveKeyboard &>(from));
    case CODE_ReplyMarkupForceReply: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::replyMarkupForceReply &>(from));
    case CODE_ReplyMarkupShowKeyboard: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::replyMarkupShowKeyboard &>(from));
    case CODE_ReplyMarkupInlineKeyboard: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::replyMarkupInlineKeyboard &>(from));
    case CODE_RichTextPlain: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTextPlain &>(from));
    case CODE_RichTextBold: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTextBold &>(from));
    case CODE_RichTextItalic: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTextItalic &>(from));
    case CODE_RichTextUnderline: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTextUnderline &>(from));
    case CODE_RichTextStrikethrough: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTextStrikethrough &>(from));
    case CODE_RichTextFixed: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTextFixed &>(from));
    case CODE_RichTextUrl: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTextUrl &>(from));
    case CODE_RichTextEmailAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTextEmailAddress &>(from));
    case CODE_RichTexts: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::richTexts &>(from));
    case CODE_SavedCredentials: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::savedCredentials &>(from));
    case CODE_ScopeNotificationSettings: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::scopeNotificationSettings &>(from));
    case CODE_SearchMessagesFilterEmpty: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterEmpty &>(from));
    case CODE_SearchMessagesFilterAnimation: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterAnimation &>(from));
    case CODE_SearchMessagesFilterAudio: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterAudio &>(from));
    case CODE_SearchMessagesFilterDocument: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterDocument &>(from));
    case CODE_SearchMessagesFilterPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterPhoto &>(from));
    case CODE_SearchMessagesFilterVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterVideo &>(from));
    case CODE_SearchMessagesFilterVoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterVoiceNote &>(from));
    case CODE_SearchMessagesFilterPhotoAndVideo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterPhotoAndVideo &>(from));
    case CODE_SearchMessagesFilterUrl: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterUrl &>(from));
    case CODE_SearchMessagesFilterChatPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterChatPhoto &>(from));
    case CODE_SearchMessagesFilterCall: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterCall &>(from));
    case CODE_SearchMessagesFilterMissedCall: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterMissedCall &>(from));
    case CODE_SearchMessagesFilterVideoNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterVideoNote &>(from));
    case CODE_SearchMessagesFilterVoiceAndVideoNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterVoiceAndVideoNote &>(from));
    case CODE_SearchMessagesFilterMention: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterMention &>(from));
    case CODE_SearchMessagesFilterUnreadMention: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterUnreadMention &>(from));
    case CODE_Seconds: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::seconds &>(from));
    case CODE_SecretChat: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::secretChat &>(from));
    case CODE_SecretChatStatePending: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::secretChatStatePending &>(from));
    case CODE_SecretChatStateReady: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::secretChatStateReady &>(from));
    case CODE_SecretChatStateClosed: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::secretChatStateClosed &>(from));
    case CODE_Session: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::session &>(from));
    case CODE_Sessions: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::sessions &>(from));
    case CODE_ShippingOption: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::shippingOption &>(from));
    case CODE_Sticker: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::sticker &>(from));
    case CODE_StickerEmojis: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::stickerEmojis &>(from));
    case CODE_StickerSet: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::stickerSet &>(from));
    case CODE_StickerSetInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::stickerSetInfo &>(from));
    case CODE_StickerSets: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::stickerSets &>(from));
    case CODE_Stickers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::stickers &>(from));
    case CODE_StorageStatistics: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::storageStatistics &>(from));
    case CODE_StorageStatisticsByChat: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::storageStatisticsByChat &>(from));
    case CODE_StorageStatisticsByFileType: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::storageStatisticsByFileType &>(from));
    case CODE_StorageStatisticsFast: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::storageStatisticsFast &>(from));
    case CODE_Supergroup: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::supergroup &>(from));
    case CODE_SupergroupFullInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::supergroupFullInfo &>(from));
    case CODE_SupergroupMembersFilterRecent: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterRecent &>(from));
    case CODE_SupergroupMembersFilterAdministrators: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterAdministrators &>(from));
    case CODE_SupergroupMembersFilterSearch: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterSearch &>(from));
    case CODE_SupergroupMembersFilterRestricted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterRestricted &>(from));
    case CODE_SupergroupMembersFilterBanned: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterBanned &>(from));
    case CODE_SupergroupMembersFilterBots: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterBots &>(from));
    case CODE_TMeUrl: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrl &>(from));
    case CODE_TMeUrlTypeUser: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrlTypeUser &>(from));
    case CODE_TMeUrlTypeSupergroup: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrlTypeSupergroup &>(from));
    case CODE_TMeUrlTypeChatInvite: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrlTypeChatInvite &>(from));
    case CODE_TMeUrlTypeStickerSet: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrlTypeStickerSet &>(from));
    case CODE_TMeUrls: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrls &>(from));
    case CODE_TdlibParameters: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::tdlibParameters &>(from));
    case CODE_TemporaryPasswordState: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::temporaryPasswordState &>(from));
    case CODE_TermsOfService: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::termsOfService &>(from));
    case CODE_TestBytes: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::testBytes &>(from));
    case CODE_TestInt: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::testInt &>(from));
    case CODE_TestString: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::testString &>(from));
    case CODE_TestVectorInt: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::testVectorInt &>(from));
    case CODE_TestVectorIntObject: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::testVectorIntObject &>(from));
    case CODE_TestVectorString: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::testVectorString &>(from));
    case CODE_TestVectorStringObject: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::testVectorStringObject &>(from));
    case CODE_Text: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::text &>(from));
    case CODE_TextEntities: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntities &>(from));
    case CODE_TextEntity: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntity &>(from));
    case CODE_TextEntityTypeMention: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeMention &>(from));
    case CODE_TextEntityTypeHashtag: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeHashtag &>(from));
    case CODE_TextEntityTypeCashtag: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeCashtag &>(from));
    case CODE_TextEntityTypeBotCommand: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeBotCommand &>(from));
    case CODE_TextEntityTypeUrl: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeUrl &>(from));
    case CODE_TextEntityTypeEmailAddress: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeEmailAddress &>(from));
    case CODE_TextEntityTypeBold: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeBold &>(from));
    case CODE_TextEntityTypeItalic: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeItalic &>(from));
    case CODE_TextEntityTypeCode: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeCode &>(from));
    case CODE_TextEntityTypePre: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypePre &>(from));
    case CODE_TextEntityTypePreCode: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypePreCode &>(from));
    case CODE_TextEntityTypeTextUrl: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeTextUrl &>(from));
    case CODE_TextEntityTypeMentionName: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeMentionName &>(from));
    case CODE_TextEntityTypePhoneNumber: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypePhoneNumber &>(from));
    case CODE_TextParseModeMarkdown: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textParseModeMarkdown &>(from));
    case CODE_TextParseModeHTML: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::textParseModeHTML &>(from));
    case CODE_TopChatCategoryUsers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryUsers &>(from));
    case CODE_TopChatCategoryBots: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryBots &>(from));
    case CODE_TopChatCategoryGroups: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryGroups &>(from));
    case CODE_TopChatCategoryChannels: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryChannels &>(from));
    case CODE_TopChatCategoryInlineBots: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryInlineBots &>(from));
    case CODE_TopChatCategoryCalls: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryCalls &>(from));
    case CODE_UpdateAuthorizationState: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateAuthorizationState &>(from));
    case CODE_UpdateNewMessage: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewMessage &>(from));
    case CODE_UpdateMessageSendAcknowledged: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageSendAcknowledged &>(from));
    case CODE_UpdateMessageSendSucceeded: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageSendSucceeded &>(from));
    case CODE_UpdateMessageSendFailed: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageSendFailed &>(from));
    case CODE_UpdateMessageContent: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageContent &>(from));
    case CODE_UpdateMessageEdited: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageEdited &>(from));
    case CODE_UpdateMessageViews: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageViews &>(from));
    case CODE_UpdateMessageContentOpened: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageContentOpened &>(from));
    case CODE_UpdateMessageMentionRead: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageMentionRead &>(from));
    case CODE_UpdateNewChat: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewChat &>(from));
    case CODE_UpdateChatTitle: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatTitle &>(from));
    case CODE_UpdateChatPhoto: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatPhoto &>(from));
    case CODE_UpdateChatLastMessage: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatLastMessage &>(from));
    case CODE_UpdateChatOrder: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatOrder &>(from));
    case CODE_UpdateChatIsPinned: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatIsPinned &>(from));
    case CODE_UpdateChatIsMarkedAsUnread: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatIsMarkedAsUnread &>(from));
    case CODE_UpdateChatIsSponsored: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatIsSponsored &>(from));
    case CODE_UpdateChatDefaultDisableNotification: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatDefaultDisableNotification &>(from));
    case CODE_UpdateChatReadInbox: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatReadInbox &>(from));
    case CODE_UpdateChatReadOutbox: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatReadOutbox &>(from));
    case CODE_UpdateChatUnreadMentionCount: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatUnreadMentionCount &>(from));
    case CODE_UpdateChatNotificationSettings: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatNotificationSettings &>(from));
    case CODE_UpdateScopeNotificationSettings: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateScopeNotificationSettings &>(from));
    case CODE_UpdateChatReplyMarkup: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatReplyMarkup &>(from));
    case CODE_UpdateChatDraftMessage: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateChatDraftMessage &>(from));
    case CODE_UpdateDeleteMessages: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateDeleteMessages &>(from));
    case CODE_UpdateUserChatAction: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateUserChatAction &>(from));
    case CODE_UpdateUserStatus: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateUserStatus &>(from));
    case CODE_UpdateUser: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateUser &>(from));
    case CODE_UpdateBasicGroup: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateBasicGroup &>(from));
    case CODE_UpdateSupergroup: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateSupergroup &>(from));
    case CODE_UpdateSecretChat: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateSecretChat &>(from));
    case CODE_UpdateUserFullInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateUserFullInfo &>(from));
    case CODE_UpdateBasicGroupFullInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateBasicGroupFullInfo &>(from));
    case CODE_UpdateSupergroupFullInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateSupergroupFullInfo &>(from));
    case CODE_UpdateServiceNotification: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateServiceNotification &>(from));
    case CODE_UpdateFile: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateFile &>(from));
    case CODE_UpdateFileGenerationStart: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateFileGenerationStart &>(from));
    case CODE_UpdateFileGenerationStop: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateFileGenerationStop &>(from));
    case CODE_UpdateCall: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateCall &>(from));
    case CODE_UpdateUserPrivacySettingRules: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateUserPrivacySettingRules &>(from));
    case CODE_UpdateUnreadMessageCount: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateUnreadMessageCount &>(from));
    case CODE_UpdateUnreadChatCount: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateUnreadChatCount &>(from));
    case CODE_UpdateOption: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateOption &>(from));
    case CODE_UpdateInstalledStickerSets: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateInstalledStickerSets &>(from));
    case CODE_UpdateTrendingStickerSets: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateTrendingStickerSets &>(from));
    case CODE_UpdateRecentStickers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateRecentStickers &>(from));
    case CODE_UpdateFavoriteStickers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateFavoriteStickers &>(from));
    case CODE_UpdateSavedAnimations: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateSavedAnimations &>(from));
    case CODE_UpdateLanguagePackStrings: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateLanguagePackStrings &>(from));
    case CODE_UpdateConnectionState: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateConnectionState &>(from));
    case CODE_UpdateTermsOfService: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateTermsOfService &>(from));
    case CODE_UpdateNewInlineQuery: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewInlineQuery &>(from));
    case CODE_UpdateNewChosenInlineResult: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewChosenInlineResult &>(from));
    case CODE_UpdateNewCallbackQuery: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewCallbackQuery &>(from));
    case CODE_UpdateNewInlineCallbackQuery: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewInlineCallbackQuery &>(from));
    case CODE_UpdateNewShippingQuery: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewShippingQuery &>(from));
    case CODE_UpdateNewPreCheckoutQuery: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewPreCheckoutQuery &>(from));
    case CODE_UpdateNewCustomEvent: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewCustomEvent &>(from));
    case CODE_UpdateNewCustomQuery: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::updateNewCustomQuery &>(from));
    case CODE_User: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::user &>(from));
    case CODE_UserFullInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userFullInfo &>(from));
    case CODE_UserPrivacySettingShowStatus: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingShowStatus &>(from));
    case CODE_UserPrivacySettingAllowChatInvites: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingAllowChatInvites &>(from));
    case CODE_UserPrivacySettingAllowCalls: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingAllowCalls &>(from));
    case CODE_UserPrivacySettingRuleAllowAll: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleAllowAll &>(from));
    case CODE_UserPrivacySettingRuleAllowContacts: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleAllowContacts &>(from));
    case CODE_UserPrivacySettingRuleAllowUsers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleAllowUsers &>(from));
    case CODE_UserPrivacySettingRuleRestrictAll: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleRestrictAll &>(from));
    case CODE_UserPrivacySettingRuleRestrictContacts: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleRestrictContacts &>(from));
    case CODE_UserPrivacySettingRuleRestrictUsers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleRestrictUsers &>(from));
    case CODE_UserPrivacySettingRules: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRules &>(from));
    case CODE_UserProfilePhotos: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userProfilePhotos &>(from));
    case CODE_UserStatusEmpty: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userStatusEmpty &>(from));
    case CODE_UserStatusOnline: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userStatusOnline &>(from));
    case CODE_UserStatusOffline: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userStatusOffline &>(from));
    case CODE_UserStatusRecently: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userStatusRecently &>(from));
    case CODE_UserStatusLastWeek: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userStatusLastWeek &>(from));
    case CODE_UserStatusLastMonth: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userStatusLastMonth &>(from));
    case CODE_UserTypeRegular: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userTypeRegular &>(from));
    case CODE_UserTypeDeleted: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userTypeDeleted &>(from));
    case CODE_UserTypeBot: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userTypeBot &>(from));
    case CODE_UserTypeUnknown: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::userTypeUnknown &>(from));
    case CODE_Users: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::users &>(from));
    case CODE_ValidatedOrderInfo: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::validatedOrderInfo &>(from));
    case CODE_Venue: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::venue &>(from));
    case CODE_Video: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::video &>(from));
    case CODE_VideoNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::videoNote &>(from));
    case CODE_VoiceNote: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::voiceNote &>(from));
    case CODE_Wallpaper: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::wallpaper &>(from));
    case CODE_Wallpapers: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::wallpapers &>(from));
    case CODE_WebPage: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::webPage &>(from));
    case CODE_WebPageInstantView: return (struct TdObject *)TdConvertFromInternal(static_cast<const td::td_api::webPageInstantView &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeObject (struct TdObject *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdObject *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectObject (struct TdObject *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdObject *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AccountTtl: return TdDestroyObject ((struct TdAccountTtl *)var);
    case CODE_Address: return TdDestroyObject ((struct TdAddress *)var);
    case CODE_Animation: return TdDestroyObject ((struct TdAnimation *)var);
    case CODE_Animations: return TdDestroyObject ((struct TdAnimations *)var);
    case CODE_Audio: return TdDestroyObject ((struct TdAudio *)var);
    case CODE_AuthenticationCodeInfo: return TdDestroyObject ((struct TdAuthenticationCodeInfo *)var);
    case CODE_AuthenticationCodeTypeTelegramMessage: return TdDestroyObject ((struct TdAuthenticationCodeTypeTelegramMessage *)var);
    case CODE_AuthenticationCodeTypeSms: return TdDestroyObject ((struct TdAuthenticationCodeTypeSms *)var);
    case CODE_AuthenticationCodeTypeCall: return TdDestroyObject ((struct TdAuthenticationCodeTypeCall *)var);
    case CODE_AuthenticationCodeTypeFlashCall: return TdDestroyObject ((struct TdAuthenticationCodeTypeFlashCall *)var);
    case CODE_AuthorizationStateWaitTdlibParameters: return TdDestroyObject ((struct TdAuthorizationStateWaitTdlibParameters *)var);
    case CODE_AuthorizationStateWaitEncryptionKey: return TdDestroyObject ((struct TdAuthorizationStateWaitEncryptionKey *)var);
    case CODE_AuthorizationStateWaitPhoneNumber: return TdDestroyObject ((struct TdAuthorizationStateWaitPhoneNumber *)var);
    case CODE_AuthorizationStateWaitCode: return TdDestroyObject ((struct TdAuthorizationStateWaitCode *)var);
    case CODE_AuthorizationStateWaitPassword: return TdDestroyObject ((struct TdAuthorizationStateWaitPassword *)var);
    case CODE_AuthorizationStateReady: return TdDestroyObject ((struct TdAuthorizationStateReady *)var);
    case CODE_AuthorizationStateLoggingOut: return TdDestroyObject ((struct TdAuthorizationStateLoggingOut *)var);
    case CODE_AuthorizationStateClosing: return TdDestroyObject ((struct TdAuthorizationStateClosing *)var);
    case CODE_AuthorizationStateClosed: return TdDestroyObject ((struct TdAuthorizationStateClosed *)var);
    case CODE_BasicGroup: return TdDestroyObject ((struct TdBasicGroup *)var);
    case CODE_BasicGroupFullInfo: return TdDestroyObject ((struct TdBasicGroupFullInfo *)var);
    case CODE_BotCommand: return TdDestroyObject ((struct TdBotCommand *)var);
    case CODE_BotInfo: return TdDestroyObject ((struct TdBotInfo *)var);
    case CODE_Call: return TdDestroyObject ((struct TdCall *)var);
    case CODE_CallConnection: return TdDestroyObject ((struct TdCallConnection *)var);
    case CODE_CallDiscardReasonEmpty: return TdDestroyObject ((struct TdCallDiscardReasonEmpty *)var);
    case CODE_CallDiscardReasonMissed: return TdDestroyObject ((struct TdCallDiscardReasonMissed *)var);
    case CODE_CallDiscardReasonDeclined: return TdDestroyObject ((struct TdCallDiscardReasonDeclined *)var);
    case CODE_CallDiscardReasonDisconnected: return TdDestroyObject ((struct TdCallDiscardReasonDisconnected *)var);
    case CODE_CallDiscardReasonHungUp: return TdDestroyObject ((struct TdCallDiscardReasonHungUp *)var);
    case CODE_CallId: return TdDestroyObject ((struct TdCallId *)var);
    case CODE_CallProtocol: return TdDestroyObject ((struct TdCallProtocol *)var);
    case CODE_CallStatePending: return TdDestroyObject ((struct TdCallStatePending *)var);
    case CODE_CallStateExchangingKeys: return TdDestroyObject ((struct TdCallStateExchangingKeys *)var);
    case CODE_CallStateReady: return TdDestroyObject ((struct TdCallStateReady *)var);
    case CODE_CallStateHangingUp: return TdDestroyObject ((struct TdCallStateHangingUp *)var);
    case CODE_CallStateDiscarded: return TdDestroyObject ((struct TdCallStateDiscarded *)var);
    case CODE_CallStateError: return TdDestroyObject ((struct TdCallStateError *)var);
    case CODE_CallbackQueryAnswer: return TdDestroyObject ((struct TdCallbackQueryAnswer *)var);
    case CODE_CallbackQueryPayloadData: return TdDestroyObject ((struct TdCallbackQueryPayloadData *)var);
    case CODE_CallbackQueryPayloadGame: return TdDestroyObject ((struct TdCallbackQueryPayloadGame *)var);
    case CODE_Chat: return TdDestroyObject ((struct TdChat *)var);
    case CODE_ChatActionTyping: return TdDestroyObject ((struct TdChatActionTyping *)var);
    case CODE_ChatActionRecordingVideo: return TdDestroyObject ((struct TdChatActionRecordingVideo *)var);
    case CODE_ChatActionUploadingVideo: return TdDestroyObject ((struct TdChatActionUploadingVideo *)var);
    case CODE_ChatActionRecordingVoiceNote: return TdDestroyObject ((struct TdChatActionRecordingVoiceNote *)var);
    case CODE_ChatActionUploadingVoiceNote: return TdDestroyObject ((struct TdChatActionUploadingVoiceNote *)var);
    case CODE_ChatActionUploadingPhoto: return TdDestroyObject ((struct TdChatActionUploadingPhoto *)var);
    case CODE_ChatActionUploadingDocument: return TdDestroyObject ((struct TdChatActionUploadingDocument *)var);
    case CODE_ChatActionChoosingLocation: return TdDestroyObject ((struct TdChatActionChoosingLocation *)var);
    case CODE_ChatActionChoosingContact: return TdDestroyObject ((struct TdChatActionChoosingContact *)var);
    case CODE_ChatActionStartPlayingGame: return TdDestroyObject ((struct TdChatActionStartPlayingGame *)var);
    case CODE_ChatActionRecordingVideoNote: return TdDestroyObject ((struct TdChatActionRecordingVideoNote *)var);
    case CODE_ChatActionUploadingVideoNote: return TdDestroyObject ((struct TdChatActionUploadingVideoNote *)var);
    case CODE_ChatActionCancel: return TdDestroyObject ((struct TdChatActionCancel *)var);
    case CODE_ChatEvent: return TdDestroyObject ((struct TdChatEvent *)var);
    case CODE_ChatEventMessageEdited: return TdDestroyObject ((struct TdChatEventMessageEdited *)var);
    case CODE_ChatEventMessageDeleted: return TdDestroyObject ((struct TdChatEventMessageDeleted *)var);
    case CODE_ChatEventMessagePinned: return TdDestroyObject ((struct TdChatEventMessagePinned *)var);
    case CODE_ChatEventMessageUnpinned: return TdDestroyObject ((struct TdChatEventMessageUnpinned *)var);
    case CODE_ChatEventMemberJoined: return TdDestroyObject ((struct TdChatEventMemberJoined *)var);
    case CODE_ChatEventMemberLeft: return TdDestroyObject ((struct TdChatEventMemberLeft *)var);
    case CODE_ChatEventMemberInvited: return TdDestroyObject ((struct TdChatEventMemberInvited *)var);
    case CODE_ChatEventMemberPromoted: return TdDestroyObject ((struct TdChatEventMemberPromoted *)var);
    case CODE_ChatEventMemberRestricted: return TdDestroyObject ((struct TdChatEventMemberRestricted *)var);
    case CODE_ChatEventTitleChanged: return TdDestroyObject ((struct TdChatEventTitleChanged *)var);
    case CODE_ChatEventDescriptionChanged: return TdDestroyObject ((struct TdChatEventDescriptionChanged *)var);
    case CODE_ChatEventUsernameChanged: return TdDestroyObject ((struct TdChatEventUsernameChanged *)var);
    case CODE_ChatEventPhotoChanged: return TdDestroyObject ((struct TdChatEventPhotoChanged *)var);
    case CODE_ChatEventInvitesToggled: return TdDestroyObject ((struct TdChatEventInvitesToggled *)var);
    case CODE_ChatEventSignMessagesToggled: return TdDestroyObject ((struct TdChatEventSignMessagesToggled *)var);
    case CODE_ChatEventStickerSetChanged: return TdDestroyObject ((struct TdChatEventStickerSetChanged *)var);
    case CODE_ChatEventIsAllHistoryAvailableToggled: return TdDestroyObject ((struct TdChatEventIsAllHistoryAvailableToggled *)var);
    case CODE_ChatEventLogFilters: return TdDestroyObject ((struct TdChatEventLogFilters *)var);
    case CODE_ChatEvents: return TdDestroyObject ((struct TdChatEvents *)var);
    case CODE_ChatInviteLink: return TdDestroyObject ((struct TdChatInviteLink *)var);
    case CODE_ChatInviteLinkInfo: return TdDestroyObject ((struct TdChatInviteLinkInfo *)var);
    case CODE_ChatMember: return TdDestroyObject ((struct TdChatMember *)var);
    case CODE_ChatMemberStatusCreator: return TdDestroyObject ((struct TdChatMemberStatusCreator *)var);
    case CODE_ChatMemberStatusAdministrator: return TdDestroyObject ((struct TdChatMemberStatusAdministrator *)var);
    case CODE_ChatMemberStatusMember: return TdDestroyObject ((struct TdChatMemberStatusMember *)var);
    case CODE_ChatMemberStatusRestricted: return TdDestroyObject ((struct TdChatMemberStatusRestricted *)var);
    case CODE_ChatMemberStatusLeft: return TdDestroyObject ((struct TdChatMemberStatusLeft *)var);
    case CODE_ChatMemberStatusBanned: return TdDestroyObject ((struct TdChatMemberStatusBanned *)var);
    case CODE_ChatMembers: return TdDestroyObject ((struct TdChatMembers *)var);
    case CODE_ChatMembersFilterAdministrators: return TdDestroyObject ((struct TdChatMembersFilterAdministrators *)var);
    case CODE_ChatMembersFilterMembers: return TdDestroyObject ((struct TdChatMembersFilterMembers *)var);
    case CODE_ChatMembersFilterRestricted: return TdDestroyObject ((struct TdChatMembersFilterRestricted *)var);
    case CODE_ChatMembersFilterBanned: return TdDestroyObject ((struct TdChatMembersFilterBanned *)var);
    case CODE_ChatMembersFilterBots: return TdDestroyObject ((struct TdChatMembersFilterBots *)var);
    case CODE_ChatNotificationSettings: return TdDestroyObject ((struct TdChatNotificationSettings *)var);
    case CODE_ChatPhoto: return TdDestroyObject ((struct TdChatPhoto *)var);
    case CODE_ChatReportReasonSpam: return TdDestroyObject ((struct TdChatReportReasonSpam *)var);
    case CODE_ChatReportReasonViolence: return TdDestroyObject ((struct TdChatReportReasonViolence *)var);
    case CODE_ChatReportReasonPornography: return TdDestroyObject ((struct TdChatReportReasonPornography *)var);
    case CODE_ChatReportReasonCopyright: return TdDestroyObject ((struct TdChatReportReasonCopyright *)var);
    case CODE_ChatReportReasonCustom: return TdDestroyObject ((struct TdChatReportReasonCustom *)var);
    case CODE_ChatReportSpamState: return TdDestroyObject ((struct TdChatReportSpamState *)var);
    case CODE_ChatTypePrivate: return TdDestroyObject ((struct TdChatTypePrivate *)var);
    case CODE_ChatTypeBasicGroup: return TdDestroyObject ((struct TdChatTypeBasicGroup *)var);
    case CODE_ChatTypeSupergroup: return TdDestroyObject ((struct TdChatTypeSupergroup *)var);
    case CODE_ChatTypeSecret: return TdDestroyObject ((struct TdChatTypeSecret *)var);
    case CODE_Chats: return TdDestroyObject ((struct TdChats *)var);
    case CODE_CheckChatUsernameResultOk: return TdDestroyObject ((struct TdCheckChatUsernameResultOk *)var);
    case CODE_CheckChatUsernameResultUsernameInvalid: return TdDestroyObject ((struct TdCheckChatUsernameResultUsernameInvalid *)var);
    case CODE_CheckChatUsernameResultUsernameOccupied: return TdDestroyObject ((struct TdCheckChatUsernameResultUsernameOccupied *)var);
    case CODE_CheckChatUsernameResultPublicChatsTooMuch: return TdDestroyObject ((struct TdCheckChatUsernameResultPublicChatsTooMuch *)var);
    case CODE_CheckChatUsernameResultPublicGroupsUnavailable: return TdDestroyObject ((struct TdCheckChatUsernameResultPublicGroupsUnavailable *)var);
    case CODE_ConnectedWebsite: return TdDestroyObject ((struct TdConnectedWebsite *)var);
    case CODE_ConnectedWebsites: return TdDestroyObject ((struct TdConnectedWebsites *)var);
    case CODE_ConnectionStateWaitingForNetwork: return TdDestroyObject ((struct TdConnectionStateWaitingForNetwork *)var);
    case CODE_ConnectionStateConnectingToProxy: return TdDestroyObject ((struct TdConnectionStateConnectingToProxy *)var);
    case CODE_ConnectionStateConnecting: return TdDestroyObject ((struct TdConnectionStateConnecting *)var);
    case CODE_ConnectionStateUpdating: return TdDestroyObject ((struct TdConnectionStateUpdating *)var);
    case CODE_ConnectionStateReady: return TdDestroyObject ((struct TdConnectionStateReady *)var);
    case CODE_Contact: return TdDestroyObject ((struct TdContact *)var);
    case CODE_Count: return TdDestroyObject ((struct TdCount *)var);
    case CODE_CustomRequestResult: return TdDestroyObject ((struct TdCustomRequestResult *)var);
    case CODE_Date: return TdDestroyObject ((struct TdDate *)var);
    case CODE_DatedFile: return TdDestroyObject ((struct TdDatedFile *)var);
    case CODE_DeepLinkInfo: return TdDestroyObject ((struct TdDeepLinkInfo *)var);
    case CODE_DeviceTokenGoogleCloudMessaging: return TdDestroyObject ((struct TdDeviceTokenGoogleCloudMessaging *)var);
    case CODE_DeviceTokenApplePush: return TdDestroyObject ((struct TdDeviceTokenApplePush *)var);
    case CODE_DeviceTokenApplePushVoIP: return TdDestroyObject ((struct TdDeviceTokenApplePushVoIP *)var);
    case CODE_DeviceTokenWindowsPush: return TdDestroyObject ((struct TdDeviceTokenWindowsPush *)var);
    case CODE_DeviceTokenMicrosoftPush: return TdDestroyObject ((struct TdDeviceTokenMicrosoftPush *)var);
    case CODE_DeviceTokenMicrosoftPushVoIP: return TdDestroyObject ((struct TdDeviceTokenMicrosoftPushVoIP *)var);
    case CODE_DeviceTokenWebPush: return TdDestroyObject ((struct TdDeviceTokenWebPush *)var);
    case CODE_DeviceTokenSimplePush: return TdDestroyObject ((struct TdDeviceTokenSimplePush *)var);
    case CODE_DeviceTokenUbuntuPush: return TdDestroyObject ((struct TdDeviceTokenUbuntuPush *)var);
    case CODE_DeviceTokenBlackBerryPush: return TdDestroyObject ((struct TdDeviceTokenBlackBerryPush *)var);
    case CODE_DeviceTokenTizenPush: return TdDestroyObject ((struct TdDeviceTokenTizenPush *)var);
    case CODE_Document: return TdDestroyObject ((struct TdDocument *)var);
    case CODE_DraftMessage: return TdDestroyObject ((struct TdDraftMessage *)var);
    case CODE_EmailAddressAuthenticationCodeInfo: return TdDestroyObject ((struct TdEmailAddressAuthenticationCodeInfo *)var);
    case CODE_EncryptedCredentials: return TdDestroyObject ((struct TdEncryptedCredentials *)var);
    case CODE_EncryptedPassportElement: return TdDestroyObject ((struct TdEncryptedPassportElement *)var);
    case CODE_Error: return TdDestroyObject ((struct TdError *)var);
    case CODE_File: return TdDestroyObject ((struct TdFile *)var);
    case CODE_FileTypeNone: return TdDestroyObject ((struct TdFileTypeNone *)var);
    case CODE_FileTypeAnimation: return TdDestroyObject ((struct TdFileTypeAnimation *)var);
    case CODE_FileTypeAudio: return TdDestroyObject ((struct TdFileTypeAudio *)var);
    case CODE_FileTypeDocument: return TdDestroyObject ((struct TdFileTypeDocument *)var);
    case CODE_FileTypePhoto: return TdDestroyObject ((struct TdFileTypePhoto *)var);
    case CODE_FileTypeProfilePhoto: return TdDestroyObject ((struct TdFileTypeProfilePhoto *)var);
    case CODE_FileTypeSecret: return TdDestroyObject ((struct TdFileTypeSecret *)var);
    case CODE_FileTypeSecretThumbnail: return TdDestroyObject ((struct TdFileTypeSecretThumbnail *)var);
    case CODE_FileTypeSecure: return TdDestroyObject ((struct TdFileTypeSecure *)var);
    case CODE_FileTypeSticker: return TdDestroyObject ((struct TdFileTypeSticker *)var);
    case CODE_FileTypeThumbnail: return TdDestroyObject ((struct TdFileTypeThumbnail *)var);
    case CODE_FileTypeUnknown: return TdDestroyObject ((struct TdFileTypeUnknown *)var);
    case CODE_FileTypeVideo: return TdDestroyObject ((struct TdFileTypeVideo *)var);
    case CODE_FileTypeVideoNote: return TdDestroyObject ((struct TdFileTypeVideoNote *)var);
    case CODE_FileTypeVoiceNote: return TdDestroyObject ((struct TdFileTypeVoiceNote *)var);
    case CODE_FileTypeWallpaper: return TdDestroyObject ((struct TdFileTypeWallpaper *)var);
    case CODE_FormattedText: return TdDestroyObject ((struct TdFormattedText *)var);
    case CODE_FoundMessages: return TdDestroyObject ((struct TdFoundMessages *)var);
    case CODE_Game: return TdDestroyObject ((struct TdGame *)var);
    case CODE_GameHighScore: return TdDestroyObject ((struct TdGameHighScore *)var);
    case CODE_GameHighScores: return TdDestroyObject ((struct TdGameHighScores *)var);
    case CODE_Hashtags: return TdDestroyObject ((struct TdHashtags *)var);
    case CODE_IdentityDocument: return TdDestroyObject ((struct TdIdentityDocument *)var);
    case CODE_ImportedContacts: return TdDestroyObject ((struct TdImportedContacts *)var);
    case CODE_InlineKeyboardButton: return TdDestroyObject ((struct TdInlineKeyboardButton *)var);
    case CODE_InlineKeyboardButtonTypeUrl: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeUrl *)var);
    case CODE_InlineKeyboardButtonTypeCallback: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeCallback *)var);
    case CODE_InlineKeyboardButtonTypeCallbackGame: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeCallbackGame *)var);
    case CODE_InlineKeyboardButtonTypeSwitchInline: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeSwitchInline *)var);
    case CODE_InlineKeyboardButtonTypeBuy: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeBuy *)var);
    case CODE_InlineQueryResultArticle: return TdDestroyObject ((struct TdInlineQueryResultArticle *)var);
    case CODE_InlineQueryResultContact: return TdDestroyObject ((struct TdInlineQueryResultContact *)var);
    case CODE_InlineQueryResultLocation: return TdDestroyObject ((struct TdInlineQueryResultLocation *)var);
    case CODE_InlineQueryResultVenue: return TdDestroyObject ((struct TdInlineQueryResultVenue *)var);
    case CODE_InlineQueryResultGame: return TdDestroyObject ((struct TdInlineQueryResultGame *)var);
    case CODE_InlineQueryResultAnimation: return TdDestroyObject ((struct TdInlineQueryResultAnimation *)var);
    case CODE_InlineQueryResultAudio: return TdDestroyObject ((struct TdInlineQueryResultAudio *)var);
    case CODE_InlineQueryResultDocument: return TdDestroyObject ((struct TdInlineQueryResultDocument *)var);
    case CODE_InlineQueryResultPhoto: return TdDestroyObject ((struct TdInlineQueryResultPhoto *)var);
    case CODE_InlineQueryResultSticker: return TdDestroyObject ((struct TdInlineQueryResultSticker *)var);
    case CODE_InlineQueryResultVideo: return TdDestroyObject ((struct TdInlineQueryResultVideo *)var);
    case CODE_InlineQueryResultVoiceNote: return TdDestroyObject ((struct TdInlineQueryResultVoiceNote *)var);
    case CODE_InlineQueryResults: return TdDestroyObject ((struct TdInlineQueryResults *)var);
    case CODE_InputCredentialsSaved: return TdDestroyObject ((struct TdInputCredentialsSaved *)var);
    case CODE_InputCredentialsNew: return TdDestroyObject ((struct TdInputCredentialsNew *)var);
    case CODE_InputCredentialsAndroidPay: return TdDestroyObject ((struct TdInputCredentialsAndroidPay *)var);
    case CODE_InputCredentialsApplePay: return TdDestroyObject ((struct TdInputCredentialsApplePay *)var);
    case CODE_InputFileId: return TdDestroyObject ((struct TdInputFileId *)var);
    case CODE_InputFileRemote: return TdDestroyObject ((struct TdInputFileRemote *)var);
    case CODE_InputFileLocal: return TdDestroyObject ((struct TdInputFileLocal *)var);
    case CODE_InputFileGenerated: return TdDestroyObject ((struct TdInputFileGenerated *)var);
    case CODE_InputIdentityDocument: return TdDestroyObject ((struct TdInputIdentityDocument *)var);
    case CODE_InputInlineQueryResultAnimatedGif: return TdDestroyObject ((struct TdInputInlineQueryResultAnimatedGif *)var);
    case CODE_InputInlineQueryResultAnimatedMpeg4: return TdDestroyObject ((struct TdInputInlineQueryResultAnimatedMpeg4 *)var);
    case CODE_InputInlineQueryResultArticle: return TdDestroyObject ((struct TdInputInlineQueryResultArticle *)var);
    case CODE_InputInlineQueryResultAudio: return TdDestroyObject ((struct TdInputInlineQueryResultAudio *)var);
    case CODE_InputInlineQueryResultContact: return TdDestroyObject ((struct TdInputInlineQueryResultContact *)var);
    case CODE_InputInlineQueryResultDocument: return TdDestroyObject ((struct TdInputInlineQueryResultDocument *)var);
    case CODE_InputInlineQueryResultGame: return TdDestroyObject ((struct TdInputInlineQueryResultGame *)var);
    case CODE_InputInlineQueryResultLocation: return TdDestroyObject ((struct TdInputInlineQueryResultLocation *)var);
    case CODE_InputInlineQueryResultPhoto: return TdDestroyObject ((struct TdInputInlineQueryResultPhoto *)var);
    case CODE_InputInlineQueryResultSticker: return TdDestroyObject ((struct TdInputInlineQueryResultSticker *)var);
    case CODE_InputInlineQueryResultVenue: return TdDestroyObject ((struct TdInputInlineQueryResultVenue *)var);
    case CODE_InputInlineQueryResultVideo: return TdDestroyObject ((struct TdInputInlineQueryResultVideo *)var);
    case CODE_InputInlineQueryResultVoiceNote: return TdDestroyObject ((struct TdInputInlineQueryResultVoiceNote *)var);
    case CODE_InputMessageText: return TdDestroyObject ((struct TdInputMessageText *)var);
    case CODE_InputMessageAnimation: return TdDestroyObject ((struct TdInputMessageAnimation *)var);
    case CODE_InputMessageAudio: return TdDestroyObject ((struct TdInputMessageAudio *)var);
    case CODE_InputMessageDocument: return TdDestroyObject ((struct TdInputMessageDocument *)var);
    case CODE_InputMessagePhoto: return TdDestroyObject ((struct TdInputMessagePhoto *)var);
    case CODE_InputMessageSticker: return TdDestroyObject ((struct TdInputMessageSticker *)var);
    case CODE_InputMessageVideo: return TdDestroyObject ((struct TdInputMessageVideo *)var);
    case CODE_InputMessageVideoNote: return TdDestroyObject ((struct TdInputMessageVideoNote *)var);
    case CODE_InputMessageVoiceNote: return TdDestroyObject ((struct TdInputMessageVoiceNote *)var);
    case CODE_InputMessageLocation: return TdDestroyObject ((struct TdInputMessageLocation *)var);
    case CODE_InputMessageVenue: return TdDestroyObject ((struct TdInputMessageVenue *)var);
    case CODE_InputMessageContact: return TdDestroyObject ((struct TdInputMessageContact *)var);
    case CODE_InputMessageGame: return TdDestroyObject ((struct TdInputMessageGame *)var);
    case CODE_InputMessageInvoice: return TdDestroyObject ((struct TdInputMessageInvoice *)var);
    case CODE_InputMessageForwarded: return TdDestroyObject ((struct TdInputMessageForwarded *)var);
    case CODE_InputPassportElementPersonalDetails: return TdDestroyObject ((struct TdInputPassportElementPersonalDetails *)var);
    case CODE_InputPassportElementPassport: return TdDestroyObject ((struct TdInputPassportElementPassport *)var);
    case CODE_InputPassportElementDriverLicense: return TdDestroyObject ((struct TdInputPassportElementDriverLicense *)var);
    case CODE_InputPassportElementIdentityCard: return TdDestroyObject ((struct TdInputPassportElementIdentityCard *)var);
    case CODE_InputPassportElementInternalPassport: return TdDestroyObject ((struct TdInputPassportElementInternalPassport *)var);
    case CODE_InputPassportElementAddress: return TdDestroyObject ((struct TdInputPassportElementAddress *)var);
    case CODE_InputPassportElementUtilityBill: return TdDestroyObject ((struct TdInputPassportElementUtilityBill *)var);
    case CODE_InputPassportElementBankStatement: return TdDestroyObject ((struct TdInputPassportElementBankStatement *)var);
    case CODE_InputPassportElementRentalAgreement: return TdDestroyObject ((struct TdInputPassportElementRentalAgreement *)var);
    case CODE_InputPassportElementPassportRegistration: return TdDestroyObject ((struct TdInputPassportElementPassportRegistration *)var);
    case CODE_InputPassportElementTemporaryRegistration: return TdDestroyObject ((struct TdInputPassportElementTemporaryRegistration *)var);
    case CODE_InputPassportElementPhoneNumber: return TdDestroyObject ((struct TdInputPassportElementPhoneNumber *)var);
    case CODE_InputPassportElementEmailAddress: return TdDestroyObject ((struct TdInputPassportElementEmailAddress *)var);
    case CODE_InputPassportElementError: return TdDestroyObject ((struct TdInputPassportElementError *)var);
    case CODE_InputPassportElementErrorSourceUnspecified: return TdDestroyObject ((struct TdInputPassportElementErrorSourceUnspecified *)var);
    case CODE_InputPassportElementErrorSourceDataField: return TdDestroyObject ((struct TdInputPassportElementErrorSourceDataField *)var);
    case CODE_InputPassportElementErrorSourceFrontSide: return TdDestroyObject ((struct TdInputPassportElementErrorSourceFrontSide *)var);
    case CODE_InputPassportElementErrorSourceReverseSide: return TdDestroyObject ((struct TdInputPassportElementErrorSourceReverseSide *)var);
    case CODE_InputPassportElementErrorSourceSelfie: return TdDestroyObject ((struct TdInputPassportElementErrorSourceSelfie *)var);
    case CODE_InputPassportElementErrorSourceTranslationFile: return TdDestroyObject ((struct TdInputPassportElementErrorSourceTranslationFile *)var);
    case CODE_InputPassportElementErrorSourceTranslationFiles: return TdDestroyObject ((struct TdInputPassportElementErrorSourceTranslationFiles *)var);
    case CODE_InputPassportElementErrorSourceFile: return TdDestroyObject ((struct TdInputPassportElementErrorSourceFile *)var);
    case CODE_InputPassportElementErrorSourceFiles: return TdDestroyObject ((struct TdInputPassportElementErrorSourceFiles *)var);
    case CODE_InputPersonalDocument: return TdDestroyObject ((struct TdInputPersonalDocument *)var);
    case CODE_InputSticker: return TdDestroyObject ((struct TdInputSticker *)var);
    case CODE_InputThumbnail: return TdDestroyObject ((struct TdInputThumbnail *)var);
    case CODE_Invoice: return TdDestroyObject ((struct TdInvoice *)var);
    case CODE_KeyboardButton: return TdDestroyObject ((struct TdKeyboardButton *)var);
    case CODE_KeyboardButtonTypeText: return TdDestroyObject ((struct TdKeyboardButtonTypeText *)var);
    case CODE_KeyboardButtonTypeRequestPhoneNumber: return TdDestroyObject ((struct TdKeyboardButtonTypeRequestPhoneNumber *)var);
    case CODE_KeyboardButtonTypeRequestLocation: return TdDestroyObject ((struct TdKeyboardButtonTypeRequestLocation *)var);
    case CODE_LabeledPricePart: return TdDestroyObject ((struct TdLabeledPricePart *)var);
    case CODE_LanguagePackInfo: return TdDestroyObject ((struct TdLanguagePackInfo *)var);
    case CODE_LanguagePackString: return TdDestroyObject ((struct TdLanguagePackString *)var);
    case CODE_LanguagePackStringValueOrdinary: return TdDestroyObject ((struct TdLanguagePackStringValueOrdinary *)var);
    case CODE_LanguagePackStringValuePluralized: return TdDestroyObject ((struct TdLanguagePackStringValuePluralized *)var);
    case CODE_LanguagePackStringValueDeleted: return TdDestroyObject ((struct TdLanguagePackStringValueDeleted *)var);
    case CODE_LanguagePackStrings: return TdDestroyObject ((struct TdLanguagePackStrings *)var);
    case CODE_LinkStateNone: return TdDestroyObject ((struct TdLinkStateNone *)var);
    case CODE_LinkStateKnowsPhoneNumber: return TdDestroyObject ((struct TdLinkStateKnowsPhoneNumber *)var);
    case CODE_LinkStateIsContact: return TdDestroyObject ((struct TdLinkStateIsContact *)var);
    case CODE_LocalFile: return TdDestroyObject ((struct TdLocalFile *)var);
    case CODE_LocalizationTargetInfo: return TdDestroyObject ((struct TdLocalizationTargetInfo *)var);
    case CODE_Location: return TdDestroyObject ((struct TdLocation *)var);
    case CODE_MaskPointForehead: return TdDestroyObject ((struct TdMaskPointForehead *)var);
    case CODE_MaskPointEyes: return TdDestroyObject ((struct TdMaskPointEyes *)var);
    case CODE_MaskPointMouth: return TdDestroyObject ((struct TdMaskPointMouth *)var);
    case CODE_MaskPointChin: return TdDestroyObject ((struct TdMaskPointChin *)var);
    case CODE_MaskPosition: return TdDestroyObject ((struct TdMaskPosition *)var);
    case CODE_Message: return TdDestroyObject ((struct TdMessage *)var);
    case CODE_MessageText: return TdDestroyObject ((struct TdMessageText *)var);
    case CODE_MessageAnimation: return TdDestroyObject ((struct TdMessageAnimation *)var);
    case CODE_MessageAudio: return TdDestroyObject ((struct TdMessageAudio *)var);
    case CODE_MessageDocument: return TdDestroyObject ((struct TdMessageDocument *)var);
    case CODE_MessagePhoto: return TdDestroyObject ((struct TdMessagePhoto *)var);
    case CODE_MessageExpiredPhoto: return TdDestroyObject ((struct TdMessageExpiredPhoto *)var);
    case CODE_MessageSticker: return TdDestroyObject ((struct TdMessageSticker *)var);
    case CODE_MessageVideo: return TdDestroyObject ((struct TdMessageVideo *)var);
    case CODE_MessageExpiredVideo: return TdDestroyObject ((struct TdMessageExpiredVideo *)var);
    case CODE_MessageVideoNote: return TdDestroyObject ((struct TdMessageVideoNote *)var);
    case CODE_MessageVoiceNote: return TdDestroyObject ((struct TdMessageVoiceNote *)var);
    case CODE_MessageLocation: return TdDestroyObject ((struct TdMessageLocation *)var);
    case CODE_MessageVenue: return TdDestroyObject ((struct TdMessageVenue *)var);
    case CODE_MessageContact: return TdDestroyObject ((struct TdMessageContact *)var);
    case CODE_MessageGame: return TdDestroyObject ((struct TdMessageGame *)var);
    case CODE_MessageInvoice: return TdDestroyObject ((struct TdMessageInvoice *)var);
    case CODE_MessageCall: return TdDestroyObject ((struct TdMessageCall *)var);
    case CODE_MessageBasicGroupChatCreate: return TdDestroyObject ((struct TdMessageBasicGroupChatCreate *)var);
    case CODE_MessageSupergroupChatCreate: return TdDestroyObject ((struct TdMessageSupergroupChatCreate *)var);
    case CODE_MessageChatChangeTitle: return TdDestroyObject ((struct TdMessageChatChangeTitle *)var);
    case CODE_MessageChatChangePhoto: return TdDestroyObject ((struct TdMessageChatChangePhoto *)var);
    case CODE_MessageChatDeletePhoto: return TdDestroyObject ((struct TdMessageChatDeletePhoto *)var);
    case CODE_MessageChatAddMembers: return TdDestroyObject ((struct TdMessageChatAddMembers *)var);
    case CODE_MessageChatJoinByLink: return TdDestroyObject ((struct TdMessageChatJoinByLink *)var);
    case CODE_MessageChatDeleteMember: return TdDestroyObject ((struct TdMessageChatDeleteMember *)var);
    case CODE_MessageChatUpgradeTo: return TdDestroyObject ((struct TdMessageChatUpgradeTo *)var);
    case CODE_MessageChatUpgradeFrom: return TdDestroyObject ((struct TdMessageChatUpgradeFrom *)var);
    case CODE_MessagePinMessage: return TdDestroyObject ((struct TdMessagePinMessage *)var);
    case CODE_MessageScreenshotTaken: return TdDestroyObject ((struct TdMessageScreenshotTaken *)var);
    case CODE_MessageChatSetTtl: return TdDestroyObject ((struct TdMessageChatSetTtl *)var);
    case CODE_MessageCustomServiceAction: return TdDestroyObject ((struct TdMessageCustomServiceAction *)var);
    case CODE_MessageGameScore: return TdDestroyObject ((struct TdMessageGameScore *)var);
    case CODE_MessagePaymentSuccessful: return TdDestroyObject ((struct TdMessagePaymentSuccessful *)var);
    case CODE_MessagePaymentSuccessfulBot: return TdDestroyObject ((struct TdMessagePaymentSuccessfulBot *)var);
    case CODE_MessageContactRegistered: return TdDestroyObject ((struct TdMessageContactRegistered *)var);
    case CODE_MessageWebsiteConnected: return TdDestroyObject ((struct TdMessageWebsiteConnected *)var);
    case CODE_MessagePassportDataSent: return TdDestroyObject ((struct TdMessagePassportDataSent *)var);
    case CODE_MessagePassportDataReceived: return TdDestroyObject ((struct TdMessagePassportDataReceived *)var);
    case CODE_MessageUnsupported: return TdDestroyObject ((struct TdMessageUnsupported *)var);
    case CODE_MessageForwardedFromUser: return TdDestroyObject ((struct TdMessageForwardedFromUser *)var);
    case CODE_MessageForwardedPost: return TdDestroyObject ((struct TdMessageForwardedPost *)var);
    case CODE_MessageSendingStatePending: return TdDestroyObject ((struct TdMessageSendingStatePending *)var);
    case CODE_MessageSendingStateFailed: return TdDestroyObject ((struct TdMessageSendingStateFailed *)var);
    case CODE_Messages: return TdDestroyObject ((struct TdMessages *)var);
    case CODE_NetworkStatistics: return TdDestroyObject ((struct TdNetworkStatistics *)var);
    case CODE_NetworkStatisticsEntryFile: return TdDestroyObject ((struct TdNetworkStatisticsEntryFile *)var);
    case CODE_NetworkStatisticsEntryCall: return TdDestroyObject ((struct TdNetworkStatisticsEntryCall *)var);
    case CODE_NetworkTypeNone: return TdDestroyObject ((struct TdNetworkTypeNone *)var);
    case CODE_NetworkTypeMobile: return TdDestroyObject ((struct TdNetworkTypeMobile *)var);
    case CODE_NetworkTypeMobileRoaming: return TdDestroyObject ((struct TdNetworkTypeMobileRoaming *)var);
    case CODE_NetworkTypeWiFi: return TdDestroyObject ((struct TdNetworkTypeWiFi *)var);
    case CODE_NetworkTypeOther: return TdDestroyObject ((struct TdNetworkTypeOther *)var);
    case CODE_NotificationSettingsScopePrivateChats: return TdDestroyObject ((struct TdNotificationSettingsScopePrivateChats *)var);
    case CODE_NotificationSettingsScopeGroupChats: return TdDestroyObject ((struct TdNotificationSettingsScopeGroupChats *)var);
    case CODE_Ok: return TdDestroyObject ((struct TdOk *)var);
    case CODE_OptionValueBoolean: return TdDestroyObject ((struct TdOptionValueBoolean *)var);
    case CODE_OptionValueEmpty: return TdDestroyObject ((struct TdOptionValueEmpty *)var);
    case CODE_OptionValueInteger: return TdDestroyObject ((struct TdOptionValueInteger *)var);
    case CODE_OptionValueString: return TdDestroyObject ((struct TdOptionValueString *)var);
    case CODE_OrderInfo: return TdDestroyObject ((struct TdOrderInfo *)var);
    case CODE_PageBlockTitle: return TdDestroyObject ((struct TdPageBlockTitle *)var);
    case CODE_PageBlockSubtitle: return TdDestroyObject ((struct TdPageBlockSubtitle *)var);
    case CODE_PageBlockAuthorDate: return TdDestroyObject ((struct TdPageBlockAuthorDate *)var);
    case CODE_PageBlockHeader: return TdDestroyObject ((struct TdPageBlockHeader *)var);
    case CODE_PageBlockSubheader: return TdDestroyObject ((struct TdPageBlockSubheader *)var);
    case CODE_PageBlockParagraph: return TdDestroyObject ((struct TdPageBlockParagraph *)var);
    case CODE_PageBlockPreformatted: return TdDestroyObject ((struct TdPageBlockPreformatted *)var);
    case CODE_PageBlockFooter: return TdDestroyObject ((struct TdPageBlockFooter *)var);
    case CODE_PageBlockDivider: return TdDestroyObject ((struct TdPageBlockDivider *)var);
    case CODE_PageBlockAnchor: return TdDestroyObject ((struct TdPageBlockAnchor *)var);
    case CODE_PageBlockList: return TdDestroyObject ((struct TdPageBlockList *)var);
    case CODE_PageBlockBlockQuote: return TdDestroyObject ((struct TdPageBlockBlockQuote *)var);
    case CODE_PageBlockPullQuote: return TdDestroyObject ((struct TdPageBlockPullQuote *)var);
    case CODE_PageBlockAnimation: return TdDestroyObject ((struct TdPageBlockAnimation *)var);
    case CODE_PageBlockAudio: return TdDestroyObject ((struct TdPageBlockAudio *)var);
    case CODE_PageBlockPhoto: return TdDestroyObject ((struct TdPageBlockPhoto *)var);
    case CODE_PageBlockVideo: return TdDestroyObject ((struct TdPageBlockVideo *)var);
    case CODE_PageBlockCover: return TdDestroyObject ((struct TdPageBlockCover *)var);
    case CODE_PageBlockEmbedded: return TdDestroyObject ((struct TdPageBlockEmbedded *)var);
    case CODE_PageBlockEmbeddedPost: return TdDestroyObject ((struct TdPageBlockEmbeddedPost *)var);
    case CODE_PageBlockCollage: return TdDestroyObject ((struct TdPageBlockCollage *)var);
    case CODE_PageBlockSlideshow: return TdDestroyObject ((struct TdPageBlockSlideshow *)var);
    case CODE_PageBlockChatLink: return TdDestroyObject ((struct TdPageBlockChatLink *)var);
    case CODE_PassportAuthorizationForm: return TdDestroyObject ((struct TdPassportAuthorizationForm *)var);
    case CODE_PassportElementPersonalDetails: return TdDestroyObject ((struct TdPassportElementPersonalDetails *)var);
    case CODE_PassportElementPassport: return TdDestroyObject ((struct TdPassportElementPassport *)var);
    case CODE_PassportElementDriverLicense: return TdDestroyObject ((struct TdPassportElementDriverLicense *)var);
    case CODE_PassportElementIdentityCard: return TdDestroyObject ((struct TdPassportElementIdentityCard *)var);
    case CODE_PassportElementInternalPassport: return TdDestroyObject ((struct TdPassportElementInternalPassport *)var);
    case CODE_PassportElementAddress: return TdDestroyObject ((struct TdPassportElementAddress *)var);
    case CODE_PassportElementUtilityBill: return TdDestroyObject ((struct TdPassportElementUtilityBill *)var);
    case CODE_PassportElementBankStatement: return TdDestroyObject ((struct TdPassportElementBankStatement *)var);
    case CODE_PassportElementRentalAgreement: return TdDestroyObject ((struct TdPassportElementRentalAgreement *)var);
    case CODE_PassportElementPassportRegistration: return TdDestroyObject ((struct TdPassportElementPassportRegistration *)var);
    case CODE_PassportElementTemporaryRegistration: return TdDestroyObject ((struct TdPassportElementTemporaryRegistration *)var);
    case CODE_PassportElementPhoneNumber: return TdDestroyObject ((struct TdPassportElementPhoneNumber *)var);
    case CODE_PassportElementEmailAddress: return TdDestroyObject ((struct TdPassportElementEmailAddress *)var);
    case CODE_PassportElementError: return TdDestroyObject ((struct TdPassportElementError *)var);
    case CODE_PassportElementErrorSourceUnspecified: return TdDestroyObject ((struct TdPassportElementErrorSourceUnspecified *)var);
    case CODE_PassportElementErrorSourceDataField: return TdDestroyObject ((struct TdPassportElementErrorSourceDataField *)var);
    case CODE_PassportElementErrorSourceFrontSide: return TdDestroyObject ((struct TdPassportElementErrorSourceFrontSide *)var);
    case CODE_PassportElementErrorSourceReverseSide: return TdDestroyObject ((struct TdPassportElementErrorSourceReverseSide *)var);
    case CODE_PassportElementErrorSourceSelfie: return TdDestroyObject ((struct TdPassportElementErrorSourceSelfie *)var);
    case CODE_PassportElementErrorSourceTranslationFile: return TdDestroyObject ((struct TdPassportElementErrorSourceTranslationFile *)var);
    case CODE_PassportElementErrorSourceTranslationFiles: return TdDestroyObject ((struct TdPassportElementErrorSourceTranslationFiles *)var);
    case CODE_PassportElementErrorSourceFile: return TdDestroyObject ((struct TdPassportElementErrorSourceFile *)var);
    case CODE_PassportElementErrorSourceFiles: return TdDestroyObject ((struct TdPassportElementErrorSourceFiles *)var);
    case CODE_PassportElementTypePersonalDetails: return TdDestroyObject ((struct TdPassportElementTypePersonalDetails *)var);
    case CODE_PassportElementTypePassport: return TdDestroyObject ((struct TdPassportElementTypePassport *)var);
    case CODE_PassportElementTypeDriverLicense: return TdDestroyObject ((struct TdPassportElementTypeDriverLicense *)var);
    case CODE_PassportElementTypeIdentityCard: return TdDestroyObject ((struct TdPassportElementTypeIdentityCard *)var);
    case CODE_PassportElementTypeInternalPassport: return TdDestroyObject ((struct TdPassportElementTypeInternalPassport *)var);
    case CODE_PassportElementTypeAddress: return TdDestroyObject ((struct TdPassportElementTypeAddress *)var);
    case CODE_PassportElementTypeUtilityBill: return TdDestroyObject ((struct TdPassportElementTypeUtilityBill *)var);
    case CODE_PassportElementTypeBankStatement: return TdDestroyObject ((struct TdPassportElementTypeBankStatement *)var);
    case CODE_PassportElementTypeRentalAgreement: return TdDestroyObject ((struct TdPassportElementTypeRentalAgreement *)var);
    case CODE_PassportElementTypePassportRegistration: return TdDestroyObject ((struct TdPassportElementTypePassportRegistration *)var);
    case CODE_PassportElementTypeTemporaryRegistration: return TdDestroyObject ((struct TdPassportElementTypeTemporaryRegistration *)var);
    case CODE_PassportElementTypePhoneNumber: return TdDestroyObject ((struct TdPassportElementTypePhoneNumber *)var);
    case CODE_PassportElementTypeEmailAddress: return TdDestroyObject ((struct TdPassportElementTypeEmailAddress *)var);
    case CODE_PassportElements: return TdDestroyObject ((struct TdPassportElements *)var);
    case CODE_PassportRequiredElement: return TdDestroyObject ((struct TdPassportRequiredElement *)var);
    case CODE_PassportSuitableElement: return TdDestroyObject ((struct TdPassportSuitableElement *)var);
    case CODE_PasswordState: return TdDestroyObject ((struct TdPasswordState *)var);
    case CODE_PaymentForm: return TdDestroyObject ((struct TdPaymentForm *)var);
    case CODE_PaymentReceipt: return TdDestroyObject ((struct TdPaymentReceipt *)var);
    case CODE_PaymentResult: return TdDestroyObject ((struct TdPaymentResult *)var);
    case CODE_PaymentsProviderStripe: return TdDestroyObject ((struct TdPaymentsProviderStripe *)var);
    case CODE_PersonalDetails: return TdDestroyObject ((struct TdPersonalDetails *)var);
    case CODE_PersonalDocument: return TdDestroyObject ((struct TdPersonalDocument *)var);
    case CODE_Photo: return TdDestroyObject ((struct TdPhoto *)var);
    case CODE_PhotoSize: return TdDestroyObject ((struct TdPhotoSize *)var);
    case CODE_ProfilePhoto: return TdDestroyObject ((struct TdProfilePhoto *)var);
    case CODE_Proxies: return TdDestroyObject ((struct TdProxies *)var);
    case CODE_Proxy: return TdDestroyObject ((struct TdProxy *)var);
    case CODE_ProxyTypeSocks5: return TdDestroyObject ((struct TdProxyTypeSocks5 *)var);
    case CODE_ProxyTypeHttp: return TdDestroyObject ((struct TdProxyTypeHttp *)var);
    case CODE_ProxyTypeMtproto: return TdDestroyObject ((struct TdProxyTypeMtproto *)var);
    case CODE_PublicMessageLink: return TdDestroyObject ((struct TdPublicMessageLink *)var);
    case CODE_RecoveryEmailAddress: return TdDestroyObject ((struct TdRecoveryEmailAddress *)var);
    case CODE_RemoteFile: return TdDestroyObject ((struct TdRemoteFile *)var);
    case CODE_ReplyMarkupRemoveKeyboard: return TdDestroyObject ((struct TdReplyMarkupRemoveKeyboard *)var);
    case CODE_ReplyMarkupForceReply: return TdDestroyObject ((struct TdReplyMarkupForceReply *)var);
    case CODE_ReplyMarkupShowKeyboard: return TdDestroyObject ((struct TdReplyMarkupShowKeyboard *)var);
    case CODE_ReplyMarkupInlineKeyboard: return TdDestroyObject ((struct TdReplyMarkupInlineKeyboard *)var);
    case CODE_RichTextPlain: return TdDestroyObject ((struct TdRichTextPlain *)var);
    case CODE_RichTextBold: return TdDestroyObject ((struct TdRichTextBold *)var);
    case CODE_RichTextItalic: return TdDestroyObject ((struct TdRichTextItalic *)var);
    case CODE_RichTextUnderline: return TdDestroyObject ((struct TdRichTextUnderline *)var);
    case CODE_RichTextStrikethrough: return TdDestroyObject ((struct TdRichTextStrikethrough *)var);
    case CODE_RichTextFixed: return TdDestroyObject ((struct TdRichTextFixed *)var);
    case CODE_RichTextUrl: return TdDestroyObject ((struct TdRichTextUrl *)var);
    case CODE_RichTextEmailAddress: return TdDestroyObject ((struct TdRichTextEmailAddress *)var);
    case CODE_RichTexts: return TdDestroyObject ((struct TdRichTexts *)var);
    case CODE_SavedCredentials: return TdDestroyObject ((struct TdSavedCredentials *)var);
    case CODE_ScopeNotificationSettings: return TdDestroyObject ((struct TdScopeNotificationSettings *)var);
    case CODE_SearchMessagesFilterEmpty: return TdDestroyObject ((struct TdSearchMessagesFilterEmpty *)var);
    case CODE_SearchMessagesFilterAnimation: return TdDestroyObject ((struct TdSearchMessagesFilterAnimation *)var);
    case CODE_SearchMessagesFilterAudio: return TdDestroyObject ((struct TdSearchMessagesFilterAudio *)var);
    case CODE_SearchMessagesFilterDocument: return TdDestroyObject ((struct TdSearchMessagesFilterDocument *)var);
    case CODE_SearchMessagesFilterPhoto: return TdDestroyObject ((struct TdSearchMessagesFilterPhoto *)var);
    case CODE_SearchMessagesFilterVideo: return TdDestroyObject ((struct TdSearchMessagesFilterVideo *)var);
    case CODE_SearchMessagesFilterVoiceNote: return TdDestroyObject ((struct TdSearchMessagesFilterVoiceNote *)var);
    case CODE_SearchMessagesFilterPhotoAndVideo: return TdDestroyObject ((struct TdSearchMessagesFilterPhotoAndVideo *)var);
    case CODE_SearchMessagesFilterUrl: return TdDestroyObject ((struct TdSearchMessagesFilterUrl *)var);
    case CODE_SearchMessagesFilterChatPhoto: return TdDestroyObject ((struct TdSearchMessagesFilterChatPhoto *)var);
    case CODE_SearchMessagesFilterCall: return TdDestroyObject ((struct TdSearchMessagesFilterCall *)var);
    case CODE_SearchMessagesFilterMissedCall: return TdDestroyObject ((struct TdSearchMessagesFilterMissedCall *)var);
    case CODE_SearchMessagesFilterVideoNote: return TdDestroyObject ((struct TdSearchMessagesFilterVideoNote *)var);
    case CODE_SearchMessagesFilterVoiceAndVideoNote: return TdDestroyObject ((struct TdSearchMessagesFilterVoiceAndVideoNote *)var);
    case CODE_SearchMessagesFilterMention: return TdDestroyObject ((struct TdSearchMessagesFilterMention *)var);
    case CODE_SearchMessagesFilterUnreadMention: return TdDestroyObject ((struct TdSearchMessagesFilterUnreadMention *)var);
    case CODE_Seconds: return TdDestroyObject ((struct TdSeconds *)var);
    case CODE_SecretChat: return TdDestroyObject ((struct TdSecretChat *)var);
    case CODE_SecretChatStatePending: return TdDestroyObject ((struct TdSecretChatStatePending *)var);
    case CODE_SecretChatStateReady: return TdDestroyObject ((struct TdSecretChatStateReady *)var);
    case CODE_SecretChatStateClosed: return TdDestroyObject ((struct TdSecretChatStateClosed *)var);
    case CODE_Session: return TdDestroyObject ((struct TdSession *)var);
    case CODE_Sessions: return TdDestroyObject ((struct TdSessions *)var);
    case CODE_ShippingOption: return TdDestroyObject ((struct TdShippingOption *)var);
    case CODE_Sticker: return TdDestroyObject ((struct TdSticker *)var);
    case CODE_StickerEmojis: return TdDestroyObject ((struct TdStickerEmojis *)var);
    case CODE_StickerSet: return TdDestroyObject ((struct TdStickerSet *)var);
    case CODE_StickerSetInfo: return TdDestroyObject ((struct TdStickerSetInfo *)var);
    case CODE_StickerSets: return TdDestroyObject ((struct TdStickerSets *)var);
    case CODE_Stickers: return TdDestroyObject ((struct TdStickers *)var);
    case CODE_StorageStatistics: return TdDestroyObject ((struct TdStorageStatistics *)var);
    case CODE_StorageStatisticsByChat: return TdDestroyObject ((struct TdStorageStatisticsByChat *)var);
    case CODE_StorageStatisticsByFileType: return TdDestroyObject ((struct TdStorageStatisticsByFileType *)var);
    case CODE_StorageStatisticsFast: return TdDestroyObject ((struct TdStorageStatisticsFast *)var);
    case CODE_Supergroup: return TdDestroyObject ((struct TdSupergroup *)var);
    case CODE_SupergroupFullInfo: return TdDestroyObject ((struct TdSupergroupFullInfo *)var);
    case CODE_SupergroupMembersFilterRecent: return TdDestroyObject ((struct TdSupergroupMembersFilterRecent *)var);
    case CODE_SupergroupMembersFilterAdministrators: return TdDestroyObject ((struct TdSupergroupMembersFilterAdministrators *)var);
    case CODE_SupergroupMembersFilterSearch: return TdDestroyObject ((struct TdSupergroupMembersFilterSearch *)var);
    case CODE_SupergroupMembersFilterRestricted: return TdDestroyObject ((struct TdSupergroupMembersFilterRestricted *)var);
    case CODE_SupergroupMembersFilterBanned: return TdDestroyObject ((struct TdSupergroupMembersFilterBanned *)var);
    case CODE_SupergroupMembersFilterBots: return TdDestroyObject ((struct TdSupergroupMembersFilterBots *)var);
    case CODE_TMeUrl: return TdDestroyObject ((struct TdTMeUrl *)var);
    case CODE_TMeUrlTypeUser: return TdDestroyObject ((struct TdTMeUrlTypeUser *)var);
    case CODE_TMeUrlTypeSupergroup: return TdDestroyObject ((struct TdTMeUrlTypeSupergroup *)var);
    case CODE_TMeUrlTypeChatInvite: return TdDestroyObject ((struct TdTMeUrlTypeChatInvite *)var);
    case CODE_TMeUrlTypeStickerSet: return TdDestroyObject ((struct TdTMeUrlTypeStickerSet *)var);
    case CODE_TMeUrls: return TdDestroyObject ((struct TdTMeUrls *)var);
    case CODE_TdlibParameters: return TdDestroyObject ((struct TdTdlibParameters *)var);
    case CODE_TemporaryPasswordState: return TdDestroyObject ((struct TdTemporaryPasswordState *)var);
    case CODE_TermsOfService: return TdDestroyObject ((struct TdTermsOfService *)var);
    case CODE_TestBytes: return TdDestroyObject ((struct TdTestBytes *)var);
    case CODE_TestInt: return TdDestroyObject ((struct TdTestInt *)var);
    case CODE_TestString: return TdDestroyObject ((struct TdTestString *)var);
    case CODE_TestVectorInt: return TdDestroyObject ((struct TdTestVectorInt *)var);
    case CODE_TestVectorIntObject: return TdDestroyObject ((struct TdTestVectorIntObject *)var);
    case CODE_TestVectorString: return TdDestroyObject ((struct TdTestVectorString *)var);
    case CODE_TestVectorStringObject: return TdDestroyObject ((struct TdTestVectorStringObject *)var);
    case CODE_Text: return TdDestroyObject ((struct TdText *)var);
    case CODE_TextEntities: return TdDestroyObject ((struct TdTextEntities *)var);
    case CODE_TextEntity: return TdDestroyObject ((struct TdTextEntity *)var);
    case CODE_TextEntityTypeMention: return TdDestroyObject ((struct TdTextEntityTypeMention *)var);
    case CODE_TextEntityTypeHashtag: return TdDestroyObject ((struct TdTextEntityTypeHashtag *)var);
    case CODE_TextEntityTypeCashtag: return TdDestroyObject ((struct TdTextEntityTypeCashtag *)var);
    case CODE_TextEntityTypeBotCommand: return TdDestroyObject ((struct TdTextEntityTypeBotCommand *)var);
    case CODE_TextEntityTypeUrl: return TdDestroyObject ((struct TdTextEntityTypeUrl *)var);
    case CODE_TextEntityTypeEmailAddress: return TdDestroyObject ((struct TdTextEntityTypeEmailAddress *)var);
    case CODE_TextEntityTypeBold: return TdDestroyObject ((struct TdTextEntityTypeBold *)var);
    case CODE_TextEntityTypeItalic: return TdDestroyObject ((struct TdTextEntityTypeItalic *)var);
    case CODE_TextEntityTypeCode: return TdDestroyObject ((struct TdTextEntityTypeCode *)var);
    case CODE_TextEntityTypePre: return TdDestroyObject ((struct TdTextEntityTypePre *)var);
    case CODE_TextEntityTypePreCode: return TdDestroyObject ((struct TdTextEntityTypePreCode *)var);
    case CODE_TextEntityTypeTextUrl: return TdDestroyObject ((struct TdTextEntityTypeTextUrl *)var);
    case CODE_TextEntityTypeMentionName: return TdDestroyObject ((struct TdTextEntityTypeMentionName *)var);
    case CODE_TextEntityTypePhoneNumber: return TdDestroyObject ((struct TdTextEntityTypePhoneNumber *)var);
    case CODE_TextParseModeMarkdown: return TdDestroyObject ((struct TdTextParseModeMarkdown *)var);
    case CODE_TextParseModeHTML: return TdDestroyObject ((struct TdTextParseModeHTML *)var);
    case CODE_TopChatCategoryUsers: return TdDestroyObject ((struct TdTopChatCategoryUsers *)var);
    case CODE_TopChatCategoryBots: return TdDestroyObject ((struct TdTopChatCategoryBots *)var);
    case CODE_TopChatCategoryGroups: return TdDestroyObject ((struct TdTopChatCategoryGroups *)var);
    case CODE_TopChatCategoryChannels: return TdDestroyObject ((struct TdTopChatCategoryChannels *)var);
    case CODE_TopChatCategoryInlineBots: return TdDestroyObject ((struct TdTopChatCategoryInlineBots *)var);
    case CODE_TopChatCategoryCalls: return TdDestroyObject ((struct TdTopChatCategoryCalls *)var);
    case CODE_UpdateAuthorizationState: return TdDestroyObject ((struct TdUpdateAuthorizationState *)var);
    case CODE_UpdateNewMessage: return TdDestroyObject ((struct TdUpdateNewMessage *)var);
    case CODE_UpdateMessageSendAcknowledged: return TdDestroyObject ((struct TdUpdateMessageSendAcknowledged *)var);
    case CODE_UpdateMessageSendSucceeded: return TdDestroyObject ((struct TdUpdateMessageSendSucceeded *)var);
    case CODE_UpdateMessageSendFailed: return TdDestroyObject ((struct TdUpdateMessageSendFailed *)var);
    case CODE_UpdateMessageContent: return TdDestroyObject ((struct TdUpdateMessageContent *)var);
    case CODE_UpdateMessageEdited: return TdDestroyObject ((struct TdUpdateMessageEdited *)var);
    case CODE_UpdateMessageViews: return TdDestroyObject ((struct TdUpdateMessageViews *)var);
    case CODE_UpdateMessageContentOpened: return TdDestroyObject ((struct TdUpdateMessageContentOpened *)var);
    case CODE_UpdateMessageMentionRead: return TdDestroyObject ((struct TdUpdateMessageMentionRead *)var);
    case CODE_UpdateNewChat: return TdDestroyObject ((struct TdUpdateNewChat *)var);
    case CODE_UpdateChatTitle: return TdDestroyObject ((struct TdUpdateChatTitle *)var);
    case CODE_UpdateChatPhoto: return TdDestroyObject ((struct TdUpdateChatPhoto *)var);
    case CODE_UpdateChatLastMessage: return TdDestroyObject ((struct TdUpdateChatLastMessage *)var);
    case CODE_UpdateChatOrder: return TdDestroyObject ((struct TdUpdateChatOrder *)var);
    case CODE_UpdateChatIsPinned: return TdDestroyObject ((struct TdUpdateChatIsPinned *)var);
    case CODE_UpdateChatIsMarkedAsUnread: return TdDestroyObject ((struct TdUpdateChatIsMarkedAsUnread *)var);
    case CODE_UpdateChatIsSponsored: return TdDestroyObject ((struct TdUpdateChatIsSponsored *)var);
    case CODE_UpdateChatDefaultDisableNotification: return TdDestroyObject ((struct TdUpdateChatDefaultDisableNotification *)var);
    case CODE_UpdateChatReadInbox: return TdDestroyObject ((struct TdUpdateChatReadInbox *)var);
    case CODE_UpdateChatReadOutbox: return TdDestroyObject ((struct TdUpdateChatReadOutbox *)var);
    case CODE_UpdateChatUnreadMentionCount: return TdDestroyObject ((struct TdUpdateChatUnreadMentionCount *)var);
    case CODE_UpdateChatNotificationSettings: return TdDestroyObject ((struct TdUpdateChatNotificationSettings *)var);
    case CODE_UpdateScopeNotificationSettings: return TdDestroyObject ((struct TdUpdateScopeNotificationSettings *)var);
    case CODE_UpdateChatReplyMarkup: return TdDestroyObject ((struct TdUpdateChatReplyMarkup *)var);
    case CODE_UpdateChatDraftMessage: return TdDestroyObject ((struct TdUpdateChatDraftMessage *)var);
    case CODE_UpdateDeleteMessages: return TdDestroyObject ((struct TdUpdateDeleteMessages *)var);
    case CODE_UpdateUserChatAction: return TdDestroyObject ((struct TdUpdateUserChatAction *)var);
    case CODE_UpdateUserStatus: return TdDestroyObject ((struct TdUpdateUserStatus *)var);
    case CODE_UpdateUser: return TdDestroyObject ((struct TdUpdateUser *)var);
    case CODE_UpdateBasicGroup: return TdDestroyObject ((struct TdUpdateBasicGroup *)var);
    case CODE_UpdateSupergroup: return TdDestroyObject ((struct TdUpdateSupergroup *)var);
    case CODE_UpdateSecretChat: return TdDestroyObject ((struct TdUpdateSecretChat *)var);
    case CODE_UpdateUserFullInfo: return TdDestroyObject ((struct TdUpdateUserFullInfo *)var);
    case CODE_UpdateBasicGroupFullInfo: return TdDestroyObject ((struct TdUpdateBasicGroupFullInfo *)var);
    case CODE_UpdateSupergroupFullInfo: return TdDestroyObject ((struct TdUpdateSupergroupFullInfo *)var);
    case CODE_UpdateServiceNotification: return TdDestroyObject ((struct TdUpdateServiceNotification *)var);
    case CODE_UpdateFile: return TdDestroyObject ((struct TdUpdateFile *)var);
    case CODE_UpdateFileGenerationStart: return TdDestroyObject ((struct TdUpdateFileGenerationStart *)var);
    case CODE_UpdateFileGenerationStop: return TdDestroyObject ((struct TdUpdateFileGenerationStop *)var);
    case CODE_UpdateCall: return TdDestroyObject ((struct TdUpdateCall *)var);
    case CODE_UpdateUserPrivacySettingRules: return TdDestroyObject ((struct TdUpdateUserPrivacySettingRules *)var);
    case CODE_UpdateUnreadMessageCount: return TdDestroyObject ((struct TdUpdateUnreadMessageCount *)var);
    case CODE_UpdateUnreadChatCount: return TdDestroyObject ((struct TdUpdateUnreadChatCount *)var);
    case CODE_UpdateOption: return TdDestroyObject ((struct TdUpdateOption *)var);
    case CODE_UpdateInstalledStickerSets: return TdDestroyObject ((struct TdUpdateInstalledStickerSets *)var);
    case CODE_UpdateTrendingStickerSets: return TdDestroyObject ((struct TdUpdateTrendingStickerSets *)var);
    case CODE_UpdateRecentStickers: return TdDestroyObject ((struct TdUpdateRecentStickers *)var);
    case CODE_UpdateFavoriteStickers: return TdDestroyObject ((struct TdUpdateFavoriteStickers *)var);
    case CODE_UpdateSavedAnimations: return TdDestroyObject ((struct TdUpdateSavedAnimations *)var);
    case CODE_UpdateLanguagePackStrings: return TdDestroyObject ((struct TdUpdateLanguagePackStrings *)var);
    case CODE_UpdateConnectionState: return TdDestroyObject ((struct TdUpdateConnectionState *)var);
    case CODE_UpdateTermsOfService: return TdDestroyObject ((struct TdUpdateTermsOfService *)var);
    case CODE_UpdateNewInlineQuery: return TdDestroyObject ((struct TdUpdateNewInlineQuery *)var);
    case CODE_UpdateNewChosenInlineResult: return TdDestroyObject ((struct TdUpdateNewChosenInlineResult *)var);
    case CODE_UpdateNewCallbackQuery: return TdDestroyObject ((struct TdUpdateNewCallbackQuery *)var);
    case CODE_UpdateNewInlineCallbackQuery: return TdDestroyObject ((struct TdUpdateNewInlineCallbackQuery *)var);
    case CODE_UpdateNewShippingQuery: return TdDestroyObject ((struct TdUpdateNewShippingQuery *)var);
    case CODE_UpdateNewPreCheckoutQuery: return TdDestroyObject ((struct TdUpdateNewPreCheckoutQuery *)var);
    case CODE_UpdateNewCustomEvent: return TdDestroyObject ((struct TdUpdateNewCustomEvent *)var);
    case CODE_UpdateNewCustomQuery: return TdDestroyObject ((struct TdUpdateNewCustomQuery *)var);
    case CODE_User: return TdDestroyObject ((struct TdUser *)var);
    case CODE_UserFullInfo: return TdDestroyObject ((struct TdUserFullInfo *)var);
    case CODE_UserPrivacySettingShowStatus: return TdDestroyObject ((struct TdUserPrivacySettingShowStatus *)var);
    case CODE_UserPrivacySettingAllowChatInvites: return TdDestroyObject ((struct TdUserPrivacySettingAllowChatInvites *)var);
    case CODE_UserPrivacySettingAllowCalls: return TdDestroyObject ((struct TdUserPrivacySettingAllowCalls *)var);
    case CODE_UserPrivacySettingRuleAllowAll: return TdDestroyObject ((struct TdUserPrivacySettingRuleAllowAll *)var);
    case CODE_UserPrivacySettingRuleAllowContacts: return TdDestroyObject ((struct TdUserPrivacySettingRuleAllowContacts *)var);
    case CODE_UserPrivacySettingRuleAllowUsers: return TdDestroyObject ((struct TdUserPrivacySettingRuleAllowUsers *)var);
    case CODE_UserPrivacySettingRuleRestrictAll: return TdDestroyObject ((struct TdUserPrivacySettingRuleRestrictAll *)var);
    case CODE_UserPrivacySettingRuleRestrictContacts: return TdDestroyObject ((struct TdUserPrivacySettingRuleRestrictContacts *)var);
    case CODE_UserPrivacySettingRuleRestrictUsers: return TdDestroyObject ((struct TdUserPrivacySettingRuleRestrictUsers *)var);
    case CODE_UserPrivacySettingRules: return TdDestroyObject ((struct TdUserPrivacySettingRules *)var);
    case CODE_UserProfilePhotos: return TdDestroyObject ((struct TdUserProfilePhotos *)var);
    case CODE_UserStatusEmpty: return TdDestroyObject ((struct TdUserStatusEmpty *)var);
    case CODE_UserStatusOnline: return TdDestroyObject ((struct TdUserStatusOnline *)var);
    case CODE_UserStatusOffline: return TdDestroyObject ((struct TdUserStatusOffline *)var);
    case CODE_UserStatusRecently: return TdDestroyObject ((struct TdUserStatusRecently *)var);
    case CODE_UserStatusLastWeek: return TdDestroyObject ((struct TdUserStatusLastWeek *)var);
    case CODE_UserStatusLastMonth: return TdDestroyObject ((struct TdUserStatusLastMonth *)var);
    case CODE_UserTypeRegular: return TdDestroyObject ((struct TdUserTypeRegular *)var);
    case CODE_UserTypeDeleted: return TdDestroyObject ((struct TdUserTypeDeleted *)var);
    case CODE_UserTypeBot: return TdDestroyObject ((struct TdUserTypeBot *)var);
    case CODE_UserTypeUnknown: return TdDestroyObject ((struct TdUserTypeUnknown *)var);
    case CODE_Users: return TdDestroyObject ((struct TdUsers *)var);
    case CODE_ValidatedOrderInfo: return TdDestroyObject ((struct TdValidatedOrderInfo *)var);
    case CODE_Venue: return TdDestroyObject ((struct TdVenue *)var);
    case CODE_Video: return TdDestroyObject ((struct TdVideo *)var);
    case CODE_VideoNote: return TdDestroyObject ((struct TdVideoNote *)var);
    case CODE_VoiceNote: return TdDestroyObject ((struct TdVoiceNote *)var);
    case CODE_Wallpaper: return TdDestroyObject ((struct TdWallpaper *)var);
    case CODE_Wallpapers: return TdDestroyObject ((struct TdWallpapers *)var);
    case CODE_WebPage: return TdDestroyObject ((struct TdWebPage *)var);
    case CODE_WebPageInstantView: return TdDestroyObject ((struct TdWebPageInstantView *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerObject (struct TdObject *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdObject *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AccountTtl: return TdStackStorer ((struct TdAccountTtl *)var, M);
    case CODE_Address: return TdStackStorer ((struct TdAddress *)var, M);
    case CODE_Animation: return TdStackStorer ((struct TdAnimation *)var, M);
    case CODE_Animations: return TdStackStorer ((struct TdAnimations *)var, M);
    case CODE_Audio: return TdStackStorer ((struct TdAudio *)var, M);
    case CODE_AuthenticationCodeInfo: return TdStackStorer ((struct TdAuthenticationCodeInfo *)var, M);
    case CODE_AuthenticationCodeTypeTelegramMessage: return TdStackStorer ((struct TdAuthenticationCodeTypeTelegramMessage *)var, M);
    case CODE_AuthenticationCodeTypeSms: return TdStackStorer ((struct TdAuthenticationCodeTypeSms *)var, M);
    case CODE_AuthenticationCodeTypeCall: return TdStackStorer ((struct TdAuthenticationCodeTypeCall *)var, M);
    case CODE_AuthenticationCodeTypeFlashCall: return TdStackStorer ((struct TdAuthenticationCodeTypeFlashCall *)var, M);
    case CODE_AuthorizationStateWaitTdlibParameters: return TdStackStorer ((struct TdAuthorizationStateWaitTdlibParameters *)var, M);
    case CODE_AuthorizationStateWaitEncryptionKey: return TdStackStorer ((struct TdAuthorizationStateWaitEncryptionKey *)var, M);
    case CODE_AuthorizationStateWaitPhoneNumber: return TdStackStorer ((struct TdAuthorizationStateWaitPhoneNumber *)var, M);
    case CODE_AuthorizationStateWaitCode: return TdStackStorer ((struct TdAuthorizationStateWaitCode *)var, M);
    case CODE_AuthorizationStateWaitPassword: return TdStackStorer ((struct TdAuthorizationStateWaitPassword *)var, M);
    case CODE_AuthorizationStateReady: return TdStackStorer ((struct TdAuthorizationStateReady *)var, M);
    case CODE_AuthorizationStateLoggingOut: return TdStackStorer ((struct TdAuthorizationStateLoggingOut *)var, M);
    case CODE_AuthorizationStateClosing: return TdStackStorer ((struct TdAuthorizationStateClosing *)var, M);
    case CODE_AuthorizationStateClosed: return TdStackStorer ((struct TdAuthorizationStateClosed *)var, M);
    case CODE_BasicGroup: return TdStackStorer ((struct TdBasicGroup *)var, M);
    case CODE_BasicGroupFullInfo: return TdStackStorer ((struct TdBasicGroupFullInfo *)var, M);
    case CODE_BotCommand: return TdStackStorer ((struct TdBotCommand *)var, M);
    case CODE_BotInfo: return TdStackStorer ((struct TdBotInfo *)var, M);
    case CODE_Call: return TdStackStorer ((struct TdCall *)var, M);
    case CODE_CallConnection: return TdStackStorer ((struct TdCallConnection *)var, M);
    case CODE_CallDiscardReasonEmpty: return TdStackStorer ((struct TdCallDiscardReasonEmpty *)var, M);
    case CODE_CallDiscardReasonMissed: return TdStackStorer ((struct TdCallDiscardReasonMissed *)var, M);
    case CODE_CallDiscardReasonDeclined: return TdStackStorer ((struct TdCallDiscardReasonDeclined *)var, M);
    case CODE_CallDiscardReasonDisconnected: return TdStackStorer ((struct TdCallDiscardReasonDisconnected *)var, M);
    case CODE_CallDiscardReasonHungUp: return TdStackStorer ((struct TdCallDiscardReasonHungUp *)var, M);
    case CODE_CallId: return TdStackStorer ((struct TdCallId *)var, M);
    case CODE_CallProtocol: return TdStackStorer ((struct TdCallProtocol *)var, M);
    case CODE_CallStatePending: return TdStackStorer ((struct TdCallStatePending *)var, M);
    case CODE_CallStateExchangingKeys: return TdStackStorer ((struct TdCallStateExchangingKeys *)var, M);
    case CODE_CallStateReady: return TdStackStorer ((struct TdCallStateReady *)var, M);
    case CODE_CallStateHangingUp: return TdStackStorer ((struct TdCallStateHangingUp *)var, M);
    case CODE_CallStateDiscarded: return TdStackStorer ((struct TdCallStateDiscarded *)var, M);
    case CODE_CallStateError: return TdStackStorer ((struct TdCallStateError *)var, M);
    case CODE_CallbackQueryAnswer: return TdStackStorer ((struct TdCallbackQueryAnswer *)var, M);
    case CODE_CallbackQueryPayloadData: return TdStackStorer ((struct TdCallbackQueryPayloadData *)var, M);
    case CODE_CallbackQueryPayloadGame: return TdStackStorer ((struct TdCallbackQueryPayloadGame *)var, M);
    case CODE_Chat: return TdStackStorer ((struct TdChat *)var, M);
    case CODE_ChatActionTyping: return TdStackStorer ((struct TdChatActionTyping *)var, M);
    case CODE_ChatActionRecordingVideo: return TdStackStorer ((struct TdChatActionRecordingVideo *)var, M);
    case CODE_ChatActionUploadingVideo: return TdStackStorer ((struct TdChatActionUploadingVideo *)var, M);
    case CODE_ChatActionRecordingVoiceNote: return TdStackStorer ((struct TdChatActionRecordingVoiceNote *)var, M);
    case CODE_ChatActionUploadingVoiceNote: return TdStackStorer ((struct TdChatActionUploadingVoiceNote *)var, M);
    case CODE_ChatActionUploadingPhoto: return TdStackStorer ((struct TdChatActionUploadingPhoto *)var, M);
    case CODE_ChatActionUploadingDocument: return TdStackStorer ((struct TdChatActionUploadingDocument *)var, M);
    case CODE_ChatActionChoosingLocation: return TdStackStorer ((struct TdChatActionChoosingLocation *)var, M);
    case CODE_ChatActionChoosingContact: return TdStackStorer ((struct TdChatActionChoosingContact *)var, M);
    case CODE_ChatActionStartPlayingGame: return TdStackStorer ((struct TdChatActionStartPlayingGame *)var, M);
    case CODE_ChatActionRecordingVideoNote: return TdStackStorer ((struct TdChatActionRecordingVideoNote *)var, M);
    case CODE_ChatActionUploadingVideoNote: return TdStackStorer ((struct TdChatActionUploadingVideoNote *)var, M);
    case CODE_ChatActionCancel: return TdStackStorer ((struct TdChatActionCancel *)var, M);
    case CODE_ChatEvent: return TdStackStorer ((struct TdChatEvent *)var, M);
    case CODE_ChatEventMessageEdited: return TdStackStorer ((struct TdChatEventMessageEdited *)var, M);
    case CODE_ChatEventMessageDeleted: return TdStackStorer ((struct TdChatEventMessageDeleted *)var, M);
    case CODE_ChatEventMessagePinned: return TdStackStorer ((struct TdChatEventMessagePinned *)var, M);
    case CODE_ChatEventMessageUnpinned: return TdStackStorer ((struct TdChatEventMessageUnpinned *)var, M);
    case CODE_ChatEventMemberJoined: return TdStackStorer ((struct TdChatEventMemberJoined *)var, M);
    case CODE_ChatEventMemberLeft: return TdStackStorer ((struct TdChatEventMemberLeft *)var, M);
    case CODE_ChatEventMemberInvited: return TdStackStorer ((struct TdChatEventMemberInvited *)var, M);
    case CODE_ChatEventMemberPromoted: return TdStackStorer ((struct TdChatEventMemberPromoted *)var, M);
    case CODE_ChatEventMemberRestricted: return TdStackStorer ((struct TdChatEventMemberRestricted *)var, M);
    case CODE_ChatEventTitleChanged: return TdStackStorer ((struct TdChatEventTitleChanged *)var, M);
    case CODE_ChatEventDescriptionChanged: return TdStackStorer ((struct TdChatEventDescriptionChanged *)var, M);
    case CODE_ChatEventUsernameChanged: return TdStackStorer ((struct TdChatEventUsernameChanged *)var, M);
    case CODE_ChatEventPhotoChanged: return TdStackStorer ((struct TdChatEventPhotoChanged *)var, M);
    case CODE_ChatEventInvitesToggled: return TdStackStorer ((struct TdChatEventInvitesToggled *)var, M);
    case CODE_ChatEventSignMessagesToggled: return TdStackStorer ((struct TdChatEventSignMessagesToggled *)var, M);
    case CODE_ChatEventStickerSetChanged: return TdStackStorer ((struct TdChatEventStickerSetChanged *)var, M);
    case CODE_ChatEventIsAllHistoryAvailableToggled: return TdStackStorer ((struct TdChatEventIsAllHistoryAvailableToggled *)var, M);
    case CODE_ChatEventLogFilters: return TdStackStorer ((struct TdChatEventLogFilters *)var, M);
    case CODE_ChatEvents: return TdStackStorer ((struct TdChatEvents *)var, M);
    case CODE_ChatInviteLink: return TdStackStorer ((struct TdChatInviteLink *)var, M);
    case CODE_ChatInviteLinkInfo: return TdStackStorer ((struct TdChatInviteLinkInfo *)var, M);
    case CODE_ChatMember: return TdStackStorer ((struct TdChatMember *)var, M);
    case CODE_ChatMemberStatusCreator: return TdStackStorer ((struct TdChatMemberStatusCreator *)var, M);
    case CODE_ChatMemberStatusAdministrator: return TdStackStorer ((struct TdChatMemberStatusAdministrator *)var, M);
    case CODE_ChatMemberStatusMember: return TdStackStorer ((struct TdChatMemberStatusMember *)var, M);
    case CODE_ChatMemberStatusRestricted: return TdStackStorer ((struct TdChatMemberStatusRestricted *)var, M);
    case CODE_ChatMemberStatusLeft: return TdStackStorer ((struct TdChatMemberStatusLeft *)var, M);
    case CODE_ChatMemberStatusBanned: return TdStackStorer ((struct TdChatMemberStatusBanned *)var, M);
    case CODE_ChatMembers: return TdStackStorer ((struct TdChatMembers *)var, M);
    case CODE_ChatMembersFilterAdministrators: return TdStackStorer ((struct TdChatMembersFilterAdministrators *)var, M);
    case CODE_ChatMembersFilterMembers: return TdStackStorer ((struct TdChatMembersFilterMembers *)var, M);
    case CODE_ChatMembersFilterRestricted: return TdStackStorer ((struct TdChatMembersFilterRestricted *)var, M);
    case CODE_ChatMembersFilterBanned: return TdStackStorer ((struct TdChatMembersFilterBanned *)var, M);
    case CODE_ChatMembersFilterBots: return TdStackStorer ((struct TdChatMembersFilterBots *)var, M);
    case CODE_ChatNotificationSettings: return TdStackStorer ((struct TdChatNotificationSettings *)var, M);
    case CODE_ChatPhoto: return TdStackStorer ((struct TdChatPhoto *)var, M);
    case CODE_ChatReportReasonSpam: return TdStackStorer ((struct TdChatReportReasonSpam *)var, M);
    case CODE_ChatReportReasonViolence: return TdStackStorer ((struct TdChatReportReasonViolence *)var, M);
    case CODE_ChatReportReasonPornography: return TdStackStorer ((struct TdChatReportReasonPornography *)var, M);
    case CODE_ChatReportReasonCopyright: return TdStackStorer ((struct TdChatReportReasonCopyright *)var, M);
    case CODE_ChatReportReasonCustom: return TdStackStorer ((struct TdChatReportReasonCustom *)var, M);
    case CODE_ChatReportSpamState: return TdStackStorer ((struct TdChatReportSpamState *)var, M);
    case CODE_ChatTypePrivate: return TdStackStorer ((struct TdChatTypePrivate *)var, M);
    case CODE_ChatTypeBasicGroup: return TdStackStorer ((struct TdChatTypeBasicGroup *)var, M);
    case CODE_ChatTypeSupergroup: return TdStackStorer ((struct TdChatTypeSupergroup *)var, M);
    case CODE_ChatTypeSecret: return TdStackStorer ((struct TdChatTypeSecret *)var, M);
    case CODE_Chats: return TdStackStorer ((struct TdChats *)var, M);
    case CODE_CheckChatUsernameResultOk: return TdStackStorer ((struct TdCheckChatUsernameResultOk *)var, M);
    case CODE_CheckChatUsernameResultUsernameInvalid: return TdStackStorer ((struct TdCheckChatUsernameResultUsernameInvalid *)var, M);
    case CODE_CheckChatUsernameResultUsernameOccupied: return TdStackStorer ((struct TdCheckChatUsernameResultUsernameOccupied *)var, M);
    case CODE_CheckChatUsernameResultPublicChatsTooMuch: return TdStackStorer ((struct TdCheckChatUsernameResultPublicChatsTooMuch *)var, M);
    case CODE_CheckChatUsernameResultPublicGroupsUnavailable: return TdStackStorer ((struct TdCheckChatUsernameResultPublicGroupsUnavailable *)var, M);
    case CODE_ConnectedWebsite: return TdStackStorer ((struct TdConnectedWebsite *)var, M);
    case CODE_ConnectedWebsites: return TdStackStorer ((struct TdConnectedWebsites *)var, M);
    case CODE_ConnectionStateWaitingForNetwork: return TdStackStorer ((struct TdConnectionStateWaitingForNetwork *)var, M);
    case CODE_ConnectionStateConnectingToProxy: return TdStackStorer ((struct TdConnectionStateConnectingToProxy *)var, M);
    case CODE_ConnectionStateConnecting: return TdStackStorer ((struct TdConnectionStateConnecting *)var, M);
    case CODE_ConnectionStateUpdating: return TdStackStorer ((struct TdConnectionStateUpdating *)var, M);
    case CODE_ConnectionStateReady: return TdStackStorer ((struct TdConnectionStateReady *)var, M);
    case CODE_Contact: return TdStackStorer ((struct TdContact *)var, M);
    case CODE_Count: return TdStackStorer ((struct TdCount *)var, M);
    case CODE_CustomRequestResult: return TdStackStorer ((struct TdCustomRequestResult *)var, M);
    case CODE_Date: return TdStackStorer ((struct TdDate *)var, M);
    case CODE_DatedFile: return TdStackStorer ((struct TdDatedFile *)var, M);
    case CODE_DeepLinkInfo: return TdStackStorer ((struct TdDeepLinkInfo *)var, M);
    case CODE_DeviceTokenGoogleCloudMessaging: return TdStackStorer ((struct TdDeviceTokenGoogleCloudMessaging *)var, M);
    case CODE_DeviceTokenApplePush: return TdStackStorer ((struct TdDeviceTokenApplePush *)var, M);
    case CODE_DeviceTokenApplePushVoIP: return TdStackStorer ((struct TdDeviceTokenApplePushVoIP *)var, M);
    case CODE_DeviceTokenWindowsPush: return TdStackStorer ((struct TdDeviceTokenWindowsPush *)var, M);
    case CODE_DeviceTokenMicrosoftPush: return TdStackStorer ((struct TdDeviceTokenMicrosoftPush *)var, M);
    case CODE_DeviceTokenMicrosoftPushVoIP: return TdStackStorer ((struct TdDeviceTokenMicrosoftPushVoIP *)var, M);
    case CODE_DeviceTokenWebPush: return TdStackStorer ((struct TdDeviceTokenWebPush *)var, M);
    case CODE_DeviceTokenSimplePush: return TdStackStorer ((struct TdDeviceTokenSimplePush *)var, M);
    case CODE_DeviceTokenUbuntuPush: return TdStackStorer ((struct TdDeviceTokenUbuntuPush *)var, M);
    case CODE_DeviceTokenBlackBerryPush: return TdStackStorer ((struct TdDeviceTokenBlackBerryPush *)var, M);
    case CODE_DeviceTokenTizenPush: return TdStackStorer ((struct TdDeviceTokenTizenPush *)var, M);
    case CODE_Document: return TdStackStorer ((struct TdDocument *)var, M);
    case CODE_DraftMessage: return TdStackStorer ((struct TdDraftMessage *)var, M);
    case CODE_EmailAddressAuthenticationCodeInfo: return TdStackStorer ((struct TdEmailAddressAuthenticationCodeInfo *)var, M);
    case CODE_EncryptedCredentials: return TdStackStorer ((struct TdEncryptedCredentials *)var, M);
    case CODE_EncryptedPassportElement: return TdStackStorer ((struct TdEncryptedPassportElement *)var, M);
    case CODE_Error: return TdStackStorer ((struct TdError *)var, M);
    case CODE_File: return TdStackStorer ((struct TdFile *)var, M);
    case CODE_FileTypeNone: return TdStackStorer ((struct TdFileTypeNone *)var, M);
    case CODE_FileTypeAnimation: return TdStackStorer ((struct TdFileTypeAnimation *)var, M);
    case CODE_FileTypeAudio: return TdStackStorer ((struct TdFileTypeAudio *)var, M);
    case CODE_FileTypeDocument: return TdStackStorer ((struct TdFileTypeDocument *)var, M);
    case CODE_FileTypePhoto: return TdStackStorer ((struct TdFileTypePhoto *)var, M);
    case CODE_FileTypeProfilePhoto: return TdStackStorer ((struct TdFileTypeProfilePhoto *)var, M);
    case CODE_FileTypeSecret: return TdStackStorer ((struct TdFileTypeSecret *)var, M);
    case CODE_FileTypeSecretThumbnail: return TdStackStorer ((struct TdFileTypeSecretThumbnail *)var, M);
    case CODE_FileTypeSecure: return TdStackStorer ((struct TdFileTypeSecure *)var, M);
    case CODE_FileTypeSticker: return TdStackStorer ((struct TdFileTypeSticker *)var, M);
    case CODE_FileTypeThumbnail: return TdStackStorer ((struct TdFileTypeThumbnail *)var, M);
    case CODE_FileTypeUnknown: return TdStackStorer ((struct TdFileTypeUnknown *)var, M);
    case CODE_FileTypeVideo: return TdStackStorer ((struct TdFileTypeVideo *)var, M);
    case CODE_FileTypeVideoNote: return TdStackStorer ((struct TdFileTypeVideoNote *)var, M);
    case CODE_FileTypeVoiceNote: return TdStackStorer ((struct TdFileTypeVoiceNote *)var, M);
    case CODE_FileTypeWallpaper: return TdStackStorer ((struct TdFileTypeWallpaper *)var, M);
    case CODE_FormattedText: return TdStackStorer ((struct TdFormattedText *)var, M);
    case CODE_FoundMessages: return TdStackStorer ((struct TdFoundMessages *)var, M);
    case CODE_Game: return TdStackStorer ((struct TdGame *)var, M);
    case CODE_GameHighScore: return TdStackStorer ((struct TdGameHighScore *)var, M);
    case CODE_GameHighScores: return TdStackStorer ((struct TdGameHighScores *)var, M);
    case CODE_Hashtags: return TdStackStorer ((struct TdHashtags *)var, M);
    case CODE_IdentityDocument: return TdStackStorer ((struct TdIdentityDocument *)var, M);
    case CODE_ImportedContacts: return TdStackStorer ((struct TdImportedContacts *)var, M);
    case CODE_InlineKeyboardButton: return TdStackStorer ((struct TdInlineKeyboardButton *)var, M);
    case CODE_InlineKeyboardButtonTypeUrl: return TdStackStorer ((struct TdInlineKeyboardButtonTypeUrl *)var, M);
    case CODE_InlineKeyboardButtonTypeCallback: return TdStackStorer ((struct TdInlineKeyboardButtonTypeCallback *)var, M);
    case CODE_InlineKeyboardButtonTypeCallbackGame: return TdStackStorer ((struct TdInlineKeyboardButtonTypeCallbackGame *)var, M);
    case CODE_InlineKeyboardButtonTypeSwitchInline: return TdStackStorer ((struct TdInlineKeyboardButtonTypeSwitchInline *)var, M);
    case CODE_InlineKeyboardButtonTypeBuy: return TdStackStorer ((struct TdInlineKeyboardButtonTypeBuy *)var, M);
    case CODE_InlineQueryResultArticle: return TdStackStorer ((struct TdInlineQueryResultArticle *)var, M);
    case CODE_InlineQueryResultContact: return TdStackStorer ((struct TdInlineQueryResultContact *)var, M);
    case CODE_InlineQueryResultLocation: return TdStackStorer ((struct TdInlineQueryResultLocation *)var, M);
    case CODE_InlineQueryResultVenue: return TdStackStorer ((struct TdInlineQueryResultVenue *)var, M);
    case CODE_InlineQueryResultGame: return TdStackStorer ((struct TdInlineQueryResultGame *)var, M);
    case CODE_InlineQueryResultAnimation: return TdStackStorer ((struct TdInlineQueryResultAnimation *)var, M);
    case CODE_InlineQueryResultAudio: return TdStackStorer ((struct TdInlineQueryResultAudio *)var, M);
    case CODE_InlineQueryResultDocument: return TdStackStorer ((struct TdInlineQueryResultDocument *)var, M);
    case CODE_InlineQueryResultPhoto: return TdStackStorer ((struct TdInlineQueryResultPhoto *)var, M);
    case CODE_InlineQueryResultSticker: return TdStackStorer ((struct TdInlineQueryResultSticker *)var, M);
    case CODE_InlineQueryResultVideo: return TdStackStorer ((struct TdInlineQueryResultVideo *)var, M);
    case CODE_InlineQueryResultVoiceNote: return TdStackStorer ((struct TdInlineQueryResultVoiceNote *)var, M);
    case CODE_InlineQueryResults: return TdStackStorer ((struct TdInlineQueryResults *)var, M);
    case CODE_InputCredentialsSaved: return TdStackStorer ((struct TdInputCredentialsSaved *)var, M);
    case CODE_InputCredentialsNew: return TdStackStorer ((struct TdInputCredentialsNew *)var, M);
    case CODE_InputCredentialsAndroidPay: return TdStackStorer ((struct TdInputCredentialsAndroidPay *)var, M);
    case CODE_InputCredentialsApplePay: return TdStackStorer ((struct TdInputCredentialsApplePay *)var, M);
    case CODE_InputFileId: return TdStackStorer ((struct TdInputFileId *)var, M);
    case CODE_InputFileRemote: return TdStackStorer ((struct TdInputFileRemote *)var, M);
    case CODE_InputFileLocal: return TdStackStorer ((struct TdInputFileLocal *)var, M);
    case CODE_InputFileGenerated: return TdStackStorer ((struct TdInputFileGenerated *)var, M);
    case CODE_InputIdentityDocument: return TdStackStorer ((struct TdInputIdentityDocument *)var, M);
    case CODE_InputInlineQueryResultAnimatedGif: return TdStackStorer ((struct TdInputInlineQueryResultAnimatedGif *)var, M);
    case CODE_InputInlineQueryResultAnimatedMpeg4: return TdStackStorer ((struct TdInputInlineQueryResultAnimatedMpeg4 *)var, M);
    case CODE_InputInlineQueryResultArticle: return TdStackStorer ((struct TdInputInlineQueryResultArticle *)var, M);
    case CODE_InputInlineQueryResultAudio: return TdStackStorer ((struct TdInputInlineQueryResultAudio *)var, M);
    case CODE_InputInlineQueryResultContact: return TdStackStorer ((struct TdInputInlineQueryResultContact *)var, M);
    case CODE_InputInlineQueryResultDocument: return TdStackStorer ((struct TdInputInlineQueryResultDocument *)var, M);
    case CODE_InputInlineQueryResultGame: return TdStackStorer ((struct TdInputInlineQueryResultGame *)var, M);
    case CODE_InputInlineQueryResultLocation: return TdStackStorer ((struct TdInputInlineQueryResultLocation *)var, M);
    case CODE_InputInlineQueryResultPhoto: return TdStackStorer ((struct TdInputInlineQueryResultPhoto *)var, M);
    case CODE_InputInlineQueryResultSticker: return TdStackStorer ((struct TdInputInlineQueryResultSticker *)var, M);
    case CODE_InputInlineQueryResultVenue: return TdStackStorer ((struct TdInputInlineQueryResultVenue *)var, M);
    case CODE_InputInlineQueryResultVideo: return TdStackStorer ((struct TdInputInlineQueryResultVideo *)var, M);
    case CODE_InputInlineQueryResultVoiceNote: return TdStackStorer ((struct TdInputInlineQueryResultVoiceNote *)var, M);
    case CODE_InputMessageText: return TdStackStorer ((struct TdInputMessageText *)var, M);
    case CODE_InputMessageAnimation: return TdStackStorer ((struct TdInputMessageAnimation *)var, M);
    case CODE_InputMessageAudio: return TdStackStorer ((struct TdInputMessageAudio *)var, M);
    case CODE_InputMessageDocument: return TdStackStorer ((struct TdInputMessageDocument *)var, M);
    case CODE_InputMessagePhoto: return TdStackStorer ((struct TdInputMessagePhoto *)var, M);
    case CODE_InputMessageSticker: return TdStackStorer ((struct TdInputMessageSticker *)var, M);
    case CODE_InputMessageVideo: return TdStackStorer ((struct TdInputMessageVideo *)var, M);
    case CODE_InputMessageVideoNote: return TdStackStorer ((struct TdInputMessageVideoNote *)var, M);
    case CODE_InputMessageVoiceNote: return TdStackStorer ((struct TdInputMessageVoiceNote *)var, M);
    case CODE_InputMessageLocation: return TdStackStorer ((struct TdInputMessageLocation *)var, M);
    case CODE_InputMessageVenue: return TdStackStorer ((struct TdInputMessageVenue *)var, M);
    case CODE_InputMessageContact: return TdStackStorer ((struct TdInputMessageContact *)var, M);
    case CODE_InputMessageGame: return TdStackStorer ((struct TdInputMessageGame *)var, M);
    case CODE_InputMessageInvoice: return TdStackStorer ((struct TdInputMessageInvoice *)var, M);
    case CODE_InputMessageForwarded: return TdStackStorer ((struct TdInputMessageForwarded *)var, M);
    case CODE_InputPassportElementPersonalDetails: return TdStackStorer ((struct TdInputPassportElementPersonalDetails *)var, M);
    case CODE_InputPassportElementPassport: return TdStackStorer ((struct TdInputPassportElementPassport *)var, M);
    case CODE_InputPassportElementDriverLicense: return TdStackStorer ((struct TdInputPassportElementDriverLicense *)var, M);
    case CODE_InputPassportElementIdentityCard: return TdStackStorer ((struct TdInputPassportElementIdentityCard *)var, M);
    case CODE_InputPassportElementInternalPassport: return TdStackStorer ((struct TdInputPassportElementInternalPassport *)var, M);
    case CODE_InputPassportElementAddress: return TdStackStorer ((struct TdInputPassportElementAddress *)var, M);
    case CODE_InputPassportElementUtilityBill: return TdStackStorer ((struct TdInputPassportElementUtilityBill *)var, M);
    case CODE_InputPassportElementBankStatement: return TdStackStorer ((struct TdInputPassportElementBankStatement *)var, M);
    case CODE_InputPassportElementRentalAgreement: return TdStackStorer ((struct TdInputPassportElementRentalAgreement *)var, M);
    case CODE_InputPassportElementPassportRegistration: return TdStackStorer ((struct TdInputPassportElementPassportRegistration *)var, M);
    case CODE_InputPassportElementTemporaryRegistration: return TdStackStorer ((struct TdInputPassportElementTemporaryRegistration *)var, M);
    case CODE_InputPassportElementPhoneNumber: return TdStackStorer ((struct TdInputPassportElementPhoneNumber *)var, M);
    case CODE_InputPassportElementEmailAddress: return TdStackStorer ((struct TdInputPassportElementEmailAddress *)var, M);
    case CODE_InputPassportElementError: return TdStackStorer ((struct TdInputPassportElementError *)var, M);
    case CODE_InputPassportElementErrorSourceUnspecified: return TdStackStorer ((struct TdInputPassportElementErrorSourceUnspecified *)var, M);
    case CODE_InputPassportElementErrorSourceDataField: return TdStackStorer ((struct TdInputPassportElementErrorSourceDataField *)var, M);
    case CODE_InputPassportElementErrorSourceFrontSide: return TdStackStorer ((struct TdInputPassportElementErrorSourceFrontSide *)var, M);
    case CODE_InputPassportElementErrorSourceReverseSide: return TdStackStorer ((struct TdInputPassportElementErrorSourceReverseSide *)var, M);
    case CODE_InputPassportElementErrorSourceSelfie: return TdStackStorer ((struct TdInputPassportElementErrorSourceSelfie *)var, M);
    case CODE_InputPassportElementErrorSourceTranslationFile: return TdStackStorer ((struct TdInputPassportElementErrorSourceTranslationFile *)var, M);
    case CODE_InputPassportElementErrorSourceTranslationFiles: return TdStackStorer ((struct TdInputPassportElementErrorSourceTranslationFiles *)var, M);
    case CODE_InputPassportElementErrorSourceFile: return TdStackStorer ((struct TdInputPassportElementErrorSourceFile *)var, M);
    case CODE_InputPassportElementErrorSourceFiles: return TdStackStorer ((struct TdInputPassportElementErrorSourceFiles *)var, M);
    case CODE_InputPersonalDocument: return TdStackStorer ((struct TdInputPersonalDocument *)var, M);
    case CODE_InputSticker: return TdStackStorer ((struct TdInputSticker *)var, M);
    case CODE_InputThumbnail: return TdStackStorer ((struct TdInputThumbnail *)var, M);
    case CODE_Invoice: return TdStackStorer ((struct TdInvoice *)var, M);
    case CODE_KeyboardButton: return TdStackStorer ((struct TdKeyboardButton *)var, M);
    case CODE_KeyboardButtonTypeText: return TdStackStorer ((struct TdKeyboardButtonTypeText *)var, M);
    case CODE_KeyboardButtonTypeRequestPhoneNumber: return TdStackStorer ((struct TdKeyboardButtonTypeRequestPhoneNumber *)var, M);
    case CODE_KeyboardButtonTypeRequestLocation: return TdStackStorer ((struct TdKeyboardButtonTypeRequestLocation *)var, M);
    case CODE_LabeledPricePart: return TdStackStorer ((struct TdLabeledPricePart *)var, M);
    case CODE_LanguagePackInfo: return TdStackStorer ((struct TdLanguagePackInfo *)var, M);
    case CODE_LanguagePackString: return TdStackStorer ((struct TdLanguagePackString *)var, M);
    case CODE_LanguagePackStringValueOrdinary: return TdStackStorer ((struct TdLanguagePackStringValueOrdinary *)var, M);
    case CODE_LanguagePackStringValuePluralized: return TdStackStorer ((struct TdLanguagePackStringValuePluralized *)var, M);
    case CODE_LanguagePackStringValueDeleted: return TdStackStorer ((struct TdLanguagePackStringValueDeleted *)var, M);
    case CODE_LanguagePackStrings: return TdStackStorer ((struct TdLanguagePackStrings *)var, M);
    case CODE_LinkStateNone: return TdStackStorer ((struct TdLinkStateNone *)var, M);
    case CODE_LinkStateKnowsPhoneNumber: return TdStackStorer ((struct TdLinkStateKnowsPhoneNumber *)var, M);
    case CODE_LinkStateIsContact: return TdStackStorer ((struct TdLinkStateIsContact *)var, M);
    case CODE_LocalFile: return TdStackStorer ((struct TdLocalFile *)var, M);
    case CODE_LocalizationTargetInfo: return TdStackStorer ((struct TdLocalizationTargetInfo *)var, M);
    case CODE_Location: return TdStackStorer ((struct TdLocation *)var, M);
    case CODE_MaskPointForehead: return TdStackStorer ((struct TdMaskPointForehead *)var, M);
    case CODE_MaskPointEyes: return TdStackStorer ((struct TdMaskPointEyes *)var, M);
    case CODE_MaskPointMouth: return TdStackStorer ((struct TdMaskPointMouth *)var, M);
    case CODE_MaskPointChin: return TdStackStorer ((struct TdMaskPointChin *)var, M);
    case CODE_MaskPosition: return TdStackStorer ((struct TdMaskPosition *)var, M);
    case CODE_Message: return TdStackStorer ((struct TdMessage *)var, M);
    case CODE_MessageText: return TdStackStorer ((struct TdMessageText *)var, M);
    case CODE_MessageAnimation: return TdStackStorer ((struct TdMessageAnimation *)var, M);
    case CODE_MessageAudio: return TdStackStorer ((struct TdMessageAudio *)var, M);
    case CODE_MessageDocument: return TdStackStorer ((struct TdMessageDocument *)var, M);
    case CODE_MessagePhoto: return TdStackStorer ((struct TdMessagePhoto *)var, M);
    case CODE_MessageExpiredPhoto: return TdStackStorer ((struct TdMessageExpiredPhoto *)var, M);
    case CODE_MessageSticker: return TdStackStorer ((struct TdMessageSticker *)var, M);
    case CODE_MessageVideo: return TdStackStorer ((struct TdMessageVideo *)var, M);
    case CODE_MessageExpiredVideo: return TdStackStorer ((struct TdMessageExpiredVideo *)var, M);
    case CODE_MessageVideoNote: return TdStackStorer ((struct TdMessageVideoNote *)var, M);
    case CODE_MessageVoiceNote: return TdStackStorer ((struct TdMessageVoiceNote *)var, M);
    case CODE_MessageLocation: return TdStackStorer ((struct TdMessageLocation *)var, M);
    case CODE_MessageVenue: return TdStackStorer ((struct TdMessageVenue *)var, M);
    case CODE_MessageContact: return TdStackStorer ((struct TdMessageContact *)var, M);
    case CODE_MessageGame: return TdStackStorer ((struct TdMessageGame *)var, M);
    case CODE_MessageInvoice: return TdStackStorer ((struct TdMessageInvoice *)var, M);
    case CODE_MessageCall: return TdStackStorer ((struct TdMessageCall *)var, M);
    case CODE_MessageBasicGroupChatCreate: return TdStackStorer ((struct TdMessageBasicGroupChatCreate *)var, M);
    case CODE_MessageSupergroupChatCreate: return TdStackStorer ((struct TdMessageSupergroupChatCreate *)var, M);
    case CODE_MessageChatChangeTitle: return TdStackStorer ((struct TdMessageChatChangeTitle *)var, M);
    case CODE_MessageChatChangePhoto: return TdStackStorer ((struct TdMessageChatChangePhoto *)var, M);
    case CODE_MessageChatDeletePhoto: return TdStackStorer ((struct TdMessageChatDeletePhoto *)var, M);
    case CODE_MessageChatAddMembers: return TdStackStorer ((struct TdMessageChatAddMembers *)var, M);
    case CODE_MessageChatJoinByLink: return TdStackStorer ((struct TdMessageChatJoinByLink *)var, M);
    case CODE_MessageChatDeleteMember: return TdStackStorer ((struct TdMessageChatDeleteMember *)var, M);
    case CODE_MessageChatUpgradeTo: return TdStackStorer ((struct TdMessageChatUpgradeTo *)var, M);
    case CODE_MessageChatUpgradeFrom: return TdStackStorer ((struct TdMessageChatUpgradeFrom *)var, M);
    case CODE_MessagePinMessage: return TdStackStorer ((struct TdMessagePinMessage *)var, M);
    case CODE_MessageScreenshotTaken: return TdStackStorer ((struct TdMessageScreenshotTaken *)var, M);
    case CODE_MessageChatSetTtl: return TdStackStorer ((struct TdMessageChatSetTtl *)var, M);
    case CODE_MessageCustomServiceAction: return TdStackStorer ((struct TdMessageCustomServiceAction *)var, M);
    case CODE_MessageGameScore: return TdStackStorer ((struct TdMessageGameScore *)var, M);
    case CODE_MessagePaymentSuccessful: return TdStackStorer ((struct TdMessagePaymentSuccessful *)var, M);
    case CODE_MessagePaymentSuccessfulBot: return TdStackStorer ((struct TdMessagePaymentSuccessfulBot *)var, M);
    case CODE_MessageContactRegistered: return TdStackStorer ((struct TdMessageContactRegistered *)var, M);
    case CODE_MessageWebsiteConnected: return TdStackStorer ((struct TdMessageWebsiteConnected *)var, M);
    case CODE_MessagePassportDataSent: return TdStackStorer ((struct TdMessagePassportDataSent *)var, M);
    case CODE_MessagePassportDataReceived: return TdStackStorer ((struct TdMessagePassportDataReceived *)var, M);
    case CODE_MessageUnsupported: return TdStackStorer ((struct TdMessageUnsupported *)var, M);
    case CODE_MessageForwardedFromUser: return TdStackStorer ((struct TdMessageForwardedFromUser *)var, M);
    case CODE_MessageForwardedPost: return TdStackStorer ((struct TdMessageForwardedPost *)var, M);
    case CODE_MessageSendingStatePending: return TdStackStorer ((struct TdMessageSendingStatePending *)var, M);
    case CODE_MessageSendingStateFailed: return TdStackStorer ((struct TdMessageSendingStateFailed *)var, M);
    case CODE_Messages: return TdStackStorer ((struct TdMessages *)var, M);
    case CODE_NetworkStatistics: return TdStackStorer ((struct TdNetworkStatistics *)var, M);
    case CODE_NetworkStatisticsEntryFile: return TdStackStorer ((struct TdNetworkStatisticsEntryFile *)var, M);
    case CODE_NetworkStatisticsEntryCall: return TdStackStorer ((struct TdNetworkStatisticsEntryCall *)var, M);
    case CODE_NetworkTypeNone: return TdStackStorer ((struct TdNetworkTypeNone *)var, M);
    case CODE_NetworkTypeMobile: return TdStackStorer ((struct TdNetworkTypeMobile *)var, M);
    case CODE_NetworkTypeMobileRoaming: return TdStackStorer ((struct TdNetworkTypeMobileRoaming *)var, M);
    case CODE_NetworkTypeWiFi: return TdStackStorer ((struct TdNetworkTypeWiFi *)var, M);
    case CODE_NetworkTypeOther: return TdStackStorer ((struct TdNetworkTypeOther *)var, M);
    case CODE_NotificationSettingsScopePrivateChats: return TdStackStorer ((struct TdNotificationSettingsScopePrivateChats *)var, M);
    case CODE_NotificationSettingsScopeGroupChats: return TdStackStorer ((struct TdNotificationSettingsScopeGroupChats *)var, M);
    case CODE_Ok: return TdStackStorer ((struct TdOk *)var, M);
    case CODE_OptionValueBoolean: return TdStackStorer ((struct TdOptionValueBoolean *)var, M);
    case CODE_OptionValueEmpty: return TdStackStorer ((struct TdOptionValueEmpty *)var, M);
    case CODE_OptionValueInteger: return TdStackStorer ((struct TdOptionValueInteger *)var, M);
    case CODE_OptionValueString: return TdStackStorer ((struct TdOptionValueString *)var, M);
    case CODE_OrderInfo: return TdStackStorer ((struct TdOrderInfo *)var, M);
    case CODE_PageBlockTitle: return TdStackStorer ((struct TdPageBlockTitle *)var, M);
    case CODE_PageBlockSubtitle: return TdStackStorer ((struct TdPageBlockSubtitle *)var, M);
    case CODE_PageBlockAuthorDate: return TdStackStorer ((struct TdPageBlockAuthorDate *)var, M);
    case CODE_PageBlockHeader: return TdStackStorer ((struct TdPageBlockHeader *)var, M);
    case CODE_PageBlockSubheader: return TdStackStorer ((struct TdPageBlockSubheader *)var, M);
    case CODE_PageBlockParagraph: return TdStackStorer ((struct TdPageBlockParagraph *)var, M);
    case CODE_PageBlockPreformatted: return TdStackStorer ((struct TdPageBlockPreformatted *)var, M);
    case CODE_PageBlockFooter: return TdStackStorer ((struct TdPageBlockFooter *)var, M);
    case CODE_PageBlockDivider: return TdStackStorer ((struct TdPageBlockDivider *)var, M);
    case CODE_PageBlockAnchor: return TdStackStorer ((struct TdPageBlockAnchor *)var, M);
    case CODE_PageBlockList: return TdStackStorer ((struct TdPageBlockList *)var, M);
    case CODE_PageBlockBlockQuote: return TdStackStorer ((struct TdPageBlockBlockQuote *)var, M);
    case CODE_PageBlockPullQuote: return TdStackStorer ((struct TdPageBlockPullQuote *)var, M);
    case CODE_PageBlockAnimation: return TdStackStorer ((struct TdPageBlockAnimation *)var, M);
    case CODE_PageBlockAudio: return TdStackStorer ((struct TdPageBlockAudio *)var, M);
    case CODE_PageBlockPhoto: return TdStackStorer ((struct TdPageBlockPhoto *)var, M);
    case CODE_PageBlockVideo: return TdStackStorer ((struct TdPageBlockVideo *)var, M);
    case CODE_PageBlockCover: return TdStackStorer ((struct TdPageBlockCover *)var, M);
    case CODE_PageBlockEmbedded: return TdStackStorer ((struct TdPageBlockEmbedded *)var, M);
    case CODE_PageBlockEmbeddedPost: return TdStackStorer ((struct TdPageBlockEmbeddedPost *)var, M);
    case CODE_PageBlockCollage: return TdStackStorer ((struct TdPageBlockCollage *)var, M);
    case CODE_PageBlockSlideshow: return TdStackStorer ((struct TdPageBlockSlideshow *)var, M);
    case CODE_PageBlockChatLink: return TdStackStorer ((struct TdPageBlockChatLink *)var, M);
    case CODE_PassportAuthorizationForm: return TdStackStorer ((struct TdPassportAuthorizationForm *)var, M);
    case CODE_PassportElementPersonalDetails: return TdStackStorer ((struct TdPassportElementPersonalDetails *)var, M);
    case CODE_PassportElementPassport: return TdStackStorer ((struct TdPassportElementPassport *)var, M);
    case CODE_PassportElementDriverLicense: return TdStackStorer ((struct TdPassportElementDriverLicense *)var, M);
    case CODE_PassportElementIdentityCard: return TdStackStorer ((struct TdPassportElementIdentityCard *)var, M);
    case CODE_PassportElementInternalPassport: return TdStackStorer ((struct TdPassportElementInternalPassport *)var, M);
    case CODE_PassportElementAddress: return TdStackStorer ((struct TdPassportElementAddress *)var, M);
    case CODE_PassportElementUtilityBill: return TdStackStorer ((struct TdPassportElementUtilityBill *)var, M);
    case CODE_PassportElementBankStatement: return TdStackStorer ((struct TdPassportElementBankStatement *)var, M);
    case CODE_PassportElementRentalAgreement: return TdStackStorer ((struct TdPassportElementRentalAgreement *)var, M);
    case CODE_PassportElementPassportRegistration: return TdStackStorer ((struct TdPassportElementPassportRegistration *)var, M);
    case CODE_PassportElementTemporaryRegistration: return TdStackStorer ((struct TdPassportElementTemporaryRegistration *)var, M);
    case CODE_PassportElementPhoneNumber: return TdStackStorer ((struct TdPassportElementPhoneNumber *)var, M);
    case CODE_PassportElementEmailAddress: return TdStackStorer ((struct TdPassportElementEmailAddress *)var, M);
    case CODE_PassportElementError: return TdStackStorer ((struct TdPassportElementError *)var, M);
    case CODE_PassportElementErrorSourceUnspecified: return TdStackStorer ((struct TdPassportElementErrorSourceUnspecified *)var, M);
    case CODE_PassportElementErrorSourceDataField: return TdStackStorer ((struct TdPassportElementErrorSourceDataField *)var, M);
    case CODE_PassportElementErrorSourceFrontSide: return TdStackStorer ((struct TdPassportElementErrorSourceFrontSide *)var, M);
    case CODE_PassportElementErrorSourceReverseSide: return TdStackStorer ((struct TdPassportElementErrorSourceReverseSide *)var, M);
    case CODE_PassportElementErrorSourceSelfie: return TdStackStorer ((struct TdPassportElementErrorSourceSelfie *)var, M);
    case CODE_PassportElementErrorSourceTranslationFile: return TdStackStorer ((struct TdPassportElementErrorSourceTranslationFile *)var, M);
    case CODE_PassportElementErrorSourceTranslationFiles: return TdStackStorer ((struct TdPassportElementErrorSourceTranslationFiles *)var, M);
    case CODE_PassportElementErrorSourceFile: return TdStackStorer ((struct TdPassportElementErrorSourceFile *)var, M);
    case CODE_PassportElementErrorSourceFiles: return TdStackStorer ((struct TdPassportElementErrorSourceFiles *)var, M);
    case CODE_PassportElementTypePersonalDetails: return TdStackStorer ((struct TdPassportElementTypePersonalDetails *)var, M);
    case CODE_PassportElementTypePassport: return TdStackStorer ((struct TdPassportElementTypePassport *)var, M);
    case CODE_PassportElementTypeDriverLicense: return TdStackStorer ((struct TdPassportElementTypeDriverLicense *)var, M);
    case CODE_PassportElementTypeIdentityCard: return TdStackStorer ((struct TdPassportElementTypeIdentityCard *)var, M);
    case CODE_PassportElementTypeInternalPassport: return TdStackStorer ((struct TdPassportElementTypeInternalPassport *)var, M);
    case CODE_PassportElementTypeAddress: return TdStackStorer ((struct TdPassportElementTypeAddress *)var, M);
    case CODE_PassportElementTypeUtilityBill: return TdStackStorer ((struct TdPassportElementTypeUtilityBill *)var, M);
    case CODE_PassportElementTypeBankStatement: return TdStackStorer ((struct TdPassportElementTypeBankStatement *)var, M);
    case CODE_PassportElementTypeRentalAgreement: return TdStackStorer ((struct TdPassportElementTypeRentalAgreement *)var, M);
    case CODE_PassportElementTypePassportRegistration: return TdStackStorer ((struct TdPassportElementTypePassportRegistration *)var, M);
    case CODE_PassportElementTypeTemporaryRegistration: return TdStackStorer ((struct TdPassportElementTypeTemporaryRegistration *)var, M);
    case CODE_PassportElementTypePhoneNumber: return TdStackStorer ((struct TdPassportElementTypePhoneNumber *)var, M);
    case CODE_PassportElementTypeEmailAddress: return TdStackStorer ((struct TdPassportElementTypeEmailAddress *)var, M);
    case CODE_PassportElements: return TdStackStorer ((struct TdPassportElements *)var, M);
    case CODE_PassportRequiredElement: return TdStackStorer ((struct TdPassportRequiredElement *)var, M);
    case CODE_PassportSuitableElement: return TdStackStorer ((struct TdPassportSuitableElement *)var, M);
    case CODE_PasswordState: return TdStackStorer ((struct TdPasswordState *)var, M);
    case CODE_PaymentForm: return TdStackStorer ((struct TdPaymentForm *)var, M);
    case CODE_PaymentReceipt: return TdStackStorer ((struct TdPaymentReceipt *)var, M);
    case CODE_PaymentResult: return TdStackStorer ((struct TdPaymentResult *)var, M);
    case CODE_PaymentsProviderStripe: return TdStackStorer ((struct TdPaymentsProviderStripe *)var, M);
    case CODE_PersonalDetails: return TdStackStorer ((struct TdPersonalDetails *)var, M);
    case CODE_PersonalDocument: return TdStackStorer ((struct TdPersonalDocument *)var, M);
    case CODE_Photo: return TdStackStorer ((struct TdPhoto *)var, M);
    case CODE_PhotoSize: return TdStackStorer ((struct TdPhotoSize *)var, M);
    case CODE_ProfilePhoto: return TdStackStorer ((struct TdProfilePhoto *)var, M);
    case CODE_Proxies: return TdStackStorer ((struct TdProxies *)var, M);
    case CODE_Proxy: return TdStackStorer ((struct TdProxy *)var, M);
    case CODE_ProxyTypeSocks5: return TdStackStorer ((struct TdProxyTypeSocks5 *)var, M);
    case CODE_ProxyTypeHttp: return TdStackStorer ((struct TdProxyTypeHttp *)var, M);
    case CODE_ProxyTypeMtproto: return TdStackStorer ((struct TdProxyTypeMtproto *)var, M);
    case CODE_PublicMessageLink: return TdStackStorer ((struct TdPublicMessageLink *)var, M);
    case CODE_RecoveryEmailAddress: return TdStackStorer ((struct TdRecoveryEmailAddress *)var, M);
    case CODE_RemoteFile: return TdStackStorer ((struct TdRemoteFile *)var, M);
    case CODE_ReplyMarkupRemoveKeyboard: return TdStackStorer ((struct TdReplyMarkupRemoveKeyboard *)var, M);
    case CODE_ReplyMarkupForceReply: return TdStackStorer ((struct TdReplyMarkupForceReply *)var, M);
    case CODE_ReplyMarkupShowKeyboard: return TdStackStorer ((struct TdReplyMarkupShowKeyboard *)var, M);
    case CODE_ReplyMarkupInlineKeyboard: return TdStackStorer ((struct TdReplyMarkupInlineKeyboard *)var, M);
    case CODE_RichTextPlain: return TdStackStorer ((struct TdRichTextPlain *)var, M);
    case CODE_RichTextBold: return TdStackStorer ((struct TdRichTextBold *)var, M);
    case CODE_RichTextItalic: return TdStackStorer ((struct TdRichTextItalic *)var, M);
    case CODE_RichTextUnderline: return TdStackStorer ((struct TdRichTextUnderline *)var, M);
    case CODE_RichTextStrikethrough: return TdStackStorer ((struct TdRichTextStrikethrough *)var, M);
    case CODE_RichTextFixed: return TdStackStorer ((struct TdRichTextFixed *)var, M);
    case CODE_RichTextUrl: return TdStackStorer ((struct TdRichTextUrl *)var, M);
    case CODE_RichTextEmailAddress: return TdStackStorer ((struct TdRichTextEmailAddress *)var, M);
    case CODE_RichTexts: return TdStackStorer ((struct TdRichTexts *)var, M);
    case CODE_SavedCredentials: return TdStackStorer ((struct TdSavedCredentials *)var, M);
    case CODE_ScopeNotificationSettings: return TdStackStorer ((struct TdScopeNotificationSettings *)var, M);
    case CODE_SearchMessagesFilterEmpty: return TdStackStorer ((struct TdSearchMessagesFilterEmpty *)var, M);
    case CODE_SearchMessagesFilterAnimation: return TdStackStorer ((struct TdSearchMessagesFilterAnimation *)var, M);
    case CODE_SearchMessagesFilterAudio: return TdStackStorer ((struct TdSearchMessagesFilterAudio *)var, M);
    case CODE_SearchMessagesFilterDocument: return TdStackStorer ((struct TdSearchMessagesFilterDocument *)var, M);
    case CODE_SearchMessagesFilterPhoto: return TdStackStorer ((struct TdSearchMessagesFilterPhoto *)var, M);
    case CODE_SearchMessagesFilterVideo: return TdStackStorer ((struct TdSearchMessagesFilterVideo *)var, M);
    case CODE_SearchMessagesFilterVoiceNote: return TdStackStorer ((struct TdSearchMessagesFilterVoiceNote *)var, M);
    case CODE_SearchMessagesFilterPhotoAndVideo: return TdStackStorer ((struct TdSearchMessagesFilterPhotoAndVideo *)var, M);
    case CODE_SearchMessagesFilterUrl: return TdStackStorer ((struct TdSearchMessagesFilterUrl *)var, M);
    case CODE_SearchMessagesFilterChatPhoto: return TdStackStorer ((struct TdSearchMessagesFilterChatPhoto *)var, M);
    case CODE_SearchMessagesFilterCall: return TdStackStorer ((struct TdSearchMessagesFilterCall *)var, M);
    case CODE_SearchMessagesFilterMissedCall: return TdStackStorer ((struct TdSearchMessagesFilterMissedCall *)var, M);
    case CODE_SearchMessagesFilterVideoNote: return TdStackStorer ((struct TdSearchMessagesFilterVideoNote *)var, M);
    case CODE_SearchMessagesFilterVoiceAndVideoNote: return TdStackStorer ((struct TdSearchMessagesFilterVoiceAndVideoNote *)var, M);
    case CODE_SearchMessagesFilterMention: return TdStackStorer ((struct TdSearchMessagesFilterMention *)var, M);
    case CODE_SearchMessagesFilterUnreadMention: return TdStackStorer ((struct TdSearchMessagesFilterUnreadMention *)var, M);
    case CODE_Seconds: return TdStackStorer ((struct TdSeconds *)var, M);
    case CODE_SecretChat: return TdStackStorer ((struct TdSecretChat *)var, M);
    case CODE_SecretChatStatePending: return TdStackStorer ((struct TdSecretChatStatePending *)var, M);
    case CODE_SecretChatStateReady: return TdStackStorer ((struct TdSecretChatStateReady *)var, M);
    case CODE_SecretChatStateClosed: return TdStackStorer ((struct TdSecretChatStateClosed *)var, M);
    case CODE_Session: return TdStackStorer ((struct TdSession *)var, M);
    case CODE_Sessions: return TdStackStorer ((struct TdSessions *)var, M);
    case CODE_ShippingOption: return TdStackStorer ((struct TdShippingOption *)var, M);
    case CODE_Sticker: return TdStackStorer ((struct TdSticker *)var, M);
    case CODE_StickerEmojis: return TdStackStorer ((struct TdStickerEmojis *)var, M);
    case CODE_StickerSet: return TdStackStorer ((struct TdStickerSet *)var, M);
    case CODE_StickerSetInfo: return TdStackStorer ((struct TdStickerSetInfo *)var, M);
    case CODE_StickerSets: return TdStackStorer ((struct TdStickerSets *)var, M);
    case CODE_Stickers: return TdStackStorer ((struct TdStickers *)var, M);
    case CODE_StorageStatistics: return TdStackStorer ((struct TdStorageStatistics *)var, M);
    case CODE_StorageStatisticsByChat: return TdStackStorer ((struct TdStorageStatisticsByChat *)var, M);
    case CODE_StorageStatisticsByFileType: return TdStackStorer ((struct TdStorageStatisticsByFileType *)var, M);
    case CODE_StorageStatisticsFast: return TdStackStorer ((struct TdStorageStatisticsFast *)var, M);
    case CODE_Supergroup: return TdStackStorer ((struct TdSupergroup *)var, M);
    case CODE_SupergroupFullInfo: return TdStackStorer ((struct TdSupergroupFullInfo *)var, M);
    case CODE_SupergroupMembersFilterRecent: return TdStackStorer ((struct TdSupergroupMembersFilterRecent *)var, M);
    case CODE_SupergroupMembersFilterAdministrators: return TdStackStorer ((struct TdSupergroupMembersFilterAdministrators *)var, M);
    case CODE_SupergroupMembersFilterSearch: return TdStackStorer ((struct TdSupergroupMembersFilterSearch *)var, M);
    case CODE_SupergroupMembersFilterRestricted: return TdStackStorer ((struct TdSupergroupMembersFilterRestricted *)var, M);
    case CODE_SupergroupMembersFilterBanned: return TdStackStorer ((struct TdSupergroupMembersFilterBanned *)var, M);
    case CODE_SupergroupMembersFilterBots: return TdStackStorer ((struct TdSupergroupMembersFilterBots *)var, M);
    case CODE_TMeUrl: return TdStackStorer ((struct TdTMeUrl *)var, M);
    case CODE_TMeUrlTypeUser: return TdStackStorer ((struct TdTMeUrlTypeUser *)var, M);
    case CODE_TMeUrlTypeSupergroup: return TdStackStorer ((struct TdTMeUrlTypeSupergroup *)var, M);
    case CODE_TMeUrlTypeChatInvite: return TdStackStorer ((struct TdTMeUrlTypeChatInvite *)var, M);
    case CODE_TMeUrlTypeStickerSet: return TdStackStorer ((struct TdTMeUrlTypeStickerSet *)var, M);
    case CODE_TMeUrls: return TdStackStorer ((struct TdTMeUrls *)var, M);
    case CODE_TdlibParameters: return TdStackStorer ((struct TdTdlibParameters *)var, M);
    case CODE_TemporaryPasswordState: return TdStackStorer ((struct TdTemporaryPasswordState *)var, M);
    case CODE_TermsOfService: return TdStackStorer ((struct TdTermsOfService *)var, M);
    case CODE_TestBytes: return TdStackStorer ((struct TdTestBytes *)var, M);
    case CODE_TestInt: return TdStackStorer ((struct TdTestInt *)var, M);
    case CODE_TestString: return TdStackStorer ((struct TdTestString *)var, M);
    case CODE_TestVectorInt: return TdStackStorer ((struct TdTestVectorInt *)var, M);
    case CODE_TestVectorIntObject: return TdStackStorer ((struct TdTestVectorIntObject *)var, M);
    case CODE_TestVectorString: return TdStackStorer ((struct TdTestVectorString *)var, M);
    case CODE_TestVectorStringObject: return TdStackStorer ((struct TdTestVectorStringObject *)var, M);
    case CODE_Text: return TdStackStorer ((struct TdText *)var, M);
    case CODE_TextEntities: return TdStackStorer ((struct TdTextEntities *)var, M);
    case CODE_TextEntity: return TdStackStorer ((struct TdTextEntity *)var, M);
    case CODE_TextEntityTypeMention: return TdStackStorer ((struct TdTextEntityTypeMention *)var, M);
    case CODE_TextEntityTypeHashtag: return TdStackStorer ((struct TdTextEntityTypeHashtag *)var, M);
    case CODE_TextEntityTypeCashtag: return TdStackStorer ((struct TdTextEntityTypeCashtag *)var, M);
    case CODE_TextEntityTypeBotCommand: return TdStackStorer ((struct TdTextEntityTypeBotCommand *)var, M);
    case CODE_TextEntityTypeUrl: return TdStackStorer ((struct TdTextEntityTypeUrl *)var, M);
    case CODE_TextEntityTypeEmailAddress: return TdStackStorer ((struct TdTextEntityTypeEmailAddress *)var, M);
    case CODE_TextEntityTypeBold: return TdStackStorer ((struct TdTextEntityTypeBold *)var, M);
    case CODE_TextEntityTypeItalic: return TdStackStorer ((struct TdTextEntityTypeItalic *)var, M);
    case CODE_TextEntityTypeCode: return TdStackStorer ((struct TdTextEntityTypeCode *)var, M);
    case CODE_TextEntityTypePre: return TdStackStorer ((struct TdTextEntityTypePre *)var, M);
    case CODE_TextEntityTypePreCode: return TdStackStorer ((struct TdTextEntityTypePreCode *)var, M);
    case CODE_TextEntityTypeTextUrl: return TdStackStorer ((struct TdTextEntityTypeTextUrl *)var, M);
    case CODE_TextEntityTypeMentionName: return TdStackStorer ((struct TdTextEntityTypeMentionName *)var, M);
    case CODE_TextEntityTypePhoneNumber: return TdStackStorer ((struct TdTextEntityTypePhoneNumber *)var, M);
    case CODE_TextParseModeMarkdown: return TdStackStorer ((struct TdTextParseModeMarkdown *)var, M);
    case CODE_TextParseModeHTML: return TdStackStorer ((struct TdTextParseModeHTML *)var, M);
    case CODE_TopChatCategoryUsers: return TdStackStorer ((struct TdTopChatCategoryUsers *)var, M);
    case CODE_TopChatCategoryBots: return TdStackStorer ((struct TdTopChatCategoryBots *)var, M);
    case CODE_TopChatCategoryGroups: return TdStackStorer ((struct TdTopChatCategoryGroups *)var, M);
    case CODE_TopChatCategoryChannels: return TdStackStorer ((struct TdTopChatCategoryChannels *)var, M);
    case CODE_TopChatCategoryInlineBots: return TdStackStorer ((struct TdTopChatCategoryInlineBots *)var, M);
    case CODE_TopChatCategoryCalls: return TdStackStorer ((struct TdTopChatCategoryCalls *)var, M);
    case CODE_UpdateAuthorizationState: return TdStackStorer ((struct TdUpdateAuthorizationState *)var, M);
    case CODE_UpdateNewMessage: return TdStackStorer ((struct TdUpdateNewMessage *)var, M);
    case CODE_UpdateMessageSendAcknowledged: return TdStackStorer ((struct TdUpdateMessageSendAcknowledged *)var, M);
    case CODE_UpdateMessageSendSucceeded: return TdStackStorer ((struct TdUpdateMessageSendSucceeded *)var, M);
    case CODE_UpdateMessageSendFailed: return TdStackStorer ((struct TdUpdateMessageSendFailed *)var, M);
    case CODE_UpdateMessageContent: return TdStackStorer ((struct TdUpdateMessageContent *)var, M);
    case CODE_UpdateMessageEdited: return TdStackStorer ((struct TdUpdateMessageEdited *)var, M);
    case CODE_UpdateMessageViews: return TdStackStorer ((struct TdUpdateMessageViews *)var, M);
    case CODE_UpdateMessageContentOpened: return TdStackStorer ((struct TdUpdateMessageContentOpened *)var, M);
    case CODE_UpdateMessageMentionRead: return TdStackStorer ((struct TdUpdateMessageMentionRead *)var, M);
    case CODE_UpdateNewChat: return TdStackStorer ((struct TdUpdateNewChat *)var, M);
    case CODE_UpdateChatTitle: return TdStackStorer ((struct TdUpdateChatTitle *)var, M);
    case CODE_UpdateChatPhoto: return TdStackStorer ((struct TdUpdateChatPhoto *)var, M);
    case CODE_UpdateChatLastMessage: return TdStackStorer ((struct TdUpdateChatLastMessage *)var, M);
    case CODE_UpdateChatOrder: return TdStackStorer ((struct TdUpdateChatOrder *)var, M);
    case CODE_UpdateChatIsPinned: return TdStackStorer ((struct TdUpdateChatIsPinned *)var, M);
    case CODE_UpdateChatIsMarkedAsUnread: return TdStackStorer ((struct TdUpdateChatIsMarkedAsUnread *)var, M);
    case CODE_UpdateChatIsSponsored: return TdStackStorer ((struct TdUpdateChatIsSponsored *)var, M);
    case CODE_UpdateChatDefaultDisableNotification: return TdStackStorer ((struct TdUpdateChatDefaultDisableNotification *)var, M);
    case CODE_UpdateChatReadInbox: return TdStackStorer ((struct TdUpdateChatReadInbox *)var, M);
    case CODE_UpdateChatReadOutbox: return TdStackStorer ((struct TdUpdateChatReadOutbox *)var, M);
    case CODE_UpdateChatUnreadMentionCount: return TdStackStorer ((struct TdUpdateChatUnreadMentionCount *)var, M);
    case CODE_UpdateChatNotificationSettings: return TdStackStorer ((struct TdUpdateChatNotificationSettings *)var, M);
    case CODE_UpdateScopeNotificationSettings: return TdStackStorer ((struct TdUpdateScopeNotificationSettings *)var, M);
    case CODE_UpdateChatReplyMarkup: return TdStackStorer ((struct TdUpdateChatReplyMarkup *)var, M);
    case CODE_UpdateChatDraftMessage: return TdStackStorer ((struct TdUpdateChatDraftMessage *)var, M);
    case CODE_UpdateDeleteMessages: return TdStackStorer ((struct TdUpdateDeleteMessages *)var, M);
    case CODE_UpdateUserChatAction: return TdStackStorer ((struct TdUpdateUserChatAction *)var, M);
    case CODE_UpdateUserStatus: return TdStackStorer ((struct TdUpdateUserStatus *)var, M);
    case CODE_UpdateUser: return TdStackStorer ((struct TdUpdateUser *)var, M);
    case CODE_UpdateBasicGroup: return TdStackStorer ((struct TdUpdateBasicGroup *)var, M);
    case CODE_UpdateSupergroup: return TdStackStorer ((struct TdUpdateSupergroup *)var, M);
    case CODE_UpdateSecretChat: return TdStackStorer ((struct TdUpdateSecretChat *)var, M);
    case CODE_UpdateUserFullInfo: return TdStackStorer ((struct TdUpdateUserFullInfo *)var, M);
    case CODE_UpdateBasicGroupFullInfo: return TdStackStorer ((struct TdUpdateBasicGroupFullInfo *)var, M);
    case CODE_UpdateSupergroupFullInfo: return TdStackStorer ((struct TdUpdateSupergroupFullInfo *)var, M);
    case CODE_UpdateServiceNotification: return TdStackStorer ((struct TdUpdateServiceNotification *)var, M);
    case CODE_UpdateFile: return TdStackStorer ((struct TdUpdateFile *)var, M);
    case CODE_UpdateFileGenerationStart: return TdStackStorer ((struct TdUpdateFileGenerationStart *)var, M);
    case CODE_UpdateFileGenerationStop: return TdStackStorer ((struct TdUpdateFileGenerationStop *)var, M);
    case CODE_UpdateCall: return TdStackStorer ((struct TdUpdateCall *)var, M);
    case CODE_UpdateUserPrivacySettingRules: return TdStackStorer ((struct TdUpdateUserPrivacySettingRules *)var, M);
    case CODE_UpdateUnreadMessageCount: return TdStackStorer ((struct TdUpdateUnreadMessageCount *)var, M);
    case CODE_UpdateUnreadChatCount: return TdStackStorer ((struct TdUpdateUnreadChatCount *)var, M);
    case CODE_UpdateOption: return TdStackStorer ((struct TdUpdateOption *)var, M);
    case CODE_UpdateInstalledStickerSets: return TdStackStorer ((struct TdUpdateInstalledStickerSets *)var, M);
    case CODE_UpdateTrendingStickerSets: return TdStackStorer ((struct TdUpdateTrendingStickerSets *)var, M);
    case CODE_UpdateRecentStickers: return TdStackStorer ((struct TdUpdateRecentStickers *)var, M);
    case CODE_UpdateFavoriteStickers: return TdStackStorer ((struct TdUpdateFavoriteStickers *)var, M);
    case CODE_UpdateSavedAnimations: return TdStackStorer ((struct TdUpdateSavedAnimations *)var, M);
    case CODE_UpdateLanguagePackStrings: return TdStackStorer ((struct TdUpdateLanguagePackStrings *)var, M);
    case CODE_UpdateConnectionState: return TdStackStorer ((struct TdUpdateConnectionState *)var, M);
    case CODE_UpdateTermsOfService: return TdStackStorer ((struct TdUpdateTermsOfService *)var, M);
    case CODE_UpdateNewInlineQuery: return TdStackStorer ((struct TdUpdateNewInlineQuery *)var, M);
    case CODE_UpdateNewChosenInlineResult: return TdStackStorer ((struct TdUpdateNewChosenInlineResult *)var, M);
    case CODE_UpdateNewCallbackQuery: return TdStackStorer ((struct TdUpdateNewCallbackQuery *)var, M);
    case CODE_UpdateNewInlineCallbackQuery: return TdStackStorer ((struct TdUpdateNewInlineCallbackQuery *)var, M);
    case CODE_UpdateNewShippingQuery: return TdStackStorer ((struct TdUpdateNewShippingQuery *)var, M);
    case CODE_UpdateNewPreCheckoutQuery: return TdStackStorer ((struct TdUpdateNewPreCheckoutQuery *)var, M);
    case CODE_UpdateNewCustomEvent: return TdStackStorer ((struct TdUpdateNewCustomEvent *)var, M);
    case CODE_UpdateNewCustomQuery: return TdStackStorer ((struct TdUpdateNewCustomQuery *)var, M);
    case CODE_User: return TdStackStorer ((struct TdUser *)var, M);
    case CODE_UserFullInfo: return TdStackStorer ((struct TdUserFullInfo *)var, M);
    case CODE_UserPrivacySettingShowStatus: return TdStackStorer ((struct TdUserPrivacySettingShowStatus *)var, M);
    case CODE_UserPrivacySettingAllowChatInvites: return TdStackStorer ((struct TdUserPrivacySettingAllowChatInvites *)var, M);
    case CODE_UserPrivacySettingAllowCalls: return TdStackStorer ((struct TdUserPrivacySettingAllowCalls *)var, M);
    case CODE_UserPrivacySettingRuleAllowAll: return TdStackStorer ((struct TdUserPrivacySettingRuleAllowAll *)var, M);
    case CODE_UserPrivacySettingRuleAllowContacts: return TdStackStorer ((struct TdUserPrivacySettingRuleAllowContacts *)var, M);
    case CODE_UserPrivacySettingRuleAllowUsers: return TdStackStorer ((struct TdUserPrivacySettingRuleAllowUsers *)var, M);
    case CODE_UserPrivacySettingRuleRestrictAll: return TdStackStorer ((struct TdUserPrivacySettingRuleRestrictAll *)var, M);
    case CODE_UserPrivacySettingRuleRestrictContacts: return TdStackStorer ((struct TdUserPrivacySettingRuleRestrictContacts *)var, M);
    case CODE_UserPrivacySettingRuleRestrictUsers: return TdStackStorer ((struct TdUserPrivacySettingRuleRestrictUsers *)var, M);
    case CODE_UserPrivacySettingRules: return TdStackStorer ((struct TdUserPrivacySettingRules *)var, M);
    case CODE_UserProfilePhotos: return TdStackStorer ((struct TdUserProfilePhotos *)var, M);
    case CODE_UserStatusEmpty: return TdStackStorer ((struct TdUserStatusEmpty *)var, M);
    case CODE_UserStatusOnline: return TdStackStorer ((struct TdUserStatusOnline *)var, M);
    case CODE_UserStatusOffline: return TdStackStorer ((struct TdUserStatusOffline *)var, M);
    case CODE_UserStatusRecently: return TdStackStorer ((struct TdUserStatusRecently *)var, M);
    case CODE_UserStatusLastWeek: return TdStackStorer ((struct TdUserStatusLastWeek *)var, M);
    case CODE_UserStatusLastMonth: return TdStackStorer ((struct TdUserStatusLastMonth *)var, M);
    case CODE_UserTypeRegular: return TdStackStorer ((struct TdUserTypeRegular *)var, M);
    case CODE_UserTypeDeleted: return TdStackStorer ((struct TdUserTypeDeleted *)var, M);
    case CODE_UserTypeBot: return TdStackStorer ((struct TdUserTypeBot *)var, M);
    case CODE_UserTypeUnknown: return TdStackStorer ((struct TdUserTypeUnknown *)var, M);
    case CODE_Users: return TdStackStorer ((struct TdUsers *)var, M);
    case CODE_ValidatedOrderInfo: return TdStackStorer ((struct TdValidatedOrderInfo *)var, M);
    case CODE_Venue: return TdStackStorer ((struct TdVenue *)var, M);
    case CODE_Video: return TdStackStorer ((struct TdVideo *)var, M);
    case CODE_VideoNote: return TdStackStorer ((struct TdVideoNote *)var, M);
    case CODE_VoiceNote: return TdStackStorer ((struct TdVoiceNote *)var, M);
    case CODE_Wallpaper: return TdStackStorer ((struct TdWallpaper *)var, M);
    case CODE_Wallpapers: return TdStackStorer ((struct TdWallpapers *)var, M);
    case CODE_WebPage: return TdStackStorer ((struct TdWebPage *)var, M);
    case CODE_WebPageInstantView: return TdStackStorer ((struct TdWebPageInstantView *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdObject *TdStackFetcherObject (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "AccountTtl") {
    return (struct TdObject *)TdStackFetcherAccountTtl (M);
  }
  if (constructor == "Address") {
    return (struct TdObject *)TdStackFetcherAddress (M);
  }
  if (constructor == "Animation") {
    return (struct TdObject *)TdStackFetcherAnimation (M);
  }
  if (constructor == "Animations") {
    return (struct TdObject *)TdStackFetcherAnimations (M);
  }
  if (constructor == "Audio") {
    return (struct TdObject *)TdStackFetcherAudio (M);
  }
  if (constructor == "AuthenticationCodeInfo") {
    return (struct TdObject *)TdStackFetcherAuthenticationCodeInfo (M);
  }
  if (constructor == "AuthenticationCodeTypeTelegramMessage") {
    return (struct TdObject *)TdStackFetcherAuthenticationCodeTypeTelegramMessage (M);
  }
  if (constructor == "AuthenticationCodeTypeSms") {
    return (struct TdObject *)TdStackFetcherAuthenticationCodeTypeSms (M);
  }
  if (constructor == "AuthenticationCodeTypeCall") {
    return (struct TdObject *)TdStackFetcherAuthenticationCodeTypeCall (M);
  }
  if (constructor == "AuthenticationCodeTypeFlashCall") {
    return (struct TdObject *)TdStackFetcherAuthenticationCodeTypeFlashCall (M);
  }
  if (constructor == "AuthorizationStateWaitTdlibParameters") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateWaitTdlibParameters (M);
  }
  if (constructor == "AuthorizationStateWaitEncryptionKey") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateWaitEncryptionKey (M);
  }
  if (constructor == "AuthorizationStateWaitPhoneNumber") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateWaitPhoneNumber (M);
  }
  if (constructor == "AuthorizationStateWaitCode") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateWaitCode (M);
  }
  if (constructor == "AuthorizationStateWaitPassword") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateWaitPassword (M);
  }
  if (constructor == "AuthorizationStateReady") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateReady (M);
  }
  if (constructor == "AuthorizationStateLoggingOut") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateLoggingOut (M);
  }
  if (constructor == "AuthorizationStateClosing") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateClosing (M);
  }
  if (constructor == "AuthorizationStateClosed") {
    return (struct TdObject *)TdStackFetcherAuthorizationStateClosed (M);
  }
  if (constructor == "BasicGroup") {
    return (struct TdObject *)TdStackFetcherBasicGroup (M);
  }
  if (constructor == "BasicGroupFullInfo") {
    return (struct TdObject *)TdStackFetcherBasicGroupFullInfo (M);
  }
  if (constructor == "BotCommand") {
    return (struct TdObject *)TdStackFetcherBotCommand (M);
  }
  if (constructor == "BotInfo") {
    return (struct TdObject *)TdStackFetcherBotInfo (M);
  }
  if (constructor == "Call") {
    return (struct TdObject *)TdStackFetcherCall (M);
  }
  if (constructor == "CallConnection") {
    return (struct TdObject *)TdStackFetcherCallConnection (M);
  }
  if (constructor == "CallDiscardReasonEmpty") {
    return (struct TdObject *)TdStackFetcherCallDiscardReasonEmpty (M);
  }
  if (constructor == "CallDiscardReasonMissed") {
    return (struct TdObject *)TdStackFetcherCallDiscardReasonMissed (M);
  }
  if (constructor == "CallDiscardReasonDeclined") {
    return (struct TdObject *)TdStackFetcherCallDiscardReasonDeclined (M);
  }
  if (constructor == "CallDiscardReasonDisconnected") {
    return (struct TdObject *)TdStackFetcherCallDiscardReasonDisconnected (M);
  }
  if (constructor == "CallDiscardReasonHungUp") {
    return (struct TdObject *)TdStackFetcherCallDiscardReasonHungUp (M);
  }
  if (constructor == "CallId") {
    return (struct TdObject *)TdStackFetcherCallId (M);
  }
  if (constructor == "CallProtocol") {
    return (struct TdObject *)TdStackFetcherCallProtocol (M);
  }
  if (constructor == "CallStatePending") {
    return (struct TdObject *)TdStackFetcherCallStatePending (M);
  }
  if (constructor == "CallStateExchangingKeys") {
    return (struct TdObject *)TdStackFetcherCallStateExchangingKeys (M);
  }
  if (constructor == "CallStateReady") {
    return (struct TdObject *)TdStackFetcherCallStateReady (M);
  }
  if (constructor == "CallStateHangingUp") {
    return (struct TdObject *)TdStackFetcherCallStateHangingUp (M);
  }
  if (constructor == "CallStateDiscarded") {
    return (struct TdObject *)TdStackFetcherCallStateDiscarded (M);
  }
  if (constructor == "CallStateError") {
    return (struct TdObject *)TdStackFetcherCallStateError (M);
  }
  if (constructor == "CallbackQueryAnswer") {
    return (struct TdObject *)TdStackFetcherCallbackQueryAnswer (M);
  }
  if (constructor == "CallbackQueryPayloadData") {
    return (struct TdObject *)TdStackFetcherCallbackQueryPayloadData (M);
  }
  if (constructor == "CallbackQueryPayloadGame") {
    return (struct TdObject *)TdStackFetcherCallbackQueryPayloadGame (M);
  }
  if (constructor == "Chat") {
    return (struct TdObject *)TdStackFetcherChat (M);
  }
  if (constructor == "ChatActionTyping") {
    return (struct TdObject *)TdStackFetcherChatActionTyping (M);
  }
  if (constructor == "ChatActionRecordingVideo") {
    return (struct TdObject *)TdStackFetcherChatActionRecordingVideo (M);
  }
  if (constructor == "ChatActionUploadingVideo") {
    return (struct TdObject *)TdStackFetcherChatActionUploadingVideo (M);
  }
  if (constructor == "ChatActionRecordingVoiceNote") {
    return (struct TdObject *)TdStackFetcherChatActionRecordingVoiceNote (M);
  }
  if (constructor == "ChatActionUploadingVoiceNote") {
    return (struct TdObject *)TdStackFetcherChatActionUploadingVoiceNote (M);
  }
  if (constructor == "ChatActionUploadingPhoto") {
    return (struct TdObject *)TdStackFetcherChatActionUploadingPhoto (M);
  }
  if (constructor == "ChatActionUploadingDocument") {
    return (struct TdObject *)TdStackFetcherChatActionUploadingDocument (M);
  }
  if (constructor == "ChatActionChoosingLocation") {
    return (struct TdObject *)TdStackFetcherChatActionChoosingLocation (M);
  }
  if (constructor == "ChatActionChoosingContact") {
    return (struct TdObject *)TdStackFetcherChatActionChoosingContact (M);
  }
  if (constructor == "ChatActionStartPlayingGame") {
    return (struct TdObject *)TdStackFetcherChatActionStartPlayingGame (M);
  }
  if (constructor == "ChatActionRecordingVideoNote") {
    return (struct TdObject *)TdStackFetcherChatActionRecordingVideoNote (M);
  }
  if (constructor == "ChatActionUploadingVideoNote") {
    return (struct TdObject *)TdStackFetcherChatActionUploadingVideoNote (M);
  }
  if (constructor == "ChatActionCancel") {
    return (struct TdObject *)TdStackFetcherChatActionCancel (M);
  }
  if (constructor == "ChatEvent") {
    return (struct TdObject *)TdStackFetcherChatEvent (M);
  }
  if (constructor == "ChatEventMessageEdited") {
    return (struct TdObject *)TdStackFetcherChatEventMessageEdited (M);
  }
  if (constructor == "ChatEventMessageDeleted") {
    return (struct TdObject *)TdStackFetcherChatEventMessageDeleted (M);
  }
  if (constructor == "ChatEventMessagePinned") {
    return (struct TdObject *)TdStackFetcherChatEventMessagePinned (M);
  }
  if (constructor == "ChatEventMessageUnpinned") {
    return (struct TdObject *)TdStackFetcherChatEventMessageUnpinned (M);
  }
  if (constructor == "ChatEventMemberJoined") {
    return (struct TdObject *)TdStackFetcherChatEventMemberJoined (M);
  }
  if (constructor == "ChatEventMemberLeft") {
    return (struct TdObject *)TdStackFetcherChatEventMemberLeft (M);
  }
  if (constructor == "ChatEventMemberInvited") {
    return (struct TdObject *)TdStackFetcherChatEventMemberInvited (M);
  }
  if (constructor == "ChatEventMemberPromoted") {
    return (struct TdObject *)TdStackFetcherChatEventMemberPromoted (M);
  }
  if (constructor == "ChatEventMemberRestricted") {
    return (struct TdObject *)TdStackFetcherChatEventMemberRestricted (M);
  }
  if (constructor == "ChatEventTitleChanged") {
    return (struct TdObject *)TdStackFetcherChatEventTitleChanged (M);
  }
  if (constructor == "ChatEventDescriptionChanged") {
    return (struct TdObject *)TdStackFetcherChatEventDescriptionChanged (M);
  }
  if (constructor == "ChatEventUsernameChanged") {
    return (struct TdObject *)TdStackFetcherChatEventUsernameChanged (M);
  }
  if (constructor == "ChatEventPhotoChanged") {
    return (struct TdObject *)TdStackFetcherChatEventPhotoChanged (M);
  }
  if (constructor == "ChatEventInvitesToggled") {
    return (struct TdObject *)TdStackFetcherChatEventInvitesToggled (M);
  }
  if (constructor == "ChatEventSignMessagesToggled") {
    return (struct TdObject *)TdStackFetcherChatEventSignMessagesToggled (M);
  }
  if (constructor == "ChatEventStickerSetChanged") {
    return (struct TdObject *)TdStackFetcherChatEventStickerSetChanged (M);
  }
  if (constructor == "ChatEventIsAllHistoryAvailableToggled") {
    return (struct TdObject *)TdStackFetcherChatEventIsAllHistoryAvailableToggled (M);
  }
  if (constructor == "ChatEventLogFilters") {
    return (struct TdObject *)TdStackFetcherChatEventLogFilters (M);
  }
  if (constructor == "ChatEvents") {
    return (struct TdObject *)TdStackFetcherChatEvents (M);
  }
  if (constructor == "ChatInviteLink") {
    return (struct TdObject *)TdStackFetcherChatInviteLink (M);
  }
  if (constructor == "ChatInviteLinkInfo") {
    return (struct TdObject *)TdStackFetcherChatInviteLinkInfo (M);
  }
  if (constructor == "ChatMember") {
    return (struct TdObject *)TdStackFetcherChatMember (M);
  }
  if (constructor == "ChatMemberStatusCreator") {
    return (struct TdObject *)TdStackFetcherChatMemberStatusCreator (M);
  }
  if (constructor == "ChatMemberStatusAdministrator") {
    return (struct TdObject *)TdStackFetcherChatMemberStatusAdministrator (M);
  }
  if (constructor == "ChatMemberStatusMember") {
    return (struct TdObject *)TdStackFetcherChatMemberStatusMember (M);
  }
  if (constructor == "ChatMemberStatusRestricted") {
    return (struct TdObject *)TdStackFetcherChatMemberStatusRestricted (M);
  }
  if (constructor == "ChatMemberStatusLeft") {
    return (struct TdObject *)TdStackFetcherChatMemberStatusLeft (M);
  }
  if (constructor == "ChatMemberStatusBanned") {
    return (struct TdObject *)TdStackFetcherChatMemberStatusBanned (M);
  }
  if (constructor == "ChatMembers") {
    return (struct TdObject *)TdStackFetcherChatMembers (M);
  }
  if (constructor == "ChatMembersFilterAdministrators") {
    return (struct TdObject *)TdStackFetcherChatMembersFilterAdministrators (M);
  }
  if (constructor == "ChatMembersFilterMembers") {
    return (struct TdObject *)TdStackFetcherChatMembersFilterMembers (M);
  }
  if (constructor == "ChatMembersFilterRestricted") {
    return (struct TdObject *)TdStackFetcherChatMembersFilterRestricted (M);
  }
  if (constructor == "ChatMembersFilterBanned") {
    return (struct TdObject *)TdStackFetcherChatMembersFilterBanned (M);
  }
  if (constructor == "ChatMembersFilterBots") {
    return (struct TdObject *)TdStackFetcherChatMembersFilterBots (M);
  }
  if (constructor == "ChatNotificationSettings") {
    return (struct TdObject *)TdStackFetcherChatNotificationSettings (M);
  }
  if (constructor == "ChatPhoto") {
    return (struct TdObject *)TdStackFetcherChatPhoto (M);
  }
  if (constructor == "ChatReportReasonSpam") {
    return (struct TdObject *)TdStackFetcherChatReportReasonSpam (M);
  }
  if (constructor == "ChatReportReasonViolence") {
    return (struct TdObject *)TdStackFetcherChatReportReasonViolence (M);
  }
  if (constructor == "ChatReportReasonPornography") {
    return (struct TdObject *)TdStackFetcherChatReportReasonPornography (M);
  }
  if (constructor == "ChatReportReasonCopyright") {
    return (struct TdObject *)TdStackFetcherChatReportReasonCopyright (M);
  }
  if (constructor == "ChatReportReasonCustom") {
    return (struct TdObject *)TdStackFetcherChatReportReasonCustom (M);
  }
  if (constructor == "ChatReportSpamState") {
    return (struct TdObject *)TdStackFetcherChatReportSpamState (M);
  }
  if (constructor == "ChatTypePrivate") {
    return (struct TdObject *)TdStackFetcherChatTypePrivate (M);
  }
  if (constructor == "ChatTypeBasicGroup") {
    return (struct TdObject *)TdStackFetcherChatTypeBasicGroup (M);
  }
  if (constructor == "ChatTypeSupergroup") {
    return (struct TdObject *)TdStackFetcherChatTypeSupergroup (M);
  }
  if (constructor == "ChatTypeSecret") {
    return (struct TdObject *)TdStackFetcherChatTypeSecret (M);
  }
  if (constructor == "Chats") {
    return (struct TdObject *)TdStackFetcherChats (M);
  }
  if (constructor == "CheckChatUsernameResultOk") {
    return (struct TdObject *)TdStackFetcherCheckChatUsernameResultOk (M);
  }
  if (constructor == "CheckChatUsernameResultUsernameInvalid") {
    return (struct TdObject *)TdStackFetcherCheckChatUsernameResultUsernameInvalid (M);
  }
  if (constructor == "CheckChatUsernameResultUsernameOccupied") {
    return (struct TdObject *)TdStackFetcherCheckChatUsernameResultUsernameOccupied (M);
  }
  if (constructor == "CheckChatUsernameResultPublicChatsTooMuch") {
    return (struct TdObject *)TdStackFetcherCheckChatUsernameResultPublicChatsTooMuch (M);
  }
  if (constructor == "CheckChatUsernameResultPublicGroupsUnavailable") {
    return (struct TdObject *)TdStackFetcherCheckChatUsernameResultPublicGroupsUnavailable (M);
  }
  if (constructor == "ConnectedWebsite") {
    return (struct TdObject *)TdStackFetcherConnectedWebsite (M);
  }
  if (constructor == "ConnectedWebsites") {
    return (struct TdObject *)TdStackFetcherConnectedWebsites (M);
  }
  if (constructor == "ConnectionStateWaitingForNetwork") {
    return (struct TdObject *)TdStackFetcherConnectionStateWaitingForNetwork (M);
  }
  if (constructor == "ConnectionStateConnectingToProxy") {
    return (struct TdObject *)TdStackFetcherConnectionStateConnectingToProxy (M);
  }
  if (constructor == "ConnectionStateConnecting") {
    return (struct TdObject *)TdStackFetcherConnectionStateConnecting (M);
  }
  if (constructor == "ConnectionStateUpdating") {
    return (struct TdObject *)TdStackFetcherConnectionStateUpdating (M);
  }
  if (constructor == "ConnectionStateReady") {
    return (struct TdObject *)TdStackFetcherConnectionStateReady (M);
  }
  if (constructor == "Contact") {
    return (struct TdObject *)TdStackFetcherContact (M);
  }
  if (constructor == "Count") {
    return (struct TdObject *)TdStackFetcherCount (M);
  }
  if (constructor == "CustomRequestResult") {
    return (struct TdObject *)TdStackFetcherCustomRequestResult (M);
  }
  if (constructor == "Date") {
    return (struct TdObject *)TdStackFetcherDate (M);
  }
  if (constructor == "DatedFile") {
    return (struct TdObject *)TdStackFetcherDatedFile (M);
  }
  if (constructor == "DeepLinkInfo") {
    return (struct TdObject *)TdStackFetcherDeepLinkInfo (M);
  }
  if (constructor == "DeviceTokenGoogleCloudMessaging") {
    return (struct TdObject *)TdStackFetcherDeviceTokenGoogleCloudMessaging (M);
  }
  if (constructor == "DeviceTokenApplePush") {
    return (struct TdObject *)TdStackFetcherDeviceTokenApplePush (M);
  }
  if (constructor == "DeviceTokenApplePushVoIP") {
    return (struct TdObject *)TdStackFetcherDeviceTokenApplePushVoIP (M);
  }
  if (constructor == "DeviceTokenWindowsPush") {
    return (struct TdObject *)TdStackFetcherDeviceTokenWindowsPush (M);
  }
  if (constructor == "DeviceTokenMicrosoftPush") {
    return (struct TdObject *)TdStackFetcherDeviceTokenMicrosoftPush (M);
  }
  if (constructor == "DeviceTokenMicrosoftPushVoIP") {
    return (struct TdObject *)TdStackFetcherDeviceTokenMicrosoftPushVoIP (M);
  }
  if (constructor == "DeviceTokenWebPush") {
    return (struct TdObject *)TdStackFetcherDeviceTokenWebPush (M);
  }
  if (constructor == "DeviceTokenSimplePush") {
    return (struct TdObject *)TdStackFetcherDeviceTokenSimplePush (M);
  }
  if (constructor == "DeviceTokenUbuntuPush") {
    return (struct TdObject *)TdStackFetcherDeviceTokenUbuntuPush (M);
  }
  if (constructor == "DeviceTokenBlackBerryPush") {
    return (struct TdObject *)TdStackFetcherDeviceTokenBlackBerryPush (M);
  }
  if (constructor == "DeviceTokenTizenPush") {
    return (struct TdObject *)TdStackFetcherDeviceTokenTizenPush (M);
  }
  if (constructor == "Document") {
    return (struct TdObject *)TdStackFetcherDocument (M);
  }
  if (constructor == "DraftMessage") {
    return (struct TdObject *)TdStackFetcherDraftMessage (M);
  }
  if (constructor == "EmailAddressAuthenticationCodeInfo") {
    return (struct TdObject *)TdStackFetcherEmailAddressAuthenticationCodeInfo (M);
  }
  if (constructor == "EncryptedCredentials") {
    return (struct TdObject *)TdStackFetcherEncryptedCredentials (M);
  }
  if (constructor == "EncryptedPassportElement") {
    return (struct TdObject *)TdStackFetcherEncryptedPassportElement (M);
  }
  if (constructor == "Error") {
    return (struct TdObject *)TdStackFetcherError (M);
  }
  if (constructor == "File") {
    return (struct TdObject *)TdStackFetcherFile (M);
  }
  if (constructor == "FileTypeNone") {
    return (struct TdObject *)TdStackFetcherFileTypeNone (M);
  }
  if (constructor == "FileTypeAnimation") {
    return (struct TdObject *)TdStackFetcherFileTypeAnimation (M);
  }
  if (constructor == "FileTypeAudio") {
    return (struct TdObject *)TdStackFetcherFileTypeAudio (M);
  }
  if (constructor == "FileTypeDocument") {
    return (struct TdObject *)TdStackFetcherFileTypeDocument (M);
  }
  if (constructor == "FileTypePhoto") {
    return (struct TdObject *)TdStackFetcherFileTypePhoto (M);
  }
  if (constructor == "FileTypeProfilePhoto") {
    return (struct TdObject *)TdStackFetcherFileTypeProfilePhoto (M);
  }
  if (constructor == "FileTypeSecret") {
    return (struct TdObject *)TdStackFetcherFileTypeSecret (M);
  }
  if (constructor == "FileTypeSecretThumbnail") {
    return (struct TdObject *)TdStackFetcherFileTypeSecretThumbnail (M);
  }
  if (constructor == "FileTypeSecure") {
    return (struct TdObject *)TdStackFetcherFileTypeSecure (M);
  }
  if (constructor == "FileTypeSticker") {
    return (struct TdObject *)TdStackFetcherFileTypeSticker (M);
  }
  if (constructor == "FileTypeThumbnail") {
    return (struct TdObject *)TdStackFetcherFileTypeThumbnail (M);
  }
  if (constructor == "FileTypeUnknown") {
    return (struct TdObject *)TdStackFetcherFileTypeUnknown (M);
  }
  if (constructor == "FileTypeVideo") {
    return (struct TdObject *)TdStackFetcherFileTypeVideo (M);
  }
  if (constructor == "FileTypeVideoNote") {
    return (struct TdObject *)TdStackFetcherFileTypeVideoNote (M);
  }
  if (constructor == "FileTypeVoiceNote") {
    return (struct TdObject *)TdStackFetcherFileTypeVoiceNote (M);
  }
  if (constructor == "FileTypeWallpaper") {
    return (struct TdObject *)TdStackFetcherFileTypeWallpaper (M);
  }
  if (constructor == "FormattedText") {
    return (struct TdObject *)TdStackFetcherFormattedText (M);
  }
  if (constructor == "FoundMessages") {
    return (struct TdObject *)TdStackFetcherFoundMessages (M);
  }
  if (constructor == "Game") {
    return (struct TdObject *)TdStackFetcherGame (M);
  }
  if (constructor == "GameHighScore") {
    return (struct TdObject *)TdStackFetcherGameHighScore (M);
  }
  if (constructor == "GameHighScores") {
    return (struct TdObject *)TdStackFetcherGameHighScores (M);
  }
  if (constructor == "Hashtags") {
    return (struct TdObject *)TdStackFetcherHashtags (M);
  }
  if (constructor == "IdentityDocument") {
    return (struct TdObject *)TdStackFetcherIdentityDocument (M);
  }
  if (constructor == "ImportedContacts") {
    return (struct TdObject *)TdStackFetcherImportedContacts (M);
  }
  if (constructor == "InlineKeyboardButton") {
    return (struct TdObject *)TdStackFetcherInlineKeyboardButton (M);
  }
  if (constructor == "InlineKeyboardButtonTypeUrl") {
    return (struct TdObject *)TdStackFetcherInlineKeyboardButtonTypeUrl (M);
  }
  if (constructor == "InlineKeyboardButtonTypeCallback") {
    return (struct TdObject *)TdStackFetcherInlineKeyboardButtonTypeCallback (M);
  }
  if (constructor == "InlineKeyboardButtonTypeCallbackGame") {
    return (struct TdObject *)TdStackFetcherInlineKeyboardButtonTypeCallbackGame (M);
  }
  if (constructor == "InlineKeyboardButtonTypeSwitchInline") {
    return (struct TdObject *)TdStackFetcherInlineKeyboardButtonTypeSwitchInline (M);
  }
  if (constructor == "InlineKeyboardButtonTypeBuy") {
    return (struct TdObject *)TdStackFetcherInlineKeyboardButtonTypeBuy (M);
  }
  if (constructor == "InlineQueryResultArticle") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultArticle (M);
  }
  if (constructor == "InlineQueryResultContact") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultContact (M);
  }
  if (constructor == "InlineQueryResultLocation") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultLocation (M);
  }
  if (constructor == "InlineQueryResultVenue") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultVenue (M);
  }
  if (constructor == "InlineQueryResultGame") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultGame (M);
  }
  if (constructor == "InlineQueryResultAnimation") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultAnimation (M);
  }
  if (constructor == "InlineQueryResultAudio") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultAudio (M);
  }
  if (constructor == "InlineQueryResultDocument") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultDocument (M);
  }
  if (constructor == "InlineQueryResultPhoto") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultPhoto (M);
  }
  if (constructor == "InlineQueryResultSticker") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultSticker (M);
  }
  if (constructor == "InlineQueryResultVideo") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultVideo (M);
  }
  if (constructor == "InlineQueryResultVoiceNote") {
    return (struct TdObject *)TdStackFetcherInlineQueryResultVoiceNote (M);
  }
  if (constructor == "InlineQueryResults") {
    return (struct TdObject *)TdStackFetcherInlineQueryResults (M);
  }
  if (constructor == "InputCredentialsSaved") {
    return (struct TdObject *)TdStackFetcherInputCredentialsSaved (M);
  }
  if (constructor == "InputCredentialsNew") {
    return (struct TdObject *)TdStackFetcherInputCredentialsNew (M);
  }
  if (constructor == "InputCredentialsAndroidPay") {
    return (struct TdObject *)TdStackFetcherInputCredentialsAndroidPay (M);
  }
  if (constructor == "InputCredentialsApplePay") {
    return (struct TdObject *)TdStackFetcherInputCredentialsApplePay (M);
  }
  if (constructor == "InputFileId") {
    return (struct TdObject *)TdStackFetcherInputFileId (M);
  }
  if (constructor == "InputFileRemote") {
    return (struct TdObject *)TdStackFetcherInputFileRemote (M);
  }
  if (constructor == "InputFileLocal") {
    return (struct TdObject *)TdStackFetcherInputFileLocal (M);
  }
  if (constructor == "InputFileGenerated") {
    return (struct TdObject *)TdStackFetcherInputFileGenerated (M);
  }
  if (constructor == "InputIdentityDocument") {
    return (struct TdObject *)TdStackFetcherInputIdentityDocument (M);
  }
  if (constructor == "InputInlineQueryResultAnimatedGif") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultAnimatedGif (M);
  }
  if (constructor == "InputInlineQueryResultAnimatedMpeg4") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultAnimatedMpeg4 (M);
  }
  if (constructor == "InputInlineQueryResultArticle") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultArticle (M);
  }
  if (constructor == "InputInlineQueryResultAudio") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultAudio (M);
  }
  if (constructor == "InputInlineQueryResultContact") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultContact (M);
  }
  if (constructor == "InputInlineQueryResultDocument") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultDocument (M);
  }
  if (constructor == "InputInlineQueryResultGame") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultGame (M);
  }
  if (constructor == "InputInlineQueryResultLocation") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultLocation (M);
  }
  if (constructor == "InputInlineQueryResultPhoto") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultPhoto (M);
  }
  if (constructor == "InputInlineQueryResultSticker") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultSticker (M);
  }
  if (constructor == "InputInlineQueryResultVenue") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultVenue (M);
  }
  if (constructor == "InputInlineQueryResultVideo") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultVideo (M);
  }
  if (constructor == "InputInlineQueryResultVoiceNote") {
    return (struct TdObject *)TdStackFetcherInputInlineQueryResultVoiceNote (M);
  }
  if (constructor == "InputMessageText") {
    return (struct TdObject *)TdStackFetcherInputMessageText (M);
  }
  if (constructor == "InputMessageAnimation") {
    return (struct TdObject *)TdStackFetcherInputMessageAnimation (M);
  }
  if (constructor == "InputMessageAudio") {
    return (struct TdObject *)TdStackFetcherInputMessageAudio (M);
  }
  if (constructor == "InputMessageDocument") {
    return (struct TdObject *)TdStackFetcherInputMessageDocument (M);
  }
  if (constructor == "InputMessagePhoto") {
    return (struct TdObject *)TdStackFetcherInputMessagePhoto (M);
  }
  if (constructor == "InputMessageSticker") {
    return (struct TdObject *)TdStackFetcherInputMessageSticker (M);
  }
  if (constructor == "InputMessageVideo") {
    return (struct TdObject *)TdStackFetcherInputMessageVideo (M);
  }
  if (constructor == "InputMessageVideoNote") {
    return (struct TdObject *)TdStackFetcherInputMessageVideoNote (M);
  }
  if (constructor == "InputMessageVoiceNote") {
    return (struct TdObject *)TdStackFetcherInputMessageVoiceNote (M);
  }
  if (constructor == "InputMessageLocation") {
    return (struct TdObject *)TdStackFetcherInputMessageLocation (M);
  }
  if (constructor == "InputMessageVenue") {
    return (struct TdObject *)TdStackFetcherInputMessageVenue (M);
  }
  if (constructor == "InputMessageContact") {
    return (struct TdObject *)TdStackFetcherInputMessageContact (M);
  }
  if (constructor == "InputMessageGame") {
    return (struct TdObject *)TdStackFetcherInputMessageGame (M);
  }
  if (constructor == "InputMessageInvoice") {
    return (struct TdObject *)TdStackFetcherInputMessageInvoice (M);
  }
  if (constructor == "InputMessageForwarded") {
    return (struct TdObject *)TdStackFetcherInputMessageForwarded (M);
  }
  if (constructor == "InputPassportElementPersonalDetails") {
    return (struct TdObject *)TdStackFetcherInputPassportElementPersonalDetails (M);
  }
  if (constructor == "InputPassportElementPassport") {
    return (struct TdObject *)TdStackFetcherInputPassportElementPassport (M);
  }
  if (constructor == "InputPassportElementDriverLicense") {
    return (struct TdObject *)TdStackFetcherInputPassportElementDriverLicense (M);
  }
  if (constructor == "InputPassportElementIdentityCard") {
    return (struct TdObject *)TdStackFetcherInputPassportElementIdentityCard (M);
  }
  if (constructor == "InputPassportElementInternalPassport") {
    return (struct TdObject *)TdStackFetcherInputPassportElementInternalPassport (M);
  }
  if (constructor == "InputPassportElementAddress") {
    return (struct TdObject *)TdStackFetcherInputPassportElementAddress (M);
  }
  if (constructor == "InputPassportElementUtilityBill") {
    return (struct TdObject *)TdStackFetcherInputPassportElementUtilityBill (M);
  }
  if (constructor == "InputPassportElementBankStatement") {
    return (struct TdObject *)TdStackFetcherInputPassportElementBankStatement (M);
  }
  if (constructor == "InputPassportElementRentalAgreement") {
    return (struct TdObject *)TdStackFetcherInputPassportElementRentalAgreement (M);
  }
  if (constructor == "InputPassportElementPassportRegistration") {
    return (struct TdObject *)TdStackFetcherInputPassportElementPassportRegistration (M);
  }
  if (constructor == "InputPassportElementTemporaryRegistration") {
    return (struct TdObject *)TdStackFetcherInputPassportElementTemporaryRegistration (M);
  }
  if (constructor == "InputPassportElementPhoneNumber") {
    return (struct TdObject *)TdStackFetcherInputPassportElementPhoneNumber (M);
  }
  if (constructor == "InputPassportElementEmailAddress") {
    return (struct TdObject *)TdStackFetcherInputPassportElementEmailAddress (M);
  }
  if (constructor == "InputPassportElementError") {
    return (struct TdObject *)TdStackFetcherInputPassportElementError (M);
  }
  if (constructor == "InputPassportElementErrorSourceUnspecified") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceUnspecified (M);
  }
  if (constructor == "InputPassportElementErrorSourceDataField") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceDataField (M);
  }
  if (constructor == "InputPassportElementErrorSourceFrontSide") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceFrontSide (M);
  }
  if (constructor == "InputPassportElementErrorSourceReverseSide") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceReverseSide (M);
  }
  if (constructor == "InputPassportElementErrorSourceSelfie") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceSelfie (M);
  }
  if (constructor == "InputPassportElementErrorSourceTranslationFile") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceTranslationFile (M);
  }
  if (constructor == "InputPassportElementErrorSourceTranslationFiles") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceTranslationFiles (M);
  }
  if (constructor == "InputPassportElementErrorSourceFile") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceFile (M);
  }
  if (constructor == "InputPassportElementErrorSourceFiles") {
    return (struct TdObject *)TdStackFetcherInputPassportElementErrorSourceFiles (M);
  }
  if (constructor == "InputPersonalDocument") {
    return (struct TdObject *)TdStackFetcherInputPersonalDocument (M);
  }
  if (constructor == "InputSticker") {
    return (struct TdObject *)TdStackFetcherInputSticker (M);
  }
  if (constructor == "InputThumbnail") {
    return (struct TdObject *)TdStackFetcherInputThumbnail (M);
  }
  if (constructor == "Invoice") {
    return (struct TdObject *)TdStackFetcherInvoice (M);
  }
  if (constructor == "KeyboardButton") {
    return (struct TdObject *)TdStackFetcherKeyboardButton (M);
  }
  if (constructor == "KeyboardButtonTypeText") {
    return (struct TdObject *)TdStackFetcherKeyboardButtonTypeText (M);
  }
  if (constructor == "KeyboardButtonTypeRequestPhoneNumber") {
    return (struct TdObject *)TdStackFetcherKeyboardButtonTypeRequestPhoneNumber (M);
  }
  if (constructor == "KeyboardButtonTypeRequestLocation") {
    return (struct TdObject *)TdStackFetcherKeyboardButtonTypeRequestLocation (M);
  }
  if (constructor == "LabeledPricePart") {
    return (struct TdObject *)TdStackFetcherLabeledPricePart (M);
  }
  if (constructor == "LanguagePackInfo") {
    return (struct TdObject *)TdStackFetcherLanguagePackInfo (M);
  }
  if (constructor == "LanguagePackString") {
    return (struct TdObject *)TdStackFetcherLanguagePackString (M);
  }
  if (constructor == "LanguagePackStringValueOrdinary") {
    return (struct TdObject *)TdStackFetcherLanguagePackStringValueOrdinary (M);
  }
  if (constructor == "LanguagePackStringValuePluralized") {
    return (struct TdObject *)TdStackFetcherLanguagePackStringValuePluralized (M);
  }
  if (constructor == "LanguagePackStringValueDeleted") {
    return (struct TdObject *)TdStackFetcherLanguagePackStringValueDeleted (M);
  }
  if (constructor == "LanguagePackStrings") {
    return (struct TdObject *)TdStackFetcherLanguagePackStrings (M);
  }
  if (constructor == "LinkStateNone") {
    return (struct TdObject *)TdStackFetcherLinkStateNone (M);
  }
  if (constructor == "LinkStateKnowsPhoneNumber") {
    return (struct TdObject *)TdStackFetcherLinkStateKnowsPhoneNumber (M);
  }
  if (constructor == "LinkStateIsContact") {
    return (struct TdObject *)TdStackFetcherLinkStateIsContact (M);
  }
  if (constructor == "LocalFile") {
    return (struct TdObject *)TdStackFetcherLocalFile (M);
  }
  if (constructor == "LocalizationTargetInfo") {
    return (struct TdObject *)TdStackFetcherLocalizationTargetInfo (M);
  }
  if (constructor == "Location") {
    return (struct TdObject *)TdStackFetcherLocation (M);
  }
  if (constructor == "MaskPointForehead") {
    return (struct TdObject *)TdStackFetcherMaskPointForehead (M);
  }
  if (constructor == "MaskPointEyes") {
    return (struct TdObject *)TdStackFetcherMaskPointEyes (M);
  }
  if (constructor == "MaskPointMouth") {
    return (struct TdObject *)TdStackFetcherMaskPointMouth (M);
  }
  if (constructor == "MaskPointChin") {
    return (struct TdObject *)TdStackFetcherMaskPointChin (M);
  }
  if (constructor == "MaskPosition") {
    return (struct TdObject *)TdStackFetcherMaskPosition (M);
  }
  if (constructor == "Message") {
    return (struct TdObject *)TdStackFetcherMessage (M);
  }
  if (constructor == "MessageText") {
    return (struct TdObject *)TdStackFetcherMessageText (M);
  }
  if (constructor == "MessageAnimation") {
    return (struct TdObject *)TdStackFetcherMessageAnimation (M);
  }
  if (constructor == "MessageAudio") {
    return (struct TdObject *)TdStackFetcherMessageAudio (M);
  }
  if (constructor == "MessageDocument") {
    return (struct TdObject *)TdStackFetcherMessageDocument (M);
  }
  if (constructor == "MessagePhoto") {
    return (struct TdObject *)TdStackFetcherMessagePhoto (M);
  }
  if (constructor == "MessageExpiredPhoto") {
    return (struct TdObject *)TdStackFetcherMessageExpiredPhoto (M);
  }
  if (constructor == "MessageSticker") {
    return (struct TdObject *)TdStackFetcherMessageSticker (M);
  }
  if (constructor == "MessageVideo") {
    return (struct TdObject *)TdStackFetcherMessageVideo (M);
  }
  if (constructor == "MessageExpiredVideo") {
    return (struct TdObject *)TdStackFetcherMessageExpiredVideo (M);
  }
  if (constructor == "MessageVideoNote") {
    return (struct TdObject *)TdStackFetcherMessageVideoNote (M);
  }
  if (constructor == "MessageVoiceNote") {
    return (struct TdObject *)TdStackFetcherMessageVoiceNote (M);
  }
  if (constructor == "MessageLocation") {
    return (struct TdObject *)TdStackFetcherMessageLocation (M);
  }
  if (constructor == "MessageVenue") {
    return (struct TdObject *)TdStackFetcherMessageVenue (M);
  }
  if (constructor == "MessageContact") {
    return (struct TdObject *)TdStackFetcherMessageContact (M);
  }
  if (constructor == "MessageGame") {
    return (struct TdObject *)TdStackFetcherMessageGame (M);
  }
  if (constructor == "MessageInvoice") {
    return (struct TdObject *)TdStackFetcherMessageInvoice (M);
  }
  if (constructor == "MessageCall") {
    return (struct TdObject *)TdStackFetcherMessageCall (M);
  }
  if (constructor == "MessageBasicGroupChatCreate") {
    return (struct TdObject *)TdStackFetcherMessageBasicGroupChatCreate (M);
  }
  if (constructor == "MessageSupergroupChatCreate") {
    return (struct TdObject *)TdStackFetcherMessageSupergroupChatCreate (M);
  }
  if (constructor == "MessageChatChangeTitle") {
    return (struct TdObject *)TdStackFetcherMessageChatChangeTitle (M);
  }
  if (constructor == "MessageChatChangePhoto") {
    return (struct TdObject *)TdStackFetcherMessageChatChangePhoto (M);
  }
  if (constructor == "MessageChatDeletePhoto") {
    return (struct TdObject *)TdStackFetcherMessageChatDeletePhoto (M);
  }
  if (constructor == "MessageChatAddMembers") {
    return (struct TdObject *)TdStackFetcherMessageChatAddMembers (M);
  }
  if (constructor == "MessageChatJoinByLink") {
    return (struct TdObject *)TdStackFetcherMessageChatJoinByLink (M);
  }
  if (constructor == "MessageChatDeleteMember") {
    return (struct TdObject *)TdStackFetcherMessageChatDeleteMember (M);
  }
  if (constructor == "MessageChatUpgradeTo") {
    return (struct TdObject *)TdStackFetcherMessageChatUpgradeTo (M);
  }
  if (constructor == "MessageChatUpgradeFrom") {
    return (struct TdObject *)TdStackFetcherMessageChatUpgradeFrom (M);
  }
  if (constructor == "MessagePinMessage") {
    return (struct TdObject *)TdStackFetcherMessagePinMessage (M);
  }
  if (constructor == "MessageScreenshotTaken") {
    return (struct TdObject *)TdStackFetcherMessageScreenshotTaken (M);
  }
  if (constructor == "MessageChatSetTtl") {
    return (struct TdObject *)TdStackFetcherMessageChatSetTtl (M);
  }
  if (constructor == "MessageCustomServiceAction") {
    return (struct TdObject *)TdStackFetcherMessageCustomServiceAction (M);
  }
  if (constructor == "MessageGameScore") {
    return (struct TdObject *)TdStackFetcherMessageGameScore (M);
  }
  if (constructor == "MessagePaymentSuccessful") {
    return (struct TdObject *)TdStackFetcherMessagePaymentSuccessful (M);
  }
  if (constructor == "MessagePaymentSuccessfulBot") {
    return (struct TdObject *)TdStackFetcherMessagePaymentSuccessfulBot (M);
  }
  if (constructor == "MessageContactRegistered") {
    return (struct TdObject *)TdStackFetcherMessageContactRegistered (M);
  }
  if (constructor == "MessageWebsiteConnected") {
    return (struct TdObject *)TdStackFetcherMessageWebsiteConnected (M);
  }
  if (constructor == "MessagePassportDataSent") {
    return (struct TdObject *)TdStackFetcherMessagePassportDataSent (M);
  }
  if (constructor == "MessagePassportDataReceived") {
    return (struct TdObject *)TdStackFetcherMessagePassportDataReceived (M);
  }
  if (constructor == "MessageUnsupported") {
    return (struct TdObject *)TdStackFetcherMessageUnsupported (M);
  }
  if (constructor == "MessageForwardedFromUser") {
    return (struct TdObject *)TdStackFetcherMessageForwardedFromUser (M);
  }
  if (constructor == "MessageForwardedPost") {
    return (struct TdObject *)TdStackFetcherMessageForwardedPost (M);
  }
  if (constructor == "MessageSendingStatePending") {
    return (struct TdObject *)TdStackFetcherMessageSendingStatePending (M);
  }
  if (constructor == "MessageSendingStateFailed") {
    return (struct TdObject *)TdStackFetcherMessageSendingStateFailed (M);
  }
  if (constructor == "Messages") {
    return (struct TdObject *)TdStackFetcherMessages (M);
  }
  if (constructor == "NetworkStatistics") {
    return (struct TdObject *)TdStackFetcherNetworkStatistics (M);
  }
  if (constructor == "NetworkStatisticsEntryFile") {
    return (struct TdObject *)TdStackFetcherNetworkStatisticsEntryFile (M);
  }
  if (constructor == "NetworkStatisticsEntryCall") {
    return (struct TdObject *)TdStackFetcherNetworkStatisticsEntryCall (M);
  }
  if (constructor == "NetworkTypeNone") {
    return (struct TdObject *)TdStackFetcherNetworkTypeNone (M);
  }
  if (constructor == "NetworkTypeMobile") {
    return (struct TdObject *)TdStackFetcherNetworkTypeMobile (M);
  }
  if (constructor == "NetworkTypeMobileRoaming") {
    return (struct TdObject *)TdStackFetcherNetworkTypeMobileRoaming (M);
  }
  if (constructor == "NetworkTypeWiFi") {
    return (struct TdObject *)TdStackFetcherNetworkTypeWiFi (M);
  }
  if (constructor == "NetworkTypeOther") {
    return (struct TdObject *)TdStackFetcherNetworkTypeOther (M);
  }
  if (constructor == "NotificationSettingsScopePrivateChats") {
    return (struct TdObject *)TdStackFetcherNotificationSettingsScopePrivateChats (M);
  }
  if (constructor == "NotificationSettingsScopeGroupChats") {
    return (struct TdObject *)TdStackFetcherNotificationSettingsScopeGroupChats (M);
  }
  if (constructor == "Ok") {
    return (struct TdObject *)TdStackFetcherOk (M);
  }
  if (constructor == "OptionValueBoolean") {
    return (struct TdObject *)TdStackFetcherOptionValueBoolean (M);
  }
  if (constructor == "OptionValueEmpty") {
    return (struct TdObject *)TdStackFetcherOptionValueEmpty (M);
  }
  if (constructor == "OptionValueInteger") {
    return (struct TdObject *)TdStackFetcherOptionValueInteger (M);
  }
  if (constructor == "OptionValueString") {
    return (struct TdObject *)TdStackFetcherOptionValueString (M);
  }
  if (constructor == "OrderInfo") {
    return (struct TdObject *)TdStackFetcherOrderInfo (M);
  }
  if (constructor == "PageBlockTitle") {
    return (struct TdObject *)TdStackFetcherPageBlockTitle (M);
  }
  if (constructor == "PageBlockSubtitle") {
    return (struct TdObject *)TdStackFetcherPageBlockSubtitle (M);
  }
  if (constructor == "PageBlockAuthorDate") {
    return (struct TdObject *)TdStackFetcherPageBlockAuthorDate (M);
  }
  if (constructor == "PageBlockHeader") {
    return (struct TdObject *)TdStackFetcherPageBlockHeader (M);
  }
  if (constructor == "PageBlockSubheader") {
    return (struct TdObject *)TdStackFetcherPageBlockSubheader (M);
  }
  if (constructor == "PageBlockParagraph") {
    return (struct TdObject *)TdStackFetcherPageBlockParagraph (M);
  }
  if (constructor == "PageBlockPreformatted") {
    return (struct TdObject *)TdStackFetcherPageBlockPreformatted (M);
  }
  if (constructor == "PageBlockFooter") {
    return (struct TdObject *)TdStackFetcherPageBlockFooter (M);
  }
  if (constructor == "PageBlockDivider") {
    return (struct TdObject *)TdStackFetcherPageBlockDivider (M);
  }
  if (constructor == "PageBlockAnchor") {
    return (struct TdObject *)TdStackFetcherPageBlockAnchor (M);
  }
  if (constructor == "PageBlockList") {
    return (struct TdObject *)TdStackFetcherPageBlockList (M);
  }
  if (constructor == "PageBlockBlockQuote") {
    return (struct TdObject *)TdStackFetcherPageBlockBlockQuote (M);
  }
  if (constructor == "PageBlockPullQuote") {
    return (struct TdObject *)TdStackFetcherPageBlockPullQuote (M);
  }
  if (constructor == "PageBlockAnimation") {
    return (struct TdObject *)TdStackFetcherPageBlockAnimation (M);
  }
  if (constructor == "PageBlockAudio") {
    return (struct TdObject *)TdStackFetcherPageBlockAudio (M);
  }
  if (constructor == "PageBlockPhoto") {
    return (struct TdObject *)TdStackFetcherPageBlockPhoto (M);
  }
  if (constructor == "PageBlockVideo") {
    return (struct TdObject *)TdStackFetcherPageBlockVideo (M);
  }
  if (constructor == "PageBlockCover") {
    return (struct TdObject *)TdStackFetcherPageBlockCover (M);
  }
  if (constructor == "PageBlockEmbedded") {
    return (struct TdObject *)TdStackFetcherPageBlockEmbedded (M);
  }
  if (constructor == "PageBlockEmbeddedPost") {
    return (struct TdObject *)TdStackFetcherPageBlockEmbeddedPost (M);
  }
  if (constructor == "PageBlockCollage") {
    return (struct TdObject *)TdStackFetcherPageBlockCollage (M);
  }
  if (constructor == "PageBlockSlideshow") {
    return (struct TdObject *)TdStackFetcherPageBlockSlideshow (M);
  }
  if (constructor == "PageBlockChatLink") {
    return (struct TdObject *)TdStackFetcherPageBlockChatLink (M);
  }
  if (constructor == "PassportAuthorizationForm") {
    return (struct TdObject *)TdStackFetcherPassportAuthorizationForm (M);
  }
  if (constructor == "PassportElementPersonalDetails") {
    return (struct TdObject *)TdStackFetcherPassportElementPersonalDetails (M);
  }
  if (constructor == "PassportElementPassport") {
    return (struct TdObject *)TdStackFetcherPassportElementPassport (M);
  }
  if (constructor == "PassportElementDriverLicense") {
    return (struct TdObject *)TdStackFetcherPassportElementDriverLicense (M);
  }
  if (constructor == "PassportElementIdentityCard") {
    return (struct TdObject *)TdStackFetcherPassportElementIdentityCard (M);
  }
  if (constructor == "PassportElementInternalPassport") {
    return (struct TdObject *)TdStackFetcherPassportElementInternalPassport (M);
  }
  if (constructor == "PassportElementAddress") {
    return (struct TdObject *)TdStackFetcherPassportElementAddress (M);
  }
  if (constructor == "PassportElementUtilityBill") {
    return (struct TdObject *)TdStackFetcherPassportElementUtilityBill (M);
  }
  if (constructor == "PassportElementBankStatement") {
    return (struct TdObject *)TdStackFetcherPassportElementBankStatement (M);
  }
  if (constructor == "PassportElementRentalAgreement") {
    return (struct TdObject *)TdStackFetcherPassportElementRentalAgreement (M);
  }
  if (constructor == "PassportElementPassportRegistration") {
    return (struct TdObject *)TdStackFetcherPassportElementPassportRegistration (M);
  }
  if (constructor == "PassportElementTemporaryRegistration") {
    return (struct TdObject *)TdStackFetcherPassportElementTemporaryRegistration (M);
  }
  if (constructor == "PassportElementPhoneNumber") {
    return (struct TdObject *)TdStackFetcherPassportElementPhoneNumber (M);
  }
  if (constructor == "PassportElementEmailAddress") {
    return (struct TdObject *)TdStackFetcherPassportElementEmailAddress (M);
  }
  if (constructor == "PassportElementError") {
    return (struct TdObject *)TdStackFetcherPassportElementError (M);
  }
  if (constructor == "PassportElementErrorSourceUnspecified") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceUnspecified (M);
  }
  if (constructor == "PassportElementErrorSourceDataField") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceDataField (M);
  }
  if (constructor == "PassportElementErrorSourceFrontSide") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceFrontSide (M);
  }
  if (constructor == "PassportElementErrorSourceReverseSide") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceReverseSide (M);
  }
  if (constructor == "PassportElementErrorSourceSelfie") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceSelfie (M);
  }
  if (constructor == "PassportElementErrorSourceTranslationFile") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceTranslationFile (M);
  }
  if (constructor == "PassportElementErrorSourceTranslationFiles") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceTranslationFiles (M);
  }
  if (constructor == "PassportElementErrorSourceFile") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceFile (M);
  }
  if (constructor == "PassportElementErrorSourceFiles") {
    return (struct TdObject *)TdStackFetcherPassportElementErrorSourceFiles (M);
  }
  if (constructor == "PassportElementTypePersonalDetails") {
    return (struct TdObject *)TdStackFetcherPassportElementTypePersonalDetails (M);
  }
  if (constructor == "PassportElementTypePassport") {
    return (struct TdObject *)TdStackFetcherPassportElementTypePassport (M);
  }
  if (constructor == "PassportElementTypeDriverLicense") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeDriverLicense (M);
  }
  if (constructor == "PassportElementTypeIdentityCard") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeIdentityCard (M);
  }
  if (constructor == "PassportElementTypeInternalPassport") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeInternalPassport (M);
  }
  if (constructor == "PassportElementTypeAddress") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeAddress (M);
  }
  if (constructor == "PassportElementTypeUtilityBill") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeUtilityBill (M);
  }
  if (constructor == "PassportElementTypeBankStatement") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeBankStatement (M);
  }
  if (constructor == "PassportElementTypeRentalAgreement") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeRentalAgreement (M);
  }
  if (constructor == "PassportElementTypePassportRegistration") {
    return (struct TdObject *)TdStackFetcherPassportElementTypePassportRegistration (M);
  }
  if (constructor == "PassportElementTypeTemporaryRegistration") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeTemporaryRegistration (M);
  }
  if (constructor == "PassportElementTypePhoneNumber") {
    return (struct TdObject *)TdStackFetcherPassportElementTypePhoneNumber (M);
  }
  if (constructor == "PassportElementTypeEmailAddress") {
    return (struct TdObject *)TdStackFetcherPassportElementTypeEmailAddress (M);
  }
  if (constructor == "PassportElements") {
    return (struct TdObject *)TdStackFetcherPassportElements (M);
  }
  if (constructor == "PassportRequiredElement") {
    return (struct TdObject *)TdStackFetcherPassportRequiredElement (M);
  }
  if (constructor == "PassportSuitableElement") {
    return (struct TdObject *)TdStackFetcherPassportSuitableElement (M);
  }
  if (constructor == "PasswordState") {
    return (struct TdObject *)TdStackFetcherPasswordState (M);
  }
  if (constructor == "PaymentForm") {
    return (struct TdObject *)TdStackFetcherPaymentForm (M);
  }
  if (constructor == "PaymentReceipt") {
    return (struct TdObject *)TdStackFetcherPaymentReceipt (M);
  }
  if (constructor == "PaymentResult") {
    return (struct TdObject *)TdStackFetcherPaymentResult (M);
  }
  if (constructor == "PaymentsProviderStripe") {
    return (struct TdObject *)TdStackFetcherPaymentsProviderStripe (M);
  }
  if (constructor == "PersonalDetails") {
    return (struct TdObject *)TdStackFetcherPersonalDetails (M);
  }
  if (constructor == "PersonalDocument") {
    return (struct TdObject *)TdStackFetcherPersonalDocument (M);
  }
  if (constructor == "Photo") {
    return (struct TdObject *)TdStackFetcherPhoto (M);
  }
  if (constructor == "PhotoSize") {
    return (struct TdObject *)TdStackFetcherPhotoSize (M);
  }
  if (constructor == "ProfilePhoto") {
    return (struct TdObject *)TdStackFetcherProfilePhoto (M);
  }
  if (constructor == "Proxies") {
    return (struct TdObject *)TdStackFetcherProxies (M);
  }
  if (constructor == "Proxy") {
    return (struct TdObject *)TdStackFetcherProxy (M);
  }
  if (constructor == "ProxyTypeSocks5") {
    return (struct TdObject *)TdStackFetcherProxyTypeSocks5 (M);
  }
  if (constructor == "ProxyTypeHttp") {
    return (struct TdObject *)TdStackFetcherProxyTypeHttp (M);
  }
  if (constructor == "ProxyTypeMtproto") {
    return (struct TdObject *)TdStackFetcherProxyTypeMtproto (M);
  }
  if (constructor == "PublicMessageLink") {
    return (struct TdObject *)TdStackFetcherPublicMessageLink (M);
  }
  if (constructor == "RecoveryEmailAddress") {
    return (struct TdObject *)TdStackFetcherRecoveryEmailAddress (M);
  }
  if (constructor == "RemoteFile") {
    return (struct TdObject *)TdStackFetcherRemoteFile (M);
  }
  if (constructor == "ReplyMarkupRemoveKeyboard") {
    return (struct TdObject *)TdStackFetcherReplyMarkupRemoveKeyboard (M);
  }
  if (constructor == "ReplyMarkupForceReply") {
    return (struct TdObject *)TdStackFetcherReplyMarkupForceReply (M);
  }
  if (constructor == "ReplyMarkupShowKeyboard") {
    return (struct TdObject *)TdStackFetcherReplyMarkupShowKeyboard (M);
  }
  if (constructor == "ReplyMarkupInlineKeyboard") {
    return (struct TdObject *)TdStackFetcherReplyMarkupInlineKeyboard (M);
  }
  if (constructor == "RichTextPlain") {
    return (struct TdObject *)TdStackFetcherRichTextPlain (M);
  }
  if (constructor == "RichTextBold") {
    return (struct TdObject *)TdStackFetcherRichTextBold (M);
  }
  if (constructor == "RichTextItalic") {
    return (struct TdObject *)TdStackFetcherRichTextItalic (M);
  }
  if (constructor == "RichTextUnderline") {
    return (struct TdObject *)TdStackFetcherRichTextUnderline (M);
  }
  if (constructor == "RichTextStrikethrough") {
    return (struct TdObject *)TdStackFetcherRichTextStrikethrough (M);
  }
  if (constructor == "RichTextFixed") {
    return (struct TdObject *)TdStackFetcherRichTextFixed (M);
  }
  if (constructor == "RichTextUrl") {
    return (struct TdObject *)TdStackFetcherRichTextUrl (M);
  }
  if (constructor == "RichTextEmailAddress") {
    return (struct TdObject *)TdStackFetcherRichTextEmailAddress (M);
  }
  if (constructor == "RichTexts") {
    return (struct TdObject *)TdStackFetcherRichTexts (M);
  }
  if (constructor == "SavedCredentials") {
    return (struct TdObject *)TdStackFetcherSavedCredentials (M);
  }
  if (constructor == "ScopeNotificationSettings") {
    return (struct TdObject *)TdStackFetcherScopeNotificationSettings (M);
  }
  if (constructor == "SearchMessagesFilterEmpty") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterEmpty (M);
  }
  if (constructor == "SearchMessagesFilterAnimation") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterAnimation (M);
  }
  if (constructor == "SearchMessagesFilterAudio") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterAudio (M);
  }
  if (constructor == "SearchMessagesFilterDocument") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterDocument (M);
  }
  if (constructor == "SearchMessagesFilterPhoto") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterPhoto (M);
  }
  if (constructor == "SearchMessagesFilterVideo") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterVideo (M);
  }
  if (constructor == "SearchMessagesFilterVoiceNote") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterVoiceNote (M);
  }
  if (constructor == "SearchMessagesFilterPhotoAndVideo") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterPhotoAndVideo (M);
  }
  if (constructor == "SearchMessagesFilterUrl") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterUrl (M);
  }
  if (constructor == "SearchMessagesFilterChatPhoto") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterChatPhoto (M);
  }
  if (constructor == "SearchMessagesFilterCall") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterCall (M);
  }
  if (constructor == "SearchMessagesFilterMissedCall") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterMissedCall (M);
  }
  if (constructor == "SearchMessagesFilterVideoNote") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterVideoNote (M);
  }
  if (constructor == "SearchMessagesFilterVoiceAndVideoNote") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterVoiceAndVideoNote (M);
  }
  if (constructor == "SearchMessagesFilterMention") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterMention (M);
  }
  if (constructor == "SearchMessagesFilterUnreadMention") {
    return (struct TdObject *)TdStackFetcherSearchMessagesFilterUnreadMention (M);
  }
  if (constructor == "Seconds") {
    return (struct TdObject *)TdStackFetcherSeconds (M);
  }
  if (constructor == "SecretChat") {
    return (struct TdObject *)TdStackFetcherSecretChat (M);
  }
  if (constructor == "SecretChatStatePending") {
    return (struct TdObject *)TdStackFetcherSecretChatStatePending (M);
  }
  if (constructor == "SecretChatStateReady") {
    return (struct TdObject *)TdStackFetcherSecretChatStateReady (M);
  }
  if (constructor == "SecretChatStateClosed") {
    return (struct TdObject *)TdStackFetcherSecretChatStateClosed (M);
  }
  if (constructor == "Session") {
    return (struct TdObject *)TdStackFetcherSession (M);
  }
  if (constructor == "Sessions") {
    return (struct TdObject *)TdStackFetcherSessions (M);
  }
  if (constructor == "ShippingOption") {
    return (struct TdObject *)TdStackFetcherShippingOption (M);
  }
  if (constructor == "Sticker") {
    return (struct TdObject *)TdStackFetcherSticker (M);
  }
  if (constructor == "StickerEmojis") {
    return (struct TdObject *)TdStackFetcherStickerEmojis (M);
  }
  if (constructor == "StickerSet") {
    return (struct TdObject *)TdStackFetcherStickerSet (M);
  }
  if (constructor == "StickerSetInfo") {
    return (struct TdObject *)TdStackFetcherStickerSetInfo (M);
  }
  if (constructor == "StickerSets") {
    return (struct TdObject *)TdStackFetcherStickerSets (M);
  }
  if (constructor == "Stickers") {
    return (struct TdObject *)TdStackFetcherStickers (M);
  }
  if (constructor == "StorageStatistics") {
    return (struct TdObject *)TdStackFetcherStorageStatistics (M);
  }
  if (constructor == "StorageStatisticsByChat") {
    return (struct TdObject *)TdStackFetcherStorageStatisticsByChat (M);
  }
  if (constructor == "StorageStatisticsByFileType") {
    return (struct TdObject *)TdStackFetcherStorageStatisticsByFileType (M);
  }
  if (constructor == "StorageStatisticsFast") {
    return (struct TdObject *)TdStackFetcherStorageStatisticsFast (M);
  }
  if (constructor == "Supergroup") {
    return (struct TdObject *)TdStackFetcherSupergroup (M);
  }
  if (constructor == "SupergroupFullInfo") {
    return (struct TdObject *)TdStackFetcherSupergroupFullInfo (M);
  }
  if (constructor == "SupergroupMembersFilterRecent") {
    return (struct TdObject *)TdStackFetcherSupergroupMembersFilterRecent (M);
  }
  if (constructor == "SupergroupMembersFilterAdministrators") {
    return (struct TdObject *)TdStackFetcherSupergroupMembersFilterAdministrators (M);
  }
  if (constructor == "SupergroupMembersFilterSearch") {
    return (struct TdObject *)TdStackFetcherSupergroupMembersFilterSearch (M);
  }
  if (constructor == "SupergroupMembersFilterRestricted") {
    return (struct TdObject *)TdStackFetcherSupergroupMembersFilterRestricted (M);
  }
  if (constructor == "SupergroupMembersFilterBanned") {
    return (struct TdObject *)TdStackFetcherSupergroupMembersFilterBanned (M);
  }
  if (constructor == "SupergroupMembersFilterBots") {
    return (struct TdObject *)TdStackFetcherSupergroupMembersFilterBots (M);
  }
  if (constructor == "TMeUrl") {
    return (struct TdObject *)TdStackFetcherTMeUrl (M);
  }
  if (constructor == "TMeUrlTypeUser") {
    return (struct TdObject *)TdStackFetcherTMeUrlTypeUser (M);
  }
  if (constructor == "TMeUrlTypeSupergroup") {
    return (struct TdObject *)TdStackFetcherTMeUrlTypeSupergroup (M);
  }
  if (constructor == "TMeUrlTypeChatInvite") {
    return (struct TdObject *)TdStackFetcherTMeUrlTypeChatInvite (M);
  }
  if (constructor == "TMeUrlTypeStickerSet") {
    return (struct TdObject *)TdStackFetcherTMeUrlTypeStickerSet (M);
  }
  if (constructor == "TMeUrls") {
    return (struct TdObject *)TdStackFetcherTMeUrls (M);
  }
  if (constructor == "TdlibParameters") {
    return (struct TdObject *)TdStackFetcherTdlibParameters (M);
  }
  if (constructor == "TemporaryPasswordState") {
    return (struct TdObject *)TdStackFetcherTemporaryPasswordState (M);
  }
  if (constructor == "TermsOfService") {
    return (struct TdObject *)TdStackFetcherTermsOfService (M);
  }
  if (constructor == "TestBytes") {
    return (struct TdObject *)TdStackFetcherTestBytes (M);
  }
  if (constructor == "TestInt") {
    return (struct TdObject *)TdStackFetcherTestInt (M);
  }
  if (constructor == "TestString") {
    return (struct TdObject *)TdStackFetcherTestString (M);
  }
  if (constructor == "TestVectorInt") {
    return (struct TdObject *)TdStackFetcherTestVectorInt (M);
  }
  if (constructor == "TestVectorIntObject") {
    return (struct TdObject *)TdStackFetcherTestVectorIntObject (M);
  }
  if (constructor == "TestVectorString") {
    return (struct TdObject *)TdStackFetcherTestVectorString (M);
  }
  if (constructor == "TestVectorStringObject") {
    return (struct TdObject *)TdStackFetcherTestVectorStringObject (M);
  }
  if (constructor == "Text") {
    return (struct TdObject *)TdStackFetcherText (M);
  }
  if (constructor == "TextEntities") {
    return (struct TdObject *)TdStackFetcherTextEntities (M);
  }
  if (constructor == "TextEntity") {
    return (struct TdObject *)TdStackFetcherTextEntity (M);
  }
  if (constructor == "TextEntityTypeMention") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeMention (M);
  }
  if (constructor == "TextEntityTypeHashtag") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeHashtag (M);
  }
  if (constructor == "TextEntityTypeCashtag") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeCashtag (M);
  }
  if (constructor == "TextEntityTypeBotCommand") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeBotCommand (M);
  }
  if (constructor == "TextEntityTypeUrl") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeUrl (M);
  }
  if (constructor == "TextEntityTypeEmailAddress") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeEmailAddress (M);
  }
  if (constructor == "TextEntityTypeBold") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeBold (M);
  }
  if (constructor == "TextEntityTypeItalic") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeItalic (M);
  }
  if (constructor == "TextEntityTypeCode") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeCode (M);
  }
  if (constructor == "TextEntityTypePre") {
    return (struct TdObject *)TdStackFetcherTextEntityTypePre (M);
  }
  if (constructor == "TextEntityTypePreCode") {
    return (struct TdObject *)TdStackFetcherTextEntityTypePreCode (M);
  }
  if (constructor == "TextEntityTypeTextUrl") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeTextUrl (M);
  }
  if (constructor == "TextEntityTypeMentionName") {
    return (struct TdObject *)TdStackFetcherTextEntityTypeMentionName (M);
  }
  if (constructor == "TextEntityTypePhoneNumber") {
    return (struct TdObject *)TdStackFetcherTextEntityTypePhoneNumber (M);
  }
  if (constructor == "TextParseModeMarkdown") {
    return (struct TdObject *)TdStackFetcherTextParseModeMarkdown (M);
  }
  if (constructor == "TextParseModeHTML") {
    return (struct TdObject *)TdStackFetcherTextParseModeHTML (M);
  }
  if (constructor == "TopChatCategoryUsers") {
    return (struct TdObject *)TdStackFetcherTopChatCategoryUsers (M);
  }
  if (constructor == "TopChatCategoryBots") {
    return (struct TdObject *)TdStackFetcherTopChatCategoryBots (M);
  }
  if (constructor == "TopChatCategoryGroups") {
    return (struct TdObject *)TdStackFetcherTopChatCategoryGroups (M);
  }
  if (constructor == "TopChatCategoryChannels") {
    return (struct TdObject *)TdStackFetcherTopChatCategoryChannels (M);
  }
  if (constructor == "TopChatCategoryInlineBots") {
    return (struct TdObject *)TdStackFetcherTopChatCategoryInlineBots (M);
  }
  if (constructor == "TopChatCategoryCalls") {
    return (struct TdObject *)TdStackFetcherTopChatCategoryCalls (M);
  }
  if (constructor == "UpdateAuthorizationState") {
    return (struct TdObject *)TdStackFetcherUpdateAuthorizationState (M);
  }
  if (constructor == "UpdateNewMessage") {
    return (struct TdObject *)TdStackFetcherUpdateNewMessage (M);
  }
  if (constructor == "UpdateMessageSendAcknowledged") {
    return (struct TdObject *)TdStackFetcherUpdateMessageSendAcknowledged (M);
  }
  if (constructor == "UpdateMessageSendSucceeded") {
    return (struct TdObject *)TdStackFetcherUpdateMessageSendSucceeded (M);
  }
  if (constructor == "UpdateMessageSendFailed") {
    return (struct TdObject *)TdStackFetcherUpdateMessageSendFailed (M);
  }
  if (constructor == "UpdateMessageContent") {
    return (struct TdObject *)TdStackFetcherUpdateMessageContent (M);
  }
  if (constructor == "UpdateMessageEdited") {
    return (struct TdObject *)TdStackFetcherUpdateMessageEdited (M);
  }
  if (constructor == "UpdateMessageViews") {
    return (struct TdObject *)TdStackFetcherUpdateMessageViews (M);
  }
  if (constructor == "UpdateMessageContentOpened") {
    return (struct TdObject *)TdStackFetcherUpdateMessageContentOpened (M);
  }
  if (constructor == "UpdateMessageMentionRead") {
    return (struct TdObject *)TdStackFetcherUpdateMessageMentionRead (M);
  }
  if (constructor == "UpdateNewChat") {
    return (struct TdObject *)TdStackFetcherUpdateNewChat (M);
  }
  if (constructor == "UpdateChatTitle") {
    return (struct TdObject *)TdStackFetcherUpdateChatTitle (M);
  }
  if (constructor == "UpdateChatPhoto") {
    return (struct TdObject *)TdStackFetcherUpdateChatPhoto (M);
  }
  if (constructor == "UpdateChatLastMessage") {
    return (struct TdObject *)TdStackFetcherUpdateChatLastMessage (M);
  }
  if (constructor == "UpdateChatOrder") {
    return (struct TdObject *)TdStackFetcherUpdateChatOrder (M);
  }
  if (constructor == "UpdateChatIsPinned") {
    return (struct TdObject *)TdStackFetcherUpdateChatIsPinned (M);
  }
  if (constructor == "UpdateChatIsMarkedAsUnread") {
    return (struct TdObject *)TdStackFetcherUpdateChatIsMarkedAsUnread (M);
  }
  if (constructor == "UpdateChatIsSponsored") {
    return (struct TdObject *)TdStackFetcherUpdateChatIsSponsored (M);
  }
  if (constructor == "UpdateChatDefaultDisableNotification") {
    return (struct TdObject *)TdStackFetcherUpdateChatDefaultDisableNotification (M);
  }
  if (constructor == "UpdateChatReadInbox") {
    return (struct TdObject *)TdStackFetcherUpdateChatReadInbox (M);
  }
  if (constructor == "UpdateChatReadOutbox") {
    return (struct TdObject *)TdStackFetcherUpdateChatReadOutbox (M);
  }
  if (constructor == "UpdateChatUnreadMentionCount") {
    return (struct TdObject *)TdStackFetcherUpdateChatUnreadMentionCount (M);
  }
  if (constructor == "UpdateChatNotificationSettings") {
    return (struct TdObject *)TdStackFetcherUpdateChatNotificationSettings (M);
  }
  if (constructor == "UpdateScopeNotificationSettings") {
    return (struct TdObject *)TdStackFetcherUpdateScopeNotificationSettings (M);
  }
  if (constructor == "UpdateChatReplyMarkup") {
    return (struct TdObject *)TdStackFetcherUpdateChatReplyMarkup (M);
  }
  if (constructor == "UpdateChatDraftMessage") {
    return (struct TdObject *)TdStackFetcherUpdateChatDraftMessage (M);
  }
  if (constructor == "UpdateDeleteMessages") {
    return (struct TdObject *)TdStackFetcherUpdateDeleteMessages (M);
  }
  if (constructor == "UpdateUserChatAction") {
    return (struct TdObject *)TdStackFetcherUpdateUserChatAction (M);
  }
  if (constructor == "UpdateUserStatus") {
    return (struct TdObject *)TdStackFetcherUpdateUserStatus (M);
  }
  if (constructor == "UpdateUser") {
    return (struct TdObject *)TdStackFetcherUpdateUser (M);
  }
  if (constructor == "UpdateBasicGroup") {
    return (struct TdObject *)TdStackFetcherUpdateBasicGroup (M);
  }
  if (constructor == "UpdateSupergroup") {
    return (struct TdObject *)TdStackFetcherUpdateSupergroup (M);
  }
  if (constructor == "UpdateSecretChat") {
    return (struct TdObject *)TdStackFetcherUpdateSecretChat (M);
  }
  if (constructor == "UpdateUserFullInfo") {
    return (struct TdObject *)TdStackFetcherUpdateUserFullInfo (M);
  }
  if (constructor == "UpdateBasicGroupFullInfo") {
    return (struct TdObject *)TdStackFetcherUpdateBasicGroupFullInfo (M);
  }
  if (constructor == "UpdateSupergroupFullInfo") {
    return (struct TdObject *)TdStackFetcherUpdateSupergroupFullInfo (M);
  }
  if (constructor == "UpdateServiceNotification") {
    return (struct TdObject *)TdStackFetcherUpdateServiceNotification (M);
  }
  if (constructor == "UpdateFile") {
    return (struct TdObject *)TdStackFetcherUpdateFile (M);
  }
  if (constructor == "UpdateFileGenerationStart") {
    return (struct TdObject *)TdStackFetcherUpdateFileGenerationStart (M);
  }
  if (constructor == "UpdateFileGenerationStop") {
    return (struct TdObject *)TdStackFetcherUpdateFileGenerationStop (M);
  }
  if (constructor == "UpdateCall") {
    return (struct TdObject *)TdStackFetcherUpdateCall (M);
  }
  if (constructor == "UpdateUserPrivacySettingRules") {
    return (struct TdObject *)TdStackFetcherUpdateUserPrivacySettingRules (M);
  }
  if (constructor == "UpdateUnreadMessageCount") {
    return (struct TdObject *)TdStackFetcherUpdateUnreadMessageCount (M);
  }
  if (constructor == "UpdateUnreadChatCount") {
    return (struct TdObject *)TdStackFetcherUpdateUnreadChatCount (M);
  }
  if (constructor == "UpdateOption") {
    return (struct TdObject *)TdStackFetcherUpdateOption (M);
  }
  if (constructor == "UpdateInstalledStickerSets") {
    return (struct TdObject *)TdStackFetcherUpdateInstalledStickerSets (M);
  }
  if (constructor == "UpdateTrendingStickerSets") {
    return (struct TdObject *)TdStackFetcherUpdateTrendingStickerSets (M);
  }
  if (constructor == "UpdateRecentStickers") {
    return (struct TdObject *)TdStackFetcherUpdateRecentStickers (M);
  }
  if (constructor == "UpdateFavoriteStickers") {
    return (struct TdObject *)TdStackFetcherUpdateFavoriteStickers (M);
  }
  if (constructor == "UpdateSavedAnimations") {
    return (struct TdObject *)TdStackFetcherUpdateSavedAnimations (M);
  }
  if (constructor == "UpdateLanguagePackStrings") {
    return (struct TdObject *)TdStackFetcherUpdateLanguagePackStrings (M);
  }
  if (constructor == "UpdateConnectionState") {
    return (struct TdObject *)TdStackFetcherUpdateConnectionState (M);
  }
  if (constructor == "UpdateTermsOfService") {
    return (struct TdObject *)TdStackFetcherUpdateTermsOfService (M);
  }
  if (constructor == "UpdateNewInlineQuery") {
    return (struct TdObject *)TdStackFetcherUpdateNewInlineQuery (M);
  }
  if (constructor == "UpdateNewChosenInlineResult") {
    return (struct TdObject *)TdStackFetcherUpdateNewChosenInlineResult (M);
  }
  if (constructor == "UpdateNewCallbackQuery") {
    return (struct TdObject *)TdStackFetcherUpdateNewCallbackQuery (M);
  }
  if (constructor == "UpdateNewInlineCallbackQuery") {
    return (struct TdObject *)TdStackFetcherUpdateNewInlineCallbackQuery (M);
  }
  if (constructor == "UpdateNewShippingQuery") {
    return (struct TdObject *)TdStackFetcherUpdateNewShippingQuery (M);
  }
  if (constructor == "UpdateNewPreCheckoutQuery") {
    return (struct TdObject *)TdStackFetcherUpdateNewPreCheckoutQuery (M);
  }
  if (constructor == "UpdateNewCustomEvent") {
    return (struct TdObject *)TdStackFetcherUpdateNewCustomEvent (M);
  }
  if (constructor == "UpdateNewCustomQuery") {
    return (struct TdObject *)TdStackFetcherUpdateNewCustomQuery (M);
  }
  if (constructor == "User") {
    return (struct TdObject *)TdStackFetcherUser (M);
  }
  if (constructor == "UserFullInfo") {
    return (struct TdObject *)TdStackFetcherUserFullInfo (M);
  }
  if (constructor == "UserPrivacySettingShowStatus") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingShowStatus (M);
  }
  if (constructor == "UserPrivacySettingAllowChatInvites") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingAllowChatInvites (M);
  }
  if (constructor == "UserPrivacySettingAllowCalls") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingAllowCalls (M);
  }
  if (constructor == "UserPrivacySettingRuleAllowAll") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingRuleAllowAll (M);
  }
  if (constructor == "UserPrivacySettingRuleAllowContacts") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingRuleAllowContacts (M);
  }
  if (constructor == "UserPrivacySettingRuleAllowUsers") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingRuleAllowUsers (M);
  }
  if (constructor == "UserPrivacySettingRuleRestrictAll") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingRuleRestrictAll (M);
  }
  if (constructor == "UserPrivacySettingRuleRestrictContacts") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingRuleRestrictContacts (M);
  }
  if (constructor == "UserPrivacySettingRuleRestrictUsers") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingRuleRestrictUsers (M);
  }
  if (constructor == "UserPrivacySettingRules") {
    return (struct TdObject *)TdStackFetcherUserPrivacySettingRules (M);
  }
  if (constructor == "UserProfilePhotos") {
    return (struct TdObject *)TdStackFetcherUserProfilePhotos (M);
  }
  if (constructor == "UserStatusEmpty") {
    return (struct TdObject *)TdStackFetcherUserStatusEmpty (M);
  }
  if (constructor == "UserStatusOnline") {
    return (struct TdObject *)TdStackFetcherUserStatusOnline (M);
  }
  if (constructor == "UserStatusOffline") {
    return (struct TdObject *)TdStackFetcherUserStatusOffline (M);
  }
  if (constructor == "UserStatusRecently") {
    return (struct TdObject *)TdStackFetcherUserStatusRecently (M);
  }
  if (constructor == "UserStatusLastWeek") {
    return (struct TdObject *)TdStackFetcherUserStatusLastWeek (M);
  }
  if (constructor == "UserStatusLastMonth") {
    return (struct TdObject *)TdStackFetcherUserStatusLastMonth (M);
  }
  if (constructor == "UserTypeRegular") {
    return (struct TdObject *)TdStackFetcherUserTypeRegular (M);
  }
  if (constructor == "UserTypeDeleted") {
    return (struct TdObject *)TdStackFetcherUserTypeDeleted (M);
  }
  if (constructor == "UserTypeBot") {
    return (struct TdObject *)TdStackFetcherUserTypeBot (M);
  }
  if (constructor == "UserTypeUnknown") {
    return (struct TdObject *)TdStackFetcherUserTypeUnknown (M);
  }
  if (constructor == "Users") {
    return (struct TdObject *)TdStackFetcherUsers (M);
  }
  if (constructor == "ValidatedOrderInfo") {
    return (struct TdObject *)TdStackFetcherValidatedOrderInfo (M);
  }
  if (constructor == "Venue") {
    return (struct TdObject *)TdStackFetcherVenue (M);
  }
  if (constructor == "Video") {
    return (struct TdObject *)TdStackFetcherVideo (M);
  }
  if (constructor == "VideoNote") {
    return (struct TdObject *)TdStackFetcherVideoNote (M);
  }
  if (constructor == "VoiceNote") {
    return (struct TdObject *)TdStackFetcherVoiceNote (M);
  }
  if (constructor == "Wallpaper") {
    return (struct TdObject *)TdStackFetcherWallpaper (M);
  }
  if (constructor == "Wallpapers") {
    return (struct TdObject *)TdStackFetcherWallpapers (M);
  }
  if (constructor == "WebPage") {
    return (struct TdObject *)TdStackFetcherWebPage (M);
  }
  if (constructor == "WebPageInstantView") {
    return (struct TdObject *)TdStackFetcherWebPageInstantView (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
td::td_api::object_ptr<td::td_api::Function> TdConvertToInternal (struct TdFunction *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AcceptCall: return TdConvertToInternal ((struct TdAcceptCall *)var);
    case CODE_AcceptTermsOfService: return TdConvertToInternal ((struct TdAcceptTermsOfService *)var);
    case CODE_AddChatMember: return TdConvertToInternal ((struct TdAddChatMember *)var);
    case CODE_AddChatMembers: return TdConvertToInternal ((struct TdAddChatMembers *)var);
    case CODE_AddFavoriteSticker: return TdConvertToInternal ((struct TdAddFavoriteSticker *)var);
    case CODE_AddLocalMessage: return TdConvertToInternal ((struct TdAddLocalMessage *)var);
    case CODE_AddNetworkStatistics: return TdConvertToInternal ((struct TdAddNetworkStatistics *)var);
    case CODE_AddProxy: return TdConvertToInternal ((struct TdAddProxy *)var);
    case CODE_AddRecentSticker: return TdConvertToInternal ((struct TdAddRecentSticker *)var);
    case CODE_AddRecentlyFoundChat: return TdConvertToInternal ((struct TdAddRecentlyFoundChat *)var);
    case CODE_AddSavedAnimation: return TdConvertToInternal ((struct TdAddSavedAnimation *)var);
    case CODE_AddStickerToSet: return TdConvertToInternal ((struct TdAddStickerToSet *)var);
    case CODE_AnswerCallbackQuery: return TdConvertToInternal ((struct TdAnswerCallbackQuery *)var);
    case CODE_AnswerCustomQuery: return TdConvertToInternal ((struct TdAnswerCustomQuery *)var);
    case CODE_AnswerInlineQuery: return TdConvertToInternal ((struct TdAnswerInlineQuery *)var);
    case CODE_AnswerPreCheckoutQuery: return TdConvertToInternal ((struct TdAnswerPreCheckoutQuery *)var);
    case CODE_AnswerShippingQuery: return TdConvertToInternal ((struct TdAnswerShippingQuery *)var);
    case CODE_BlockUser: return TdConvertToInternal ((struct TdBlockUser *)var);
    case CODE_CancelDownloadFile: return TdConvertToInternal ((struct TdCancelDownloadFile *)var);
    case CODE_CancelUploadFile: return TdConvertToInternal ((struct TdCancelUploadFile *)var);
    case CODE_ChangeChatReportSpamState: return TdConvertToInternal ((struct TdChangeChatReportSpamState *)var);
    case CODE_ChangeImportedContacts: return TdConvertToInternal ((struct TdChangeImportedContacts *)var);
    case CODE_ChangePhoneNumber: return TdConvertToInternal ((struct TdChangePhoneNumber *)var);
    case CODE_ChangeStickerSet: return TdConvertToInternal ((struct TdChangeStickerSet *)var);
    case CODE_CheckAuthenticationBotToken: return TdConvertToInternal ((struct TdCheckAuthenticationBotToken *)var);
    case CODE_CheckAuthenticationCode: return TdConvertToInternal ((struct TdCheckAuthenticationCode *)var);
    case CODE_CheckAuthenticationPassword: return TdConvertToInternal ((struct TdCheckAuthenticationPassword *)var);
    case CODE_CheckChangePhoneNumberCode: return TdConvertToInternal ((struct TdCheckChangePhoneNumberCode *)var);
    case CODE_CheckChatInviteLink: return TdConvertToInternal ((struct TdCheckChatInviteLink *)var);
    case CODE_CheckChatUsername: return TdConvertToInternal ((struct TdCheckChatUsername *)var);
    case CODE_CheckDatabaseEncryptionKey: return TdConvertToInternal ((struct TdCheckDatabaseEncryptionKey *)var);
    case CODE_CheckEmailAddressVerificationCode: return TdConvertToInternal ((struct TdCheckEmailAddressVerificationCode *)var);
    case CODE_CheckPhoneNumberConfirmationCode: return TdConvertToInternal ((struct TdCheckPhoneNumberConfirmationCode *)var);
    case CODE_CheckPhoneNumberVerificationCode: return TdConvertToInternal ((struct TdCheckPhoneNumberVerificationCode *)var);
    case CODE_CleanFileName: return TdConvertToInternal ((struct TdCleanFileName *)var);
    case CODE_ClearAllDraftMessages: return TdConvertToInternal ((struct TdClearAllDraftMessages *)var);
    case CODE_ClearImportedContacts: return TdConvertToInternal ((struct TdClearImportedContacts *)var);
    case CODE_ClearRecentStickers: return TdConvertToInternal ((struct TdClearRecentStickers *)var);
    case CODE_ClearRecentlyFoundChats: return TdConvertToInternal ((struct TdClearRecentlyFoundChats *)var);
    case CODE_Close: return TdConvertToInternal ((struct TdClose *)var);
    case CODE_CloseChat: return TdConvertToInternal ((struct TdCloseChat *)var);
    case CODE_CloseSecretChat: return TdConvertToInternal ((struct TdCloseSecretChat *)var);
    case CODE_CreateBasicGroupChat: return TdConvertToInternal ((struct TdCreateBasicGroupChat *)var);
    case CODE_CreateCall: return TdConvertToInternal ((struct TdCreateCall *)var);
    case CODE_CreateNewBasicGroupChat: return TdConvertToInternal ((struct TdCreateNewBasicGroupChat *)var);
    case CODE_CreateNewSecretChat: return TdConvertToInternal ((struct TdCreateNewSecretChat *)var);
    case CODE_CreateNewStickerSet: return TdConvertToInternal ((struct TdCreateNewStickerSet *)var);
    case CODE_CreateNewSupergroupChat: return TdConvertToInternal ((struct TdCreateNewSupergroupChat *)var);
    case CODE_CreatePrivateChat: return TdConvertToInternal ((struct TdCreatePrivateChat *)var);
    case CODE_CreateSecretChat: return TdConvertToInternal ((struct TdCreateSecretChat *)var);
    case CODE_CreateSupergroupChat: return TdConvertToInternal ((struct TdCreateSupergroupChat *)var);
    case CODE_CreateTemporaryPassword: return TdConvertToInternal ((struct TdCreateTemporaryPassword *)var);
    case CODE_DeleteAccount: return TdConvertToInternal ((struct TdDeleteAccount *)var);
    case CODE_DeleteChatHistory: return TdConvertToInternal ((struct TdDeleteChatHistory *)var);
    case CODE_DeleteChatMessagesFromUser: return TdConvertToInternal ((struct TdDeleteChatMessagesFromUser *)var);
    case CODE_DeleteChatReplyMarkup: return TdConvertToInternal ((struct TdDeleteChatReplyMarkup *)var);
    case CODE_DeleteFile: return TdConvertToInternal ((struct TdDeleteFile *)var);
    case CODE_DeleteLanguagePack: return TdConvertToInternal ((struct TdDeleteLanguagePack *)var);
    case CODE_DeleteMessages: return TdConvertToInternal ((struct TdDeleteMessages *)var);
    case CODE_DeletePassportElement: return TdConvertToInternal ((struct TdDeletePassportElement *)var);
    case CODE_DeleteProfilePhoto: return TdConvertToInternal ((struct TdDeleteProfilePhoto *)var);
    case CODE_DeleteSavedCredentials: return TdConvertToInternal ((struct TdDeleteSavedCredentials *)var);
    case CODE_DeleteSavedOrderInfo: return TdConvertToInternal ((struct TdDeleteSavedOrderInfo *)var);
    case CODE_DeleteSupergroup: return TdConvertToInternal ((struct TdDeleteSupergroup *)var);
    case CODE_Destroy: return TdConvertToInternal ((struct TdDestroy *)var);
    case CODE_DisableProxy: return TdConvertToInternal ((struct TdDisableProxy *)var);
    case CODE_DiscardCall: return TdConvertToInternal ((struct TdDiscardCall *)var);
    case CODE_DisconnectAllWebsites: return TdConvertToInternal ((struct TdDisconnectAllWebsites *)var);
    case CODE_DisconnectWebsite: return TdConvertToInternal ((struct TdDisconnectWebsite *)var);
    case CODE_DownloadFile: return TdConvertToInternal ((struct TdDownloadFile *)var);
    case CODE_EditCustomLanguagePackInfo: return TdConvertToInternal ((struct TdEditCustomLanguagePackInfo *)var);
    case CODE_EditInlineMessageCaption: return TdConvertToInternal ((struct TdEditInlineMessageCaption *)var);
    case CODE_EditInlineMessageLiveLocation: return TdConvertToInternal ((struct TdEditInlineMessageLiveLocation *)var);
    case CODE_EditInlineMessageMedia: return TdConvertToInternal ((struct TdEditInlineMessageMedia *)var);
    case CODE_EditInlineMessageReplyMarkup: return TdConvertToInternal ((struct TdEditInlineMessageReplyMarkup *)var);
    case CODE_EditInlineMessageText: return TdConvertToInternal ((struct TdEditInlineMessageText *)var);
    case CODE_EditMessageCaption: return TdConvertToInternal ((struct TdEditMessageCaption *)var);
    case CODE_EditMessageLiveLocation: return TdConvertToInternal ((struct TdEditMessageLiveLocation *)var);
    case CODE_EditMessageMedia: return TdConvertToInternal ((struct TdEditMessageMedia *)var);
    case CODE_EditMessageReplyMarkup: return TdConvertToInternal ((struct TdEditMessageReplyMarkup *)var);
    case CODE_EditMessageText: return TdConvertToInternal ((struct TdEditMessageText *)var);
    case CODE_EditProxy: return TdConvertToInternal ((struct TdEditProxy *)var);
    case CODE_EnableProxy: return TdConvertToInternal ((struct TdEnableProxy *)var);
    case CODE_FinishFileGeneration: return TdConvertToInternal ((struct TdFinishFileGeneration *)var);
    case CODE_ForwardMessages: return TdConvertToInternal ((struct TdForwardMessages *)var);
    case CODE_GenerateChatInviteLink: return TdConvertToInternal ((struct TdGenerateChatInviteLink *)var);
    case CODE_GetAccountTtl: return TdConvertToInternal ((struct TdGetAccountTtl *)var);
    case CODE_GetActiveLiveLocationMessages: return TdConvertToInternal ((struct TdGetActiveLiveLocationMessages *)var);
    case CODE_GetActiveSessions: return TdConvertToInternal ((struct TdGetActiveSessions *)var);
    case CODE_GetAllPassportElements: return TdConvertToInternal ((struct TdGetAllPassportElements *)var);
    case CODE_GetArchivedStickerSets: return TdConvertToInternal ((struct TdGetArchivedStickerSets *)var);
    case CODE_GetAttachedStickerSets: return TdConvertToInternal ((struct TdGetAttachedStickerSets *)var);
    case CODE_GetAuthorizationState: return TdConvertToInternal ((struct TdGetAuthorizationState *)var);
    case CODE_GetBasicGroup: return TdConvertToInternal ((struct TdGetBasicGroup *)var);
    case CODE_GetBasicGroupFullInfo: return TdConvertToInternal ((struct TdGetBasicGroupFullInfo *)var);
    case CODE_GetBlockedUsers: return TdConvertToInternal ((struct TdGetBlockedUsers *)var);
    case CODE_GetCallbackQueryAnswer: return TdConvertToInternal ((struct TdGetCallbackQueryAnswer *)var);
    case CODE_GetChat: return TdConvertToInternal ((struct TdGetChat *)var);
    case CODE_GetChatAdministrators: return TdConvertToInternal ((struct TdGetChatAdministrators *)var);
    case CODE_GetChatEventLog: return TdConvertToInternal ((struct TdGetChatEventLog *)var);
    case CODE_GetChatHistory: return TdConvertToInternal ((struct TdGetChatHistory *)var);
    case CODE_GetChatMember: return TdConvertToInternal ((struct TdGetChatMember *)var);
    case CODE_GetChatMessageByDate: return TdConvertToInternal ((struct TdGetChatMessageByDate *)var);
    case CODE_GetChatMessageCount: return TdConvertToInternal ((struct TdGetChatMessageCount *)var);
    case CODE_GetChatPinnedMessage: return TdConvertToInternal ((struct TdGetChatPinnedMessage *)var);
    case CODE_GetChatReportSpamState: return TdConvertToInternal ((struct TdGetChatReportSpamState *)var);
    case CODE_GetChats: return TdConvertToInternal ((struct TdGetChats *)var);
    case CODE_GetConnectedWebsites: return TdConvertToInternal ((struct TdGetConnectedWebsites *)var);
    case CODE_GetContacts: return TdConvertToInternal ((struct TdGetContacts *)var);
    case CODE_GetCountryCode: return TdConvertToInternal ((struct TdGetCountryCode *)var);
    case CODE_GetCreatedPublicChats: return TdConvertToInternal ((struct TdGetCreatedPublicChats *)var);
    case CODE_GetDeepLinkInfo: return TdConvertToInternal ((struct TdGetDeepLinkInfo *)var);
    case CODE_GetFavoriteStickers: return TdConvertToInternal ((struct TdGetFavoriteStickers *)var);
    case CODE_GetFile: return TdConvertToInternal ((struct TdGetFile *)var);
    case CODE_GetFileExtension: return TdConvertToInternal ((struct TdGetFileExtension *)var);
    case CODE_GetFileMimeType: return TdConvertToInternal ((struct TdGetFileMimeType *)var);
    case CODE_GetGameHighScores: return TdConvertToInternal ((struct TdGetGameHighScores *)var);
    case CODE_GetGroupsInCommon: return TdConvertToInternal ((struct TdGetGroupsInCommon *)var);
    case CODE_GetImportedContactCount: return TdConvertToInternal ((struct TdGetImportedContactCount *)var);
    case CODE_GetInlineGameHighScores: return TdConvertToInternal ((struct TdGetInlineGameHighScores *)var);
    case CODE_GetInlineQueryResults: return TdConvertToInternal ((struct TdGetInlineQueryResults *)var);
    case CODE_GetInstalledStickerSets: return TdConvertToInternal ((struct TdGetInstalledStickerSets *)var);
    case CODE_GetInviteText: return TdConvertToInternal ((struct TdGetInviteText *)var);
    case CODE_GetLanguagePackString: return TdConvertToInternal ((struct TdGetLanguagePackString *)var);
    case CODE_GetLanguagePackStrings: return TdConvertToInternal ((struct TdGetLanguagePackStrings *)var);
    case CODE_GetLocalizationTargetInfo: return TdConvertToInternal ((struct TdGetLocalizationTargetInfo *)var);
    case CODE_GetMapThumbnailFile: return TdConvertToInternal ((struct TdGetMapThumbnailFile *)var);
    case CODE_GetMe: return TdConvertToInternal ((struct TdGetMe *)var);
    case CODE_GetMessage: return TdConvertToInternal ((struct TdGetMessage *)var);
    case CODE_GetMessages: return TdConvertToInternal ((struct TdGetMessages *)var);
    case CODE_GetNetworkStatistics: return TdConvertToInternal ((struct TdGetNetworkStatistics *)var);
    case CODE_GetOption: return TdConvertToInternal ((struct TdGetOption *)var);
    case CODE_GetPassportAuthorizationForm: return TdConvertToInternal ((struct TdGetPassportAuthorizationForm *)var);
    case CODE_GetPassportElement: return TdConvertToInternal ((struct TdGetPassportElement *)var);
    case CODE_GetPasswordState: return TdConvertToInternal ((struct TdGetPasswordState *)var);
    case CODE_GetPaymentForm: return TdConvertToInternal ((struct TdGetPaymentForm *)var);
    case CODE_GetPaymentReceipt: return TdConvertToInternal ((struct TdGetPaymentReceipt *)var);
    case CODE_GetPreferredCountryLanguage: return TdConvertToInternal ((struct TdGetPreferredCountryLanguage *)var);
    case CODE_GetProxies: return TdConvertToInternal ((struct TdGetProxies *)var);
    case CODE_GetProxyLink: return TdConvertToInternal ((struct TdGetProxyLink *)var);
    case CODE_GetPublicMessageLink: return TdConvertToInternal ((struct TdGetPublicMessageLink *)var);
    case CODE_GetRecentInlineBots: return TdConvertToInternal ((struct TdGetRecentInlineBots *)var);
    case CODE_GetRecentStickers: return TdConvertToInternal ((struct TdGetRecentStickers *)var);
    case CODE_GetRecentlyVisitedTMeUrls: return TdConvertToInternal ((struct TdGetRecentlyVisitedTMeUrls *)var);
    case CODE_GetRecoveryEmailAddress: return TdConvertToInternal ((struct TdGetRecoveryEmailAddress *)var);
    case CODE_GetRemoteFile: return TdConvertToInternal ((struct TdGetRemoteFile *)var);
    case CODE_GetRepliedMessage: return TdConvertToInternal ((struct TdGetRepliedMessage *)var);
    case CODE_GetSavedAnimations: return TdConvertToInternal ((struct TdGetSavedAnimations *)var);
    case CODE_GetSavedOrderInfo: return TdConvertToInternal ((struct TdGetSavedOrderInfo *)var);
    case CODE_GetScopeNotificationSettings: return TdConvertToInternal ((struct TdGetScopeNotificationSettings *)var);
    case CODE_GetSecretChat: return TdConvertToInternal ((struct TdGetSecretChat *)var);
    case CODE_GetStickerEmojis: return TdConvertToInternal ((struct TdGetStickerEmojis *)var);
    case CODE_GetStickerSet: return TdConvertToInternal ((struct TdGetStickerSet *)var);
    case CODE_GetStickers: return TdConvertToInternal ((struct TdGetStickers *)var);
    case CODE_GetStorageStatistics: return TdConvertToInternal ((struct TdGetStorageStatistics *)var);
    case CODE_GetStorageStatisticsFast: return TdConvertToInternal ((struct TdGetStorageStatisticsFast *)var);
    case CODE_GetSupergroup: return TdConvertToInternal ((struct TdGetSupergroup *)var);
    case CODE_GetSupergroupFullInfo: return TdConvertToInternal ((struct TdGetSupergroupFullInfo *)var);
    case CODE_GetSupergroupMembers: return TdConvertToInternal ((struct TdGetSupergroupMembers *)var);
    case CODE_GetSupportUser: return TdConvertToInternal ((struct TdGetSupportUser *)var);
    case CODE_GetTemporaryPasswordState: return TdConvertToInternal ((struct TdGetTemporaryPasswordState *)var);
    case CODE_GetTextEntities: return TdConvertToInternal ((struct TdGetTextEntities *)var);
    case CODE_GetTopChats: return TdConvertToInternal ((struct TdGetTopChats *)var);
    case CODE_GetTrendingStickerSets: return TdConvertToInternal ((struct TdGetTrendingStickerSets *)var);
    case CODE_GetUser: return TdConvertToInternal ((struct TdGetUser *)var);
    case CODE_GetUserFullInfo: return TdConvertToInternal ((struct TdGetUserFullInfo *)var);
    case CODE_GetUserPrivacySettingRules: return TdConvertToInternal ((struct TdGetUserPrivacySettingRules *)var);
    case CODE_GetUserProfilePhotos: return TdConvertToInternal ((struct TdGetUserProfilePhotos *)var);
    case CODE_GetWallpapers: return TdConvertToInternal ((struct TdGetWallpapers *)var);
    case CODE_GetWebPageInstantView: return TdConvertToInternal ((struct TdGetWebPageInstantView *)var);
    case CODE_GetWebPagePreview: return TdConvertToInternal ((struct TdGetWebPagePreview *)var);
    case CODE_ImportContacts: return TdConvertToInternal ((struct TdImportContacts *)var);
    case CODE_JoinChat: return TdConvertToInternal ((struct TdJoinChat *)var);
    case CODE_JoinChatByInviteLink: return TdConvertToInternal ((struct TdJoinChatByInviteLink *)var);
    case CODE_LeaveChat: return TdConvertToInternal ((struct TdLeaveChat *)var);
    case CODE_LogOut: return TdConvertToInternal ((struct TdLogOut *)var);
    case CODE_OpenChat: return TdConvertToInternal ((struct TdOpenChat *)var);
    case CODE_OpenMessageContent: return TdConvertToInternal ((struct TdOpenMessageContent *)var);
    case CODE_OptimizeStorage: return TdConvertToInternal ((struct TdOptimizeStorage *)var);
    case CODE_ParseTextEntities: return TdConvertToInternal ((struct TdParseTextEntities *)var);
    case CODE_PinSupergroupMessage: return TdConvertToInternal ((struct TdPinSupergroupMessage *)var);
    case CODE_PingProxy: return TdConvertToInternal ((struct TdPingProxy *)var);
    case CODE_ProcessDcUpdate: return TdConvertToInternal ((struct TdProcessDcUpdate *)var);
    case CODE_ReadAllChatMentions: return TdConvertToInternal ((struct TdReadAllChatMentions *)var);
    case CODE_RecoverAuthenticationPassword: return TdConvertToInternal ((struct TdRecoverAuthenticationPassword *)var);
    case CODE_RecoverPassword: return TdConvertToInternal ((struct TdRecoverPassword *)var);
    case CODE_RegisterDevice: return TdConvertToInternal ((struct TdRegisterDevice *)var);
    case CODE_RemoveContacts: return TdConvertToInternal ((struct TdRemoveContacts *)var);
    case CODE_RemoveFavoriteSticker: return TdConvertToInternal ((struct TdRemoveFavoriteSticker *)var);
    case CODE_RemoveProxy: return TdConvertToInternal ((struct TdRemoveProxy *)var);
    case CODE_RemoveRecentHashtag: return TdConvertToInternal ((struct TdRemoveRecentHashtag *)var);
    case CODE_RemoveRecentSticker: return TdConvertToInternal ((struct TdRemoveRecentSticker *)var);
    case CODE_RemoveRecentlyFoundChat: return TdConvertToInternal ((struct TdRemoveRecentlyFoundChat *)var);
    case CODE_RemoveSavedAnimation: return TdConvertToInternal ((struct TdRemoveSavedAnimation *)var);
    case CODE_RemoveStickerFromSet: return TdConvertToInternal ((struct TdRemoveStickerFromSet *)var);
    case CODE_RemoveTopChat: return TdConvertToInternal ((struct TdRemoveTopChat *)var);
    case CODE_ReorderInstalledStickerSets: return TdConvertToInternal ((struct TdReorderInstalledStickerSets *)var);
    case CODE_ReportChat: return TdConvertToInternal ((struct TdReportChat *)var);
    case CODE_ReportSupergroupSpam: return TdConvertToInternal ((struct TdReportSupergroupSpam *)var);
    case CODE_RequestAuthenticationPasswordRecovery: return TdConvertToInternal ((struct TdRequestAuthenticationPasswordRecovery *)var);
    case CODE_RequestPasswordRecovery: return TdConvertToInternal ((struct TdRequestPasswordRecovery *)var);
    case CODE_ResendAuthenticationCode: return TdConvertToInternal ((struct TdResendAuthenticationCode *)var);
    case CODE_ResendChangePhoneNumberCode: return TdConvertToInternal ((struct TdResendChangePhoneNumberCode *)var);
    case CODE_ResendEmailAddressVerificationCode: return TdConvertToInternal ((struct TdResendEmailAddressVerificationCode *)var);
    case CODE_ResendPhoneNumberConfirmationCode: return TdConvertToInternal ((struct TdResendPhoneNumberConfirmationCode *)var);
    case CODE_ResendPhoneNumberVerificationCode: return TdConvertToInternal ((struct TdResendPhoneNumberVerificationCode *)var);
    case CODE_ResetAllNotificationSettings: return TdConvertToInternal ((struct TdResetAllNotificationSettings *)var);
    case CODE_ResetNetworkStatistics: return TdConvertToInternal ((struct TdResetNetworkStatistics *)var);
    case CODE_SearchCallMessages: return TdConvertToInternal ((struct TdSearchCallMessages *)var);
    case CODE_SearchChatMembers: return TdConvertToInternal ((struct TdSearchChatMembers *)var);
    case CODE_SearchChatMessages: return TdConvertToInternal ((struct TdSearchChatMessages *)var);
    case CODE_SearchChatRecentLocationMessages: return TdConvertToInternal ((struct TdSearchChatRecentLocationMessages *)var);
    case CODE_SearchChats: return TdConvertToInternal ((struct TdSearchChats *)var);
    case CODE_SearchChatsOnServer: return TdConvertToInternal ((struct TdSearchChatsOnServer *)var);
    case CODE_SearchContacts: return TdConvertToInternal ((struct TdSearchContacts *)var);
    case CODE_SearchHashtags: return TdConvertToInternal ((struct TdSearchHashtags *)var);
    case CODE_SearchInstalledStickerSets: return TdConvertToInternal ((struct TdSearchInstalledStickerSets *)var);
    case CODE_SearchMessages: return TdConvertToInternal ((struct TdSearchMessages *)var);
    case CODE_SearchPublicChat: return TdConvertToInternal ((struct TdSearchPublicChat *)var);
    case CODE_SearchPublicChats: return TdConvertToInternal ((struct TdSearchPublicChats *)var);
    case CODE_SearchSecretMessages: return TdConvertToInternal ((struct TdSearchSecretMessages *)var);
    case CODE_SearchStickerSet: return TdConvertToInternal ((struct TdSearchStickerSet *)var);
    case CODE_SearchStickerSets: return TdConvertToInternal ((struct TdSearchStickerSets *)var);
    case CODE_SearchStickers: return TdConvertToInternal ((struct TdSearchStickers *)var);
    case CODE_SendBotStartMessage: return TdConvertToInternal ((struct TdSendBotStartMessage *)var);
    case CODE_SendCallDebugInformation: return TdConvertToInternal ((struct TdSendCallDebugInformation *)var);
    case CODE_SendCallRating: return TdConvertToInternal ((struct TdSendCallRating *)var);
    case CODE_SendChatAction: return TdConvertToInternal ((struct TdSendChatAction *)var);
    case CODE_SendChatScreenshotTakenNotification: return TdConvertToInternal ((struct TdSendChatScreenshotTakenNotification *)var);
    case CODE_SendChatSetTtlMessage: return TdConvertToInternal ((struct TdSendChatSetTtlMessage *)var);
    case CODE_SendCustomRequest: return TdConvertToInternal ((struct TdSendCustomRequest *)var);
    case CODE_SendEmailAddressVerificationCode: return TdConvertToInternal ((struct TdSendEmailAddressVerificationCode *)var);
    case CODE_SendInlineQueryResultMessage: return TdConvertToInternal ((struct TdSendInlineQueryResultMessage *)var);
    case CODE_SendMessage: return TdConvertToInternal ((struct TdSendMessage *)var);
    case CODE_SendMessageAlbum: return TdConvertToInternal ((struct TdSendMessageAlbum *)var);
    case CODE_SendPassportAuthorizationForm: return TdConvertToInternal ((struct TdSendPassportAuthorizationForm *)var);
    case CODE_SendPaymentForm: return TdConvertToInternal ((struct TdSendPaymentForm *)var);
    case CODE_SendPhoneNumberConfirmationCode: return TdConvertToInternal ((struct TdSendPhoneNumberConfirmationCode *)var);
    case CODE_SendPhoneNumberVerificationCode: return TdConvertToInternal ((struct TdSendPhoneNumberVerificationCode *)var);
    case CODE_SetAccountTtl: return TdConvertToInternal ((struct TdSetAccountTtl *)var);
    case CODE_SetAlarm: return TdConvertToInternal ((struct TdSetAlarm *)var);
    case CODE_SetAuthenticationPhoneNumber: return TdConvertToInternal ((struct TdSetAuthenticationPhoneNumber *)var);
    case CODE_SetBio: return TdConvertToInternal ((struct TdSetBio *)var);
    case CODE_SetBotUpdatesStatus: return TdConvertToInternal ((struct TdSetBotUpdatesStatus *)var);
    case CODE_SetChatClientData: return TdConvertToInternal ((struct TdSetChatClientData *)var);
    case CODE_SetChatDraftMessage: return TdConvertToInternal ((struct TdSetChatDraftMessage *)var);
    case CODE_SetChatMemberStatus: return TdConvertToInternal ((struct TdSetChatMemberStatus *)var);
    case CODE_SetChatNotificationSettings: return TdConvertToInternal ((struct TdSetChatNotificationSettings *)var);
    case CODE_SetChatPhoto: return TdConvertToInternal ((struct TdSetChatPhoto *)var);
    case CODE_SetChatTitle: return TdConvertToInternal ((struct TdSetChatTitle *)var);
    case CODE_SetCustomLanguagePack: return TdConvertToInternal ((struct TdSetCustomLanguagePack *)var);
    case CODE_SetCustomLanguagePackString: return TdConvertToInternal ((struct TdSetCustomLanguagePackString *)var);
    case CODE_SetDatabaseEncryptionKey: return TdConvertToInternal ((struct TdSetDatabaseEncryptionKey *)var);
    case CODE_SetFileGenerationProgress: return TdConvertToInternal ((struct TdSetFileGenerationProgress *)var);
    case CODE_SetGameScore: return TdConvertToInternal ((struct TdSetGameScore *)var);
    case CODE_SetInlineGameScore: return TdConvertToInternal ((struct TdSetInlineGameScore *)var);
    case CODE_SetName: return TdConvertToInternal ((struct TdSetName *)var);
    case CODE_SetNetworkType: return TdConvertToInternal ((struct TdSetNetworkType *)var);
    case CODE_SetOption: return TdConvertToInternal ((struct TdSetOption *)var);
    case CODE_SetPassportElement: return TdConvertToInternal ((struct TdSetPassportElement *)var);
    case CODE_SetPassportElementErrors: return TdConvertToInternal ((struct TdSetPassportElementErrors *)var);
    case CODE_SetPassword: return TdConvertToInternal ((struct TdSetPassword *)var);
    case CODE_SetPinnedChats: return TdConvertToInternal ((struct TdSetPinnedChats *)var);
    case CODE_SetProfilePhoto: return TdConvertToInternal ((struct TdSetProfilePhoto *)var);
    case CODE_SetRecoveryEmailAddress: return TdConvertToInternal ((struct TdSetRecoveryEmailAddress *)var);
    case CODE_SetScopeNotificationSettings: return TdConvertToInternal ((struct TdSetScopeNotificationSettings *)var);
    case CODE_SetStickerPositionInSet: return TdConvertToInternal ((struct TdSetStickerPositionInSet *)var);
    case CODE_SetSupergroupDescription: return TdConvertToInternal ((struct TdSetSupergroupDescription *)var);
    case CODE_SetSupergroupStickerSet: return TdConvertToInternal ((struct TdSetSupergroupStickerSet *)var);
    case CODE_SetSupergroupUsername: return TdConvertToInternal ((struct TdSetSupergroupUsername *)var);
    case CODE_SetTdlibParameters: return TdConvertToInternal ((struct TdSetTdlibParameters *)var);
    case CODE_SetUserPrivacySettingRules: return TdConvertToInternal ((struct TdSetUserPrivacySettingRules *)var);
    case CODE_SetUsername: return TdConvertToInternal ((struct TdSetUsername *)var);
    case CODE_TerminateAllOtherSessions: return TdConvertToInternal ((struct TdTerminateAllOtherSessions *)var);
    case CODE_TerminateSession: return TdConvertToInternal ((struct TdTerminateSession *)var);
    case CODE_TestCallBytes: return TdConvertToInternal ((struct TdTestCallBytes *)var);
    case CODE_TestCallEmpty: return TdConvertToInternal ((struct TdTestCallEmpty *)var);
    case CODE_TestCallString: return TdConvertToInternal ((struct TdTestCallString *)var);
    case CODE_TestCallVectorInt: return TdConvertToInternal ((struct TdTestCallVectorInt *)var);
    case CODE_TestCallVectorIntObject: return TdConvertToInternal ((struct TdTestCallVectorIntObject *)var);
    case CODE_TestCallVectorString: return TdConvertToInternal ((struct TdTestCallVectorString *)var);
    case CODE_TestCallVectorStringObject: return TdConvertToInternal ((struct TdTestCallVectorStringObject *)var);
    case CODE_TestGetDifference: return TdConvertToInternal ((struct TdTestGetDifference *)var);
    case CODE_TestNetwork: return TdConvertToInternal ((struct TdTestNetwork *)var);
    case CODE_TestSquareInt: return TdConvertToInternal ((struct TdTestSquareInt *)var);
    case CODE_TestUseError: return TdConvertToInternal ((struct TdTestUseError *)var);
    case CODE_TestUseUpdate: return TdConvertToInternal ((struct TdTestUseUpdate *)var);
    case CODE_ToggleBasicGroupAdministrators: return TdConvertToInternal ((struct TdToggleBasicGroupAdministrators *)var);
    case CODE_ToggleChatDefaultDisableNotification: return TdConvertToInternal ((struct TdToggleChatDefaultDisableNotification *)var);
    case CODE_ToggleChatIsMarkedAsUnread: return TdConvertToInternal ((struct TdToggleChatIsMarkedAsUnread *)var);
    case CODE_ToggleChatIsPinned: return TdConvertToInternal ((struct TdToggleChatIsPinned *)var);
    case CODE_ToggleSupergroupInvites: return TdConvertToInternal ((struct TdToggleSupergroupInvites *)var);
    case CODE_ToggleSupergroupIsAllHistoryAvailable: return TdConvertToInternal ((struct TdToggleSupergroupIsAllHistoryAvailable *)var);
    case CODE_ToggleSupergroupSignMessages: return TdConvertToInternal ((struct TdToggleSupergroupSignMessages *)var);
    case CODE_UnblockUser: return TdConvertToInternal ((struct TdUnblockUser *)var);
    case CODE_UnpinSupergroupMessage: return TdConvertToInternal ((struct TdUnpinSupergroupMessage *)var);
    case CODE_UpgradeBasicGroupChatToSupergroupChat: return TdConvertToInternal ((struct TdUpgradeBasicGroupChatToSupergroupChat *)var);
    case CODE_UploadFile: return TdConvertToInternal ((struct TdUploadFile *)var);
    case CODE_UploadStickerFile: return TdConvertToInternal ((struct TdUploadStickerFile *)var);
    case CODE_ValidateOrderInfo: return TdConvertToInternal ((struct TdValidateOrderInfo *)var);
    case CODE_ViewMessages: return TdConvertToInternal ((struct TdViewMessages *)var);
    case CODE_ViewTrendingStickerSets: return TdConvertToInternal ((struct TdViewTrendingStickerSets *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdFunction *TdConvertFromInternal (const td::td_api::Function &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_AcceptCall: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::acceptCall &>(from));
    case CODE_AcceptTermsOfService: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::acceptTermsOfService &>(from));
    case CODE_AddChatMember: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addChatMember &>(from));
    case CODE_AddChatMembers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addChatMembers &>(from));
    case CODE_AddFavoriteSticker: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addFavoriteSticker &>(from));
    case CODE_AddLocalMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addLocalMessage &>(from));
    case CODE_AddNetworkStatistics: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addNetworkStatistics &>(from));
    case CODE_AddProxy: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addProxy &>(from));
    case CODE_AddRecentSticker: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addRecentSticker &>(from));
    case CODE_AddRecentlyFoundChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addRecentlyFoundChat &>(from));
    case CODE_AddSavedAnimation: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addSavedAnimation &>(from));
    case CODE_AddStickerToSet: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::addStickerToSet &>(from));
    case CODE_AnswerCallbackQuery: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::answerCallbackQuery &>(from));
    case CODE_AnswerCustomQuery: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::answerCustomQuery &>(from));
    case CODE_AnswerInlineQuery: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::answerInlineQuery &>(from));
    case CODE_AnswerPreCheckoutQuery: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::answerPreCheckoutQuery &>(from));
    case CODE_AnswerShippingQuery: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::answerShippingQuery &>(from));
    case CODE_BlockUser: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::blockUser &>(from));
    case CODE_CancelDownloadFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::cancelDownloadFile &>(from));
    case CODE_CancelUploadFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::cancelUploadFile &>(from));
    case CODE_ChangeChatReportSpamState: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::changeChatReportSpamState &>(from));
    case CODE_ChangeImportedContacts: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::changeImportedContacts &>(from));
    case CODE_ChangePhoneNumber: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::changePhoneNumber &>(from));
    case CODE_ChangeStickerSet: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::changeStickerSet &>(from));
    case CODE_CheckAuthenticationBotToken: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkAuthenticationBotToken &>(from));
    case CODE_CheckAuthenticationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkAuthenticationCode &>(from));
    case CODE_CheckAuthenticationPassword: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkAuthenticationPassword &>(from));
    case CODE_CheckChangePhoneNumberCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkChangePhoneNumberCode &>(from));
    case CODE_CheckChatInviteLink: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkChatInviteLink &>(from));
    case CODE_CheckChatUsername: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsername &>(from));
    case CODE_CheckDatabaseEncryptionKey: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkDatabaseEncryptionKey &>(from));
    case CODE_CheckEmailAddressVerificationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkEmailAddressVerificationCode &>(from));
    case CODE_CheckPhoneNumberConfirmationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkPhoneNumberConfirmationCode &>(from));
    case CODE_CheckPhoneNumberVerificationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::checkPhoneNumberVerificationCode &>(from));
    case CODE_CleanFileName: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::cleanFileName &>(from));
    case CODE_ClearAllDraftMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::clearAllDraftMessages &>(from));
    case CODE_ClearImportedContacts: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::clearImportedContacts &>(from));
    case CODE_ClearRecentStickers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::clearRecentStickers &>(from));
    case CODE_ClearRecentlyFoundChats: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::clearRecentlyFoundChats &>(from));
    case CODE_Close: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::close &>(from));
    case CODE_CloseChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::closeChat &>(from));
    case CODE_CloseSecretChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::closeSecretChat &>(from));
    case CODE_CreateBasicGroupChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createBasicGroupChat &>(from));
    case CODE_CreateCall: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createCall &>(from));
    case CODE_CreateNewBasicGroupChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createNewBasicGroupChat &>(from));
    case CODE_CreateNewSecretChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createNewSecretChat &>(from));
    case CODE_CreateNewStickerSet: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createNewStickerSet &>(from));
    case CODE_CreateNewSupergroupChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createNewSupergroupChat &>(from));
    case CODE_CreatePrivateChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createPrivateChat &>(from));
    case CODE_CreateSecretChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createSecretChat &>(from));
    case CODE_CreateSupergroupChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createSupergroupChat &>(from));
    case CODE_CreateTemporaryPassword: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::createTemporaryPassword &>(from));
    case CODE_DeleteAccount: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteAccount &>(from));
    case CODE_DeleteChatHistory: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteChatHistory &>(from));
    case CODE_DeleteChatMessagesFromUser: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteChatMessagesFromUser &>(from));
    case CODE_DeleteChatReplyMarkup: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteChatReplyMarkup &>(from));
    case CODE_DeleteFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteFile &>(from));
    case CODE_DeleteLanguagePack: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteLanguagePack &>(from));
    case CODE_DeleteMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteMessages &>(from));
    case CODE_DeletePassportElement: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deletePassportElement &>(from));
    case CODE_DeleteProfilePhoto: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteProfilePhoto &>(from));
    case CODE_DeleteSavedCredentials: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteSavedCredentials &>(from));
    case CODE_DeleteSavedOrderInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteSavedOrderInfo &>(from));
    case CODE_DeleteSupergroup: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::deleteSupergroup &>(from));
    case CODE_Destroy: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::destroy &>(from));
    case CODE_DisableProxy: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::disableProxy &>(from));
    case CODE_DiscardCall: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::discardCall &>(from));
    case CODE_DisconnectAllWebsites: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::disconnectAllWebsites &>(from));
    case CODE_DisconnectWebsite: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::disconnectWebsite &>(from));
    case CODE_DownloadFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::downloadFile &>(from));
    case CODE_EditCustomLanguagePackInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editCustomLanguagePackInfo &>(from));
    case CODE_EditInlineMessageCaption: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editInlineMessageCaption &>(from));
    case CODE_EditInlineMessageLiveLocation: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editInlineMessageLiveLocation &>(from));
    case CODE_EditInlineMessageMedia: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editInlineMessageMedia &>(from));
    case CODE_EditInlineMessageReplyMarkup: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editInlineMessageReplyMarkup &>(from));
    case CODE_EditInlineMessageText: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editInlineMessageText &>(from));
    case CODE_EditMessageCaption: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editMessageCaption &>(from));
    case CODE_EditMessageLiveLocation: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editMessageLiveLocation &>(from));
    case CODE_EditMessageMedia: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editMessageMedia &>(from));
    case CODE_EditMessageReplyMarkup: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editMessageReplyMarkup &>(from));
    case CODE_EditMessageText: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editMessageText &>(from));
    case CODE_EditProxy: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::editProxy &>(from));
    case CODE_EnableProxy: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::enableProxy &>(from));
    case CODE_FinishFileGeneration: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::finishFileGeneration &>(from));
    case CODE_ForwardMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::forwardMessages &>(from));
    case CODE_GenerateChatInviteLink: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::generateChatInviteLink &>(from));
    case CODE_GetAccountTtl: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getAccountTtl &>(from));
    case CODE_GetActiveLiveLocationMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getActiveLiveLocationMessages &>(from));
    case CODE_GetActiveSessions: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getActiveSessions &>(from));
    case CODE_GetAllPassportElements: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getAllPassportElements &>(from));
    case CODE_GetArchivedStickerSets: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getArchivedStickerSets &>(from));
    case CODE_GetAttachedStickerSets: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getAttachedStickerSets &>(from));
    case CODE_GetAuthorizationState: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getAuthorizationState &>(from));
    case CODE_GetBasicGroup: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getBasicGroup &>(from));
    case CODE_GetBasicGroupFullInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getBasicGroupFullInfo &>(from));
    case CODE_GetBlockedUsers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getBlockedUsers &>(from));
    case CODE_GetCallbackQueryAnswer: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getCallbackQueryAnswer &>(from));
    case CODE_GetChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChat &>(from));
    case CODE_GetChatAdministrators: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChatAdministrators &>(from));
    case CODE_GetChatEventLog: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChatEventLog &>(from));
    case CODE_GetChatHistory: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChatHistory &>(from));
    case CODE_GetChatMember: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChatMember &>(from));
    case CODE_GetChatMessageByDate: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChatMessageByDate &>(from));
    case CODE_GetChatMessageCount: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChatMessageCount &>(from));
    case CODE_GetChatPinnedMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChatPinnedMessage &>(from));
    case CODE_GetChatReportSpamState: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChatReportSpamState &>(from));
    case CODE_GetChats: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getChats &>(from));
    case CODE_GetConnectedWebsites: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getConnectedWebsites &>(from));
    case CODE_GetContacts: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getContacts &>(from));
    case CODE_GetCountryCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getCountryCode &>(from));
    case CODE_GetCreatedPublicChats: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getCreatedPublicChats &>(from));
    case CODE_GetDeepLinkInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getDeepLinkInfo &>(from));
    case CODE_GetFavoriteStickers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getFavoriteStickers &>(from));
    case CODE_GetFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getFile &>(from));
    case CODE_GetFileExtension: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getFileExtension &>(from));
    case CODE_GetFileMimeType: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getFileMimeType &>(from));
    case CODE_GetGameHighScores: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getGameHighScores &>(from));
    case CODE_GetGroupsInCommon: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getGroupsInCommon &>(from));
    case CODE_GetImportedContactCount: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getImportedContactCount &>(from));
    case CODE_GetInlineGameHighScores: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getInlineGameHighScores &>(from));
    case CODE_GetInlineQueryResults: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getInlineQueryResults &>(from));
    case CODE_GetInstalledStickerSets: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getInstalledStickerSets &>(from));
    case CODE_GetInviteText: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getInviteText &>(from));
    case CODE_GetLanguagePackString: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getLanguagePackString &>(from));
    case CODE_GetLanguagePackStrings: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getLanguagePackStrings &>(from));
    case CODE_GetLocalizationTargetInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getLocalizationTargetInfo &>(from));
    case CODE_GetMapThumbnailFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getMapThumbnailFile &>(from));
    case CODE_GetMe: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getMe &>(from));
    case CODE_GetMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getMessage &>(from));
    case CODE_GetMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getMessages &>(from));
    case CODE_GetNetworkStatistics: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getNetworkStatistics &>(from));
    case CODE_GetOption: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getOption &>(from));
    case CODE_GetPassportAuthorizationForm: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getPassportAuthorizationForm &>(from));
    case CODE_GetPassportElement: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getPassportElement &>(from));
    case CODE_GetPasswordState: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getPasswordState &>(from));
    case CODE_GetPaymentForm: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getPaymentForm &>(from));
    case CODE_GetPaymentReceipt: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getPaymentReceipt &>(from));
    case CODE_GetPreferredCountryLanguage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getPreferredCountryLanguage &>(from));
    case CODE_GetProxies: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getProxies &>(from));
    case CODE_GetProxyLink: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getProxyLink &>(from));
    case CODE_GetPublicMessageLink: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getPublicMessageLink &>(from));
    case CODE_GetRecentInlineBots: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getRecentInlineBots &>(from));
    case CODE_GetRecentStickers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getRecentStickers &>(from));
    case CODE_GetRecentlyVisitedTMeUrls: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getRecentlyVisitedTMeUrls &>(from));
    case CODE_GetRecoveryEmailAddress: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getRecoveryEmailAddress &>(from));
    case CODE_GetRemoteFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getRemoteFile &>(from));
    case CODE_GetRepliedMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getRepliedMessage &>(from));
    case CODE_GetSavedAnimations: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getSavedAnimations &>(from));
    case CODE_GetSavedOrderInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getSavedOrderInfo &>(from));
    case CODE_GetScopeNotificationSettings: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getScopeNotificationSettings &>(from));
    case CODE_GetSecretChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getSecretChat &>(from));
    case CODE_GetStickerEmojis: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getStickerEmojis &>(from));
    case CODE_GetStickerSet: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getStickerSet &>(from));
    case CODE_GetStickers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getStickers &>(from));
    case CODE_GetStorageStatistics: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getStorageStatistics &>(from));
    case CODE_GetStorageStatisticsFast: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getStorageStatisticsFast &>(from));
    case CODE_GetSupergroup: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getSupergroup &>(from));
    case CODE_GetSupergroupFullInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getSupergroupFullInfo &>(from));
    case CODE_GetSupergroupMembers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getSupergroupMembers &>(from));
    case CODE_GetSupportUser: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getSupportUser &>(from));
    case CODE_GetTemporaryPasswordState: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getTemporaryPasswordState &>(from));
    case CODE_GetTextEntities: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getTextEntities &>(from));
    case CODE_GetTopChats: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getTopChats &>(from));
    case CODE_GetTrendingStickerSets: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getTrendingStickerSets &>(from));
    case CODE_GetUser: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getUser &>(from));
    case CODE_GetUserFullInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getUserFullInfo &>(from));
    case CODE_GetUserPrivacySettingRules: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getUserPrivacySettingRules &>(from));
    case CODE_GetUserProfilePhotos: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getUserProfilePhotos &>(from));
    case CODE_GetWallpapers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getWallpapers &>(from));
    case CODE_GetWebPageInstantView: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getWebPageInstantView &>(from));
    case CODE_GetWebPagePreview: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::getWebPagePreview &>(from));
    case CODE_ImportContacts: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::importContacts &>(from));
    case CODE_JoinChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::joinChat &>(from));
    case CODE_JoinChatByInviteLink: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::joinChatByInviteLink &>(from));
    case CODE_LeaveChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::leaveChat &>(from));
    case CODE_LogOut: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::logOut &>(from));
    case CODE_OpenChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::openChat &>(from));
    case CODE_OpenMessageContent: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::openMessageContent &>(from));
    case CODE_OptimizeStorage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::optimizeStorage &>(from));
    case CODE_ParseTextEntities: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::parseTextEntities &>(from));
    case CODE_PinSupergroupMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::pinSupergroupMessage &>(from));
    case CODE_PingProxy: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::pingProxy &>(from));
    case CODE_ProcessDcUpdate: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::processDcUpdate &>(from));
    case CODE_ReadAllChatMentions: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::readAllChatMentions &>(from));
    case CODE_RecoverAuthenticationPassword: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::recoverAuthenticationPassword &>(from));
    case CODE_RecoverPassword: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::recoverPassword &>(from));
    case CODE_RegisterDevice: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::registerDevice &>(from));
    case CODE_RemoveContacts: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeContacts &>(from));
    case CODE_RemoveFavoriteSticker: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeFavoriteSticker &>(from));
    case CODE_RemoveProxy: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeProxy &>(from));
    case CODE_RemoveRecentHashtag: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeRecentHashtag &>(from));
    case CODE_RemoveRecentSticker: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeRecentSticker &>(from));
    case CODE_RemoveRecentlyFoundChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeRecentlyFoundChat &>(from));
    case CODE_RemoveSavedAnimation: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeSavedAnimation &>(from));
    case CODE_RemoveStickerFromSet: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeStickerFromSet &>(from));
    case CODE_RemoveTopChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::removeTopChat &>(from));
    case CODE_ReorderInstalledStickerSets: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::reorderInstalledStickerSets &>(from));
    case CODE_ReportChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::reportChat &>(from));
    case CODE_ReportSupergroupSpam: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::reportSupergroupSpam &>(from));
    case CODE_RequestAuthenticationPasswordRecovery: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::requestAuthenticationPasswordRecovery &>(from));
    case CODE_RequestPasswordRecovery: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::requestPasswordRecovery &>(from));
    case CODE_ResendAuthenticationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::resendAuthenticationCode &>(from));
    case CODE_ResendChangePhoneNumberCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::resendChangePhoneNumberCode &>(from));
    case CODE_ResendEmailAddressVerificationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::resendEmailAddressVerificationCode &>(from));
    case CODE_ResendPhoneNumberConfirmationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::resendPhoneNumberConfirmationCode &>(from));
    case CODE_ResendPhoneNumberVerificationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::resendPhoneNumberVerificationCode &>(from));
    case CODE_ResetAllNotificationSettings: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::resetAllNotificationSettings &>(from));
    case CODE_ResetNetworkStatistics: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::resetNetworkStatistics &>(from));
    case CODE_SearchCallMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchCallMessages &>(from));
    case CODE_SearchChatMembers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchChatMembers &>(from));
    case CODE_SearchChatMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchChatMessages &>(from));
    case CODE_SearchChatRecentLocationMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchChatRecentLocationMessages &>(from));
    case CODE_SearchChats: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchChats &>(from));
    case CODE_SearchChatsOnServer: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchChatsOnServer &>(from));
    case CODE_SearchContacts: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchContacts &>(from));
    case CODE_SearchHashtags: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchHashtags &>(from));
    case CODE_SearchInstalledStickerSets: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchInstalledStickerSets &>(from));
    case CODE_SearchMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchMessages &>(from));
    case CODE_SearchPublicChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchPublicChat &>(from));
    case CODE_SearchPublicChats: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchPublicChats &>(from));
    case CODE_SearchSecretMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchSecretMessages &>(from));
    case CODE_SearchStickerSet: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchStickerSet &>(from));
    case CODE_SearchStickerSets: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchStickerSets &>(from));
    case CODE_SearchStickers: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::searchStickers &>(from));
    case CODE_SendBotStartMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendBotStartMessage &>(from));
    case CODE_SendCallDebugInformation: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendCallDebugInformation &>(from));
    case CODE_SendCallRating: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendCallRating &>(from));
    case CODE_SendChatAction: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendChatAction &>(from));
    case CODE_SendChatScreenshotTakenNotification: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendChatScreenshotTakenNotification &>(from));
    case CODE_SendChatSetTtlMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendChatSetTtlMessage &>(from));
    case CODE_SendCustomRequest: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendCustomRequest &>(from));
    case CODE_SendEmailAddressVerificationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendEmailAddressVerificationCode &>(from));
    case CODE_SendInlineQueryResultMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendInlineQueryResultMessage &>(from));
    case CODE_SendMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendMessage &>(from));
    case CODE_SendMessageAlbum: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendMessageAlbum &>(from));
    case CODE_SendPassportAuthorizationForm: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendPassportAuthorizationForm &>(from));
    case CODE_SendPaymentForm: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendPaymentForm &>(from));
    case CODE_SendPhoneNumberConfirmationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendPhoneNumberConfirmationCode &>(from));
    case CODE_SendPhoneNumberVerificationCode: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::sendPhoneNumberVerificationCode &>(from));
    case CODE_SetAccountTtl: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setAccountTtl &>(from));
    case CODE_SetAlarm: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setAlarm &>(from));
    case CODE_SetAuthenticationPhoneNumber: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setAuthenticationPhoneNumber &>(from));
    case CODE_SetBio: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setBio &>(from));
    case CODE_SetBotUpdatesStatus: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setBotUpdatesStatus &>(from));
    case CODE_SetChatClientData: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setChatClientData &>(from));
    case CODE_SetChatDraftMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setChatDraftMessage &>(from));
    case CODE_SetChatMemberStatus: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setChatMemberStatus &>(from));
    case CODE_SetChatNotificationSettings: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setChatNotificationSettings &>(from));
    case CODE_SetChatPhoto: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setChatPhoto &>(from));
    case CODE_SetChatTitle: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setChatTitle &>(from));
    case CODE_SetCustomLanguagePack: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setCustomLanguagePack &>(from));
    case CODE_SetCustomLanguagePackString: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setCustomLanguagePackString &>(from));
    case CODE_SetDatabaseEncryptionKey: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setDatabaseEncryptionKey &>(from));
    case CODE_SetFileGenerationProgress: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setFileGenerationProgress &>(from));
    case CODE_SetGameScore: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setGameScore &>(from));
    case CODE_SetInlineGameScore: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setInlineGameScore &>(from));
    case CODE_SetName: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setName &>(from));
    case CODE_SetNetworkType: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setNetworkType &>(from));
    case CODE_SetOption: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setOption &>(from));
    case CODE_SetPassportElement: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setPassportElement &>(from));
    case CODE_SetPassportElementErrors: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setPassportElementErrors &>(from));
    case CODE_SetPassword: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setPassword &>(from));
    case CODE_SetPinnedChats: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setPinnedChats &>(from));
    case CODE_SetProfilePhoto: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setProfilePhoto &>(from));
    case CODE_SetRecoveryEmailAddress: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setRecoveryEmailAddress &>(from));
    case CODE_SetScopeNotificationSettings: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setScopeNotificationSettings &>(from));
    case CODE_SetStickerPositionInSet: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setStickerPositionInSet &>(from));
    case CODE_SetSupergroupDescription: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setSupergroupDescription &>(from));
    case CODE_SetSupergroupStickerSet: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setSupergroupStickerSet &>(from));
    case CODE_SetSupergroupUsername: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setSupergroupUsername &>(from));
    case CODE_SetTdlibParameters: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setTdlibParameters &>(from));
    case CODE_SetUserPrivacySettingRules: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setUserPrivacySettingRules &>(from));
    case CODE_SetUsername: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::setUsername &>(from));
    case CODE_TerminateAllOtherSessions: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::terminateAllOtherSessions &>(from));
    case CODE_TerminateSession: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::terminateSession &>(from));
    case CODE_TestCallBytes: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testCallBytes &>(from));
    case CODE_TestCallEmpty: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testCallEmpty &>(from));
    case CODE_TestCallString: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testCallString &>(from));
    case CODE_TestCallVectorInt: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testCallVectorInt &>(from));
    case CODE_TestCallVectorIntObject: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testCallVectorIntObject &>(from));
    case CODE_TestCallVectorString: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testCallVectorString &>(from));
    case CODE_TestCallVectorStringObject: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testCallVectorStringObject &>(from));
    case CODE_TestGetDifference: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testGetDifference &>(from));
    case CODE_TestNetwork: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testNetwork &>(from));
    case CODE_TestSquareInt: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testSquareInt &>(from));
    case CODE_TestUseError: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testUseError &>(from));
    case CODE_TestUseUpdate: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::testUseUpdate &>(from));
    case CODE_ToggleBasicGroupAdministrators: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::toggleBasicGroupAdministrators &>(from));
    case CODE_ToggleChatDefaultDisableNotification: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::toggleChatDefaultDisableNotification &>(from));
    case CODE_ToggleChatIsMarkedAsUnread: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::toggleChatIsMarkedAsUnread &>(from));
    case CODE_ToggleChatIsPinned: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::toggleChatIsPinned &>(from));
    case CODE_ToggleSupergroupInvites: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::toggleSupergroupInvites &>(from));
    case CODE_ToggleSupergroupIsAllHistoryAvailable: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::toggleSupergroupIsAllHistoryAvailable &>(from));
    case CODE_ToggleSupergroupSignMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::toggleSupergroupSignMessages &>(from));
    case CODE_UnblockUser: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::unblockUser &>(from));
    case CODE_UnpinSupergroupMessage: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::unpinSupergroupMessage &>(from));
    case CODE_UpgradeBasicGroupChatToSupergroupChat: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::upgradeBasicGroupChatToSupergroupChat &>(from));
    case CODE_UploadFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::uploadFile &>(from));
    case CODE_UploadStickerFile: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::uploadStickerFile &>(from));
    case CODE_ValidateOrderInfo: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::validateOrderInfo &>(from));
    case CODE_ViewMessages: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::viewMessages &>(from));
    case CODE_ViewTrendingStickerSets: return (struct TdFunction *)TdConvertFromInternal(static_cast<const td::td_api::viewTrendingStickerSets &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeFunction (struct TdFunction *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFunction *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFunction (struct TdFunction *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFunction *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AcceptCall: return TdDestroyObject ((struct TdAcceptCall *)var);
    case CODE_AcceptTermsOfService: return TdDestroyObject ((struct TdAcceptTermsOfService *)var);
    case CODE_AddChatMember: return TdDestroyObject ((struct TdAddChatMember *)var);
    case CODE_AddChatMembers: return TdDestroyObject ((struct TdAddChatMembers *)var);
    case CODE_AddFavoriteSticker: return TdDestroyObject ((struct TdAddFavoriteSticker *)var);
    case CODE_AddLocalMessage: return TdDestroyObject ((struct TdAddLocalMessage *)var);
    case CODE_AddNetworkStatistics: return TdDestroyObject ((struct TdAddNetworkStatistics *)var);
    case CODE_AddProxy: return TdDestroyObject ((struct TdAddProxy *)var);
    case CODE_AddRecentSticker: return TdDestroyObject ((struct TdAddRecentSticker *)var);
    case CODE_AddRecentlyFoundChat: return TdDestroyObject ((struct TdAddRecentlyFoundChat *)var);
    case CODE_AddSavedAnimation: return TdDestroyObject ((struct TdAddSavedAnimation *)var);
    case CODE_AddStickerToSet: return TdDestroyObject ((struct TdAddStickerToSet *)var);
    case CODE_AnswerCallbackQuery: return TdDestroyObject ((struct TdAnswerCallbackQuery *)var);
    case CODE_AnswerCustomQuery: return TdDestroyObject ((struct TdAnswerCustomQuery *)var);
    case CODE_AnswerInlineQuery: return TdDestroyObject ((struct TdAnswerInlineQuery *)var);
    case CODE_AnswerPreCheckoutQuery: return TdDestroyObject ((struct TdAnswerPreCheckoutQuery *)var);
    case CODE_AnswerShippingQuery: return TdDestroyObject ((struct TdAnswerShippingQuery *)var);
    case CODE_BlockUser: return TdDestroyObject ((struct TdBlockUser *)var);
    case CODE_CancelDownloadFile: return TdDestroyObject ((struct TdCancelDownloadFile *)var);
    case CODE_CancelUploadFile: return TdDestroyObject ((struct TdCancelUploadFile *)var);
    case CODE_ChangeChatReportSpamState: return TdDestroyObject ((struct TdChangeChatReportSpamState *)var);
    case CODE_ChangeImportedContacts: return TdDestroyObject ((struct TdChangeImportedContacts *)var);
    case CODE_ChangePhoneNumber: return TdDestroyObject ((struct TdChangePhoneNumber *)var);
    case CODE_ChangeStickerSet: return TdDestroyObject ((struct TdChangeStickerSet *)var);
    case CODE_CheckAuthenticationBotToken: return TdDestroyObject ((struct TdCheckAuthenticationBotToken *)var);
    case CODE_CheckAuthenticationCode: return TdDestroyObject ((struct TdCheckAuthenticationCode *)var);
    case CODE_CheckAuthenticationPassword: return TdDestroyObject ((struct TdCheckAuthenticationPassword *)var);
    case CODE_CheckChangePhoneNumberCode: return TdDestroyObject ((struct TdCheckChangePhoneNumberCode *)var);
    case CODE_CheckChatInviteLink: return TdDestroyObject ((struct TdCheckChatInviteLink *)var);
    case CODE_CheckChatUsername: return TdDestroyObject ((struct TdCheckChatUsername *)var);
    case CODE_CheckDatabaseEncryptionKey: return TdDestroyObject ((struct TdCheckDatabaseEncryptionKey *)var);
    case CODE_CheckEmailAddressVerificationCode: return TdDestroyObject ((struct TdCheckEmailAddressVerificationCode *)var);
    case CODE_CheckPhoneNumberConfirmationCode: return TdDestroyObject ((struct TdCheckPhoneNumberConfirmationCode *)var);
    case CODE_CheckPhoneNumberVerificationCode: return TdDestroyObject ((struct TdCheckPhoneNumberVerificationCode *)var);
    case CODE_CleanFileName: return TdDestroyObject ((struct TdCleanFileName *)var);
    case CODE_ClearAllDraftMessages: return TdDestroyObject ((struct TdClearAllDraftMessages *)var);
    case CODE_ClearImportedContacts: return TdDestroyObject ((struct TdClearImportedContacts *)var);
    case CODE_ClearRecentStickers: return TdDestroyObject ((struct TdClearRecentStickers *)var);
    case CODE_ClearRecentlyFoundChats: return TdDestroyObject ((struct TdClearRecentlyFoundChats *)var);
    case CODE_Close: return TdDestroyObject ((struct TdClose *)var);
    case CODE_CloseChat: return TdDestroyObject ((struct TdCloseChat *)var);
    case CODE_CloseSecretChat: return TdDestroyObject ((struct TdCloseSecretChat *)var);
    case CODE_CreateBasicGroupChat: return TdDestroyObject ((struct TdCreateBasicGroupChat *)var);
    case CODE_CreateCall: return TdDestroyObject ((struct TdCreateCall *)var);
    case CODE_CreateNewBasicGroupChat: return TdDestroyObject ((struct TdCreateNewBasicGroupChat *)var);
    case CODE_CreateNewSecretChat: return TdDestroyObject ((struct TdCreateNewSecretChat *)var);
    case CODE_CreateNewStickerSet: return TdDestroyObject ((struct TdCreateNewStickerSet *)var);
    case CODE_CreateNewSupergroupChat: return TdDestroyObject ((struct TdCreateNewSupergroupChat *)var);
    case CODE_CreatePrivateChat: return TdDestroyObject ((struct TdCreatePrivateChat *)var);
    case CODE_CreateSecretChat: return TdDestroyObject ((struct TdCreateSecretChat *)var);
    case CODE_CreateSupergroupChat: return TdDestroyObject ((struct TdCreateSupergroupChat *)var);
    case CODE_CreateTemporaryPassword: return TdDestroyObject ((struct TdCreateTemporaryPassword *)var);
    case CODE_DeleteAccount: return TdDestroyObject ((struct TdDeleteAccount *)var);
    case CODE_DeleteChatHistory: return TdDestroyObject ((struct TdDeleteChatHistory *)var);
    case CODE_DeleteChatMessagesFromUser: return TdDestroyObject ((struct TdDeleteChatMessagesFromUser *)var);
    case CODE_DeleteChatReplyMarkup: return TdDestroyObject ((struct TdDeleteChatReplyMarkup *)var);
    case CODE_DeleteFile: return TdDestroyObject ((struct TdDeleteFile *)var);
    case CODE_DeleteLanguagePack: return TdDestroyObject ((struct TdDeleteLanguagePack *)var);
    case CODE_DeleteMessages: return TdDestroyObject ((struct TdDeleteMessages *)var);
    case CODE_DeletePassportElement: return TdDestroyObject ((struct TdDeletePassportElement *)var);
    case CODE_DeleteProfilePhoto: return TdDestroyObject ((struct TdDeleteProfilePhoto *)var);
    case CODE_DeleteSavedCredentials: return TdDestroyObject ((struct TdDeleteSavedCredentials *)var);
    case CODE_DeleteSavedOrderInfo: return TdDestroyObject ((struct TdDeleteSavedOrderInfo *)var);
    case CODE_DeleteSupergroup: return TdDestroyObject ((struct TdDeleteSupergroup *)var);
    case CODE_Destroy: return TdDestroyObject ((struct TdDestroy *)var);
    case CODE_DisableProxy: return TdDestroyObject ((struct TdDisableProxy *)var);
    case CODE_DiscardCall: return TdDestroyObject ((struct TdDiscardCall *)var);
    case CODE_DisconnectAllWebsites: return TdDestroyObject ((struct TdDisconnectAllWebsites *)var);
    case CODE_DisconnectWebsite: return TdDestroyObject ((struct TdDisconnectWebsite *)var);
    case CODE_DownloadFile: return TdDestroyObject ((struct TdDownloadFile *)var);
    case CODE_EditCustomLanguagePackInfo: return TdDestroyObject ((struct TdEditCustomLanguagePackInfo *)var);
    case CODE_EditInlineMessageCaption: return TdDestroyObject ((struct TdEditInlineMessageCaption *)var);
    case CODE_EditInlineMessageLiveLocation: return TdDestroyObject ((struct TdEditInlineMessageLiveLocation *)var);
    case CODE_EditInlineMessageMedia: return TdDestroyObject ((struct TdEditInlineMessageMedia *)var);
    case CODE_EditInlineMessageReplyMarkup: return TdDestroyObject ((struct TdEditInlineMessageReplyMarkup *)var);
    case CODE_EditInlineMessageText: return TdDestroyObject ((struct TdEditInlineMessageText *)var);
    case CODE_EditMessageCaption: return TdDestroyObject ((struct TdEditMessageCaption *)var);
    case CODE_EditMessageLiveLocation: return TdDestroyObject ((struct TdEditMessageLiveLocation *)var);
    case CODE_EditMessageMedia: return TdDestroyObject ((struct TdEditMessageMedia *)var);
    case CODE_EditMessageReplyMarkup: return TdDestroyObject ((struct TdEditMessageReplyMarkup *)var);
    case CODE_EditMessageText: return TdDestroyObject ((struct TdEditMessageText *)var);
    case CODE_EditProxy: return TdDestroyObject ((struct TdEditProxy *)var);
    case CODE_EnableProxy: return TdDestroyObject ((struct TdEnableProxy *)var);
    case CODE_FinishFileGeneration: return TdDestroyObject ((struct TdFinishFileGeneration *)var);
    case CODE_ForwardMessages: return TdDestroyObject ((struct TdForwardMessages *)var);
    case CODE_GenerateChatInviteLink: return TdDestroyObject ((struct TdGenerateChatInviteLink *)var);
    case CODE_GetAccountTtl: return TdDestroyObject ((struct TdGetAccountTtl *)var);
    case CODE_GetActiveLiveLocationMessages: return TdDestroyObject ((struct TdGetActiveLiveLocationMessages *)var);
    case CODE_GetActiveSessions: return TdDestroyObject ((struct TdGetActiveSessions *)var);
    case CODE_GetAllPassportElements: return TdDestroyObject ((struct TdGetAllPassportElements *)var);
    case CODE_GetArchivedStickerSets: return TdDestroyObject ((struct TdGetArchivedStickerSets *)var);
    case CODE_GetAttachedStickerSets: return TdDestroyObject ((struct TdGetAttachedStickerSets *)var);
    case CODE_GetAuthorizationState: return TdDestroyObject ((struct TdGetAuthorizationState *)var);
    case CODE_GetBasicGroup: return TdDestroyObject ((struct TdGetBasicGroup *)var);
    case CODE_GetBasicGroupFullInfo: return TdDestroyObject ((struct TdGetBasicGroupFullInfo *)var);
    case CODE_GetBlockedUsers: return TdDestroyObject ((struct TdGetBlockedUsers *)var);
    case CODE_GetCallbackQueryAnswer: return TdDestroyObject ((struct TdGetCallbackQueryAnswer *)var);
    case CODE_GetChat: return TdDestroyObject ((struct TdGetChat *)var);
    case CODE_GetChatAdministrators: return TdDestroyObject ((struct TdGetChatAdministrators *)var);
    case CODE_GetChatEventLog: return TdDestroyObject ((struct TdGetChatEventLog *)var);
    case CODE_GetChatHistory: return TdDestroyObject ((struct TdGetChatHistory *)var);
    case CODE_GetChatMember: return TdDestroyObject ((struct TdGetChatMember *)var);
    case CODE_GetChatMessageByDate: return TdDestroyObject ((struct TdGetChatMessageByDate *)var);
    case CODE_GetChatMessageCount: return TdDestroyObject ((struct TdGetChatMessageCount *)var);
    case CODE_GetChatPinnedMessage: return TdDestroyObject ((struct TdGetChatPinnedMessage *)var);
    case CODE_GetChatReportSpamState: return TdDestroyObject ((struct TdGetChatReportSpamState *)var);
    case CODE_GetChats: return TdDestroyObject ((struct TdGetChats *)var);
    case CODE_GetConnectedWebsites: return TdDestroyObject ((struct TdGetConnectedWebsites *)var);
    case CODE_GetContacts: return TdDestroyObject ((struct TdGetContacts *)var);
    case CODE_GetCountryCode: return TdDestroyObject ((struct TdGetCountryCode *)var);
    case CODE_GetCreatedPublicChats: return TdDestroyObject ((struct TdGetCreatedPublicChats *)var);
    case CODE_GetDeepLinkInfo: return TdDestroyObject ((struct TdGetDeepLinkInfo *)var);
    case CODE_GetFavoriteStickers: return TdDestroyObject ((struct TdGetFavoriteStickers *)var);
    case CODE_GetFile: return TdDestroyObject ((struct TdGetFile *)var);
    case CODE_GetFileExtension: return TdDestroyObject ((struct TdGetFileExtension *)var);
    case CODE_GetFileMimeType: return TdDestroyObject ((struct TdGetFileMimeType *)var);
    case CODE_GetGameHighScores: return TdDestroyObject ((struct TdGetGameHighScores *)var);
    case CODE_GetGroupsInCommon: return TdDestroyObject ((struct TdGetGroupsInCommon *)var);
    case CODE_GetImportedContactCount: return TdDestroyObject ((struct TdGetImportedContactCount *)var);
    case CODE_GetInlineGameHighScores: return TdDestroyObject ((struct TdGetInlineGameHighScores *)var);
    case CODE_GetInlineQueryResults: return TdDestroyObject ((struct TdGetInlineQueryResults *)var);
    case CODE_GetInstalledStickerSets: return TdDestroyObject ((struct TdGetInstalledStickerSets *)var);
    case CODE_GetInviteText: return TdDestroyObject ((struct TdGetInviteText *)var);
    case CODE_GetLanguagePackString: return TdDestroyObject ((struct TdGetLanguagePackString *)var);
    case CODE_GetLanguagePackStrings: return TdDestroyObject ((struct TdGetLanguagePackStrings *)var);
    case CODE_GetLocalizationTargetInfo: return TdDestroyObject ((struct TdGetLocalizationTargetInfo *)var);
    case CODE_GetMapThumbnailFile: return TdDestroyObject ((struct TdGetMapThumbnailFile *)var);
    case CODE_GetMe: return TdDestroyObject ((struct TdGetMe *)var);
    case CODE_GetMessage: return TdDestroyObject ((struct TdGetMessage *)var);
    case CODE_GetMessages: return TdDestroyObject ((struct TdGetMessages *)var);
    case CODE_GetNetworkStatistics: return TdDestroyObject ((struct TdGetNetworkStatistics *)var);
    case CODE_GetOption: return TdDestroyObject ((struct TdGetOption *)var);
    case CODE_GetPassportAuthorizationForm: return TdDestroyObject ((struct TdGetPassportAuthorizationForm *)var);
    case CODE_GetPassportElement: return TdDestroyObject ((struct TdGetPassportElement *)var);
    case CODE_GetPasswordState: return TdDestroyObject ((struct TdGetPasswordState *)var);
    case CODE_GetPaymentForm: return TdDestroyObject ((struct TdGetPaymentForm *)var);
    case CODE_GetPaymentReceipt: return TdDestroyObject ((struct TdGetPaymentReceipt *)var);
    case CODE_GetPreferredCountryLanguage: return TdDestroyObject ((struct TdGetPreferredCountryLanguage *)var);
    case CODE_GetProxies: return TdDestroyObject ((struct TdGetProxies *)var);
    case CODE_GetProxyLink: return TdDestroyObject ((struct TdGetProxyLink *)var);
    case CODE_GetPublicMessageLink: return TdDestroyObject ((struct TdGetPublicMessageLink *)var);
    case CODE_GetRecentInlineBots: return TdDestroyObject ((struct TdGetRecentInlineBots *)var);
    case CODE_GetRecentStickers: return TdDestroyObject ((struct TdGetRecentStickers *)var);
    case CODE_GetRecentlyVisitedTMeUrls: return TdDestroyObject ((struct TdGetRecentlyVisitedTMeUrls *)var);
    case CODE_GetRecoveryEmailAddress: return TdDestroyObject ((struct TdGetRecoveryEmailAddress *)var);
    case CODE_GetRemoteFile: return TdDestroyObject ((struct TdGetRemoteFile *)var);
    case CODE_GetRepliedMessage: return TdDestroyObject ((struct TdGetRepliedMessage *)var);
    case CODE_GetSavedAnimations: return TdDestroyObject ((struct TdGetSavedAnimations *)var);
    case CODE_GetSavedOrderInfo: return TdDestroyObject ((struct TdGetSavedOrderInfo *)var);
    case CODE_GetScopeNotificationSettings: return TdDestroyObject ((struct TdGetScopeNotificationSettings *)var);
    case CODE_GetSecretChat: return TdDestroyObject ((struct TdGetSecretChat *)var);
    case CODE_GetStickerEmojis: return TdDestroyObject ((struct TdGetStickerEmojis *)var);
    case CODE_GetStickerSet: return TdDestroyObject ((struct TdGetStickerSet *)var);
    case CODE_GetStickers: return TdDestroyObject ((struct TdGetStickers *)var);
    case CODE_GetStorageStatistics: return TdDestroyObject ((struct TdGetStorageStatistics *)var);
    case CODE_GetStorageStatisticsFast: return TdDestroyObject ((struct TdGetStorageStatisticsFast *)var);
    case CODE_GetSupergroup: return TdDestroyObject ((struct TdGetSupergroup *)var);
    case CODE_GetSupergroupFullInfo: return TdDestroyObject ((struct TdGetSupergroupFullInfo *)var);
    case CODE_GetSupergroupMembers: return TdDestroyObject ((struct TdGetSupergroupMembers *)var);
    case CODE_GetSupportUser: return TdDestroyObject ((struct TdGetSupportUser *)var);
    case CODE_GetTemporaryPasswordState: return TdDestroyObject ((struct TdGetTemporaryPasswordState *)var);
    case CODE_GetTextEntities: return TdDestroyObject ((struct TdGetTextEntities *)var);
    case CODE_GetTopChats: return TdDestroyObject ((struct TdGetTopChats *)var);
    case CODE_GetTrendingStickerSets: return TdDestroyObject ((struct TdGetTrendingStickerSets *)var);
    case CODE_GetUser: return TdDestroyObject ((struct TdGetUser *)var);
    case CODE_GetUserFullInfo: return TdDestroyObject ((struct TdGetUserFullInfo *)var);
    case CODE_GetUserPrivacySettingRules: return TdDestroyObject ((struct TdGetUserPrivacySettingRules *)var);
    case CODE_GetUserProfilePhotos: return TdDestroyObject ((struct TdGetUserProfilePhotos *)var);
    case CODE_GetWallpapers: return TdDestroyObject ((struct TdGetWallpapers *)var);
    case CODE_GetWebPageInstantView: return TdDestroyObject ((struct TdGetWebPageInstantView *)var);
    case CODE_GetWebPagePreview: return TdDestroyObject ((struct TdGetWebPagePreview *)var);
    case CODE_ImportContacts: return TdDestroyObject ((struct TdImportContacts *)var);
    case CODE_JoinChat: return TdDestroyObject ((struct TdJoinChat *)var);
    case CODE_JoinChatByInviteLink: return TdDestroyObject ((struct TdJoinChatByInviteLink *)var);
    case CODE_LeaveChat: return TdDestroyObject ((struct TdLeaveChat *)var);
    case CODE_LogOut: return TdDestroyObject ((struct TdLogOut *)var);
    case CODE_OpenChat: return TdDestroyObject ((struct TdOpenChat *)var);
    case CODE_OpenMessageContent: return TdDestroyObject ((struct TdOpenMessageContent *)var);
    case CODE_OptimizeStorage: return TdDestroyObject ((struct TdOptimizeStorage *)var);
    case CODE_ParseTextEntities: return TdDestroyObject ((struct TdParseTextEntities *)var);
    case CODE_PinSupergroupMessage: return TdDestroyObject ((struct TdPinSupergroupMessage *)var);
    case CODE_PingProxy: return TdDestroyObject ((struct TdPingProxy *)var);
    case CODE_ProcessDcUpdate: return TdDestroyObject ((struct TdProcessDcUpdate *)var);
    case CODE_ReadAllChatMentions: return TdDestroyObject ((struct TdReadAllChatMentions *)var);
    case CODE_RecoverAuthenticationPassword: return TdDestroyObject ((struct TdRecoverAuthenticationPassword *)var);
    case CODE_RecoverPassword: return TdDestroyObject ((struct TdRecoverPassword *)var);
    case CODE_RegisterDevice: return TdDestroyObject ((struct TdRegisterDevice *)var);
    case CODE_RemoveContacts: return TdDestroyObject ((struct TdRemoveContacts *)var);
    case CODE_RemoveFavoriteSticker: return TdDestroyObject ((struct TdRemoveFavoriteSticker *)var);
    case CODE_RemoveProxy: return TdDestroyObject ((struct TdRemoveProxy *)var);
    case CODE_RemoveRecentHashtag: return TdDestroyObject ((struct TdRemoveRecentHashtag *)var);
    case CODE_RemoveRecentSticker: return TdDestroyObject ((struct TdRemoveRecentSticker *)var);
    case CODE_RemoveRecentlyFoundChat: return TdDestroyObject ((struct TdRemoveRecentlyFoundChat *)var);
    case CODE_RemoveSavedAnimation: return TdDestroyObject ((struct TdRemoveSavedAnimation *)var);
    case CODE_RemoveStickerFromSet: return TdDestroyObject ((struct TdRemoveStickerFromSet *)var);
    case CODE_RemoveTopChat: return TdDestroyObject ((struct TdRemoveTopChat *)var);
    case CODE_ReorderInstalledStickerSets: return TdDestroyObject ((struct TdReorderInstalledStickerSets *)var);
    case CODE_ReportChat: return TdDestroyObject ((struct TdReportChat *)var);
    case CODE_ReportSupergroupSpam: return TdDestroyObject ((struct TdReportSupergroupSpam *)var);
    case CODE_RequestAuthenticationPasswordRecovery: return TdDestroyObject ((struct TdRequestAuthenticationPasswordRecovery *)var);
    case CODE_RequestPasswordRecovery: return TdDestroyObject ((struct TdRequestPasswordRecovery *)var);
    case CODE_ResendAuthenticationCode: return TdDestroyObject ((struct TdResendAuthenticationCode *)var);
    case CODE_ResendChangePhoneNumberCode: return TdDestroyObject ((struct TdResendChangePhoneNumberCode *)var);
    case CODE_ResendEmailAddressVerificationCode: return TdDestroyObject ((struct TdResendEmailAddressVerificationCode *)var);
    case CODE_ResendPhoneNumberConfirmationCode: return TdDestroyObject ((struct TdResendPhoneNumberConfirmationCode *)var);
    case CODE_ResendPhoneNumberVerificationCode: return TdDestroyObject ((struct TdResendPhoneNumberVerificationCode *)var);
    case CODE_ResetAllNotificationSettings: return TdDestroyObject ((struct TdResetAllNotificationSettings *)var);
    case CODE_ResetNetworkStatistics: return TdDestroyObject ((struct TdResetNetworkStatistics *)var);
    case CODE_SearchCallMessages: return TdDestroyObject ((struct TdSearchCallMessages *)var);
    case CODE_SearchChatMembers: return TdDestroyObject ((struct TdSearchChatMembers *)var);
    case CODE_SearchChatMessages: return TdDestroyObject ((struct TdSearchChatMessages *)var);
    case CODE_SearchChatRecentLocationMessages: return TdDestroyObject ((struct TdSearchChatRecentLocationMessages *)var);
    case CODE_SearchChats: return TdDestroyObject ((struct TdSearchChats *)var);
    case CODE_SearchChatsOnServer: return TdDestroyObject ((struct TdSearchChatsOnServer *)var);
    case CODE_SearchContacts: return TdDestroyObject ((struct TdSearchContacts *)var);
    case CODE_SearchHashtags: return TdDestroyObject ((struct TdSearchHashtags *)var);
    case CODE_SearchInstalledStickerSets: return TdDestroyObject ((struct TdSearchInstalledStickerSets *)var);
    case CODE_SearchMessages: return TdDestroyObject ((struct TdSearchMessages *)var);
    case CODE_SearchPublicChat: return TdDestroyObject ((struct TdSearchPublicChat *)var);
    case CODE_SearchPublicChats: return TdDestroyObject ((struct TdSearchPublicChats *)var);
    case CODE_SearchSecretMessages: return TdDestroyObject ((struct TdSearchSecretMessages *)var);
    case CODE_SearchStickerSet: return TdDestroyObject ((struct TdSearchStickerSet *)var);
    case CODE_SearchStickerSets: return TdDestroyObject ((struct TdSearchStickerSets *)var);
    case CODE_SearchStickers: return TdDestroyObject ((struct TdSearchStickers *)var);
    case CODE_SendBotStartMessage: return TdDestroyObject ((struct TdSendBotStartMessage *)var);
    case CODE_SendCallDebugInformation: return TdDestroyObject ((struct TdSendCallDebugInformation *)var);
    case CODE_SendCallRating: return TdDestroyObject ((struct TdSendCallRating *)var);
    case CODE_SendChatAction: return TdDestroyObject ((struct TdSendChatAction *)var);
    case CODE_SendChatScreenshotTakenNotification: return TdDestroyObject ((struct TdSendChatScreenshotTakenNotification *)var);
    case CODE_SendChatSetTtlMessage: return TdDestroyObject ((struct TdSendChatSetTtlMessage *)var);
    case CODE_SendCustomRequest: return TdDestroyObject ((struct TdSendCustomRequest *)var);
    case CODE_SendEmailAddressVerificationCode: return TdDestroyObject ((struct TdSendEmailAddressVerificationCode *)var);
    case CODE_SendInlineQueryResultMessage: return TdDestroyObject ((struct TdSendInlineQueryResultMessage *)var);
    case CODE_SendMessage: return TdDestroyObject ((struct TdSendMessage *)var);
    case CODE_SendMessageAlbum: return TdDestroyObject ((struct TdSendMessageAlbum *)var);
    case CODE_SendPassportAuthorizationForm: return TdDestroyObject ((struct TdSendPassportAuthorizationForm *)var);
    case CODE_SendPaymentForm: return TdDestroyObject ((struct TdSendPaymentForm *)var);
    case CODE_SendPhoneNumberConfirmationCode: return TdDestroyObject ((struct TdSendPhoneNumberConfirmationCode *)var);
    case CODE_SendPhoneNumberVerificationCode: return TdDestroyObject ((struct TdSendPhoneNumberVerificationCode *)var);
    case CODE_SetAccountTtl: return TdDestroyObject ((struct TdSetAccountTtl *)var);
    case CODE_SetAlarm: return TdDestroyObject ((struct TdSetAlarm *)var);
    case CODE_SetAuthenticationPhoneNumber: return TdDestroyObject ((struct TdSetAuthenticationPhoneNumber *)var);
    case CODE_SetBio: return TdDestroyObject ((struct TdSetBio *)var);
    case CODE_SetBotUpdatesStatus: return TdDestroyObject ((struct TdSetBotUpdatesStatus *)var);
    case CODE_SetChatClientData: return TdDestroyObject ((struct TdSetChatClientData *)var);
    case CODE_SetChatDraftMessage: return TdDestroyObject ((struct TdSetChatDraftMessage *)var);
    case CODE_SetChatMemberStatus: return TdDestroyObject ((struct TdSetChatMemberStatus *)var);
    case CODE_SetChatNotificationSettings: return TdDestroyObject ((struct TdSetChatNotificationSettings *)var);
    case CODE_SetChatPhoto: return TdDestroyObject ((struct TdSetChatPhoto *)var);
    case CODE_SetChatTitle: return TdDestroyObject ((struct TdSetChatTitle *)var);
    case CODE_SetCustomLanguagePack: return TdDestroyObject ((struct TdSetCustomLanguagePack *)var);
    case CODE_SetCustomLanguagePackString: return TdDestroyObject ((struct TdSetCustomLanguagePackString *)var);
    case CODE_SetDatabaseEncryptionKey: return TdDestroyObject ((struct TdSetDatabaseEncryptionKey *)var);
    case CODE_SetFileGenerationProgress: return TdDestroyObject ((struct TdSetFileGenerationProgress *)var);
    case CODE_SetGameScore: return TdDestroyObject ((struct TdSetGameScore *)var);
    case CODE_SetInlineGameScore: return TdDestroyObject ((struct TdSetInlineGameScore *)var);
    case CODE_SetName: return TdDestroyObject ((struct TdSetName *)var);
    case CODE_SetNetworkType: return TdDestroyObject ((struct TdSetNetworkType *)var);
    case CODE_SetOption: return TdDestroyObject ((struct TdSetOption *)var);
    case CODE_SetPassportElement: return TdDestroyObject ((struct TdSetPassportElement *)var);
    case CODE_SetPassportElementErrors: return TdDestroyObject ((struct TdSetPassportElementErrors *)var);
    case CODE_SetPassword: return TdDestroyObject ((struct TdSetPassword *)var);
    case CODE_SetPinnedChats: return TdDestroyObject ((struct TdSetPinnedChats *)var);
    case CODE_SetProfilePhoto: return TdDestroyObject ((struct TdSetProfilePhoto *)var);
    case CODE_SetRecoveryEmailAddress: return TdDestroyObject ((struct TdSetRecoveryEmailAddress *)var);
    case CODE_SetScopeNotificationSettings: return TdDestroyObject ((struct TdSetScopeNotificationSettings *)var);
    case CODE_SetStickerPositionInSet: return TdDestroyObject ((struct TdSetStickerPositionInSet *)var);
    case CODE_SetSupergroupDescription: return TdDestroyObject ((struct TdSetSupergroupDescription *)var);
    case CODE_SetSupergroupStickerSet: return TdDestroyObject ((struct TdSetSupergroupStickerSet *)var);
    case CODE_SetSupergroupUsername: return TdDestroyObject ((struct TdSetSupergroupUsername *)var);
    case CODE_SetTdlibParameters: return TdDestroyObject ((struct TdSetTdlibParameters *)var);
    case CODE_SetUserPrivacySettingRules: return TdDestroyObject ((struct TdSetUserPrivacySettingRules *)var);
    case CODE_SetUsername: return TdDestroyObject ((struct TdSetUsername *)var);
    case CODE_TerminateAllOtherSessions: return TdDestroyObject ((struct TdTerminateAllOtherSessions *)var);
    case CODE_TerminateSession: return TdDestroyObject ((struct TdTerminateSession *)var);
    case CODE_TestCallBytes: return TdDestroyObject ((struct TdTestCallBytes *)var);
    case CODE_TestCallEmpty: return TdDestroyObject ((struct TdTestCallEmpty *)var);
    case CODE_TestCallString: return TdDestroyObject ((struct TdTestCallString *)var);
    case CODE_TestCallVectorInt: return TdDestroyObject ((struct TdTestCallVectorInt *)var);
    case CODE_TestCallVectorIntObject: return TdDestroyObject ((struct TdTestCallVectorIntObject *)var);
    case CODE_TestCallVectorString: return TdDestroyObject ((struct TdTestCallVectorString *)var);
    case CODE_TestCallVectorStringObject: return TdDestroyObject ((struct TdTestCallVectorStringObject *)var);
    case CODE_TestGetDifference: return TdDestroyObject ((struct TdTestGetDifference *)var);
    case CODE_TestNetwork: return TdDestroyObject ((struct TdTestNetwork *)var);
    case CODE_TestSquareInt: return TdDestroyObject ((struct TdTestSquareInt *)var);
    case CODE_TestUseError: return TdDestroyObject ((struct TdTestUseError *)var);
    case CODE_TestUseUpdate: return TdDestroyObject ((struct TdTestUseUpdate *)var);
    case CODE_ToggleBasicGroupAdministrators: return TdDestroyObject ((struct TdToggleBasicGroupAdministrators *)var);
    case CODE_ToggleChatDefaultDisableNotification: return TdDestroyObject ((struct TdToggleChatDefaultDisableNotification *)var);
    case CODE_ToggleChatIsMarkedAsUnread: return TdDestroyObject ((struct TdToggleChatIsMarkedAsUnread *)var);
    case CODE_ToggleChatIsPinned: return TdDestroyObject ((struct TdToggleChatIsPinned *)var);
    case CODE_ToggleSupergroupInvites: return TdDestroyObject ((struct TdToggleSupergroupInvites *)var);
    case CODE_ToggleSupergroupIsAllHistoryAvailable: return TdDestroyObject ((struct TdToggleSupergroupIsAllHistoryAvailable *)var);
    case CODE_ToggleSupergroupSignMessages: return TdDestroyObject ((struct TdToggleSupergroupSignMessages *)var);
    case CODE_UnblockUser: return TdDestroyObject ((struct TdUnblockUser *)var);
    case CODE_UnpinSupergroupMessage: return TdDestroyObject ((struct TdUnpinSupergroupMessage *)var);
    case CODE_UpgradeBasicGroupChatToSupergroupChat: return TdDestroyObject ((struct TdUpgradeBasicGroupChatToSupergroupChat *)var);
    case CODE_UploadFile: return TdDestroyObject ((struct TdUploadFile *)var);
    case CODE_UploadStickerFile: return TdDestroyObject ((struct TdUploadStickerFile *)var);
    case CODE_ValidateOrderInfo: return TdDestroyObject ((struct TdValidateOrderInfo *)var);
    case CODE_ViewMessages: return TdDestroyObject ((struct TdViewMessages *)var);
    case CODE_ViewTrendingStickerSets: return TdDestroyObject ((struct TdViewTrendingStickerSets *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerFunction (struct TdFunction *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFunction *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AcceptCall: return TdStackStorer ((struct TdAcceptCall *)var, M);
    case CODE_AcceptTermsOfService: return TdStackStorer ((struct TdAcceptTermsOfService *)var, M);
    case CODE_AddChatMember: return TdStackStorer ((struct TdAddChatMember *)var, M);
    case CODE_AddChatMembers: return TdStackStorer ((struct TdAddChatMembers *)var, M);
    case CODE_AddFavoriteSticker: return TdStackStorer ((struct TdAddFavoriteSticker *)var, M);
    case CODE_AddLocalMessage: return TdStackStorer ((struct TdAddLocalMessage *)var, M);
    case CODE_AddNetworkStatistics: return TdStackStorer ((struct TdAddNetworkStatistics *)var, M);
    case CODE_AddProxy: return TdStackStorer ((struct TdAddProxy *)var, M);
    case CODE_AddRecentSticker: return TdStackStorer ((struct TdAddRecentSticker *)var, M);
    case CODE_AddRecentlyFoundChat: return TdStackStorer ((struct TdAddRecentlyFoundChat *)var, M);
    case CODE_AddSavedAnimation: return TdStackStorer ((struct TdAddSavedAnimation *)var, M);
    case CODE_AddStickerToSet: return TdStackStorer ((struct TdAddStickerToSet *)var, M);
    case CODE_AnswerCallbackQuery: return TdStackStorer ((struct TdAnswerCallbackQuery *)var, M);
    case CODE_AnswerCustomQuery: return TdStackStorer ((struct TdAnswerCustomQuery *)var, M);
    case CODE_AnswerInlineQuery: return TdStackStorer ((struct TdAnswerInlineQuery *)var, M);
    case CODE_AnswerPreCheckoutQuery: return TdStackStorer ((struct TdAnswerPreCheckoutQuery *)var, M);
    case CODE_AnswerShippingQuery: return TdStackStorer ((struct TdAnswerShippingQuery *)var, M);
    case CODE_BlockUser: return TdStackStorer ((struct TdBlockUser *)var, M);
    case CODE_CancelDownloadFile: return TdStackStorer ((struct TdCancelDownloadFile *)var, M);
    case CODE_CancelUploadFile: return TdStackStorer ((struct TdCancelUploadFile *)var, M);
    case CODE_ChangeChatReportSpamState: return TdStackStorer ((struct TdChangeChatReportSpamState *)var, M);
    case CODE_ChangeImportedContacts: return TdStackStorer ((struct TdChangeImportedContacts *)var, M);
    case CODE_ChangePhoneNumber: return TdStackStorer ((struct TdChangePhoneNumber *)var, M);
    case CODE_ChangeStickerSet: return TdStackStorer ((struct TdChangeStickerSet *)var, M);
    case CODE_CheckAuthenticationBotToken: return TdStackStorer ((struct TdCheckAuthenticationBotToken *)var, M);
    case CODE_CheckAuthenticationCode: return TdStackStorer ((struct TdCheckAuthenticationCode *)var, M);
    case CODE_CheckAuthenticationPassword: return TdStackStorer ((struct TdCheckAuthenticationPassword *)var, M);
    case CODE_CheckChangePhoneNumberCode: return TdStackStorer ((struct TdCheckChangePhoneNumberCode *)var, M);
    case CODE_CheckChatInviteLink: return TdStackStorer ((struct TdCheckChatInviteLink *)var, M);
    case CODE_CheckChatUsername: return TdStackStorer ((struct TdCheckChatUsername *)var, M);
    case CODE_CheckDatabaseEncryptionKey: return TdStackStorer ((struct TdCheckDatabaseEncryptionKey *)var, M);
    case CODE_CheckEmailAddressVerificationCode: return TdStackStorer ((struct TdCheckEmailAddressVerificationCode *)var, M);
    case CODE_CheckPhoneNumberConfirmationCode: return TdStackStorer ((struct TdCheckPhoneNumberConfirmationCode *)var, M);
    case CODE_CheckPhoneNumberVerificationCode: return TdStackStorer ((struct TdCheckPhoneNumberVerificationCode *)var, M);
    case CODE_CleanFileName: return TdStackStorer ((struct TdCleanFileName *)var, M);
    case CODE_ClearAllDraftMessages: return TdStackStorer ((struct TdClearAllDraftMessages *)var, M);
    case CODE_ClearImportedContacts: return TdStackStorer ((struct TdClearImportedContacts *)var, M);
    case CODE_ClearRecentStickers: return TdStackStorer ((struct TdClearRecentStickers *)var, M);
    case CODE_ClearRecentlyFoundChats: return TdStackStorer ((struct TdClearRecentlyFoundChats *)var, M);
    case CODE_Close: return TdStackStorer ((struct TdClose *)var, M);
    case CODE_CloseChat: return TdStackStorer ((struct TdCloseChat *)var, M);
    case CODE_CloseSecretChat: return TdStackStorer ((struct TdCloseSecretChat *)var, M);
    case CODE_CreateBasicGroupChat: return TdStackStorer ((struct TdCreateBasicGroupChat *)var, M);
    case CODE_CreateCall: return TdStackStorer ((struct TdCreateCall *)var, M);
    case CODE_CreateNewBasicGroupChat: return TdStackStorer ((struct TdCreateNewBasicGroupChat *)var, M);
    case CODE_CreateNewSecretChat: return TdStackStorer ((struct TdCreateNewSecretChat *)var, M);
    case CODE_CreateNewStickerSet: return TdStackStorer ((struct TdCreateNewStickerSet *)var, M);
    case CODE_CreateNewSupergroupChat: return TdStackStorer ((struct TdCreateNewSupergroupChat *)var, M);
    case CODE_CreatePrivateChat: return TdStackStorer ((struct TdCreatePrivateChat *)var, M);
    case CODE_CreateSecretChat: return TdStackStorer ((struct TdCreateSecretChat *)var, M);
    case CODE_CreateSupergroupChat: return TdStackStorer ((struct TdCreateSupergroupChat *)var, M);
    case CODE_CreateTemporaryPassword: return TdStackStorer ((struct TdCreateTemporaryPassword *)var, M);
    case CODE_DeleteAccount: return TdStackStorer ((struct TdDeleteAccount *)var, M);
    case CODE_DeleteChatHistory: return TdStackStorer ((struct TdDeleteChatHistory *)var, M);
    case CODE_DeleteChatMessagesFromUser: return TdStackStorer ((struct TdDeleteChatMessagesFromUser *)var, M);
    case CODE_DeleteChatReplyMarkup: return TdStackStorer ((struct TdDeleteChatReplyMarkup *)var, M);
    case CODE_DeleteFile: return TdStackStorer ((struct TdDeleteFile *)var, M);
    case CODE_DeleteLanguagePack: return TdStackStorer ((struct TdDeleteLanguagePack *)var, M);
    case CODE_DeleteMessages: return TdStackStorer ((struct TdDeleteMessages *)var, M);
    case CODE_DeletePassportElement: return TdStackStorer ((struct TdDeletePassportElement *)var, M);
    case CODE_DeleteProfilePhoto: return TdStackStorer ((struct TdDeleteProfilePhoto *)var, M);
    case CODE_DeleteSavedCredentials: return TdStackStorer ((struct TdDeleteSavedCredentials *)var, M);
    case CODE_DeleteSavedOrderInfo: return TdStackStorer ((struct TdDeleteSavedOrderInfo *)var, M);
    case CODE_DeleteSupergroup: return TdStackStorer ((struct TdDeleteSupergroup *)var, M);
    case CODE_Destroy: return TdStackStorer ((struct TdDestroy *)var, M);
    case CODE_DisableProxy: return TdStackStorer ((struct TdDisableProxy *)var, M);
    case CODE_DiscardCall: return TdStackStorer ((struct TdDiscardCall *)var, M);
    case CODE_DisconnectAllWebsites: return TdStackStorer ((struct TdDisconnectAllWebsites *)var, M);
    case CODE_DisconnectWebsite: return TdStackStorer ((struct TdDisconnectWebsite *)var, M);
    case CODE_DownloadFile: return TdStackStorer ((struct TdDownloadFile *)var, M);
    case CODE_EditCustomLanguagePackInfo: return TdStackStorer ((struct TdEditCustomLanguagePackInfo *)var, M);
    case CODE_EditInlineMessageCaption: return TdStackStorer ((struct TdEditInlineMessageCaption *)var, M);
    case CODE_EditInlineMessageLiveLocation: return TdStackStorer ((struct TdEditInlineMessageLiveLocation *)var, M);
    case CODE_EditInlineMessageMedia: return TdStackStorer ((struct TdEditInlineMessageMedia *)var, M);
    case CODE_EditInlineMessageReplyMarkup: return TdStackStorer ((struct TdEditInlineMessageReplyMarkup *)var, M);
    case CODE_EditInlineMessageText: return TdStackStorer ((struct TdEditInlineMessageText *)var, M);
    case CODE_EditMessageCaption: return TdStackStorer ((struct TdEditMessageCaption *)var, M);
    case CODE_EditMessageLiveLocation: return TdStackStorer ((struct TdEditMessageLiveLocation *)var, M);
    case CODE_EditMessageMedia: return TdStackStorer ((struct TdEditMessageMedia *)var, M);
    case CODE_EditMessageReplyMarkup: return TdStackStorer ((struct TdEditMessageReplyMarkup *)var, M);
    case CODE_EditMessageText: return TdStackStorer ((struct TdEditMessageText *)var, M);
    case CODE_EditProxy: return TdStackStorer ((struct TdEditProxy *)var, M);
    case CODE_EnableProxy: return TdStackStorer ((struct TdEnableProxy *)var, M);
    case CODE_FinishFileGeneration: return TdStackStorer ((struct TdFinishFileGeneration *)var, M);
    case CODE_ForwardMessages: return TdStackStorer ((struct TdForwardMessages *)var, M);
    case CODE_GenerateChatInviteLink: return TdStackStorer ((struct TdGenerateChatInviteLink *)var, M);
    case CODE_GetAccountTtl: return TdStackStorer ((struct TdGetAccountTtl *)var, M);
    case CODE_GetActiveLiveLocationMessages: return TdStackStorer ((struct TdGetActiveLiveLocationMessages *)var, M);
    case CODE_GetActiveSessions: return TdStackStorer ((struct TdGetActiveSessions *)var, M);
    case CODE_GetAllPassportElements: return TdStackStorer ((struct TdGetAllPassportElements *)var, M);
    case CODE_GetArchivedStickerSets: return TdStackStorer ((struct TdGetArchivedStickerSets *)var, M);
    case CODE_GetAttachedStickerSets: return TdStackStorer ((struct TdGetAttachedStickerSets *)var, M);
    case CODE_GetAuthorizationState: return TdStackStorer ((struct TdGetAuthorizationState *)var, M);
    case CODE_GetBasicGroup: return TdStackStorer ((struct TdGetBasicGroup *)var, M);
    case CODE_GetBasicGroupFullInfo: return TdStackStorer ((struct TdGetBasicGroupFullInfo *)var, M);
    case CODE_GetBlockedUsers: return TdStackStorer ((struct TdGetBlockedUsers *)var, M);
    case CODE_GetCallbackQueryAnswer: return TdStackStorer ((struct TdGetCallbackQueryAnswer *)var, M);
    case CODE_GetChat: return TdStackStorer ((struct TdGetChat *)var, M);
    case CODE_GetChatAdministrators: return TdStackStorer ((struct TdGetChatAdministrators *)var, M);
    case CODE_GetChatEventLog: return TdStackStorer ((struct TdGetChatEventLog *)var, M);
    case CODE_GetChatHistory: return TdStackStorer ((struct TdGetChatHistory *)var, M);
    case CODE_GetChatMember: return TdStackStorer ((struct TdGetChatMember *)var, M);
    case CODE_GetChatMessageByDate: return TdStackStorer ((struct TdGetChatMessageByDate *)var, M);
    case CODE_GetChatMessageCount: return TdStackStorer ((struct TdGetChatMessageCount *)var, M);
    case CODE_GetChatPinnedMessage: return TdStackStorer ((struct TdGetChatPinnedMessage *)var, M);
    case CODE_GetChatReportSpamState: return TdStackStorer ((struct TdGetChatReportSpamState *)var, M);
    case CODE_GetChats: return TdStackStorer ((struct TdGetChats *)var, M);
    case CODE_GetConnectedWebsites: return TdStackStorer ((struct TdGetConnectedWebsites *)var, M);
    case CODE_GetContacts: return TdStackStorer ((struct TdGetContacts *)var, M);
    case CODE_GetCountryCode: return TdStackStorer ((struct TdGetCountryCode *)var, M);
    case CODE_GetCreatedPublicChats: return TdStackStorer ((struct TdGetCreatedPublicChats *)var, M);
    case CODE_GetDeepLinkInfo: return TdStackStorer ((struct TdGetDeepLinkInfo *)var, M);
    case CODE_GetFavoriteStickers: return TdStackStorer ((struct TdGetFavoriteStickers *)var, M);
    case CODE_GetFile: return TdStackStorer ((struct TdGetFile *)var, M);
    case CODE_GetFileExtension: return TdStackStorer ((struct TdGetFileExtension *)var, M);
    case CODE_GetFileMimeType: return TdStackStorer ((struct TdGetFileMimeType *)var, M);
    case CODE_GetGameHighScores: return TdStackStorer ((struct TdGetGameHighScores *)var, M);
    case CODE_GetGroupsInCommon: return TdStackStorer ((struct TdGetGroupsInCommon *)var, M);
    case CODE_GetImportedContactCount: return TdStackStorer ((struct TdGetImportedContactCount *)var, M);
    case CODE_GetInlineGameHighScores: return TdStackStorer ((struct TdGetInlineGameHighScores *)var, M);
    case CODE_GetInlineQueryResults: return TdStackStorer ((struct TdGetInlineQueryResults *)var, M);
    case CODE_GetInstalledStickerSets: return TdStackStorer ((struct TdGetInstalledStickerSets *)var, M);
    case CODE_GetInviteText: return TdStackStorer ((struct TdGetInviteText *)var, M);
    case CODE_GetLanguagePackString: return TdStackStorer ((struct TdGetLanguagePackString *)var, M);
    case CODE_GetLanguagePackStrings: return TdStackStorer ((struct TdGetLanguagePackStrings *)var, M);
    case CODE_GetLocalizationTargetInfo: return TdStackStorer ((struct TdGetLocalizationTargetInfo *)var, M);
    case CODE_GetMapThumbnailFile: return TdStackStorer ((struct TdGetMapThumbnailFile *)var, M);
    case CODE_GetMe: return TdStackStorer ((struct TdGetMe *)var, M);
    case CODE_GetMessage: return TdStackStorer ((struct TdGetMessage *)var, M);
    case CODE_GetMessages: return TdStackStorer ((struct TdGetMessages *)var, M);
    case CODE_GetNetworkStatistics: return TdStackStorer ((struct TdGetNetworkStatistics *)var, M);
    case CODE_GetOption: return TdStackStorer ((struct TdGetOption *)var, M);
    case CODE_GetPassportAuthorizationForm: return TdStackStorer ((struct TdGetPassportAuthorizationForm *)var, M);
    case CODE_GetPassportElement: return TdStackStorer ((struct TdGetPassportElement *)var, M);
    case CODE_GetPasswordState: return TdStackStorer ((struct TdGetPasswordState *)var, M);
    case CODE_GetPaymentForm: return TdStackStorer ((struct TdGetPaymentForm *)var, M);
    case CODE_GetPaymentReceipt: return TdStackStorer ((struct TdGetPaymentReceipt *)var, M);
    case CODE_GetPreferredCountryLanguage: return TdStackStorer ((struct TdGetPreferredCountryLanguage *)var, M);
    case CODE_GetProxies: return TdStackStorer ((struct TdGetProxies *)var, M);
    case CODE_GetProxyLink: return TdStackStorer ((struct TdGetProxyLink *)var, M);
    case CODE_GetPublicMessageLink: return TdStackStorer ((struct TdGetPublicMessageLink *)var, M);
    case CODE_GetRecentInlineBots: return TdStackStorer ((struct TdGetRecentInlineBots *)var, M);
    case CODE_GetRecentStickers: return TdStackStorer ((struct TdGetRecentStickers *)var, M);
    case CODE_GetRecentlyVisitedTMeUrls: return TdStackStorer ((struct TdGetRecentlyVisitedTMeUrls *)var, M);
    case CODE_GetRecoveryEmailAddress: return TdStackStorer ((struct TdGetRecoveryEmailAddress *)var, M);
    case CODE_GetRemoteFile: return TdStackStorer ((struct TdGetRemoteFile *)var, M);
    case CODE_GetRepliedMessage: return TdStackStorer ((struct TdGetRepliedMessage *)var, M);
    case CODE_GetSavedAnimations: return TdStackStorer ((struct TdGetSavedAnimations *)var, M);
    case CODE_GetSavedOrderInfo: return TdStackStorer ((struct TdGetSavedOrderInfo *)var, M);
    case CODE_GetScopeNotificationSettings: return TdStackStorer ((struct TdGetScopeNotificationSettings *)var, M);
    case CODE_GetSecretChat: return TdStackStorer ((struct TdGetSecretChat *)var, M);
    case CODE_GetStickerEmojis: return TdStackStorer ((struct TdGetStickerEmojis *)var, M);
    case CODE_GetStickerSet: return TdStackStorer ((struct TdGetStickerSet *)var, M);
    case CODE_GetStickers: return TdStackStorer ((struct TdGetStickers *)var, M);
    case CODE_GetStorageStatistics: return TdStackStorer ((struct TdGetStorageStatistics *)var, M);
    case CODE_GetStorageStatisticsFast: return TdStackStorer ((struct TdGetStorageStatisticsFast *)var, M);
    case CODE_GetSupergroup: return TdStackStorer ((struct TdGetSupergroup *)var, M);
    case CODE_GetSupergroupFullInfo: return TdStackStorer ((struct TdGetSupergroupFullInfo *)var, M);
    case CODE_GetSupergroupMembers: return TdStackStorer ((struct TdGetSupergroupMembers *)var, M);
    case CODE_GetSupportUser: return TdStackStorer ((struct TdGetSupportUser *)var, M);
    case CODE_GetTemporaryPasswordState: return TdStackStorer ((struct TdGetTemporaryPasswordState *)var, M);
    case CODE_GetTextEntities: return TdStackStorer ((struct TdGetTextEntities *)var, M);
    case CODE_GetTopChats: return TdStackStorer ((struct TdGetTopChats *)var, M);
    case CODE_GetTrendingStickerSets: return TdStackStorer ((struct TdGetTrendingStickerSets *)var, M);
    case CODE_GetUser: return TdStackStorer ((struct TdGetUser *)var, M);
    case CODE_GetUserFullInfo: return TdStackStorer ((struct TdGetUserFullInfo *)var, M);
    case CODE_GetUserPrivacySettingRules: return TdStackStorer ((struct TdGetUserPrivacySettingRules *)var, M);
    case CODE_GetUserProfilePhotos: return TdStackStorer ((struct TdGetUserProfilePhotos *)var, M);
    case CODE_GetWallpapers: return TdStackStorer ((struct TdGetWallpapers *)var, M);
    case CODE_GetWebPageInstantView: return TdStackStorer ((struct TdGetWebPageInstantView *)var, M);
    case CODE_GetWebPagePreview: return TdStackStorer ((struct TdGetWebPagePreview *)var, M);
    case CODE_ImportContacts: return TdStackStorer ((struct TdImportContacts *)var, M);
    case CODE_JoinChat: return TdStackStorer ((struct TdJoinChat *)var, M);
    case CODE_JoinChatByInviteLink: return TdStackStorer ((struct TdJoinChatByInviteLink *)var, M);
    case CODE_LeaveChat: return TdStackStorer ((struct TdLeaveChat *)var, M);
    case CODE_LogOut: return TdStackStorer ((struct TdLogOut *)var, M);
    case CODE_OpenChat: return TdStackStorer ((struct TdOpenChat *)var, M);
    case CODE_OpenMessageContent: return TdStackStorer ((struct TdOpenMessageContent *)var, M);
    case CODE_OptimizeStorage: return TdStackStorer ((struct TdOptimizeStorage *)var, M);
    case CODE_ParseTextEntities: return TdStackStorer ((struct TdParseTextEntities *)var, M);
    case CODE_PinSupergroupMessage: return TdStackStorer ((struct TdPinSupergroupMessage *)var, M);
    case CODE_PingProxy: return TdStackStorer ((struct TdPingProxy *)var, M);
    case CODE_ProcessDcUpdate: return TdStackStorer ((struct TdProcessDcUpdate *)var, M);
    case CODE_ReadAllChatMentions: return TdStackStorer ((struct TdReadAllChatMentions *)var, M);
    case CODE_RecoverAuthenticationPassword: return TdStackStorer ((struct TdRecoverAuthenticationPassword *)var, M);
    case CODE_RecoverPassword: return TdStackStorer ((struct TdRecoverPassword *)var, M);
    case CODE_RegisterDevice: return TdStackStorer ((struct TdRegisterDevice *)var, M);
    case CODE_RemoveContacts: return TdStackStorer ((struct TdRemoveContacts *)var, M);
    case CODE_RemoveFavoriteSticker: return TdStackStorer ((struct TdRemoveFavoriteSticker *)var, M);
    case CODE_RemoveProxy: return TdStackStorer ((struct TdRemoveProxy *)var, M);
    case CODE_RemoveRecentHashtag: return TdStackStorer ((struct TdRemoveRecentHashtag *)var, M);
    case CODE_RemoveRecentSticker: return TdStackStorer ((struct TdRemoveRecentSticker *)var, M);
    case CODE_RemoveRecentlyFoundChat: return TdStackStorer ((struct TdRemoveRecentlyFoundChat *)var, M);
    case CODE_RemoveSavedAnimation: return TdStackStorer ((struct TdRemoveSavedAnimation *)var, M);
    case CODE_RemoveStickerFromSet: return TdStackStorer ((struct TdRemoveStickerFromSet *)var, M);
    case CODE_RemoveTopChat: return TdStackStorer ((struct TdRemoveTopChat *)var, M);
    case CODE_ReorderInstalledStickerSets: return TdStackStorer ((struct TdReorderInstalledStickerSets *)var, M);
    case CODE_ReportChat: return TdStackStorer ((struct TdReportChat *)var, M);
    case CODE_ReportSupergroupSpam: return TdStackStorer ((struct TdReportSupergroupSpam *)var, M);
    case CODE_RequestAuthenticationPasswordRecovery: return TdStackStorer ((struct TdRequestAuthenticationPasswordRecovery *)var, M);
    case CODE_RequestPasswordRecovery: return TdStackStorer ((struct TdRequestPasswordRecovery *)var, M);
    case CODE_ResendAuthenticationCode: return TdStackStorer ((struct TdResendAuthenticationCode *)var, M);
    case CODE_ResendChangePhoneNumberCode: return TdStackStorer ((struct TdResendChangePhoneNumberCode *)var, M);
    case CODE_ResendEmailAddressVerificationCode: return TdStackStorer ((struct TdResendEmailAddressVerificationCode *)var, M);
    case CODE_ResendPhoneNumberConfirmationCode: return TdStackStorer ((struct TdResendPhoneNumberConfirmationCode *)var, M);
    case CODE_ResendPhoneNumberVerificationCode: return TdStackStorer ((struct TdResendPhoneNumberVerificationCode *)var, M);
    case CODE_ResetAllNotificationSettings: return TdStackStorer ((struct TdResetAllNotificationSettings *)var, M);
    case CODE_ResetNetworkStatistics: return TdStackStorer ((struct TdResetNetworkStatistics *)var, M);
    case CODE_SearchCallMessages: return TdStackStorer ((struct TdSearchCallMessages *)var, M);
    case CODE_SearchChatMembers: return TdStackStorer ((struct TdSearchChatMembers *)var, M);
    case CODE_SearchChatMessages: return TdStackStorer ((struct TdSearchChatMessages *)var, M);
    case CODE_SearchChatRecentLocationMessages: return TdStackStorer ((struct TdSearchChatRecentLocationMessages *)var, M);
    case CODE_SearchChats: return TdStackStorer ((struct TdSearchChats *)var, M);
    case CODE_SearchChatsOnServer: return TdStackStorer ((struct TdSearchChatsOnServer *)var, M);
    case CODE_SearchContacts: return TdStackStorer ((struct TdSearchContacts *)var, M);
    case CODE_SearchHashtags: return TdStackStorer ((struct TdSearchHashtags *)var, M);
    case CODE_SearchInstalledStickerSets: return TdStackStorer ((struct TdSearchInstalledStickerSets *)var, M);
    case CODE_SearchMessages: return TdStackStorer ((struct TdSearchMessages *)var, M);
    case CODE_SearchPublicChat: return TdStackStorer ((struct TdSearchPublicChat *)var, M);
    case CODE_SearchPublicChats: return TdStackStorer ((struct TdSearchPublicChats *)var, M);
    case CODE_SearchSecretMessages: return TdStackStorer ((struct TdSearchSecretMessages *)var, M);
    case CODE_SearchStickerSet: return TdStackStorer ((struct TdSearchStickerSet *)var, M);
    case CODE_SearchStickerSets: return TdStackStorer ((struct TdSearchStickerSets *)var, M);
    case CODE_SearchStickers: return TdStackStorer ((struct TdSearchStickers *)var, M);
    case CODE_SendBotStartMessage: return TdStackStorer ((struct TdSendBotStartMessage *)var, M);
    case CODE_SendCallDebugInformation: return TdStackStorer ((struct TdSendCallDebugInformation *)var, M);
    case CODE_SendCallRating: return TdStackStorer ((struct TdSendCallRating *)var, M);
    case CODE_SendChatAction: return TdStackStorer ((struct TdSendChatAction *)var, M);
    case CODE_SendChatScreenshotTakenNotification: return TdStackStorer ((struct TdSendChatScreenshotTakenNotification *)var, M);
    case CODE_SendChatSetTtlMessage: return TdStackStorer ((struct TdSendChatSetTtlMessage *)var, M);
    case CODE_SendCustomRequest: return TdStackStorer ((struct TdSendCustomRequest *)var, M);
    case CODE_SendEmailAddressVerificationCode: return TdStackStorer ((struct TdSendEmailAddressVerificationCode *)var, M);
    case CODE_SendInlineQueryResultMessage: return TdStackStorer ((struct TdSendInlineQueryResultMessage *)var, M);
    case CODE_SendMessage: return TdStackStorer ((struct TdSendMessage *)var, M);
    case CODE_SendMessageAlbum: return TdStackStorer ((struct TdSendMessageAlbum *)var, M);
    case CODE_SendPassportAuthorizationForm: return TdStackStorer ((struct TdSendPassportAuthorizationForm *)var, M);
    case CODE_SendPaymentForm: return TdStackStorer ((struct TdSendPaymentForm *)var, M);
    case CODE_SendPhoneNumberConfirmationCode: return TdStackStorer ((struct TdSendPhoneNumberConfirmationCode *)var, M);
    case CODE_SendPhoneNumberVerificationCode: return TdStackStorer ((struct TdSendPhoneNumberVerificationCode *)var, M);
    case CODE_SetAccountTtl: return TdStackStorer ((struct TdSetAccountTtl *)var, M);
    case CODE_SetAlarm: return TdStackStorer ((struct TdSetAlarm *)var, M);
    case CODE_SetAuthenticationPhoneNumber: return TdStackStorer ((struct TdSetAuthenticationPhoneNumber *)var, M);
    case CODE_SetBio: return TdStackStorer ((struct TdSetBio *)var, M);
    case CODE_SetBotUpdatesStatus: return TdStackStorer ((struct TdSetBotUpdatesStatus *)var, M);
    case CODE_SetChatClientData: return TdStackStorer ((struct TdSetChatClientData *)var, M);
    case CODE_SetChatDraftMessage: return TdStackStorer ((struct TdSetChatDraftMessage *)var, M);
    case CODE_SetChatMemberStatus: return TdStackStorer ((struct TdSetChatMemberStatus *)var, M);
    case CODE_SetChatNotificationSettings: return TdStackStorer ((struct TdSetChatNotificationSettings *)var, M);
    case CODE_SetChatPhoto: return TdStackStorer ((struct TdSetChatPhoto *)var, M);
    case CODE_SetChatTitle: return TdStackStorer ((struct TdSetChatTitle *)var, M);
    case CODE_SetCustomLanguagePack: return TdStackStorer ((struct TdSetCustomLanguagePack *)var, M);
    case CODE_SetCustomLanguagePackString: return TdStackStorer ((struct TdSetCustomLanguagePackString *)var, M);
    case CODE_SetDatabaseEncryptionKey: return TdStackStorer ((struct TdSetDatabaseEncryptionKey *)var, M);
    case CODE_SetFileGenerationProgress: return TdStackStorer ((struct TdSetFileGenerationProgress *)var, M);
    case CODE_SetGameScore: return TdStackStorer ((struct TdSetGameScore *)var, M);
    case CODE_SetInlineGameScore: return TdStackStorer ((struct TdSetInlineGameScore *)var, M);
    case CODE_SetName: return TdStackStorer ((struct TdSetName *)var, M);
    case CODE_SetNetworkType: return TdStackStorer ((struct TdSetNetworkType *)var, M);
    case CODE_SetOption: return TdStackStorer ((struct TdSetOption *)var, M);
    case CODE_SetPassportElement: return TdStackStorer ((struct TdSetPassportElement *)var, M);
    case CODE_SetPassportElementErrors: return TdStackStorer ((struct TdSetPassportElementErrors *)var, M);
    case CODE_SetPassword: return TdStackStorer ((struct TdSetPassword *)var, M);
    case CODE_SetPinnedChats: return TdStackStorer ((struct TdSetPinnedChats *)var, M);
    case CODE_SetProfilePhoto: return TdStackStorer ((struct TdSetProfilePhoto *)var, M);
    case CODE_SetRecoveryEmailAddress: return TdStackStorer ((struct TdSetRecoveryEmailAddress *)var, M);
    case CODE_SetScopeNotificationSettings: return TdStackStorer ((struct TdSetScopeNotificationSettings *)var, M);
    case CODE_SetStickerPositionInSet: return TdStackStorer ((struct TdSetStickerPositionInSet *)var, M);
    case CODE_SetSupergroupDescription: return TdStackStorer ((struct TdSetSupergroupDescription *)var, M);
    case CODE_SetSupergroupStickerSet: return TdStackStorer ((struct TdSetSupergroupStickerSet *)var, M);
    case CODE_SetSupergroupUsername: return TdStackStorer ((struct TdSetSupergroupUsername *)var, M);
    case CODE_SetTdlibParameters: return TdStackStorer ((struct TdSetTdlibParameters *)var, M);
    case CODE_SetUserPrivacySettingRules: return TdStackStorer ((struct TdSetUserPrivacySettingRules *)var, M);
    case CODE_SetUsername: return TdStackStorer ((struct TdSetUsername *)var, M);
    case CODE_TerminateAllOtherSessions: return TdStackStorer ((struct TdTerminateAllOtherSessions *)var, M);
    case CODE_TerminateSession: return TdStackStorer ((struct TdTerminateSession *)var, M);
    case CODE_TestCallBytes: return TdStackStorer ((struct TdTestCallBytes *)var, M);
    case CODE_TestCallEmpty: return TdStackStorer ((struct TdTestCallEmpty *)var, M);
    case CODE_TestCallString: return TdStackStorer ((struct TdTestCallString *)var, M);
    case CODE_TestCallVectorInt: return TdStackStorer ((struct TdTestCallVectorInt *)var, M);
    case CODE_TestCallVectorIntObject: return TdStackStorer ((struct TdTestCallVectorIntObject *)var, M);
    case CODE_TestCallVectorString: return TdStackStorer ((struct TdTestCallVectorString *)var, M);
    case CODE_TestCallVectorStringObject: return TdStackStorer ((struct TdTestCallVectorStringObject *)var, M);
    case CODE_TestGetDifference: return TdStackStorer ((struct TdTestGetDifference *)var, M);
    case CODE_TestNetwork: return TdStackStorer ((struct TdTestNetwork *)var, M);
    case CODE_TestSquareInt: return TdStackStorer ((struct TdTestSquareInt *)var, M);
    case CODE_TestUseError: return TdStackStorer ((struct TdTestUseError *)var, M);
    case CODE_TestUseUpdate: return TdStackStorer ((struct TdTestUseUpdate *)var, M);
    case CODE_ToggleBasicGroupAdministrators: return TdStackStorer ((struct TdToggleBasicGroupAdministrators *)var, M);
    case CODE_ToggleChatDefaultDisableNotification: return TdStackStorer ((struct TdToggleChatDefaultDisableNotification *)var, M);
    case CODE_ToggleChatIsMarkedAsUnread: return TdStackStorer ((struct TdToggleChatIsMarkedAsUnread *)var, M);
    case CODE_ToggleChatIsPinned: return TdStackStorer ((struct TdToggleChatIsPinned *)var, M);
    case CODE_ToggleSupergroupInvites: return TdStackStorer ((struct TdToggleSupergroupInvites *)var, M);
    case CODE_ToggleSupergroupIsAllHistoryAvailable: return TdStackStorer ((struct TdToggleSupergroupIsAllHistoryAvailable *)var, M);
    case CODE_ToggleSupergroupSignMessages: return TdStackStorer ((struct TdToggleSupergroupSignMessages *)var, M);
    case CODE_UnblockUser: return TdStackStorer ((struct TdUnblockUser *)var, M);
    case CODE_UnpinSupergroupMessage: return TdStackStorer ((struct TdUnpinSupergroupMessage *)var, M);
    case CODE_UpgradeBasicGroupChatToSupergroupChat: return TdStackStorer ((struct TdUpgradeBasicGroupChatToSupergroupChat *)var, M);
    case CODE_UploadFile: return TdStackStorer ((struct TdUploadFile *)var, M);
    case CODE_UploadStickerFile: return TdStackStorer ((struct TdUploadStickerFile *)var, M);
    case CODE_ValidateOrderInfo: return TdStackStorer ((struct TdValidateOrderInfo *)var, M);
    case CODE_ViewMessages: return TdStackStorer ((struct TdViewMessages *)var, M);
    case CODE_ViewTrendingStickerSets: return TdStackStorer ((struct TdViewTrendingStickerSets *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdFunction *TdStackFetcherFunction (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "AcceptCall") {
    return (struct TdFunction *)TdStackFetcherAcceptCall (M);
  }
  if (constructor == "AcceptTermsOfService") {
    return (struct TdFunction *)TdStackFetcherAcceptTermsOfService (M);
  }
  if (constructor == "AddChatMember") {
    return (struct TdFunction *)TdStackFetcherAddChatMember (M);
  }
  if (constructor == "AddChatMembers") {
    return (struct TdFunction *)TdStackFetcherAddChatMembers (M);
  }
  if (constructor == "AddFavoriteSticker") {
    return (struct TdFunction *)TdStackFetcherAddFavoriteSticker (M);
  }
  if (constructor == "AddLocalMessage") {
    return (struct TdFunction *)TdStackFetcherAddLocalMessage (M);
  }
  if (constructor == "AddNetworkStatistics") {
    return (struct TdFunction *)TdStackFetcherAddNetworkStatistics (M);
  }
  if (constructor == "AddProxy") {
    return (struct TdFunction *)TdStackFetcherAddProxy (M);
  }
  if (constructor == "AddRecentSticker") {
    return (struct TdFunction *)TdStackFetcherAddRecentSticker (M);
  }
  if (constructor == "AddRecentlyFoundChat") {
    return (struct TdFunction *)TdStackFetcherAddRecentlyFoundChat (M);
  }
  if (constructor == "AddSavedAnimation") {
    return (struct TdFunction *)TdStackFetcherAddSavedAnimation (M);
  }
  if (constructor == "AddStickerToSet") {
    return (struct TdFunction *)TdStackFetcherAddStickerToSet (M);
  }
  if (constructor == "AnswerCallbackQuery") {
    return (struct TdFunction *)TdStackFetcherAnswerCallbackQuery (M);
  }
  if (constructor == "AnswerCustomQuery") {
    return (struct TdFunction *)TdStackFetcherAnswerCustomQuery (M);
  }
  if (constructor == "AnswerInlineQuery") {
    return (struct TdFunction *)TdStackFetcherAnswerInlineQuery (M);
  }
  if (constructor == "AnswerPreCheckoutQuery") {
    return (struct TdFunction *)TdStackFetcherAnswerPreCheckoutQuery (M);
  }
  if (constructor == "AnswerShippingQuery") {
    return (struct TdFunction *)TdStackFetcherAnswerShippingQuery (M);
  }
  if (constructor == "BlockUser") {
    return (struct TdFunction *)TdStackFetcherBlockUser (M);
  }
  if (constructor == "CancelDownloadFile") {
    return (struct TdFunction *)TdStackFetcherCancelDownloadFile (M);
  }
  if (constructor == "CancelUploadFile") {
    return (struct TdFunction *)TdStackFetcherCancelUploadFile (M);
  }
  if (constructor == "ChangeChatReportSpamState") {
    return (struct TdFunction *)TdStackFetcherChangeChatReportSpamState (M);
  }
  if (constructor == "ChangeImportedContacts") {
    return (struct TdFunction *)TdStackFetcherChangeImportedContacts (M);
  }
  if (constructor == "ChangePhoneNumber") {
    return (struct TdFunction *)TdStackFetcherChangePhoneNumber (M);
  }
  if (constructor == "ChangeStickerSet") {
    return (struct TdFunction *)TdStackFetcherChangeStickerSet (M);
  }
  if (constructor == "CheckAuthenticationBotToken") {
    return (struct TdFunction *)TdStackFetcherCheckAuthenticationBotToken (M);
  }
  if (constructor == "CheckAuthenticationCode") {
    return (struct TdFunction *)TdStackFetcherCheckAuthenticationCode (M);
  }
  if (constructor == "CheckAuthenticationPassword") {
    return (struct TdFunction *)TdStackFetcherCheckAuthenticationPassword (M);
  }
  if (constructor == "CheckChangePhoneNumberCode") {
    return (struct TdFunction *)TdStackFetcherCheckChangePhoneNumberCode (M);
  }
  if (constructor == "CheckChatInviteLink") {
    return (struct TdFunction *)TdStackFetcherCheckChatInviteLink (M);
  }
  if (constructor == "CheckChatUsername") {
    return (struct TdFunction *)TdStackFetcherCheckChatUsername (M);
  }
  if (constructor == "CheckDatabaseEncryptionKey") {
    return (struct TdFunction *)TdStackFetcherCheckDatabaseEncryptionKey (M);
  }
  if (constructor == "CheckEmailAddressVerificationCode") {
    return (struct TdFunction *)TdStackFetcherCheckEmailAddressVerificationCode (M);
  }
  if (constructor == "CheckPhoneNumberConfirmationCode") {
    return (struct TdFunction *)TdStackFetcherCheckPhoneNumberConfirmationCode (M);
  }
  if (constructor == "CheckPhoneNumberVerificationCode") {
    return (struct TdFunction *)TdStackFetcherCheckPhoneNumberVerificationCode (M);
  }
  if (constructor == "CleanFileName") {
    return (struct TdFunction *)TdStackFetcherCleanFileName (M);
  }
  if (constructor == "ClearAllDraftMessages") {
    return (struct TdFunction *)TdStackFetcherClearAllDraftMessages (M);
  }
  if (constructor == "ClearImportedContacts") {
    return (struct TdFunction *)TdStackFetcherClearImportedContacts (M);
  }
  if (constructor == "ClearRecentStickers") {
    return (struct TdFunction *)TdStackFetcherClearRecentStickers (M);
  }
  if (constructor == "ClearRecentlyFoundChats") {
    return (struct TdFunction *)TdStackFetcherClearRecentlyFoundChats (M);
  }
  if (constructor == "Close") {
    return (struct TdFunction *)TdStackFetcherClose (M);
  }
  if (constructor == "CloseChat") {
    return (struct TdFunction *)TdStackFetcherCloseChat (M);
  }
  if (constructor == "CloseSecretChat") {
    return (struct TdFunction *)TdStackFetcherCloseSecretChat (M);
  }
  if (constructor == "CreateBasicGroupChat") {
    return (struct TdFunction *)TdStackFetcherCreateBasicGroupChat (M);
  }
  if (constructor == "CreateCall") {
    return (struct TdFunction *)TdStackFetcherCreateCall (M);
  }
  if (constructor == "CreateNewBasicGroupChat") {
    return (struct TdFunction *)TdStackFetcherCreateNewBasicGroupChat (M);
  }
  if (constructor == "CreateNewSecretChat") {
    return (struct TdFunction *)TdStackFetcherCreateNewSecretChat (M);
  }
  if (constructor == "CreateNewStickerSet") {
    return (struct TdFunction *)TdStackFetcherCreateNewStickerSet (M);
  }
  if (constructor == "CreateNewSupergroupChat") {
    return (struct TdFunction *)TdStackFetcherCreateNewSupergroupChat (M);
  }
  if (constructor == "CreatePrivateChat") {
    return (struct TdFunction *)TdStackFetcherCreatePrivateChat (M);
  }
  if (constructor == "CreateSecretChat") {
    return (struct TdFunction *)TdStackFetcherCreateSecretChat (M);
  }
  if (constructor == "CreateSupergroupChat") {
    return (struct TdFunction *)TdStackFetcherCreateSupergroupChat (M);
  }
  if (constructor == "CreateTemporaryPassword") {
    return (struct TdFunction *)TdStackFetcherCreateTemporaryPassword (M);
  }
  if (constructor == "DeleteAccount") {
    return (struct TdFunction *)TdStackFetcherDeleteAccount (M);
  }
  if (constructor == "DeleteChatHistory") {
    return (struct TdFunction *)TdStackFetcherDeleteChatHistory (M);
  }
  if (constructor == "DeleteChatMessagesFromUser") {
    return (struct TdFunction *)TdStackFetcherDeleteChatMessagesFromUser (M);
  }
  if (constructor == "DeleteChatReplyMarkup") {
    return (struct TdFunction *)TdStackFetcherDeleteChatReplyMarkup (M);
  }
  if (constructor == "DeleteFile") {
    return (struct TdFunction *)TdStackFetcherDeleteFile (M);
  }
  if (constructor == "DeleteLanguagePack") {
    return (struct TdFunction *)TdStackFetcherDeleteLanguagePack (M);
  }
  if (constructor == "DeleteMessages") {
    return (struct TdFunction *)TdStackFetcherDeleteMessages (M);
  }
  if (constructor == "DeletePassportElement") {
    return (struct TdFunction *)TdStackFetcherDeletePassportElement (M);
  }
  if (constructor == "DeleteProfilePhoto") {
    return (struct TdFunction *)TdStackFetcherDeleteProfilePhoto (M);
  }
  if (constructor == "DeleteSavedCredentials") {
    return (struct TdFunction *)TdStackFetcherDeleteSavedCredentials (M);
  }
  if (constructor == "DeleteSavedOrderInfo") {
    return (struct TdFunction *)TdStackFetcherDeleteSavedOrderInfo (M);
  }
  if (constructor == "DeleteSupergroup") {
    return (struct TdFunction *)TdStackFetcherDeleteSupergroup (M);
  }
  if (constructor == "Destroy") {
    return (struct TdFunction *)TdStackFetcherDestroy (M);
  }
  if (constructor == "DisableProxy") {
    return (struct TdFunction *)TdStackFetcherDisableProxy (M);
  }
  if (constructor == "DiscardCall") {
    return (struct TdFunction *)TdStackFetcherDiscardCall (M);
  }
  if (constructor == "DisconnectAllWebsites") {
    return (struct TdFunction *)TdStackFetcherDisconnectAllWebsites (M);
  }
  if (constructor == "DisconnectWebsite") {
    return (struct TdFunction *)TdStackFetcherDisconnectWebsite (M);
  }
  if (constructor == "DownloadFile") {
    return (struct TdFunction *)TdStackFetcherDownloadFile (M);
  }
  if (constructor == "EditCustomLanguagePackInfo") {
    return (struct TdFunction *)TdStackFetcherEditCustomLanguagePackInfo (M);
  }
  if (constructor == "EditInlineMessageCaption") {
    return (struct TdFunction *)TdStackFetcherEditInlineMessageCaption (M);
  }
  if (constructor == "EditInlineMessageLiveLocation") {
    return (struct TdFunction *)TdStackFetcherEditInlineMessageLiveLocation (M);
  }
  if (constructor == "EditInlineMessageMedia") {
    return (struct TdFunction *)TdStackFetcherEditInlineMessageMedia (M);
  }
  if (constructor == "EditInlineMessageReplyMarkup") {
    return (struct TdFunction *)TdStackFetcherEditInlineMessageReplyMarkup (M);
  }
  if (constructor == "EditInlineMessageText") {
    return (struct TdFunction *)TdStackFetcherEditInlineMessageText (M);
  }
  if (constructor == "EditMessageCaption") {
    return (struct TdFunction *)TdStackFetcherEditMessageCaption (M);
  }
  if (constructor == "EditMessageLiveLocation") {
    return (struct TdFunction *)TdStackFetcherEditMessageLiveLocation (M);
  }
  if (constructor == "EditMessageMedia") {
    return (struct TdFunction *)TdStackFetcherEditMessageMedia (M);
  }
  if (constructor == "EditMessageReplyMarkup") {
    return (struct TdFunction *)TdStackFetcherEditMessageReplyMarkup (M);
  }
  if (constructor == "EditMessageText") {
    return (struct TdFunction *)TdStackFetcherEditMessageText (M);
  }
  if (constructor == "EditProxy") {
    return (struct TdFunction *)TdStackFetcherEditProxy (M);
  }
  if (constructor == "EnableProxy") {
    return (struct TdFunction *)TdStackFetcherEnableProxy (M);
  }
  if (constructor == "FinishFileGeneration") {
    return (struct TdFunction *)TdStackFetcherFinishFileGeneration (M);
  }
  if (constructor == "ForwardMessages") {
    return (struct TdFunction *)TdStackFetcherForwardMessages (M);
  }
  if (constructor == "GenerateChatInviteLink") {
    return (struct TdFunction *)TdStackFetcherGenerateChatInviteLink (M);
  }
  if (constructor == "GetAccountTtl") {
    return (struct TdFunction *)TdStackFetcherGetAccountTtl (M);
  }
  if (constructor == "GetActiveLiveLocationMessages") {
    return (struct TdFunction *)TdStackFetcherGetActiveLiveLocationMessages (M);
  }
  if (constructor == "GetActiveSessions") {
    return (struct TdFunction *)TdStackFetcherGetActiveSessions (M);
  }
  if (constructor == "GetAllPassportElements") {
    return (struct TdFunction *)TdStackFetcherGetAllPassportElements (M);
  }
  if (constructor == "GetArchivedStickerSets") {
    return (struct TdFunction *)TdStackFetcherGetArchivedStickerSets (M);
  }
  if (constructor == "GetAttachedStickerSets") {
    return (struct TdFunction *)TdStackFetcherGetAttachedStickerSets (M);
  }
  if (constructor == "GetAuthorizationState") {
    return (struct TdFunction *)TdStackFetcherGetAuthorizationState (M);
  }
  if (constructor == "GetBasicGroup") {
    return (struct TdFunction *)TdStackFetcherGetBasicGroup (M);
  }
  if (constructor == "GetBasicGroupFullInfo") {
    return (struct TdFunction *)TdStackFetcherGetBasicGroupFullInfo (M);
  }
  if (constructor == "GetBlockedUsers") {
    return (struct TdFunction *)TdStackFetcherGetBlockedUsers (M);
  }
  if (constructor == "GetCallbackQueryAnswer") {
    return (struct TdFunction *)TdStackFetcherGetCallbackQueryAnswer (M);
  }
  if (constructor == "GetChat") {
    return (struct TdFunction *)TdStackFetcherGetChat (M);
  }
  if (constructor == "GetChatAdministrators") {
    return (struct TdFunction *)TdStackFetcherGetChatAdministrators (M);
  }
  if (constructor == "GetChatEventLog") {
    return (struct TdFunction *)TdStackFetcherGetChatEventLog (M);
  }
  if (constructor == "GetChatHistory") {
    return (struct TdFunction *)TdStackFetcherGetChatHistory (M);
  }
  if (constructor == "GetChatMember") {
    return (struct TdFunction *)TdStackFetcherGetChatMember (M);
  }
  if (constructor == "GetChatMessageByDate") {
    return (struct TdFunction *)TdStackFetcherGetChatMessageByDate (M);
  }
  if (constructor == "GetChatMessageCount") {
    return (struct TdFunction *)TdStackFetcherGetChatMessageCount (M);
  }
  if (constructor == "GetChatPinnedMessage") {
    return (struct TdFunction *)TdStackFetcherGetChatPinnedMessage (M);
  }
  if (constructor == "GetChatReportSpamState") {
    return (struct TdFunction *)TdStackFetcherGetChatReportSpamState (M);
  }
  if (constructor == "GetChats") {
    return (struct TdFunction *)TdStackFetcherGetChats (M);
  }
  if (constructor == "GetConnectedWebsites") {
    return (struct TdFunction *)TdStackFetcherGetConnectedWebsites (M);
  }
  if (constructor == "GetContacts") {
    return (struct TdFunction *)TdStackFetcherGetContacts (M);
  }
  if (constructor == "GetCountryCode") {
    return (struct TdFunction *)TdStackFetcherGetCountryCode (M);
  }
  if (constructor == "GetCreatedPublicChats") {
    return (struct TdFunction *)TdStackFetcherGetCreatedPublicChats (M);
  }
  if (constructor == "GetDeepLinkInfo") {
    return (struct TdFunction *)TdStackFetcherGetDeepLinkInfo (M);
  }
  if (constructor == "GetFavoriteStickers") {
    return (struct TdFunction *)TdStackFetcherGetFavoriteStickers (M);
  }
  if (constructor == "GetFile") {
    return (struct TdFunction *)TdStackFetcherGetFile (M);
  }
  if (constructor == "GetFileExtension") {
    return (struct TdFunction *)TdStackFetcherGetFileExtension (M);
  }
  if (constructor == "GetFileMimeType") {
    return (struct TdFunction *)TdStackFetcherGetFileMimeType (M);
  }
  if (constructor == "GetGameHighScores") {
    return (struct TdFunction *)TdStackFetcherGetGameHighScores (M);
  }
  if (constructor == "GetGroupsInCommon") {
    return (struct TdFunction *)TdStackFetcherGetGroupsInCommon (M);
  }
  if (constructor == "GetImportedContactCount") {
    return (struct TdFunction *)TdStackFetcherGetImportedContactCount (M);
  }
  if (constructor == "GetInlineGameHighScores") {
    return (struct TdFunction *)TdStackFetcherGetInlineGameHighScores (M);
  }
  if (constructor == "GetInlineQueryResults") {
    return (struct TdFunction *)TdStackFetcherGetInlineQueryResults (M);
  }
  if (constructor == "GetInstalledStickerSets") {
    return (struct TdFunction *)TdStackFetcherGetInstalledStickerSets (M);
  }
  if (constructor == "GetInviteText") {
    return (struct TdFunction *)TdStackFetcherGetInviteText (M);
  }
  if (constructor == "GetLanguagePackString") {
    return (struct TdFunction *)TdStackFetcherGetLanguagePackString (M);
  }
  if (constructor == "GetLanguagePackStrings") {
    return (struct TdFunction *)TdStackFetcherGetLanguagePackStrings (M);
  }
  if (constructor == "GetLocalizationTargetInfo") {
    return (struct TdFunction *)TdStackFetcherGetLocalizationTargetInfo (M);
  }
  if (constructor == "GetMapThumbnailFile") {
    return (struct TdFunction *)TdStackFetcherGetMapThumbnailFile (M);
  }
  if (constructor == "GetMe") {
    return (struct TdFunction *)TdStackFetcherGetMe (M);
  }
  if (constructor == "GetMessage") {
    return (struct TdFunction *)TdStackFetcherGetMessage (M);
  }
  if (constructor == "GetMessages") {
    return (struct TdFunction *)TdStackFetcherGetMessages (M);
  }
  if (constructor == "GetNetworkStatistics") {
    return (struct TdFunction *)TdStackFetcherGetNetworkStatistics (M);
  }
  if (constructor == "GetOption") {
    return (struct TdFunction *)TdStackFetcherGetOption (M);
  }
  if (constructor == "GetPassportAuthorizationForm") {
    return (struct TdFunction *)TdStackFetcherGetPassportAuthorizationForm (M);
  }
  if (constructor == "GetPassportElement") {
    return (struct TdFunction *)TdStackFetcherGetPassportElement (M);
  }
  if (constructor == "GetPasswordState") {
    return (struct TdFunction *)TdStackFetcherGetPasswordState (M);
  }
  if (constructor == "GetPaymentForm") {
    return (struct TdFunction *)TdStackFetcherGetPaymentForm (M);
  }
  if (constructor == "GetPaymentReceipt") {
    return (struct TdFunction *)TdStackFetcherGetPaymentReceipt (M);
  }
  if (constructor == "GetPreferredCountryLanguage") {
    return (struct TdFunction *)TdStackFetcherGetPreferredCountryLanguage (M);
  }
  if (constructor == "GetProxies") {
    return (struct TdFunction *)TdStackFetcherGetProxies (M);
  }
  if (constructor == "GetProxyLink") {
    return (struct TdFunction *)TdStackFetcherGetProxyLink (M);
  }
  if (constructor == "GetPublicMessageLink") {
    return (struct TdFunction *)TdStackFetcherGetPublicMessageLink (M);
  }
  if (constructor == "GetRecentInlineBots") {
    return (struct TdFunction *)TdStackFetcherGetRecentInlineBots (M);
  }
  if (constructor == "GetRecentStickers") {
    return (struct TdFunction *)TdStackFetcherGetRecentStickers (M);
  }
  if (constructor == "GetRecentlyVisitedTMeUrls") {
    return (struct TdFunction *)TdStackFetcherGetRecentlyVisitedTMeUrls (M);
  }
  if (constructor == "GetRecoveryEmailAddress") {
    return (struct TdFunction *)TdStackFetcherGetRecoveryEmailAddress (M);
  }
  if (constructor == "GetRemoteFile") {
    return (struct TdFunction *)TdStackFetcherGetRemoteFile (M);
  }
  if (constructor == "GetRepliedMessage") {
    return (struct TdFunction *)TdStackFetcherGetRepliedMessage (M);
  }
  if (constructor == "GetSavedAnimations") {
    return (struct TdFunction *)TdStackFetcherGetSavedAnimations (M);
  }
  if (constructor == "GetSavedOrderInfo") {
    return (struct TdFunction *)TdStackFetcherGetSavedOrderInfo (M);
  }
  if (constructor == "GetScopeNotificationSettings") {
    return (struct TdFunction *)TdStackFetcherGetScopeNotificationSettings (M);
  }
  if (constructor == "GetSecretChat") {
    return (struct TdFunction *)TdStackFetcherGetSecretChat (M);
  }
  if (constructor == "GetStickerEmojis") {
    return (struct TdFunction *)TdStackFetcherGetStickerEmojis (M);
  }
  if (constructor == "GetStickerSet") {
    return (struct TdFunction *)TdStackFetcherGetStickerSet (M);
  }
  if (constructor == "GetStickers") {
    return (struct TdFunction *)TdStackFetcherGetStickers (M);
  }
  if (constructor == "GetStorageStatistics") {
    return (struct TdFunction *)TdStackFetcherGetStorageStatistics (M);
  }
  if (constructor == "GetStorageStatisticsFast") {
    return (struct TdFunction *)TdStackFetcherGetStorageStatisticsFast (M);
  }
  if (constructor == "GetSupergroup") {
    return (struct TdFunction *)TdStackFetcherGetSupergroup (M);
  }
  if (constructor == "GetSupergroupFullInfo") {
    return (struct TdFunction *)TdStackFetcherGetSupergroupFullInfo (M);
  }
  if (constructor == "GetSupergroupMembers") {
    return (struct TdFunction *)TdStackFetcherGetSupergroupMembers (M);
  }
  if (constructor == "GetSupportUser") {
    return (struct TdFunction *)TdStackFetcherGetSupportUser (M);
  }
  if (constructor == "GetTemporaryPasswordState") {
    return (struct TdFunction *)TdStackFetcherGetTemporaryPasswordState (M);
  }
  if (constructor == "GetTextEntities") {
    return (struct TdFunction *)TdStackFetcherGetTextEntities (M);
  }
  if (constructor == "GetTopChats") {
    return (struct TdFunction *)TdStackFetcherGetTopChats (M);
  }
  if (constructor == "GetTrendingStickerSets") {
    return (struct TdFunction *)TdStackFetcherGetTrendingStickerSets (M);
  }
  if (constructor == "GetUser") {
    return (struct TdFunction *)TdStackFetcherGetUser (M);
  }
  if (constructor == "GetUserFullInfo") {
    return (struct TdFunction *)TdStackFetcherGetUserFullInfo (M);
  }
  if (constructor == "GetUserPrivacySettingRules") {
    return (struct TdFunction *)TdStackFetcherGetUserPrivacySettingRules (M);
  }
  if (constructor == "GetUserProfilePhotos") {
    return (struct TdFunction *)TdStackFetcherGetUserProfilePhotos (M);
  }
  if (constructor == "GetWallpapers") {
    return (struct TdFunction *)TdStackFetcherGetWallpapers (M);
  }
  if (constructor == "GetWebPageInstantView") {
    return (struct TdFunction *)TdStackFetcherGetWebPageInstantView (M);
  }
  if (constructor == "GetWebPagePreview") {
    return (struct TdFunction *)TdStackFetcherGetWebPagePreview (M);
  }
  if (constructor == "ImportContacts") {
    return (struct TdFunction *)TdStackFetcherImportContacts (M);
  }
  if (constructor == "JoinChat") {
    return (struct TdFunction *)TdStackFetcherJoinChat (M);
  }
  if (constructor == "JoinChatByInviteLink") {
    return (struct TdFunction *)TdStackFetcherJoinChatByInviteLink (M);
  }
  if (constructor == "LeaveChat") {
    return (struct TdFunction *)TdStackFetcherLeaveChat (M);
  }
  if (constructor == "LogOut") {
    return (struct TdFunction *)TdStackFetcherLogOut (M);
  }
  if (constructor == "OpenChat") {
    return (struct TdFunction *)TdStackFetcherOpenChat (M);
  }
  if (constructor == "OpenMessageContent") {
    return (struct TdFunction *)TdStackFetcherOpenMessageContent (M);
  }
  if (constructor == "OptimizeStorage") {
    return (struct TdFunction *)TdStackFetcherOptimizeStorage (M);
  }
  if (constructor == "ParseTextEntities") {
    return (struct TdFunction *)TdStackFetcherParseTextEntities (M);
  }
  if (constructor == "PinSupergroupMessage") {
    return (struct TdFunction *)TdStackFetcherPinSupergroupMessage (M);
  }
  if (constructor == "PingProxy") {
    return (struct TdFunction *)TdStackFetcherPingProxy (M);
  }
  if (constructor == "ProcessDcUpdate") {
    return (struct TdFunction *)TdStackFetcherProcessDcUpdate (M);
  }
  if (constructor == "ReadAllChatMentions") {
    return (struct TdFunction *)TdStackFetcherReadAllChatMentions (M);
  }
  if (constructor == "RecoverAuthenticationPassword") {
    return (struct TdFunction *)TdStackFetcherRecoverAuthenticationPassword (M);
  }
  if (constructor == "RecoverPassword") {
    return (struct TdFunction *)TdStackFetcherRecoverPassword (M);
  }
  if (constructor == "RegisterDevice") {
    return (struct TdFunction *)TdStackFetcherRegisterDevice (M);
  }
  if (constructor == "RemoveContacts") {
    return (struct TdFunction *)TdStackFetcherRemoveContacts (M);
  }
  if (constructor == "RemoveFavoriteSticker") {
    return (struct TdFunction *)TdStackFetcherRemoveFavoriteSticker (M);
  }
  if (constructor == "RemoveProxy") {
    return (struct TdFunction *)TdStackFetcherRemoveProxy (M);
  }
  if (constructor == "RemoveRecentHashtag") {
    return (struct TdFunction *)TdStackFetcherRemoveRecentHashtag (M);
  }
  if (constructor == "RemoveRecentSticker") {
    return (struct TdFunction *)TdStackFetcherRemoveRecentSticker (M);
  }
  if (constructor == "RemoveRecentlyFoundChat") {
    return (struct TdFunction *)TdStackFetcherRemoveRecentlyFoundChat (M);
  }
  if (constructor == "RemoveSavedAnimation") {
    return (struct TdFunction *)TdStackFetcherRemoveSavedAnimation (M);
  }
  if (constructor == "RemoveStickerFromSet") {
    return (struct TdFunction *)TdStackFetcherRemoveStickerFromSet (M);
  }
  if (constructor == "RemoveTopChat") {
    return (struct TdFunction *)TdStackFetcherRemoveTopChat (M);
  }
  if (constructor == "ReorderInstalledStickerSets") {
    return (struct TdFunction *)TdStackFetcherReorderInstalledStickerSets (M);
  }
  if (constructor == "ReportChat") {
    return (struct TdFunction *)TdStackFetcherReportChat (M);
  }
  if (constructor == "ReportSupergroupSpam") {
    return (struct TdFunction *)TdStackFetcherReportSupergroupSpam (M);
  }
  if (constructor == "RequestAuthenticationPasswordRecovery") {
    return (struct TdFunction *)TdStackFetcherRequestAuthenticationPasswordRecovery (M);
  }
  if (constructor == "RequestPasswordRecovery") {
    return (struct TdFunction *)TdStackFetcherRequestPasswordRecovery (M);
  }
  if (constructor == "ResendAuthenticationCode") {
    return (struct TdFunction *)TdStackFetcherResendAuthenticationCode (M);
  }
  if (constructor == "ResendChangePhoneNumberCode") {
    return (struct TdFunction *)TdStackFetcherResendChangePhoneNumberCode (M);
  }
  if (constructor == "ResendEmailAddressVerificationCode") {
    return (struct TdFunction *)TdStackFetcherResendEmailAddressVerificationCode (M);
  }
  if (constructor == "ResendPhoneNumberConfirmationCode") {
    return (struct TdFunction *)TdStackFetcherResendPhoneNumberConfirmationCode (M);
  }
  if (constructor == "ResendPhoneNumberVerificationCode") {
    return (struct TdFunction *)TdStackFetcherResendPhoneNumberVerificationCode (M);
  }
  if (constructor == "ResetAllNotificationSettings") {
    return (struct TdFunction *)TdStackFetcherResetAllNotificationSettings (M);
  }
  if (constructor == "ResetNetworkStatistics") {
    return (struct TdFunction *)TdStackFetcherResetNetworkStatistics (M);
  }
  if (constructor == "SearchCallMessages") {
    return (struct TdFunction *)TdStackFetcherSearchCallMessages (M);
  }
  if (constructor == "SearchChatMembers") {
    return (struct TdFunction *)TdStackFetcherSearchChatMembers (M);
  }
  if (constructor == "SearchChatMessages") {
    return (struct TdFunction *)TdStackFetcherSearchChatMessages (M);
  }
  if (constructor == "SearchChatRecentLocationMessages") {
    return (struct TdFunction *)TdStackFetcherSearchChatRecentLocationMessages (M);
  }
  if (constructor == "SearchChats") {
    return (struct TdFunction *)TdStackFetcherSearchChats (M);
  }
  if (constructor == "SearchChatsOnServer") {
    return (struct TdFunction *)TdStackFetcherSearchChatsOnServer (M);
  }
  if (constructor == "SearchContacts") {
    return (struct TdFunction *)TdStackFetcherSearchContacts (M);
  }
  if (constructor == "SearchHashtags") {
    return (struct TdFunction *)TdStackFetcherSearchHashtags (M);
  }
  if (constructor == "SearchInstalledStickerSets") {
    return (struct TdFunction *)TdStackFetcherSearchInstalledStickerSets (M);
  }
  if (constructor == "SearchMessages") {
    return (struct TdFunction *)TdStackFetcherSearchMessages (M);
  }
  if (constructor == "SearchPublicChat") {
    return (struct TdFunction *)TdStackFetcherSearchPublicChat (M);
  }
  if (constructor == "SearchPublicChats") {
    return (struct TdFunction *)TdStackFetcherSearchPublicChats (M);
  }
  if (constructor == "SearchSecretMessages") {
    return (struct TdFunction *)TdStackFetcherSearchSecretMessages (M);
  }
  if (constructor == "SearchStickerSet") {
    return (struct TdFunction *)TdStackFetcherSearchStickerSet (M);
  }
  if (constructor == "SearchStickerSets") {
    return (struct TdFunction *)TdStackFetcherSearchStickerSets (M);
  }
  if (constructor == "SearchStickers") {
    return (struct TdFunction *)TdStackFetcherSearchStickers (M);
  }
  if (constructor == "SendBotStartMessage") {
    return (struct TdFunction *)TdStackFetcherSendBotStartMessage (M);
  }
  if (constructor == "SendCallDebugInformation") {
    return (struct TdFunction *)TdStackFetcherSendCallDebugInformation (M);
  }
  if (constructor == "SendCallRating") {
    return (struct TdFunction *)TdStackFetcherSendCallRating (M);
  }
  if (constructor == "SendChatAction") {
    return (struct TdFunction *)TdStackFetcherSendChatAction (M);
  }
  if (constructor == "SendChatScreenshotTakenNotification") {
    return (struct TdFunction *)TdStackFetcherSendChatScreenshotTakenNotification (M);
  }
  if (constructor == "SendChatSetTtlMessage") {
    return (struct TdFunction *)TdStackFetcherSendChatSetTtlMessage (M);
  }
  if (constructor == "SendCustomRequest") {
    return (struct TdFunction *)TdStackFetcherSendCustomRequest (M);
  }
  if (constructor == "SendEmailAddressVerificationCode") {
    return (struct TdFunction *)TdStackFetcherSendEmailAddressVerificationCode (M);
  }
  if (constructor == "SendInlineQueryResultMessage") {
    return (struct TdFunction *)TdStackFetcherSendInlineQueryResultMessage (M);
  }
  if (constructor == "SendMessage") {
    return (struct TdFunction *)TdStackFetcherSendMessage (M);
  }
  if (constructor == "SendMessageAlbum") {
    return (struct TdFunction *)TdStackFetcherSendMessageAlbum (M);
  }
  if (constructor == "SendPassportAuthorizationForm") {
    return (struct TdFunction *)TdStackFetcherSendPassportAuthorizationForm (M);
  }
  if (constructor == "SendPaymentForm") {
    return (struct TdFunction *)TdStackFetcherSendPaymentForm (M);
  }
  if (constructor == "SendPhoneNumberConfirmationCode") {
    return (struct TdFunction *)TdStackFetcherSendPhoneNumberConfirmationCode (M);
  }
  if (constructor == "SendPhoneNumberVerificationCode") {
    return (struct TdFunction *)TdStackFetcherSendPhoneNumberVerificationCode (M);
  }
  if (constructor == "SetAccountTtl") {
    return (struct TdFunction *)TdStackFetcherSetAccountTtl (M);
  }
  if (constructor == "SetAlarm") {
    return (struct TdFunction *)TdStackFetcherSetAlarm (M);
  }
  if (constructor == "SetAuthenticationPhoneNumber") {
    return (struct TdFunction *)TdStackFetcherSetAuthenticationPhoneNumber (M);
  }
  if (constructor == "SetBio") {
    return (struct TdFunction *)TdStackFetcherSetBio (M);
  }
  if (constructor == "SetBotUpdatesStatus") {
    return (struct TdFunction *)TdStackFetcherSetBotUpdatesStatus (M);
  }
  if (constructor == "SetChatClientData") {
    return (struct TdFunction *)TdStackFetcherSetChatClientData (M);
  }
  if (constructor == "SetChatDraftMessage") {
    return (struct TdFunction *)TdStackFetcherSetChatDraftMessage (M);
  }
  if (constructor == "SetChatMemberStatus") {
    return (struct TdFunction *)TdStackFetcherSetChatMemberStatus (M);
  }
  if (constructor == "SetChatNotificationSettings") {
    return (struct TdFunction *)TdStackFetcherSetChatNotificationSettings (M);
  }
  if (constructor == "SetChatPhoto") {
    return (struct TdFunction *)TdStackFetcherSetChatPhoto (M);
  }
  if (constructor == "SetChatTitle") {
    return (struct TdFunction *)TdStackFetcherSetChatTitle (M);
  }
  if (constructor == "SetCustomLanguagePack") {
    return (struct TdFunction *)TdStackFetcherSetCustomLanguagePack (M);
  }
  if (constructor == "SetCustomLanguagePackString") {
    return (struct TdFunction *)TdStackFetcherSetCustomLanguagePackString (M);
  }
  if (constructor == "SetDatabaseEncryptionKey") {
    return (struct TdFunction *)TdStackFetcherSetDatabaseEncryptionKey (M);
  }
  if (constructor == "SetFileGenerationProgress") {
    return (struct TdFunction *)TdStackFetcherSetFileGenerationProgress (M);
  }
  if (constructor == "SetGameScore") {
    return (struct TdFunction *)TdStackFetcherSetGameScore (M);
  }
  if (constructor == "SetInlineGameScore") {
    return (struct TdFunction *)TdStackFetcherSetInlineGameScore (M);
  }
  if (constructor == "SetName") {
    return (struct TdFunction *)TdStackFetcherSetName (M);
  }
  if (constructor == "SetNetworkType") {
    return (struct TdFunction *)TdStackFetcherSetNetworkType (M);
  }
  if (constructor == "SetOption") {
    return (struct TdFunction *)TdStackFetcherSetOption (M);
  }
  if (constructor == "SetPassportElement") {
    return (struct TdFunction *)TdStackFetcherSetPassportElement (M);
  }
  if (constructor == "SetPassportElementErrors") {
    return (struct TdFunction *)TdStackFetcherSetPassportElementErrors (M);
  }
  if (constructor == "SetPassword") {
    return (struct TdFunction *)TdStackFetcherSetPassword (M);
  }
  if (constructor == "SetPinnedChats") {
    return (struct TdFunction *)TdStackFetcherSetPinnedChats (M);
  }
  if (constructor == "SetProfilePhoto") {
    return (struct TdFunction *)TdStackFetcherSetProfilePhoto (M);
  }
  if (constructor == "SetRecoveryEmailAddress") {
    return (struct TdFunction *)TdStackFetcherSetRecoveryEmailAddress (M);
  }
  if (constructor == "SetScopeNotificationSettings") {
    return (struct TdFunction *)TdStackFetcherSetScopeNotificationSettings (M);
  }
  if (constructor == "SetStickerPositionInSet") {
    return (struct TdFunction *)TdStackFetcherSetStickerPositionInSet (M);
  }
  if (constructor == "SetSupergroupDescription") {
    return (struct TdFunction *)TdStackFetcherSetSupergroupDescription (M);
  }
  if (constructor == "SetSupergroupStickerSet") {
    return (struct TdFunction *)TdStackFetcherSetSupergroupStickerSet (M);
  }
  if (constructor == "SetSupergroupUsername") {
    return (struct TdFunction *)TdStackFetcherSetSupergroupUsername (M);
  }
  if (constructor == "SetTdlibParameters") {
    return (struct TdFunction *)TdStackFetcherSetTdlibParameters (M);
  }
  if (constructor == "SetUserPrivacySettingRules") {
    return (struct TdFunction *)TdStackFetcherSetUserPrivacySettingRules (M);
  }
  if (constructor == "SetUsername") {
    return (struct TdFunction *)TdStackFetcherSetUsername (M);
  }
  if (constructor == "TerminateAllOtherSessions") {
    return (struct TdFunction *)TdStackFetcherTerminateAllOtherSessions (M);
  }
  if (constructor == "TerminateSession") {
    return (struct TdFunction *)TdStackFetcherTerminateSession (M);
  }
  if (constructor == "TestCallBytes") {
    return (struct TdFunction *)TdStackFetcherTestCallBytes (M);
  }
  if (constructor == "TestCallEmpty") {
    return (struct TdFunction *)TdStackFetcherTestCallEmpty (M);
  }
  if (constructor == "TestCallString") {
    return (struct TdFunction *)TdStackFetcherTestCallString (M);
  }
  if (constructor == "TestCallVectorInt") {
    return (struct TdFunction *)TdStackFetcherTestCallVectorInt (M);
  }
  if (constructor == "TestCallVectorIntObject") {
    return (struct TdFunction *)TdStackFetcherTestCallVectorIntObject (M);
  }
  if (constructor == "TestCallVectorString") {
    return (struct TdFunction *)TdStackFetcherTestCallVectorString (M);
  }
  if (constructor == "TestCallVectorStringObject") {
    return (struct TdFunction *)TdStackFetcherTestCallVectorStringObject (M);
  }
  if (constructor == "TestGetDifference") {
    return (struct TdFunction *)TdStackFetcherTestGetDifference (M);
  }
  if (constructor == "TestNetwork") {
    return (struct TdFunction *)TdStackFetcherTestNetwork (M);
  }
  if (constructor == "TestSquareInt") {
    return (struct TdFunction *)TdStackFetcherTestSquareInt (M);
  }
  if (constructor == "TestUseError") {
    return (struct TdFunction *)TdStackFetcherTestUseError (M);
  }
  if (constructor == "TestUseUpdate") {
    return (struct TdFunction *)TdStackFetcherTestUseUpdate (M);
  }
  if (constructor == "ToggleBasicGroupAdministrators") {
    return (struct TdFunction *)TdStackFetcherToggleBasicGroupAdministrators (M);
  }
  if (constructor == "ToggleChatDefaultDisableNotification") {
    return (struct TdFunction *)TdStackFetcherToggleChatDefaultDisableNotification (M);
  }
  if (constructor == "ToggleChatIsMarkedAsUnread") {
    return (struct TdFunction *)TdStackFetcherToggleChatIsMarkedAsUnread (M);
  }
  if (constructor == "ToggleChatIsPinned") {
    return (struct TdFunction *)TdStackFetcherToggleChatIsPinned (M);
  }
  if (constructor == "ToggleSupergroupInvites") {
    return (struct TdFunction *)TdStackFetcherToggleSupergroupInvites (M);
  }
  if (constructor == "ToggleSupergroupIsAllHistoryAvailable") {
    return (struct TdFunction *)TdStackFetcherToggleSupergroupIsAllHistoryAvailable (M);
  }
  if (constructor == "ToggleSupergroupSignMessages") {
    return (struct TdFunction *)TdStackFetcherToggleSupergroupSignMessages (M);
  }
  if (constructor == "UnblockUser") {
    return (struct TdFunction *)TdStackFetcherUnblockUser (M);
  }
  if (constructor == "UnpinSupergroupMessage") {
    return (struct TdFunction *)TdStackFetcherUnpinSupergroupMessage (M);
  }
  if (constructor == "UpgradeBasicGroupChatToSupergroupChat") {
    return (struct TdFunction *)TdStackFetcherUpgradeBasicGroupChatToSupergroupChat (M);
  }
  if (constructor == "UploadFile") {
    return (struct TdFunction *)TdStackFetcherUploadFile (M);
  }
  if (constructor == "UploadStickerFile") {
    return (struct TdFunction *)TdStackFetcherUploadStickerFile (M);
  }
  if (constructor == "ValidateOrderInfo") {
    return (struct TdFunction *)TdStackFetcherValidateOrderInfo (M);
  }
  if (constructor == "ViewMessages") {
    return (struct TdFunction *)TdStackFetcherViewMessages (M);
  }
  if (constructor == "ViewTrendingStickerSets") {
    return (struct TdFunction *)TdStackFetcherViewTrendingStickerSets (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdAccountTtl *TdCreateObjectAccountTtl (int days_) {
  auto var = new struct TdAccountTtl ();
  var->ID = CODE_AccountTtl;
  var->refcnt = 1;
  var->days_ = days_;
  return var;
}
td::td_api::object_ptr<td::td_api::accountTtl> TdConvertToInternal (struct TdAccountTtl *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->days_;
  return td::td_api::make_object<td::td_api::accountTtl>(std::move (v0));
}
struct TdAccountTtl *TdConvertFromInternal (const td::td_api::accountTtl &from) {
  auto res = new TdAccountTtl ();
  res->ID = CODE_AccountTtl;
  res->refcnt = 1;
  res->days_ = from.days_;
  return res;
}
char *TdSerializeAccountTtl (struct TdAccountTtl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAccountTtl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAccountTtl (struct TdAccountTtl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAccountTtl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAccountTtl (struct TdAccountTtl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAccountTtl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AccountTtl");
  M->new_field ("ID");
  M->pack_long (var->days_);
  M->new_field ("days_");
}
struct TdAccountTtl *TdStackFetcherAccountTtl (struct TdStackFetcherMethods *M) {
  auto res = new TdAccountTtl ();
  res->ID = CODE_AccountTtl;
  res->refcnt = 1;
  M->get_field ("days_");
  res->days_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdAddress *TdCreateObjectAddress (char *country_code_, char *state_, char *city_, char *street_line1_, char *street_line2_, char *postal_code_) {
  auto var = new struct TdAddress ();
  var->ID = CODE_Address;
  var->refcnt = 1;
  var->country_code_ = (country_code_) ? td::str_dup (td::Slice (country_code_)) : nullptr;
  var->state_ = (state_) ? td::str_dup (td::Slice (state_)) : nullptr;
  var->city_ = (city_) ? td::str_dup (td::Slice (city_)) : nullptr;
  var->street_line1_ = (street_line1_) ? td::str_dup (td::Slice (street_line1_)) : nullptr;
  var->street_line2_ = (street_line2_) ? td::str_dup (td::Slice (street_line2_)) : nullptr;
  var->postal_code_ = (postal_code_) ? td::str_dup (td::Slice (postal_code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::address> TdConvertToInternal (struct TdAddress *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->country_code_) ? var->country_code_: "";
  std::string v100;
  v100 = (var->state_) ? var->state_: "";
  std::string v200;
  v200 = (var->city_) ? var->city_: "";
  std::string v300;
  v300 = (var->street_line1_) ? var->street_line1_: "";
  std::string v400;
  v400 = (var->street_line2_) ? var->street_line2_: "";
  std::string v500;
  v500 = (var->postal_code_) ? var->postal_code_: "";
  return td::td_api::make_object<td::td_api::address>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdAddress *TdConvertFromInternal (const td::td_api::address &from) {
  auto res = new TdAddress ();
  res->ID = CODE_Address;
  res->refcnt = 1;
  res->country_code_ = (from.country_code_.length ()) ? td::str_dup (from.country_code_) : nullptr;
  res->state_ = (from.state_.length ()) ? td::str_dup (from.state_) : nullptr;
  res->city_ = (from.city_.length ()) ? td::str_dup (from.city_) : nullptr;
  res->street_line1_ = (from.street_line1_.length ()) ? td::str_dup (from.street_line1_) : nullptr;
  res->street_line2_ = (from.street_line2_.length ()) ? td::str_dup (from.street_line2_) : nullptr;
  res->postal_code_ = (from.postal_code_.length ()) ? td::str_dup (from.postal_code_) : nullptr;
  return res;
}
char *TdSerializeAddress (struct TdAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddress (struct TdAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->country_code_);
  free (var->state_);
  free (var->city_);
  free (var->street_line1_);
  free (var->street_line2_);
  free (var->postal_code_);
  delete var;
}
void TdStackStorerAddress (struct TdAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Address");
  M->new_field ("ID");
  M->pack_string (var->country_code_);
  M->new_field ("country_code_");
  M->pack_string (var->state_);
  M->new_field ("state_");
  M->pack_string (var->city_);
  M->new_field ("city_");
  M->pack_string (var->street_line1_);
  M->new_field ("street_line1_");
  M->pack_string (var->street_line2_);
  M->new_field ("street_line2_");
  M->pack_string (var->postal_code_);
  M->new_field ("postal_code_");
}
struct TdAddress *TdStackFetcherAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdAddress ();
  res->ID = CODE_Address;
  res->refcnt = 1;
  M->get_field ("country_code_");
  res->country_code_ = M->get_string ();
  M->pop ();
  M->get_field ("state_");
  res->state_ = M->get_string ();
  M->pop ();
  M->get_field ("city_");
  res->city_ = M->get_string ();
  M->pop ();
  M->get_field ("street_line1_");
  res->street_line1_ = M->get_string ();
  M->pop ();
  M->get_field ("street_line2_");
  res->street_line2_ = M->get_string ();
  M->pop ();
  M->get_field ("postal_code_");
  res->postal_code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdAnimation *TdCreateObjectAnimation (int duration_, int width_, int height_, char *file_name_, char *mime_type_, struct TdPhotoSize *thumbnail_, struct TdFile *animation_) {
  auto var = new struct TdAnimation ();
  var->ID = CODE_Animation;
  var->refcnt = 1;
  var->duration_ = duration_;
  var->width_ = width_;
  var->height_ = height_;
  var->file_name_ = (file_name_) ? td::str_dup (td::Slice (file_name_)) : nullptr;
  var->mime_type_ = (mime_type_) ? td::str_dup (td::Slice (mime_type_)) : nullptr;
  var->thumbnail_ = thumbnail_;
  var->animation_ = animation_;
  return var;
}
td::td_api::object_ptr<td::td_api::animation> TdConvertToInternal (struct TdAnimation *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->duration_;
  std::int32_t v100;
  v100 = var->width_;
  std::int32_t v200;
  v200 = var->height_;
  std::string v300;
  v300 = (var->file_name_) ? var->file_name_: "";
  std::string v400;
  v400 = (var->mime_type_) ? var->mime_type_: "";
  td::td_api::object_ptr<td::td_api::photoSize> v500;
  v500 = TdConvertToInternal (var->thumbnail_);
  td::td_api::object_ptr<td::td_api::file> v600;
  v600 = TdConvertToInternal (var->animation_);
  return td::td_api::make_object<td::td_api::animation>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdAnimation *TdConvertFromInternal (const td::td_api::animation &from) {
  auto res = new TdAnimation ();
  res->ID = CODE_Animation;
  res->refcnt = 1;
  res->duration_ = from.duration_;
  res->width_ = from.width_;
  res->height_ = from.height_;
  res->file_name_ = (from.file_name_.length ()) ? td::str_dup (from.file_name_) : nullptr;
  res->mime_type_ = (from.mime_type_.length ()) ? td::str_dup (from.mime_type_) : nullptr;
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.animation_));
  }
  return res;
}
char *TdSerializeAnimation (struct TdAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAnimation (struct TdAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->file_name_);
  free (var->mime_type_);
  TdDestroyObject (var->thumbnail_);
  TdDestroyObject (var->animation_);
  delete var;
}
void TdStackStorerAnimation (struct TdAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Animation");
  M->new_field ("ID");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
  M->pack_string (var->file_name_);
  M->new_field ("file_name_");
  M->pack_string (var->mime_type_);
  M->new_field ("mime_type_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
}
struct TdAnimation *TdStackFetcherAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdAnimation ();
  res->ID = CODE_Animation;
  res->refcnt = 1;
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("file_name_");
  res->file_name_ = M->get_string ();
  M->pop ();
  M->get_field ("mime_type_");
  res->mime_type_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdAnimations *TdCreateObjectAnimations (struct TdVectorAnimation *animations_) {
  auto var = new struct TdAnimations ();
  var->ID = CODE_Animations;
  var->refcnt = 1;
  var->animations_ = animations_;
  return var;
}
td::td_api::object_ptr<td::td_api::animations> TdConvertToInternal (struct TdAnimations *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::animation>> v0;
  for (int i0 = 0; i0 < var->animations_->len; i0++) {
    td::td_api::object_ptr<td::td_api::animation> v1;
    v1 = TdConvertToInternal (var->animations_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::animations>(std::move (v0));
}
struct TdAnimations *TdConvertFromInternal (const td::td_api::animations &from) {
  auto res = new TdAnimations ();
  res->ID = CODE_Animations;
  res->refcnt = 1;
  res->animations_ = new TdVectorAnimation ();
  res->animations_->len = (int)from.animations_.size ();
  res->animations_->data = new struct TdAnimation * [res->animations_->len];
  for (int i0 = 0; i0 < res->animations_->len; i0++) {
    if (!from.animations_[i0]) {
      res->animations_->data[i0] = nullptr;
    } else {
      res->animations_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::animation &>(*from.animations_[i0]));
    }
  }
  return res;
}
char *TdSerializeAnimations (struct TdAnimations *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAnimations *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAnimations (struct TdAnimations *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAnimations *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->animations_->len; i0++) {
    TdDestroyObject (var->animations_->data[i0]);
  }
  delete[] var->animations_->data;
  delete var->animations_;
  delete var;
}
void TdStackStorerAnimations (struct TdAnimations *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAnimations *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Animations");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->animations_->len; i0++) {
    TdStackStorer (var->animations_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("animations_");
}
struct TdAnimations *TdStackFetcherAnimations (struct TdStackFetcherMethods *M) {
  auto res = new TdAnimations ();
  res->ID = CODE_Animations;
  res->refcnt = 1;
  M->get_field ("animations_");
  res->animations_ = new TdVectorAnimation ();
  res->animations_->len = M->get_arr_size ();
  res->animations_->data = new struct TdAnimation * [res->animations_->len];
  for (int i0 = 0; i0 < res->animations_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->animations_->data[i0] = nullptr;
    } else {
      res->animations_->data[i0] = TdStackFetcherAnimation (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdAudio *TdCreateObjectAudio (int duration_, char *title_, char *performer_, char *file_name_, char *mime_type_, struct TdPhotoSize *album_cover_thumbnail_, struct TdFile *audio_) {
  auto var = new struct TdAudio ();
  var->ID = CODE_Audio;
  var->refcnt = 1;
  var->duration_ = duration_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->performer_ = (performer_) ? td::str_dup (td::Slice (performer_)) : nullptr;
  var->file_name_ = (file_name_) ? td::str_dup (td::Slice (file_name_)) : nullptr;
  var->mime_type_ = (mime_type_) ? td::str_dup (td::Slice (mime_type_)) : nullptr;
  var->album_cover_thumbnail_ = album_cover_thumbnail_;
  var->audio_ = audio_;
  return var;
}
td::td_api::object_ptr<td::td_api::audio> TdConvertToInternal (struct TdAudio *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->duration_;
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->performer_) ? var->performer_: "";
  std::string v300;
  v300 = (var->file_name_) ? var->file_name_: "";
  std::string v400;
  v400 = (var->mime_type_) ? var->mime_type_: "";
  td::td_api::object_ptr<td::td_api::photoSize> v500;
  v500 = TdConvertToInternal (var->album_cover_thumbnail_);
  td::td_api::object_ptr<td::td_api::file> v600;
  v600 = TdConvertToInternal (var->audio_);
  return td::td_api::make_object<td::td_api::audio>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdAudio *TdConvertFromInternal (const td::td_api::audio &from) {
  auto res = new TdAudio ();
  res->ID = CODE_Audio;
  res->refcnt = 1;
  res->duration_ = from.duration_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->performer_ = (from.performer_.length ()) ? td::str_dup (from.performer_) : nullptr;
  res->file_name_ = (from.file_name_.length ()) ? td::str_dup (from.file_name_) : nullptr;
  res->mime_type_ = (from.mime_type_.length ()) ? td::str_dup (from.mime_type_) : nullptr;
  if (!from.album_cover_thumbnail_) {
    res->album_cover_thumbnail_ = nullptr;
  } else {
    res->album_cover_thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.album_cover_thumbnail_));
  }
  if (!from.audio_) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.audio_));
  }
  return res;
}
char *TdSerializeAudio (struct TdAudio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAudio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAudio (struct TdAudio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAudio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  free (var->performer_);
  free (var->file_name_);
  free (var->mime_type_);
  TdDestroyObject (var->album_cover_thumbnail_);
  TdDestroyObject (var->audio_);
  delete var;
}
void TdStackStorerAudio (struct TdAudio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAudio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Audio");
  M->new_field ("ID");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->performer_);
  M->new_field ("performer_");
  M->pack_string (var->file_name_);
  M->new_field ("file_name_");
  M->pack_string (var->mime_type_);
  M->new_field ("mime_type_");
  TdStackStorer (var->album_cover_thumbnail_, M);
  M->new_field ("album_cover_thumbnail_");
  TdStackStorer (var->audio_, M);
  M->new_field ("audio_");
}
struct TdAudio *TdStackFetcherAudio (struct TdStackFetcherMethods *M) {
  auto res = new TdAudio ();
  res->ID = CODE_Audio;
  res->refcnt = 1;
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("performer_");
  res->performer_ = M->get_string ();
  M->pop ();
  M->get_field ("file_name_");
  res->file_name_ = M->get_string ();
  M->pop ();
  M->get_field ("mime_type_");
  res->mime_type_ = M->get_string ();
  M->pop ();
  M->get_field ("album_cover_thumbnail_");
  if (M->is_nil ()) {
    res->album_cover_thumbnail_ = nullptr;
  } else {
    res->album_cover_thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  M->get_field ("audio_");
  if (M->is_nil ()) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdAuthenticationCodeInfo *TdCreateObjectAuthenticationCodeInfo (char *phone_number_, struct TdAuthenticationCodeType *type_, struct TdAuthenticationCodeType *next_type_, int timeout_) {
  auto var = new struct TdAuthenticationCodeInfo ();
  var->ID = CODE_AuthenticationCodeInfo;
  var->refcnt = 1;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  var->type_ = type_;
  var->next_type_ = next_type_;
  var->timeout_ = timeout_;
  return var;
}
td::td_api::object_ptr<td::td_api::authenticationCodeInfo> TdConvertToInternal (struct TdAuthenticationCodeInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->phone_number_) ? var->phone_number_: "";
  td::td_api::object_ptr<td::td_api::AuthenticationCodeType> v100;
  v100 = TdConvertToInternal (var->type_);
  td::td_api::object_ptr<td::td_api::AuthenticationCodeType> v200;
  v200 = TdConvertToInternal (var->next_type_);
  std::int32_t v300;
  v300 = var->timeout_;
  return td::td_api::make_object<td::td_api::authenticationCodeInfo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdAuthenticationCodeInfo *TdConvertFromInternal (const td::td_api::authenticationCodeInfo &from) {
  auto res = new TdAuthenticationCodeInfo ();
  res->ID = CODE_AuthenticationCodeInfo;
  res->refcnt = 1;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::AuthenticationCodeType &>(*from.type_));
  }
  if (!from.next_type_) {
    res->next_type_ = nullptr;
  } else {
    res->next_type_ = TdConvertFromInternal (static_cast<const td::td_api::AuthenticationCodeType &>(*from.next_type_));
  }
  res->timeout_ = from.timeout_;
  return res;
}
char *TdSerializeAuthenticationCodeInfo (struct TdAuthenticationCodeInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthenticationCodeInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthenticationCodeInfo (struct TdAuthenticationCodeInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthenticationCodeInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->phone_number_);
  TdDestroyObject (var->type_);
  TdDestroyObject (var->next_type_);
  delete var;
}
void TdStackStorerAuthenticationCodeInfo (struct TdAuthenticationCodeInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthenticationCodeInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthenticationCodeInfo");
  M->new_field ("ID");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  TdStackStorer (var->next_type_, M);
  M->new_field ("next_type_");
  M->pack_long (var->timeout_);
  M->new_field ("timeout_");
}
struct TdAuthenticationCodeInfo *TdStackFetcherAuthenticationCodeInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthenticationCodeInfo ();
  res->ID = CODE_AuthenticationCodeInfo;
  res->refcnt = 1;
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherAuthenticationCodeType (M);
  }
  M->pop ();
  M->get_field ("next_type_");
  if (M->is_nil ()) {
    res->next_type_ = nullptr;
  } else {
    res->next_type_ = TdStackFetcherAuthenticationCodeType (M);
  }
  M->pop ();
  M->get_field ("timeout_");
  res->timeout_ = (int)M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::AuthenticationCodeType> TdConvertToInternal (struct TdAuthenticationCodeType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AuthenticationCodeTypeTelegramMessage: return TdConvertToInternal ((struct TdAuthenticationCodeTypeTelegramMessage *)var);
    case CODE_AuthenticationCodeTypeSms: return TdConvertToInternal ((struct TdAuthenticationCodeTypeSms *)var);
    case CODE_AuthenticationCodeTypeCall: return TdConvertToInternal ((struct TdAuthenticationCodeTypeCall *)var);
    case CODE_AuthenticationCodeTypeFlashCall: return TdConvertToInternal ((struct TdAuthenticationCodeTypeFlashCall *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdAuthenticationCodeType *TdConvertFromInternal (const td::td_api::AuthenticationCodeType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_AuthenticationCodeTypeTelegramMessage: return (struct TdAuthenticationCodeType *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeTypeTelegramMessage &>(from));
    case CODE_AuthenticationCodeTypeSms: return (struct TdAuthenticationCodeType *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeTypeSms &>(from));
    case CODE_AuthenticationCodeTypeCall: return (struct TdAuthenticationCodeType *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeTypeCall &>(from));
    case CODE_AuthenticationCodeTypeFlashCall: return (struct TdAuthenticationCodeType *)TdConvertFromInternal(static_cast<const td::td_api::authenticationCodeTypeFlashCall &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeAuthenticationCodeType (struct TdAuthenticationCodeType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthenticationCodeType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthenticationCodeType (struct TdAuthenticationCodeType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthenticationCodeType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AuthenticationCodeTypeTelegramMessage: return TdDestroyObject ((struct TdAuthenticationCodeTypeTelegramMessage *)var);
    case CODE_AuthenticationCodeTypeSms: return TdDestroyObject ((struct TdAuthenticationCodeTypeSms *)var);
    case CODE_AuthenticationCodeTypeCall: return TdDestroyObject ((struct TdAuthenticationCodeTypeCall *)var);
    case CODE_AuthenticationCodeTypeFlashCall: return TdDestroyObject ((struct TdAuthenticationCodeTypeFlashCall *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerAuthenticationCodeType (struct TdAuthenticationCodeType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthenticationCodeType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AuthenticationCodeTypeTelegramMessage: return TdStackStorer ((struct TdAuthenticationCodeTypeTelegramMessage *)var, M);
    case CODE_AuthenticationCodeTypeSms: return TdStackStorer ((struct TdAuthenticationCodeTypeSms *)var, M);
    case CODE_AuthenticationCodeTypeCall: return TdStackStorer ((struct TdAuthenticationCodeTypeCall *)var, M);
    case CODE_AuthenticationCodeTypeFlashCall: return TdStackStorer ((struct TdAuthenticationCodeTypeFlashCall *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdAuthenticationCodeType *TdStackFetcherAuthenticationCodeType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "AuthenticationCodeTypeTelegramMessage") {
    return (struct TdAuthenticationCodeType *)TdStackFetcherAuthenticationCodeTypeTelegramMessage (M);
  }
  if (constructor == "AuthenticationCodeTypeSms") {
    return (struct TdAuthenticationCodeType *)TdStackFetcherAuthenticationCodeTypeSms (M);
  }
  if (constructor == "AuthenticationCodeTypeCall") {
    return (struct TdAuthenticationCodeType *)TdStackFetcherAuthenticationCodeTypeCall (M);
  }
  if (constructor == "AuthenticationCodeTypeFlashCall") {
    return (struct TdAuthenticationCodeType *)TdStackFetcherAuthenticationCodeTypeFlashCall (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdAuthenticationCodeTypeTelegramMessage *TdCreateObjectAuthenticationCodeTypeTelegramMessage (int length_) {
  auto var = new struct TdAuthenticationCodeTypeTelegramMessage ();
  var->ID = CODE_AuthenticationCodeTypeTelegramMessage;
  var->refcnt = 1;
  var->length_ = length_;
  return var;
}
td::td_api::object_ptr<td::td_api::authenticationCodeTypeTelegramMessage> TdConvertToInternal (struct TdAuthenticationCodeTypeTelegramMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->length_;
  return td::td_api::make_object<td::td_api::authenticationCodeTypeTelegramMessage>(std::move (v0));
}
struct TdAuthenticationCodeTypeTelegramMessage *TdConvertFromInternal (const td::td_api::authenticationCodeTypeTelegramMessage &from) {
  auto res = new TdAuthenticationCodeTypeTelegramMessage ();
  res->ID = CODE_AuthenticationCodeTypeTelegramMessage;
  res->refcnt = 1;
  res->length_ = from.length_;
  return res;
}
char *TdSerializeAuthenticationCodeTypeTelegramMessage (struct TdAuthenticationCodeTypeTelegramMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthenticationCodeTypeTelegramMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthenticationCodeTypeTelegramMessage (struct TdAuthenticationCodeTypeTelegramMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthenticationCodeTypeTelegramMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthenticationCodeTypeTelegramMessage (struct TdAuthenticationCodeTypeTelegramMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthenticationCodeTypeTelegramMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthenticationCodeTypeTelegramMessage");
  M->new_field ("ID");
  M->pack_long (var->length_);
  M->new_field ("length_");
}
struct TdAuthenticationCodeTypeTelegramMessage *TdStackFetcherAuthenticationCodeTypeTelegramMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthenticationCodeTypeTelegramMessage ();
  res->ID = CODE_AuthenticationCodeTypeTelegramMessage;
  res->refcnt = 1;
  M->get_field ("length_");
  res->length_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdAuthenticationCodeTypeSms *TdCreateObjectAuthenticationCodeTypeSms (int length_) {
  auto var = new struct TdAuthenticationCodeTypeSms ();
  var->ID = CODE_AuthenticationCodeTypeSms;
  var->refcnt = 1;
  var->length_ = length_;
  return var;
}
td::td_api::object_ptr<td::td_api::authenticationCodeTypeSms> TdConvertToInternal (struct TdAuthenticationCodeTypeSms *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->length_;
  return td::td_api::make_object<td::td_api::authenticationCodeTypeSms>(std::move (v0));
}
struct TdAuthenticationCodeTypeSms *TdConvertFromInternal (const td::td_api::authenticationCodeTypeSms &from) {
  auto res = new TdAuthenticationCodeTypeSms ();
  res->ID = CODE_AuthenticationCodeTypeSms;
  res->refcnt = 1;
  res->length_ = from.length_;
  return res;
}
char *TdSerializeAuthenticationCodeTypeSms (struct TdAuthenticationCodeTypeSms *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthenticationCodeTypeSms *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthenticationCodeTypeSms (struct TdAuthenticationCodeTypeSms *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthenticationCodeTypeSms *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthenticationCodeTypeSms (struct TdAuthenticationCodeTypeSms *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthenticationCodeTypeSms *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthenticationCodeTypeSms");
  M->new_field ("ID");
  M->pack_long (var->length_);
  M->new_field ("length_");
}
struct TdAuthenticationCodeTypeSms *TdStackFetcherAuthenticationCodeTypeSms (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthenticationCodeTypeSms ();
  res->ID = CODE_AuthenticationCodeTypeSms;
  res->refcnt = 1;
  M->get_field ("length_");
  res->length_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdAuthenticationCodeTypeCall *TdCreateObjectAuthenticationCodeTypeCall (int length_) {
  auto var = new struct TdAuthenticationCodeTypeCall ();
  var->ID = CODE_AuthenticationCodeTypeCall;
  var->refcnt = 1;
  var->length_ = length_;
  return var;
}
td::td_api::object_ptr<td::td_api::authenticationCodeTypeCall> TdConvertToInternal (struct TdAuthenticationCodeTypeCall *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->length_;
  return td::td_api::make_object<td::td_api::authenticationCodeTypeCall>(std::move (v0));
}
struct TdAuthenticationCodeTypeCall *TdConvertFromInternal (const td::td_api::authenticationCodeTypeCall &from) {
  auto res = new TdAuthenticationCodeTypeCall ();
  res->ID = CODE_AuthenticationCodeTypeCall;
  res->refcnt = 1;
  res->length_ = from.length_;
  return res;
}
char *TdSerializeAuthenticationCodeTypeCall (struct TdAuthenticationCodeTypeCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthenticationCodeTypeCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthenticationCodeTypeCall (struct TdAuthenticationCodeTypeCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthenticationCodeTypeCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthenticationCodeTypeCall (struct TdAuthenticationCodeTypeCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthenticationCodeTypeCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthenticationCodeTypeCall");
  M->new_field ("ID");
  M->pack_long (var->length_);
  M->new_field ("length_");
}
struct TdAuthenticationCodeTypeCall *TdStackFetcherAuthenticationCodeTypeCall (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthenticationCodeTypeCall ();
  res->ID = CODE_AuthenticationCodeTypeCall;
  res->refcnt = 1;
  M->get_field ("length_");
  res->length_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdAuthenticationCodeTypeFlashCall *TdCreateObjectAuthenticationCodeTypeFlashCall (char *pattern_) {
  auto var = new struct TdAuthenticationCodeTypeFlashCall ();
  var->ID = CODE_AuthenticationCodeTypeFlashCall;
  var->refcnt = 1;
  var->pattern_ = (pattern_) ? td::str_dup (td::Slice (pattern_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::authenticationCodeTypeFlashCall> TdConvertToInternal (struct TdAuthenticationCodeTypeFlashCall *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->pattern_) ? var->pattern_: "";
  return td::td_api::make_object<td::td_api::authenticationCodeTypeFlashCall>(std::move (v0));
}
struct TdAuthenticationCodeTypeFlashCall *TdConvertFromInternal (const td::td_api::authenticationCodeTypeFlashCall &from) {
  auto res = new TdAuthenticationCodeTypeFlashCall ();
  res->ID = CODE_AuthenticationCodeTypeFlashCall;
  res->refcnt = 1;
  res->pattern_ = (from.pattern_.length ()) ? td::str_dup (from.pattern_) : nullptr;
  return res;
}
char *TdSerializeAuthenticationCodeTypeFlashCall (struct TdAuthenticationCodeTypeFlashCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthenticationCodeTypeFlashCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthenticationCodeTypeFlashCall (struct TdAuthenticationCodeTypeFlashCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthenticationCodeTypeFlashCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->pattern_);
  delete var;
}
void TdStackStorerAuthenticationCodeTypeFlashCall (struct TdAuthenticationCodeTypeFlashCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthenticationCodeTypeFlashCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthenticationCodeTypeFlashCall");
  M->new_field ("ID");
  M->pack_string (var->pattern_);
  M->new_field ("pattern_");
}
struct TdAuthenticationCodeTypeFlashCall *TdStackFetcherAuthenticationCodeTypeFlashCall (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthenticationCodeTypeFlashCall ();
  res->ID = CODE_AuthenticationCodeTypeFlashCall;
  res->refcnt = 1;
  M->get_field ("pattern_");
  res->pattern_ = M->get_string ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::AuthorizationState> TdConvertToInternal (struct TdAuthorizationState *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AuthorizationStateWaitTdlibParameters: return TdConvertToInternal ((struct TdAuthorizationStateWaitTdlibParameters *)var);
    case CODE_AuthorizationStateWaitEncryptionKey: return TdConvertToInternal ((struct TdAuthorizationStateWaitEncryptionKey *)var);
    case CODE_AuthorizationStateWaitPhoneNumber: return TdConvertToInternal ((struct TdAuthorizationStateWaitPhoneNumber *)var);
    case CODE_AuthorizationStateWaitCode: return TdConvertToInternal ((struct TdAuthorizationStateWaitCode *)var);
    case CODE_AuthorizationStateWaitPassword: return TdConvertToInternal ((struct TdAuthorizationStateWaitPassword *)var);
    case CODE_AuthorizationStateReady: return TdConvertToInternal ((struct TdAuthorizationStateReady *)var);
    case CODE_AuthorizationStateLoggingOut: return TdConvertToInternal ((struct TdAuthorizationStateLoggingOut *)var);
    case CODE_AuthorizationStateClosing: return TdConvertToInternal ((struct TdAuthorizationStateClosing *)var);
    case CODE_AuthorizationStateClosed: return TdConvertToInternal ((struct TdAuthorizationStateClosed *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdAuthorizationState *TdConvertFromInternal (const td::td_api::AuthorizationState &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_AuthorizationStateWaitTdlibParameters: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitTdlibParameters &>(from));
    case CODE_AuthorizationStateWaitEncryptionKey: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitEncryptionKey &>(from));
    case CODE_AuthorizationStateWaitPhoneNumber: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitPhoneNumber &>(from));
    case CODE_AuthorizationStateWaitCode: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitCode &>(from));
    case CODE_AuthorizationStateWaitPassword: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateWaitPassword &>(from));
    case CODE_AuthorizationStateReady: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateReady &>(from));
    case CODE_AuthorizationStateLoggingOut: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateLoggingOut &>(from));
    case CODE_AuthorizationStateClosing: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateClosing &>(from));
    case CODE_AuthorizationStateClosed: return (struct TdAuthorizationState *)TdConvertFromInternal(static_cast<const td::td_api::authorizationStateClosed &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeAuthorizationState (struct TdAuthorizationState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationState (struct TdAuthorizationState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationState *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AuthorizationStateWaitTdlibParameters: return TdDestroyObject ((struct TdAuthorizationStateWaitTdlibParameters *)var);
    case CODE_AuthorizationStateWaitEncryptionKey: return TdDestroyObject ((struct TdAuthorizationStateWaitEncryptionKey *)var);
    case CODE_AuthorizationStateWaitPhoneNumber: return TdDestroyObject ((struct TdAuthorizationStateWaitPhoneNumber *)var);
    case CODE_AuthorizationStateWaitCode: return TdDestroyObject ((struct TdAuthorizationStateWaitCode *)var);
    case CODE_AuthorizationStateWaitPassword: return TdDestroyObject ((struct TdAuthorizationStateWaitPassword *)var);
    case CODE_AuthorizationStateReady: return TdDestroyObject ((struct TdAuthorizationStateReady *)var);
    case CODE_AuthorizationStateLoggingOut: return TdDestroyObject ((struct TdAuthorizationStateLoggingOut *)var);
    case CODE_AuthorizationStateClosing: return TdDestroyObject ((struct TdAuthorizationStateClosing *)var);
    case CODE_AuthorizationStateClosed: return TdDestroyObject ((struct TdAuthorizationStateClosed *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerAuthorizationState (struct TdAuthorizationState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationState *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_AuthorizationStateWaitTdlibParameters: return TdStackStorer ((struct TdAuthorizationStateWaitTdlibParameters *)var, M);
    case CODE_AuthorizationStateWaitEncryptionKey: return TdStackStorer ((struct TdAuthorizationStateWaitEncryptionKey *)var, M);
    case CODE_AuthorizationStateWaitPhoneNumber: return TdStackStorer ((struct TdAuthorizationStateWaitPhoneNumber *)var, M);
    case CODE_AuthorizationStateWaitCode: return TdStackStorer ((struct TdAuthorizationStateWaitCode *)var, M);
    case CODE_AuthorizationStateWaitPassword: return TdStackStorer ((struct TdAuthorizationStateWaitPassword *)var, M);
    case CODE_AuthorizationStateReady: return TdStackStorer ((struct TdAuthorizationStateReady *)var, M);
    case CODE_AuthorizationStateLoggingOut: return TdStackStorer ((struct TdAuthorizationStateLoggingOut *)var, M);
    case CODE_AuthorizationStateClosing: return TdStackStorer ((struct TdAuthorizationStateClosing *)var, M);
    case CODE_AuthorizationStateClosed: return TdStackStorer ((struct TdAuthorizationStateClosed *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdAuthorizationState *TdStackFetcherAuthorizationState (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "AuthorizationStateWaitTdlibParameters") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateWaitTdlibParameters (M);
  }
  if (constructor == "AuthorizationStateWaitEncryptionKey") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateWaitEncryptionKey (M);
  }
  if (constructor == "AuthorizationStateWaitPhoneNumber") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateWaitPhoneNumber (M);
  }
  if (constructor == "AuthorizationStateWaitCode") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateWaitCode (M);
  }
  if (constructor == "AuthorizationStateWaitPassword") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateWaitPassword (M);
  }
  if (constructor == "AuthorizationStateReady") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateReady (M);
  }
  if (constructor == "AuthorizationStateLoggingOut") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateLoggingOut (M);
  }
  if (constructor == "AuthorizationStateClosing") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateClosing (M);
  }
  if (constructor == "AuthorizationStateClosed") {
    return (struct TdAuthorizationState *)TdStackFetcherAuthorizationStateClosed (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdAuthorizationStateWaitTdlibParameters *TdCreateObjectAuthorizationStateWaitTdlibParameters (void) {
  auto var = new struct TdAuthorizationStateWaitTdlibParameters ();
  var->ID = CODE_AuthorizationStateWaitTdlibParameters;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateWaitTdlibParameters> TdConvertToInternal (struct TdAuthorizationStateWaitTdlibParameters *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::authorizationStateWaitTdlibParameters>();
}
struct TdAuthorizationStateWaitTdlibParameters *TdConvertFromInternal (const td::td_api::authorizationStateWaitTdlibParameters &from) {
  auto res = new TdAuthorizationStateWaitTdlibParameters ();
  res->ID = CODE_AuthorizationStateWaitTdlibParameters;
  res->refcnt = 1;
  return res;
}
char *TdSerializeAuthorizationStateWaitTdlibParameters (struct TdAuthorizationStateWaitTdlibParameters *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateWaitTdlibParameters *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateWaitTdlibParameters (struct TdAuthorizationStateWaitTdlibParameters *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateWaitTdlibParameters *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthorizationStateWaitTdlibParameters (struct TdAuthorizationStateWaitTdlibParameters *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateWaitTdlibParameters *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateWaitTdlibParameters");
  M->new_field ("ID");
}
struct TdAuthorizationStateWaitTdlibParameters *TdStackFetcherAuthorizationStateWaitTdlibParameters (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateWaitTdlibParameters ();
  res->ID = CODE_AuthorizationStateWaitTdlibParameters;
  res->refcnt = 1;
  return res;
}
struct TdAuthorizationStateWaitEncryptionKey *TdCreateObjectAuthorizationStateWaitEncryptionKey (int is_encrypted_) {
  auto var = new struct TdAuthorizationStateWaitEncryptionKey ();
  var->ID = CODE_AuthorizationStateWaitEncryptionKey;
  var->refcnt = 1;
  var->is_encrypted_ = is_encrypted_;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateWaitEncryptionKey> TdConvertToInternal (struct TdAuthorizationStateWaitEncryptionKey *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_encrypted_ != 0;
  return td::td_api::make_object<td::td_api::authorizationStateWaitEncryptionKey>(std::move (v0));
}
struct TdAuthorizationStateWaitEncryptionKey *TdConvertFromInternal (const td::td_api::authorizationStateWaitEncryptionKey &from) {
  auto res = new TdAuthorizationStateWaitEncryptionKey ();
  res->ID = CODE_AuthorizationStateWaitEncryptionKey;
  res->refcnt = 1;
  res->is_encrypted_ = from.is_encrypted_;
  return res;
}
char *TdSerializeAuthorizationStateWaitEncryptionKey (struct TdAuthorizationStateWaitEncryptionKey *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateWaitEncryptionKey *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateWaitEncryptionKey (struct TdAuthorizationStateWaitEncryptionKey *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateWaitEncryptionKey *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthorizationStateWaitEncryptionKey (struct TdAuthorizationStateWaitEncryptionKey *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateWaitEncryptionKey *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateWaitEncryptionKey");
  M->new_field ("ID");
  M->pack_bool (var->is_encrypted_);
  M->new_field ("is_encrypted_");
}
struct TdAuthorizationStateWaitEncryptionKey *TdStackFetcherAuthorizationStateWaitEncryptionKey (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateWaitEncryptionKey ();
  res->ID = CODE_AuthorizationStateWaitEncryptionKey;
  res->refcnt = 1;
  M->get_field ("is_encrypted_");
  res->is_encrypted_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdAuthorizationStateWaitPhoneNumber *TdCreateObjectAuthorizationStateWaitPhoneNumber (void) {
  auto var = new struct TdAuthorizationStateWaitPhoneNumber ();
  var->ID = CODE_AuthorizationStateWaitPhoneNumber;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateWaitPhoneNumber> TdConvertToInternal (struct TdAuthorizationStateWaitPhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::authorizationStateWaitPhoneNumber>();
}
struct TdAuthorizationStateWaitPhoneNumber *TdConvertFromInternal (const td::td_api::authorizationStateWaitPhoneNumber &from) {
  auto res = new TdAuthorizationStateWaitPhoneNumber ();
  res->ID = CODE_AuthorizationStateWaitPhoneNumber;
  res->refcnt = 1;
  return res;
}
char *TdSerializeAuthorizationStateWaitPhoneNumber (struct TdAuthorizationStateWaitPhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateWaitPhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateWaitPhoneNumber (struct TdAuthorizationStateWaitPhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateWaitPhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthorizationStateWaitPhoneNumber (struct TdAuthorizationStateWaitPhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateWaitPhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateWaitPhoneNumber");
  M->new_field ("ID");
}
struct TdAuthorizationStateWaitPhoneNumber *TdStackFetcherAuthorizationStateWaitPhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateWaitPhoneNumber ();
  res->ID = CODE_AuthorizationStateWaitPhoneNumber;
  res->refcnt = 1;
  return res;
}
struct TdAuthorizationStateWaitCode *TdCreateObjectAuthorizationStateWaitCode (int is_registered_, struct TdTermsOfService *terms_of_service_, struct TdAuthenticationCodeInfo *code_info_) {
  auto var = new struct TdAuthorizationStateWaitCode ();
  var->ID = CODE_AuthorizationStateWaitCode;
  var->refcnt = 1;
  var->is_registered_ = is_registered_;
  var->terms_of_service_ = terms_of_service_;
  var->code_info_ = code_info_;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateWaitCode> TdConvertToInternal (struct TdAuthorizationStateWaitCode *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_registered_ != 0;
  td::td_api::object_ptr<td::td_api::termsOfService> v100;
  v100 = TdConvertToInternal (var->terms_of_service_);
  td::td_api::object_ptr<td::td_api::authenticationCodeInfo> v200;
  v200 = TdConvertToInternal (var->code_info_);
  return td::td_api::make_object<td::td_api::authorizationStateWaitCode>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdAuthorizationStateWaitCode *TdConvertFromInternal (const td::td_api::authorizationStateWaitCode &from) {
  auto res = new TdAuthorizationStateWaitCode ();
  res->ID = CODE_AuthorizationStateWaitCode;
  res->refcnt = 1;
  res->is_registered_ = from.is_registered_;
  if (!from.terms_of_service_) {
    res->terms_of_service_ = nullptr;
  } else {
    res->terms_of_service_ = TdConvertFromInternal (static_cast<const td::td_api::termsOfService &>(*from.terms_of_service_));
  }
  if (!from.code_info_) {
    res->code_info_ = nullptr;
  } else {
    res->code_info_ = TdConvertFromInternal (static_cast<const td::td_api::authenticationCodeInfo &>(*from.code_info_));
  }
  return res;
}
char *TdSerializeAuthorizationStateWaitCode (struct TdAuthorizationStateWaitCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateWaitCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateWaitCode (struct TdAuthorizationStateWaitCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateWaitCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->terms_of_service_);
  TdDestroyObject (var->code_info_);
  delete var;
}
void TdStackStorerAuthorizationStateWaitCode (struct TdAuthorizationStateWaitCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateWaitCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateWaitCode");
  M->new_field ("ID");
  M->pack_bool (var->is_registered_);
  M->new_field ("is_registered_");
  TdStackStorer (var->terms_of_service_, M);
  M->new_field ("terms_of_service_");
  TdStackStorer (var->code_info_, M);
  M->new_field ("code_info_");
}
struct TdAuthorizationStateWaitCode *TdStackFetcherAuthorizationStateWaitCode (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateWaitCode ();
  res->ID = CODE_AuthorizationStateWaitCode;
  res->refcnt = 1;
  M->get_field ("is_registered_");
  res->is_registered_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("terms_of_service_");
  if (M->is_nil ()) {
    res->terms_of_service_ = nullptr;
  } else {
    res->terms_of_service_ = TdStackFetcherTermsOfService (M);
  }
  M->pop ();
  M->get_field ("code_info_");
  if (M->is_nil ()) {
    res->code_info_ = nullptr;
  } else {
    res->code_info_ = TdStackFetcherAuthenticationCodeInfo (M);
  }
  M->pop ();
  return res;
}
struct TdAuthorizationStateWaitPassword *TdCreateObjectAuthorizationStateWaitPassword (char *password_hint_, int has_recovery_email_address_, char *recovery_email_address_pattern_) {
  auto var = new struct TdAuthorizationStateWaitPassword ();
  var->ID = CODE_AuthorizationStateWaitPassword;
  var->refcnt = 1;
  var->password_hint_ = (password_hint_) ? td::str_dup (td::Slice (password_hint_)) : nullptr;
  var->has_recovery_email_address_ = has_recovery_email_address_;
  var->recovery_email_address_pattern_ = (recovery_email_address_pattern_) ? td::str_dup (td::Slice (recovery_email_address_pattern_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateWaitPassword> TdConvertToInternal (struct TdAuthorizationStateWaitPassword *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->password_hint_) ? var->password_hint_: "";
  bool v100;
  v100 = var->has_recovery_email_address_ != 0;
  std::string v200;
  v200 = (var->recovery_email_address_pattern_) ? var->recovery_email_address_pattern_: "";
  return td::td_api::make_object<td::td_api::authorizationStateWaitPassword>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdAuthorizationStateWaitPassword *TdConvertFromInternal (const td::td_api::authorizationStateWaitPassword &from) {
  auto res = new TdAuthorizationStateWaitPassword ();
  res->ID = CODE_AuthorizationStateWaitPassword;
  res->refcnt = 1;
  res->password_hint_ = (from.password_hint_.length ()) ? td::str_dup (from.password_hint_) : nullptr;
  res->has_recovery_email_address_ = from.has_recovery_email_address_;
  res->recovery_email_address_pattern_ = (from.recovery_email_address_pattern_.length ()) ? td::str_dup (from.recovery_email_address_pattern_) : nullptr;
  return res;
}
char *TdSerializeAuthorizationStateWaitPassword (struct TdAuthorizationStateWaitPassword *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateWaitPassword *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateWaitPassword (struct TdAuthorizationStateWaitPassword *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateWaitPassword *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->password_hint_);
  free (var->recovery_email_address_pattern_);
  delete var;
}
void TdStackStorerAuthorizationStateWaitPassword (struct TdAuthorizationStateWaitPassword *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateWaitPassword *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateWaitPassword");
  M->new_field ("ID");
  M->pack_string (var->password_hint_);
  M->new_field ("password_hint_");
  M->pack_bool (var->has_recovery_email_address_);
  M->new_field ("has_recovery_email_address_");
  M->pack_string (var->recovery_email_address_pattern_);
  M->new_field ("recovery_email_address_pattern_");
}
struct TdAuthorizationStateWaitPassword *TdStackFetcherAuthorizationStateWaitPassword (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateWaitPassword ();
  res->ID = CODE_AuthorizationStateWaitPassword;
  res->refcnt = 1;
  M->get_field ("password_hint_");
  res->password_hint_ = M->get_string ();
  M->pop ();
  M->get_field ("has_recovery_email_address_");
  res->has_recovery_email_address_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("recovery_email_address_pattern_");
  res->recovery_email_address_pattern_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdAuthorizationStateReady *TdCreateObjectAuthorizationStateReady (void) {
  auto var = new struct TdAuthorizationStateReady ();
  var->ID = CODE_AuthorizationStateReady;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateReady> TdConvertToInternal (struct TdAuthorizationStateReady *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::authorizationStateReady>();
}
struct TdAuthorizationStateReady *TdConvertFromInternal (const td::td_api::authorizationStateReady &from) {
  auto res = new TdAuthorizationStateReady ();
  res->ID = CODE_AuthorizationStateReady;
  res->refcnt = 1;
  return res;
}
char *TdSerializeAuthorizationStateReady (struct TdAuthorizationStateReady *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateReady *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateReady (struct TdAuthorizationStateReady *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateReady *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthorizationStateReady (struct TdAuthorizationStateReady *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateReady *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateReady");
  M->new_field ("ID");
}
struct TdAuthorizationStateReady *TdStackFetcherAuthorizationStateReady (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateReady ();
  res->ID = CODE_AuthorizationStateReady;
  res->refcnt = 1;
  return res;
}
struct TdAuthorizationStateLoggingOut *TdCreateObjectAuthorizationStateLoggingOut (void) {
  auto var = new struct TdAuthorizationStateLoggingOut ();
  var->ID = CODE_AuthorizationStateLoggingOut;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateLoggingOut> TdConvertToInternal (struct TdAuthorizationStateLoggingOut *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::authorizationStateLoggingOut>();
}
struct TdAuthorizationStateLoggingOut *TdConvertFromInternal (const td::td_api::authorizationStateLoggingOut &from) {
  auto res = new TdAuthorizationStateLoggingOut ();
  res->ID = CODE_AuthorizationStateLoggingOut;
  res->refcnt = 1;
  return res;
}
char *TdSerializeAuthorizationStateLoggingOut (struct TdAuthorizationStateLoggingOut *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateLoggingOut *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateLoggingOut (struct TdAuthorizationStateLoggingOut *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateLoggingOut *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthorizationStateLoggingOut (struct TdAuthorizationStateLoggingOut *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateLoggingOut *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateLoggingOut");
  M->new_field ("ID");
}
struct TdAuthorizationStateLoggingOut *TdStackFetcherAuthorizationStateLoggingOut (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateLoggingOut ();
  res->ID = CODE_AuthorizationStateLoggingOut;
  res->refcnt = 1;
  return res;
}
struct TdAuthorizationStateClosing *TdCreateObjectAuthorizationStateClosing (void) {
  auto var = new struct TdAuthorizationStateClosing ();
  var->ID = CODE_AuthorizationStateClosing;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateClosing> TdConvertToInternal (struct TdAuthorizationStateClosing *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::authorizationStateClosing>();
}
struct TdAuthorizationStateClosing *TdConvertFromInternal (const td::td_api::authorizationStateClosing &from) {
  auto res = new TdAuthorizationStateClosing ();
  res->ID = CODE_AuthorizationStateClosing;
  res->refcnt = 1;
  return res;
}
char *TdSerializeAuthorizationStateClosing (struct TdAuthorizationStateClosing *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateClosing *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateClosing (struct TdAuthorizationStateClosing *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateClosing *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthorizationStateClosing (struct TdAuthorizationStateClosing *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateClosing *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateClosing");
  M->new_field ("ID");
}
struct TdAuthorizationStateClosing *TdStackFetcherAuthorizationStateClosing (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateClosing ();
  res->ID = CODE_AuthorizationStateClosing;
  res->refcnt = 1;
  return res;
}
struct TdAuthorizationStateClosed *TdCreateObjectAuthorizationStateClosed (void) {
  auto var = new struct TdAuthorizationStateClosed ();
  var->ID = CODE_AuthorizationStateClosed;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::authorizationStateClosed> TdConvertToInternal (struct TdAuthorizationStateClosed *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::authorizationStateClosed>();
}
struct TdAuthorizationStateClosed *TdConvertFromInternal (const td::td_api::authorizationStateClosed &from) {
  auto res = new TdAuthorizationStateClosed ();
  res->ID = CODE_AuthorizationStateClosed;
  res->refcnt = 1;
  return res;
}
char *TdSerializeAuthorizationStateClosed (struct TdAuthorizationStateClosed *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAuthorizationStateClosed *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAuthorizationStateClosed (struct TdAuthorizationStateClosed *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAuthorizationStateClosed *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAuthorizationStateClosed (struct TdAuthorizationStateClosed *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAuthorizationStateClosed *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AuthorizationStateClosed");
  M->new_field ("ID");
}
struct TdAuthorizationStateClosed *TdStackFetcherAuthorizationStateClosed (struct TdStackFetcherMethods *M) {
  auto res = new TdAuthorizationStateClosed ();
  res->ID = CODE_AuthorizationStateClosed;
  res->refcnt = 1;
  return res;
}
struct TdBasicGroup *TdCreateObjectBasicGroup (int id_, int member_count_, struct TdChatMemberStatus *status_, int everyone_is_administrator_, int is_active_, int upgraded_to_supergroup_id_) {
  auto var = new struct TdBasicGroup ();
  var->ID = CODE_BasicGroup;
  var->refcnt = 1;
  var->id_ = id_;
  var->member_count_ = member_count_;
  var->status_ = status_;
  var->everyone_is_administrator_ = everyone_is_administrator_;
  var->is_active_ = is_active_;
  var->upgraded_to_supergroup_id_ = upgraded_to_supergroup_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::basicGroup> TdConvertToInternal (struct TdBasicGroup *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->member_count_;
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v200;
  v200 = TdConvertToInternal (var->status_);
  bool v300;
  v300 = var->everyone_is_administrator_ != 0;
  bool v400;
  v400 = var->is_active_ != 0;
  std::int32_t v500;
  v500 = var->upgraded_to_supergroup_id_;
  return td::td_api::make_object<td::td_api::basicGroup>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdBasicGroup *TdConvertFromInternal (const td::td_api::basicGroup &from) {
  auto res = new TdBasicGroup ();
  res->ID = CODE_BasicGroup;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->member_count_ = from.member_count_;
  if (!from.status_) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.status_));
  }
  res->everyone_is_administrator_ = from.everyone_is_administrator_;
  res->is_active_ = from.is_active_;
  res->upgraded_to_supergroup_id_ = from.upgraded_to_supergroup_id_;
  return res;
}
char *TdSerializeBasicGroup (struct TdBasicGroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdBasicGroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectBasicGroup (struct TdBasicGroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdBasicGroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->status_);
  delete var;
}
void TdStackStorerBasicGroup (struct TdBasicGroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdBasicGroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("BasicGroup");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->member_count_);
  M->new_field ("member_count_");
  TdStackStorer (var->status_, M);
  M->new_field ("status_");
  M->pack_bool (var->everyone_is_administrator_);
  M->new_field ("everyone_is_administrator_");
  M->pack_bool (var->is_active_);
  M->new_field ("is_active_");
  M->pack_long (var->upgraded_to_supergroup_id_);
  M->new_field ("upgraded_to_supergroup_id_");
}
struct TdBasicGroup *TdStackFetcherBasicGroup (struct TdStackFetcherMethods *M) {
  auto res = new TdBasicGroup ();
  res->ID = CODE_BasicGroup;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("member_count_");
  res->member_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("status_");
  if (M->is_nil ()) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  M->get_field ("everyone_is_administrator_");
  res->everyone_is_administrator_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_active_");
  res->is_active_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("upgraded_to_supergroup_id_");
  res->upgraded_to_supergroup_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdBasicGroupFullInfo *TdCreateObjectBasicGroupFullInfo (int creator_user_id_, struct TdVectorChatMember *members_, char *invite_link_) {
  auto var = new struct TdBasicGroupFullInfo ();
  var->ID = CODE_BasicGroupFullInfo;
  var->refcnt = 1;
  var->creator_user_id_ = creator_user_id_;
  var->members_ = members_;
  var->invite_link_ = (invite_link_) ? td::str_dup (td::Slice (invite_link_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::basicGroupFullInfo> TdConvertToInternal (struct TdBasicGroupFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->creator_user_id_;
  std::vector<td::td_api::object_ptr<td::td_api::chatMember>> v100;
  for (int i100 = 0; i100 < var->members_->len; i100++) {
    td::td_api::object_ptr<td::td_api::chatMember> v101;
    v101 = TdConvertToInternal (var->members_->data[i100]);
    v100.push_back (std::move (v101));
  }
  std::string v200;
  v200 = (var->invite_link_) ? var->invite_link_: "";
  return td::td_api::make_object<td::td_api::basicGroupFullInfo>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdBasicGroupFullInfo *TdConvertFromInternal (const td::td_api::basicGroupFullInfo &from) {
  auto res = new TdBasicGroupFullInfo ();
  res->ID = CODE_BasicGroupFullInfo;
  res->refcnt = 1;
  res->creator_user_id_ = from.creator_user_id_;
  res->members_ = new TdVectorChatMember ();
  res->members_->len = (int)from.members_.size ();
  res->members_->data = new struct TdChatMember * [res->members_->len];
  for (int i100 = 0; i100 < res->members_->len; i100++) {
    if (!from.members_[i100]) {
      res->members_->data[i100] = nullptr;
    } else {
      res->members_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::chatMember &>(*from.members_[i100]));
    }
  }
  res->invite_link_ = (from.invite_link_.length ()) ? td::str_dup (from.invite_link_) : nullptr;
  return res;
}
char *TdSerializeBasicGroupFullInfo (struct TdBasicGroupFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdBasicGroupFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectBasicGroupFullInfo (struct TdBasicGroupFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdBasicGroupFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->members_->len; i100++) {
    TdDestroyObject (var->members_->data[i100]);
  }
  delete[] var->members_->data;
  delete var->members_;
  free (var->invite_link_);
  delete var;
}
void TdStackStorerBasicGroupFullInfo (struct TdBasicGroupFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdBasicGroupFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("BasicGroupFullInfo");
  M->new_field ("ID");
  M->pack_long (var->creator_user_id_);
  M->new_field ("creator_user_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->members_->len; i100++) {
    TdStackStorer (var->members_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("members_");
  M->pack_string (var->invite_link_);
  M->new_field ("invite_link_");
}
struct TdBasicGroupFullInfo *TdStackFetcherBasicGroupFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdBasicGroupFullInfo ();
  res->ID = CODE_BasicGroupFullInfo;
  res->refcnt = 1;
  M->get_field ("creator_user_id_");
  res->creator_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("members_");
  res->members_ = new TdVectorChatMember ();
  res->members_->len = M->get_arr_size ();
  res->members_->data = new struct TdChatMember * [res->members_->len];
  for (int i100 = 0; i100 < res->members_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->members_->data[i100] = nullptr;
    } else {
      res->members_->data[i100] = TdStackFetcherChatMember (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("invite_link_");
  res->invite_link_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdBotCommand *TdCreateObjectBotCommand (char *command_, char *description_) {
  auto var = new struct TdBotCommand ();
  var->ID = CODE_BotCommand;
  var->refcnt = 1;
  var->command_ = (command_) ? td::str_dup (td::Slice (command_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::botCommand> TdConvertToInternal (struct TdBotCommand *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->command_) ? var->command_: "";
  std::string v100;
  v100 = (var->description_) ? var->description_: "";
  return td::td_api::make_object<td::td_api::botCommand>(std::move (v0), std::move (v100));
}
struct TdBotCommand *TdConvertFromInternal (const td::td_api::botCommand &from) {
  auto res = new TdBotCommand ();
  res->ID = CODE_BotCommand;
  res->refcnt = 1;
  res->command_ = (from.command_.length ()) ? td::str_dup (from.command_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  return res;
}
char *TdSerializeBotCommand (struct TdBotCommand *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdBotCommand *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectBotCommand (struct TdBotCommand *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdBotCommand *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->command_);
  free (var->description_);
  delete var;
}
void TdStackStorerBotCommand (struct TdBotCommand *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdBotCommand *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("BotCommand");
  M->new_field ("ID");
  M->pack_string (var->command_);
  M->new_field ("command_");
  M->pack_string (var->description_);
  M->new_field ("description_");
}
struct TdBotCommand *TdStackFetcherBotCommand (struct TdStackFetcherMethods *M) {
  auto res = new TdBotCommand ();
  res->ID = CODE_BotCommand;
  res->refcnt = 1;
  M->get_field ("command_");
  res->command_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdBotInfo *TdCreateObjectBotInfo (char *description_, struct TdVectorBotCommand *commands_) {
  auto var = new struct TdBotInfo ();
  var->ID = CODE_BotInfo;
  var->refcnt = 1;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->commands_ = commands_;
  return var;
}
td::td_api::object_ptr<td::td_api::botInfo> TdConvertToInternal (struct TdBotInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->description_) ? var->description_: "";
  std::vector<td::td_api::object_ptr<td::td_api::botCommand>> v100;
  for (int i100 = 0; i100 < var->commands_->len; i100++) {
    td::td_api::object_ptr<td::td_api::botCommand> v101;
    v101 = TdConvertToInternal (var->commands_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::botInfo>(std::move (v0), std::move (v100));
}
struct TdBotInfo *TdConvertFromInternal (const td::td_api::botInfo &from) {
  auto res = new TdBotInfo ();
  res->ID = CODE_BotInfo;
  res->refcnt = 1;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  res->commands_ = new TdVectorBotCommand ();
  res->commands_->len = (int)from.commands_.size ();
  res->commands_->data = new struct TdBotCommand * [res->commands_->len];
  for (int i100 = 0; i100 < res->commands_->len; i100++) {
    if (!from.commands_[i100]) {
      res->commands_->data[i100] = nullptr;
    } else {
      res->commands_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::botCommand &>(*from.commands_[i100]));
    }
  }
  return res;
}
char *TdSerializeBotInfo (struct TdBotInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdBotInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectBotInfo (struct TdBotInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdBotInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->description_);
  for (int i100 = 0; i100 < var->commands_->len; i100++) {
    TdDestroyObject (var->commands_->data[i100]);
  }
  delete[] var->commands_->data;
  delete var->commands_;
  delete var;
}
void TdStackStorerBotInfo (struct TdBotInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdBotInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("BotInfo");
  M->new_field ("ID");
  M->pack_string (var->description_);
  M->new_field ("description_");
  M->new_array ();
  for (int i100 = 0; i100 < var->commands_->len; i100++) {
    TdStackStorer (var->commands_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("commands_");
}
struct TdBotInfo *TdStackFetcherBotInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdBotInfo ();
  res->ID = CODE_BotInfo;
  res->refcnt = 1;
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("commands_");
  res->commands_ = new TdVectorBotCommand ();
  res->commands_->len = M->get_arr_size ();
  res->commands_->data = new struct TdBotCommand * [res->commands_->len];
  for (int i100 = 0; i100 < res->commands_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->commands_->data[i100] = nullptr;
    } else {
      res->commands_->data[i100] = TdStackFetcherBotCommand (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdCall *TdCreateObjectCall (int id_, int user_id_, int is_outgoing_, struct TdCallState *state_) {
  auto var = new struct TdCall ();
  var->ID = CODE_Call;
  var->refcnt = 1;
  var->id_ = id_;
  var->user_id_ = user_id_;
  var->is_outgoing_ = is_outgoing_;
  var->state_ = state_;
  return var;
}
td::td_api::object_ptr<td::td_api::call> TdConvertToInternal (struct TdCall *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->user_id_;
  bool v200;
  v200 = var->is_outgoing_ != 0;
  td::td_api::object_ptr<td::td_api::CallState> v300;
  v300 = TdConvertToInternal (var->state_);
  return td::td_api::make_object<td::td_api::call>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdCall *TdConvertFromInternal (const td::td_api::call &from) {
  auto res = new TdCall ();
  res->ID = CODE_Call;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->user_id_ = from.user_id_;
  res->is_outgoing_ = from.is_outgoing_;
  if (!from.state_) {
    res->state_ = nullptr;
  } else {
    res->state_ = TdConvertFromInternal (static_cast<const td::td_api::CallState &>(*from.state_));
  }
  return res;
}
char *TdSerializeCall (struct TdCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCall (struct TdCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->state_);
  delete var;
}
void TdStackStorerCall (struct TdCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Call");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_bool (var->is_outgoing_);
  M->new_field ("is_outgoing_");
  TdStackStorer (var->state_, M);
  M->new_field ("state_");
}
struct TdCall *TdStackFetcherCall (struct TdStackFetcherMethods *M) {
  auto res = new TdCall ();
  res->ID = CODE_Call;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_outgoing_");
  res->is_outgoing_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("state_");
  if (M->is_nil ()) {
    res->state_ = nullptr;
  } else {
    res->state_ = TdStackFetcherCallState (M);
  }
  M->pop ();
  return res;
}
struct TdCallConnection *TdCreateObjectCallConnection (long long id_, char *ip_, char *ipv6_, int port_, struct TdBytes peer_tag_) {
  auto var = new struct TdCallConnection ();
  var->ID = CODE_CallConnection;
  var->refcnt = 1;
  var->id_ = id_;
  var->ip_ = (ip_) ? td::str_dup (td::Slice (ip_)) : nullptr;
  var->ipv6_ = (ipv6_) ? td::str_dup (td::Slice (ipv6_)) : nullptr;
  var->port_ = port_;
  var->peer_tag_ = peer_tag_;
  return var;
}
td::td_api::object_ptr<td::td_api::callConnection> TdConvertToInternal (struct TdCallConnection *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->ip_) ? var->ip_: "";
  std::string v200;
  v200 = (var->ipv6_) ? var->ipv6_: "";
  std::int32_t v300;
  v300 = var->port_;
  std::string v400;
  v400 = std::string ((char *)var->peer_tag_.data, var->peer_tag_.len);
  return td::td_api::make_object<td::td_api::callConnection>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdCallConnection *TdConvertFromInternal (const td::td_api::callConnection &from) {
  auto res = new TdCallConnection ();
  res->ID = CODE_CallConnection;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->ip_ = (from.ip_.length ()) ? td::str_dup (from.ip_) : nullptr;
  res->ipv6_ = (from.ipv6_.length ()) ? td::str_dup (from.ipv6_) : nullptr;
  res->port_ = from.port_;
  res->peer_tag_.len = (int)from.peer_tag_.length ();
  if (res->peer_tag_.len) {
    res->peer_tag_.data = new unsigned char[res->peer_tag_.len];
    memcpy (res->peer_tag_.data, from.peer_tag_.c_str (), res->peer_tag_.len);
  } else {
    res->peer_tag_.data = nullptr;
  }
  return res;
}
char *TdSerializeCallConnection (struct TdCallConnection *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallConnection *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallConnection (struct TdCallConnection *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallConnection *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->ip_);
  free (var->ipv6_);
  delete[]var->peer_tag_.data;
  delete var;
}
void TdStackStorerCallConnection (struct TdCallConnection *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallConnection *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallConnection");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->ip_);
  M->new_field ("ip_");
  M->pack_string (var->ipv6_);
  M->new_field ("ipv6_");
  M->pack_long (var->port_);
  M->new_field ("port_");
  M->pack_bytes (var->peer_tag_.data, var->peer_tag_.len);
  M->new_field ("peer_tag_");
}
struct TdCallConnection *TdStackFetcherCallConnection (struct TdStackFetcherMethods *M) {
  auto res = new TdCallConnection ();
  res->ID = CODE_CallConnection;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("ip_");
  res->ip_ = M->get_string ();
  M->pop ();
  M->get_field ("ipv6_");
  res->ipv6_ = M->get_string ();
  M->pop ();
  M->get_field ("port_");
  res->port_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("peer_tag_");
  res->peer_tag_.data = M->get_bytes (&res->peer_tag_.len);
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::CallDiscardReason> TdConvertToInternal (struct TdCallDiscardReason *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallDiscardReasonEmpty: return TdConvertToInternal ((struct TdCallDiscardReasonEmpty *)var);
    case CODE_CallDiscardReasonMissed: return TdConvertToInternal ((struct TdCallDiscardReasonMissed *)var);
    case CODE_CallDiscardReasonDeclined: return TdConvertToInternal ((struct TdCallDiscardReasonDeclined *)var);
    case CODE_CallDiscardReasonDisconnected: return TdConvertToInternal ((struct TdCallDiscardReasonDisconnected *)var);
    case CODE_CallDiscardReasonHungUp: return TdConvertToInternal ((struct TdCallDiscardReasonHungUp *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdCallDiscardReason *TdConvertFromInternal (const td::td_api::CallDiscardReason &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_CallDiscardReasonEmpty: return (struct TdCallDiscardReason *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonEmpty &>(from));
    case CODE_CallDiscardReasonMissed: return (struct TdCallDiscardReason *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonMissed &>(from));
    case CODE_CallDiscardReasonDeclined: return (struct TdCallDiscardReason *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonDeclined &>(from));
    case CODE_CallDiscardReasonDisconnected: return (struct TdCallDiscardReason *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonDisconnected &>(from));
    case CODE_CallDiscardReasonHungUp: return (struct TdCallDiscardReason *)TdConvertFromInternal(static_cast<const td::td_api::callDiscardReasonHungUp &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeCallDiscardReason (struct TdCallDiscardReason *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallDiscardReason *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallDiscardReason (struct TdCallDiscardReason *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallDiscardReason *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallDiscardReasonEmpty: return TdDestroyObject ((struct TdCallDiscardReasonEmpty *)var);
    case CODE_CallDiscardReasonMissed: return TdDestroyObject ((struct TdCallDiscardReasonMissed *)var);
    case CODE_CallDiscardReasonDeclined: return TdDestroyObject ((struct TdCallDiscardReasonDeclined *)var);
    case CODE_CallDiscardReasonDisconnected: return TdDestroyObject ((struct TdCallDiscardReasonDisconnected *)var);
    case CODE_CallDiscardReasonHungUp: return TdDestroyObject ((struct TdCallDiscardReasonHungUp *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerCallDiscardReason (struct TdCallDiscardReason *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallDiscardReason *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallDiscardReasonEmpty: return TdStackStorer ((struct TdCallDiscardReasonEmpty *)var, M);
    case CODE_CallDiscardReasonMissed: return TdStackStorer ((struct TdCallDiscardReasonMissed *)var, M);
    case CODE_CallDiscardReasonDeclined: return TdStackStorer ((struct TdCallDiscardReasonDeclined *)var, M);
    case CODE_CallDiscardReasonDisconnected: return TdStackStorer ((struct TdCallDiscardReasonDisconnected *)var, M);
    case CODE_CallDiscardReasonHungUp: return TdStackStorer ((struct TdCallDiscardReasonHungUp *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdCallDiscardReason *TdStackFetcherCallDiscardReason (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "CallDiscardReasonEmpty") {
    return (struct TdCallDiscardReason *)TdStackFetcherCallDiscardReasonEmpty (M);
  }
  if (constructor == "CallDiscardReasonMissed") {
    return (struct TdCallDiscardReason *)TdStackFetcherCallDiscardReasonMissed (M);
  }
  if (constructor == "CallDiscardReasonDeclined") {
    return (struct TdCallDiscardReason *)TdStackFetcherCallDiscardReasonDeclined (M);
  }
  if (constructor == "CallDiscardReasonDisconnected") {
    return (struct TdCallDiscardReason *)TdStackFetcherCallDiscardReasonDisconnected (M);
  }
  if (constructor == "CallDiscardReasonHungUp") {
    return (struct TdCallDiscardReason *)TdStackFetcherCallDiscardReasonHungUp (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdCallDiscardReasonEmpty *TdCreateObjectCallDiscardReasonEmpty (void) {
  auto var = new struct TdCallDiscardReasonEmpty ();
  var->ID = CODE_CallDiscardReasonEmpty;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::callDiscardReasonEmpty> TdConvertToInternal (struct TdCallDiscardReasonEmpty *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::callDiscardReasonEmpty>();
}
struct TdCallDiscardReasonEmpty *TdConvertFromInternal (const td::td_api::callDiscardReasonEmpty &from) {
  auto res = new TdCallDiscardReasonEmpty ();
  res->ID = CODE_CallDiscardReasonEmpty;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCallDiscardReasonEmpty (struct TdCallDiscardReasonEmpty *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallDiscardReasonEmpty *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallDiscardReasonEmpty (struct TdCallDiscardReasonEmpty *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallDiscardReasonEmpty *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallDiscardReasonEmpty (struct TdCallDiscardReasonEmpty *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallDiscardReasonEmpty *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallDiscardReasonEmpty");
  M->new_field ("ID");
}
struct TdCallDiscardReasonEmpty *TdStackFetcherCallDiscardReasonEmpty (struct TdStackFetcherMethods *M) {
  auto res = new TdCallDiscardReasonEmpty ();
  res->ID = CODE_CallDiscardReasonEmpty;
  res->refcnt = 1;
  return res;
}
struct TdCallDiscardReasonMissed *TdCreateObjectCallDiscardReasonMissed (void) {
  auto var = new struct TdCallDiscardReasonMissed ();
  var->ID = CODE_CallDiscardReasonMissed;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::callDiscardReasonMissed> TdConvertToInternal (struct TdCallDiscardReasonMissed *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::callDiscardReasonMissed>();
}
struct TdCallDiscardReasonMissed *TdConvertFromInternal (const td::td_api::callDiscardReasonMissed &from) {
  auto res = new TdCallDiscardReasonMissed ();
  res->ID = CODE_CallDiscardReasonMissed;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCallDiscardReasonMissed (struct TdCallDiscardReasonMissed *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallDiscardReasonMissed *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallDiscardReasonMissed (struct TdCallDiscardReasonMissed *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallDiscardReasonMissed *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallDiscardReasonMissed (struct TdCallDiscardReasonMissed *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallDiscardReasonMissed *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallDiscardReasonMissed");
  M->new_field ("ID");
}
struct TdCallDiscardReasonMissed *TdStackFetcherCallDiscardReasonMissed (struct TdStackFetcherMethods *M) {
  auto res = new TdCallDiscardReasonMissed ();
  res->ID = CODE_CallDiscardReasonMissed;
  res->refcnt = 1;
  return res;
}
struct TdCallDiscardReasonDeclined *TdCreateObjectCallDiscardReasonDeclined (void) {
  auto var = new struct TdCallDiscardReasonDeclined ();
  var->ID = CODE_CallDiscardReasonDeclined;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::callDiscardReasonDeclined> TdConvertToInternal (struct TdCallDiscardReasonDeclined *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::callDiscardReasonDeclined>();
}
struct TdCallDiscardReasonDeclined *TdConvertFromInternal (const td::td_api::callDiscardReasonDeclined &from) {
  auto res = new TdCallDiscardReasonDeclined ();
  res->ID = CODE_CallDiscardReasonDeclined;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCallDiscardReasonDeclined (struct TdCallDiscardReasonDeclined *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallDiscardReasonDeclined *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallDiscardReasonDeclined (struct TdCallDiscardReasonDeclined *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallDiscardReasonDeclined *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallDiscardReasonDeclined (struct TdCallDiscardReasonDeclined *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallDiscardReasonDeclined *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallDiscardReasonDeclined");
  M->new_field ("ID");
}
struct TdCallDiscardReasonDeclined *TdStackFetcherCallDiscardReasonDeclined (struct TdStackFetcherMethods *M) {
  auto res = new TdCallDiscardReasonDeclined ();
  res->ID = CODE_CallDiscardReasonDeclined;
  res->refcnt = 1;
  return res;
}
struct TdCallDiscardReasonDisconnected *TdCreateObjectCallDiscardReasonDisconnected (void) {
  auto var = new struct TdCallDiscardReasonDisconnected ();
  var->ID = CODE_CallDiscardReasonDisconnected;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::callDiscardReasonDisconnected> TdConvertToInternal (struct TdCallDiscardReasonDisconnected *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::callDiscardReasonDisconnected>();
}
struct TdCallDiscardReasonDisconnected *TdConvertFromInternal (const td::td_api::callDiscardReasonDisconnected &from) {
  auto res = new TdCallDiscardReasonDisconnected ();
  res->ID = CODE_CallDiscardReasonDisconnected;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCallDiscardReasonDisconnected (struct TdCallDiscardReasonDisconnected *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallDiscardReasonDisconnected *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallDiscardReasonDisconnected (struct TdCallDiscardReasonDisconnected *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallDiscardReasonDisconnected *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallDiscardReasonDisconnected (struct TdCallDiscardReasonDisconnected *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallDiscardReasonDisconnected *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallDiscardReasonDisconnected");
  M->new_field ("ID");
}
struct TdCallDiscardReasonDisconnected *TdStackFetcherCallDiscardReasonDisconnected (struct TdStackFetcherMethods *M) {
  auto res = new TdCallDiscardReasonDisconnected ();
  res->ID = CODE_CallDiscardReasonDisconnected;
  res->refcnt = 1;
  return res;
}
struct TdCallDiscardReasonHungUp *TdCreateObjectCallDiscardReasonHungUp (void) {
  auto var = new struct TdCallDiscardReasonHungUp ();
  var->ID = CODE_CallDiscardReasonHungUp;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::callDiscardReasonHungUp> TdConvertToInternal (struct TdCallDiscardReasonHungUp *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::callDiscardReasonHungUp>();
}
struct TdCallDiscardReasonHungUp *TdConvertFromInternal (const td::td_api::callDiscardReasonHungUp &from) {
  auto res = new TdCallDiscardReasonHungUp ();
  res->ID = CODE_CallDiscardReasonHungUp;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCallDiscardReasonHungUp (struct TdCallDiscardReasonHungUp *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallDiscardReasonHungUp *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallDiscardReasonHungUp (struct TdCallDiscardReasonHungUp *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallDiscardReasonHungUp *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallDiscardReasonHungUp (struct TdCallDiscardReasonHungUp *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallDiscardReasonHungUp *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallDiscardReasonHungUp");
  M->new_field ("ID");
}
struct TdCallDiscardReasonHungUp *TdStackFetcherCallDiscardReasonHungUp (struct TdStackFetcherMethods *M) {
  auto res = new TdCallDiscardReasonHungUp ();
  res->ID = CODE_CallDiscardReasonHungUp;
  res->refcnt = 1;
  return res;
}
struct TdCallId *TdCreateObjectCallId (int id_) {
  auto var = new struct TdCallId ();
  var->ID = CODE_CallId;
  var->refcnt = 1;
  var->id_ = id_;
  return var;
}
td::td_api::object_ptr<td::td_api::callId> TdConvertToInternal (struct TdCallId *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  return td::td_api::make_object<td::td_api::callId>(std::move (v0));
}
struct TdCallId *TdConvertFromInternal (const td::td_api::callId &from) {
  auto res = new TdCallId ();
  res->ID = CODE_CallId;
  res->refcnt = 1;
  res->id_ = from.id_;
  return res;
}
char *TdSerializeCallId (struct TdCallId *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallId *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallId (struct TdCallId *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallId *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallId (struct TdCallId *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallId *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallId");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
}
struct TdCallId *TdStackFetcherCallId (struct TdStackFetcherMethods *M) {
  auto res = new TdCallId ();
  res->ID = CODE_CallId;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCallProtocol *TdCreateObjectCallProtocol (int udp_p2p_, int udp_reflector_, int min_layer_, int max_layer_) {
  auto var = new struct TdCallProtocol ();
  var->ID = CODE_CallProtocol;
  var->refcnt = 1;
  var->udp_p2p_ = udp_p2p_;
  var->udp_reflector_ = udp_reflector_;
  var->min_layer_ = min_layer_;
  var->max_layer_ = max_layer_;
  return var;
}
td::td_api::object_ptr<td::td_api::callProtocol> TdConvertToInternal (struct TdCallProtocol *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->udp_p2p_ != 0;
  bool v100;
  v100 = var->udp_reflector_ != 0;
  std::int32_t v200;
  v200 = var->min_layer_;
  std::int32_t v300;
  v300 = var->max_layer_;
  return td::td_api::make_object<td::td_api::callProtocol>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdCallProtocol *TdConvertFromInternal (const td::td_api::callProtocol &from) {
  auto res = new TdCallProtocol ();
  res->ID = CODE_CallProtocol;
  res->refcnt = 1;
  res->udp_p2p_ = from.udp_p2p_;
  res->udp_reflector_ = from.udp_reflector_;
  res->min_layer_ = from.min_layer_;
  res->max_layer_ = from.max_layer_;
  return res;
}
char *TdSerializeCallProtocol (struct TdCallProtocol *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallProtocol *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallProtocol (struct TdCallProtocol *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallProtocol *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallProtocol (struct TdCallProtocol *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallProtocol *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallProtocol");
  M->new_field ("ID");
  M->pack_bool (var->udp_p2p_);
  M->new_field ("udp_p2p_");
  M->pack_bool (var->udp_reflector_);
  M->new_field ("udp_reflector_");
  M->pack_long (var->min_layer_);
  M->new_field ("min_layer_");
  M->pack_long (var->max_layer_);
  M->new_field ("max_layer_");
}
struct TdCallProtocol *TdStackFetcherCallProtocol (struct TdStackFetcherMethods *M) {
  auto res = new TdCallProtocol ();
  res->ID = CODE_CallProtocol;
  res->refcnt = 1;
  M->get_field ("udp_p2p_");
  res->udp_p2p_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("udp_reflector_");
  res->udp_reflector_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("min_layer_");
  res->min_layer_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("max_layer_");
  res->max_layer_ = (int)M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::CallState> TdConvertToInternal (struct TdCallState *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallStatePending: return TdConvertToInternal ((struct TdCallStatePending *)var);
    case CODE_CallStateExchangingKeys: return TdConvertToInternal ((struct TdCallStateExchangingKeys *)var);
    case CODE_CallStateReady: return TdConvertToInternal ((struct TdCallStateReady *)var);
    case CODE_CallStateHangingUp: return TdConvertToInternal ((struct TdCallStateHangingUp *)var);
    case CODE_CallStateDiscarded: return TdConvertToInternal ((struct TdCallStateDiscarded *)var);
    case CODE_CallStateError: return TdConvertToInternal ((struct TdCallStateError *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdCallState *TdConvertFromInternal (const td::td_api::CallState &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_CallStatePending: return (struct TdCallState *)TdConvertFromInternal(static_cast<const td::td_api::callStatePending &>(from));
    case CODE_CallStateExchangingKeys: return (struct TdCallState *)TdConvertFromInternal(static_cast<const td::td_api::callStateExchangingKeys &>(from));
    case CODE_CallStateReady: return (struct TdCallState *)TdConvertFromInternal(static_cast<const td::td_api::callStateReady &>(from));
    case CODE_CallStateHangingUp: return (struct TdCallState *)TdConvertFromInternal(static_cast<const td::td_api::callStateHangingUp &>(from));
    case CODE_CallStateDiscarded: return (struct TdCallState *)TdConvertFromInternal(static_cast<const td::td_api::callStateDiscarded &>(from));
    case CODE_CallStateError: return (struct TdCallState *)TdConvertFromInternal(static_cast<const td::td_api::callStateError &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeCallState (struct TdCallState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallState (struct TdCallState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallState *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallStatePending: return TdDestroyObject ((struct TdCallStatePending *)var);
    case CODE_CallStateExchangingKeys: return TdDestroyObject ((struct TdCallStateExchangingKeys *)var);
    case CODE_CallStateReady: return TdDestroyObject ((struct TdCallStateReady *)var);
    case CODE_CallStateHangingUp: return TdDestroyObject ((struct TdCallStateHangingUp *)var);
    case CODE_CallStateDiscarded: return TdDestroyObject ((struct TdCallStateDiscarded *)var);
    case CODE_CallStateError: return TdDestroyObject ((struct TdCallStateError *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerCallState (struct TdCallState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallState *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallStatePending: return TdStackStorer ((struct TdCallStatePending *)var, M);
    case CODE_CallStateExchangingKeys: return TdStackStorer ((struct TdCallStateExchangingKeys *)var, M);
    case CODE_CallStateReady: return TdStackStorer ((struct TdCallStateReady *)var, M);
    case CODE_CallStateHangingUp: return TdStackStorer ((struct TdCallStateHangingUp *)var, M);
    case CODE_CallStateDiscarded: return TdStackStorer ((struct TdCallStateDiscarded *)var, M);
    case CODE_CallStateError: return TdStackStorer ((struct TdCallStateError *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdCallState *TdStackFetcherCallState (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "CallStatePending") {
    return (struct TdCallState *)TdStackFetcherCallStatePending (M);
  }
  if (constructor == "CallStateExchangingKeys") {
    return (struct TdCallState *)TdStackFetcherCallStateExchangingKeys (M);
  }
  if (constructor == "CallStateReady") {
    return (struct TdCallState *)TdStackFetcherCallStateReady (M);
  }
  if (constructor == "CallStateHangingUp") {
    return (struct TdCallState *)TdStackFetcherCallStateHangingUp (M);
  }
  if (constructor == "CallStateDiscarded") {
    return (struct TdCallState *)TdStackFetcherCallStateDiscarded (M);
  }
  if (constructor == "CallStateError") {
    return (struct TdCallState *)TdStackFetcherCallStateError (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdCallStatePending *TdCreateObjectCallStatePending (int is_created_, int is_received_) {
  auto var = new struct TdCallStatePending ();
  var->ID = CODE_CallStatePending;
  var->refcnt = 1;
  var->is_created_ = is_created_;
  var->is_received_ = is_received_;
  return var;
}
td::td_api::object_ptr<td::td_api::callStatePending> TdConvertToInternal (struct TdCallStatePending *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_created_ != 0;
  bool v100;
  v100 = var->is_received_ != 0;
  return td::td_api::make_object<td::td_api::callStatePending>(std::move (v0), std::move (v100));
}
struct TdCallStatePending *TdConvertFromInternal (const td::td_api::callStatePending &from) {
  auto res = new TdCallStatePending ();
  res->ID = CODE_CallStatePending;
  res->refcnt = 1;
  res->is_created_ = from.is_created_;
  res->is_received_ = from.is_received_;
  return res;
}
char *TdSerializeCallStatePending (struct TdCallStatePending *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallStatePending *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallStatePending (struct TdCallStatePending *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallStatePending *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallStatePending (struct TdCallStatePending *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallStatePending *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallStatePending");
  M->new_field ("ID");
  M->pack_bool (var->is_created_);
  M->new_field ("is_created_");
  M->pack_bool (var->is_received_);
  M->new_field ("is_received_");
}
struct TdCallStatePending *TdStackFetcherCallStatePending (struct TdStackFetcherMethods *M) {
  auto res = new TdCallStatePending ();
  res->ID = CODE_CallStatePending;
  res->refcnt = 1;
  M->get_field ("is_created_");
  res->is_created_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_received_");
  res->is_received_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCallStateExchangingKeys *TdCreateObjectCallStateExchangingKeys (void) {
  auto var = new struct TdCallStateExchangingKeys ();
  var->ID = CODE_CallStateExchangingKeys;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::callStateExchangingKeys> TdConvertToInternal (struct TdCallStateExchangingKeys *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::callStateExchangingKeys>();
}
struct TdCallStateExchangingKeys *TdConvertFromInternal (const td::td_api::callStateExchangingKeys &from) {
  auto res = new TdCallStateExchangingKeys ();
  res->ID = CODE_CallStateExchangingKeys;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCallStateExchangingKeys (struct TdCallStateExchangingKeys *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallStateExchangingKeys *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallStateExchangingKeys (struct TdCallStateExchangingKeys *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallStateExchangingKeys *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallStateExchangingKeys (struct TdCallStateExchangingKeys *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallStateExchangingKeys *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallStateExchangingKeys");
  M->new_field ("ID");
}
struct TdCallStateExchangingKeys *TdStackFetcherCallStateExchangingKeys (struct TdStackFetcherMethods *M) {
  auto res = new TdCallStateExchangingKeys ();
  res->ID = CODE_CallStateExchangingKeys;
  res->refcnt = 1;
  return res;
}
struct TdCallStateReady *TdCreateObjectCallStateReady (struct TdCallProtocol *protocol_, struct TdVectorCallConnection *connections_, char *config_, struct TdBytes encryption_key_, struct TdVectorString *emojis_) {
  auto var = new struct TdCallStateReady ();
  var->ID = CODE_CallStateReady;
  var->refcnt = 1;
  var->protocol_ = protocol_;
  var->connections_ = connections_;
  var->config_ = (config_) ? td::str_dup (td::Slice (config_)) : nullptr;
  var->encryption_key_ = encryption_key_;
  var->emojis_ = emojis_;
  return var;
}
td::td_api::object_ptr<td::td_api::callStateReady> TdConvertToInternal (struct TdCallStateReady *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::callProtocol> v0;
  v0 = TdConvertToInternal (var->protocol_);
  std::vector<td::td_api::object_ptr<td::td_api::callConnection>> v100;
  for (int i100 = 0; i100 < var->connections_->len; i100++) {
    td::td_api::object_ptr<td::td_api::callConnection> v101;
    v101 = TdConvertToInternal (var->connections_->data[i100]);
    v100.push_back (std::move (v101));
  }
  std::string v200;
  v200 = (var->config_) ? var->config_: "";
  std::string v300;
  v300 = std::string ((char *)var->encryption_key_.data, var->encryption_key_.len);
  std::vector<std::string> v400;
  for (int i400 = 0; i400 < var->emojis_->len; i400++) {
    std::string v401;
    v401 = (var->emojis_->data[i400]) ? var->emojis_->data[i400]: "";
    v400.push_back (std::move (v401));
  }
  return td::td_api::make_object<td::td_api::callStateReady>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdCallStateReady *TdConvertFromInternal (const td::td_api::callStateReady &from) {
  auto res = new TdCallStateReady ();
  res->ID = CODE_CallStateReady;
  res->refcnt = 1;
  if (!from.protocol_) {
    res->protocol_ = nullptr;
  } else {
    res->protocol_ = TdConvertFromInternal (static_cast<const td::td_api::callProtocol &>(*from.protocol_));
  }
  res->connections_ = new TdVectorCallConnection ();
  res->connections_->len = (int)from.connections_.size ();
  res->connections_->data = new struct TdCallConnection * [res->connections_->len];
  for (int i100 = 0; i100 < res->connections_->len; i100++) {
    if (!from.connections_[i100]) {
      res->connections_->data[i100] = nullptr;
    } else {
      res->connections_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::callConnection &>(*from.connections_[i100]));
    }
  }
  res->config_ = (from.config_.length ()) ? td::str_dup (from.config_) : nullptr;
  res->encryption_key_.len = (int)from.encryption_key_.length ();
  if (res->encryption_key_.len) {
    res->encryption_key_.data = new unsigned char[res->encryption_key_.len];
    memcpy (res->encryption_key_.data, from.encryption_key_.c_str (), res->encryption_key_.len);
  } else {
    res->encryption_key_.data = nullptr;
  }
  res->emojis_ = new TdVectorString ();
  res->emojis_->len = (int)from.emojis_.size ();
  res->emojis_->data = new char * [res->emojis_->len];
  for (int i400 = 0; i400 < res->emojis_->len; i400++) {
    res->emojis_->data[i400] = (from.emojis_[i400].length ()) ? td::str_dup (from.emojis_[i400]) : nullptr;
  }
  return res;
}
char *TdSerializeCallStateReady (struct TdCallStateReady *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallStateReady *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallStateReady (struct TdCallStateReady *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallStateReady *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->protocol_);
  for (int i100 = 0; i100 < var->connections_->len; i100++) {
    TdDestroyObject (var->connections_->data[i100]);
  }
  delete[] var->connections_->data;
  delete var->connections_;
  free (var->config_);
  delete[]var->encryption_key_.data;
  for (int i400 = 0; i400 < var->emojis_->len; i400++) {
    free (var->emojis_->data[i400]);
  }
  delete[] var->emojis_->data;
  delete var->emojis_;
  delete var;
}
void TdStackStorerCallStateReady (struct TdCallStateReady *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallStateReady *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallStateReady");
  M->new_field ("ID");
  TdStackStorer (var->protocol_, M);
  M->new_field ("protocol_");
  M->new_array ();
  for (int i100 = 0; i100 < var->connections_->len; i100++) {
    TdStackStorer (var->connections_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("connections_");
  M->pack_string (var->config_);
  M->new_field ("config_");
  M->pack_bytes (var->encryption_key_.data, var->encryption_key_.len);
  M->new_field ("encryption_key_");
  M->new_array ();
  for (int i400 = 0; i400 < var->emojis_->len; i400++) {
    M->pack_string (var->emojis_->data[i400]);
    M->new_arr_field (i400);
  }
  M->new_field ("emojis_");
}
struct TdCallStateReady *TdStackFetcherCallStateReady (struct TdStackFetcherMethods *M) {
  auto res = new TdCallStateReady ();
  res->ID = CODE_CallStateReady;
  res->refcnt = 1;
  M->get_field ("protocol_");
  if (M->is_nil ()) {
    res->protocol_ = nullptr;
  } else {
    res->protocol_ = TdStackFetcherCallProtocol (M);
  }
  M->pop ();
  M->get_field ("connections_");
  res->connections_ = new TdVectorCallConnection ();
  res->connections_->len = M->get_arr_size ();
  res->connections_->data = new struct TdCallConnection * [res->connections_->len];
  for (int i100 = 0; i100 < res->connections_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->connections_->data[i100] = nullptr;
    } else {
      res->connections_->data[i100] = TdStackFetcherCallConnection (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("config_");
  res->config_ = M->get_string ();
  M->pop ();
  M->get_field ("encryption_key_");
  res->encryption_key_.data = M->get_bytes (&res->encryption_key_.len);
  M->pop ();
  M->get_field ("emojis_");
  res->emojis_ = new TdVectorString ();
  res->emojis_->len = M->get_arr_size ();
  res->emojis_->data = new char * [res->emojis_->len];
  for (int i400 = 0; i400 < res->emojis_->len; i400++) {
    M->get_arr_field (i400);
    res->emojis_->data[i400] = M->get_string ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdCallStateHangingUp *TdCreateObjectCallStateHangingUp (void) {
  auto var = new struct TdCallStateHangingUp ();
  var->ID = CODE_CallStateHangingUp;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::callStateHangingUp> TdConvertToInternal (struct TdCallStateHangingUp *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::callStateHangingUp>();
}
struct TdCallStateHangingUp *TdConvertFromInternal (const td::td_api::callStateHangingUp &from) {
  auto res = new TdCallStateHangingUp ();
  res->ID = CODE_CallStateHangingUp;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCallStateHangingUp (struct TdCallStateHangingUp *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallStateHangingUp *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallStateHangingUp (struct TdCallStateHangingUp *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallStateHangingUp *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCallStateHangingUp (struct TdCallStateHangingUp *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallStateHangingUp *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallStateHangingUp");
  M->new_field ("ID");
}
struct TdCallStateHangingUp *TdStackFetcherCallStateHangingUp (struct TdStackFetcherMethods *M) {
  auto res = new TdCallStateHangingUp ();
  res->ID = CODE_CallStateHangingUp;
  res->refcnt = 1;
  return res;
}
struct TdCallStateDiscarded *TdCreateObjectCallStateDiscarded (struct TdCallDiscardReason *reason_, int need_rating_, int need_debug_information_) {
  auto var = new struct TdCallStateDiscarded ();
  var->ID = CODE_CallStateDiscarded;
  var->refcnt = 1;
  var->reason_ = reason_;
  var->need_rating_ = need_rating_;
  var->need_debug_information_ = need_debug_information_;
  return var;
}
td::td_api::object_ptr<td::td_api::callStateDiscarded> TdConvertToInternal (struct TdCallStateDiscarded *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::CallDiscardReason> v0;
  v0 = TdConvertToInternal (var->reason_);
  bool v100;
  v100 = var->need_rating_ != 0;
  bool v200;
  v200 = var->need_debug_information_ != 0;
  return td::td_api::make_object<td::td_api::callStateDiscarded>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdCallStateDiscarded *TdConvertFromInternal (const td::td_api::callStateDiscarded &from) {
  auto res = new TdCallStateDiscarded ();
  res->ID = CODE_CallStateDiscarded;
  res->refcnt = 1;
  if (!from.reason_) {
    res->reason_ = nullptr;
  } else {
    res->reason_ = TdConvertFromInternal (static_cast<const td::td_api::CallDiscardReason &>(*from.reason_));
  }
  res->need_rating_ = from.need_rating_;
  res->need_debug_information_ = from.need_debug_information_;
  return res;
}
char *TdSerializeCallStateDiscarded (struct TdCallStateDiscarded *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallStateDiscarded *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallStateDiscarded (struct TdCallStateDiscarded *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallStateDiscarded *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reason_);
  delete var;
}
void TdStackStorerCallStateDiscarded (struct TdCallStateDiscarded *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallStateDiscarded *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallStateDiscarded");
  M->new_field ("ID");
  TdStackStorer (var->reason_, M);
  M->new_field ("reason_");
  M->pack_bool (var->need_rating_);
  M->new_field ("need_rating_");
  M->pack_bool (var->need_debug_information_);
  M->new_field ("need_debug_information_");
}
struct TdCallStateDiscarded *TdStackFetcherCallStateDiscarded (struct TdStackFetcherMethods *M) {
  auto res = new TdCallStateDiscarded ();
  res->ID = CODE_CallStateDiscarded;
  res->refcnt = 1;
  M->get_field ("reason_");
  if (M->is_nil ()) {
    res->reason_ = nullptr;
  } else {
    res->reason_ = TdStackFetcherCallDiscardReason (M);
  }
  M->pop ();
  M->get_field ("need_rating_");
  res->need_rating_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_debug_information_");
  res->need_debug_information_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCallStateError *TdCreateObjectCallStateError (struct TdError *error_) {
  auto var = new struct TdCallStateError ();
  var->ID = CODE_CallStateError;
  var->refcnt = 1;
  var->error_ = error_;
  return var;
}
td::td_api::object_ptr<td::td_api::callStateError> TdConvertToInternal (struct TdCallStateError *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::error> v0;
  v0 = TdConvertToInternal (var->error_);
  return td::td_api::make_object<td::td_api::callStateError>(std::move (v0));
}
struct TdCallStateError *TdConvertFromInternal (const td::td_api::callStateError &from) {
  auto res = new TdCallStateError ();
  res->ID = CODE_CallStateError;
  res->refcnt = 1;
  if (!from.error_) {
    res->error_ = nullptr;
  } else {
    res->error_ = TdConvertFromInternal (static_cast<const td::td_api::error &>(*from.error_));
  }
  return res;
}
char *TdSerializeCallStateError (struct TdCallStateError *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallStateError *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallStateError (struct TdCallStateError *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallStateError *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->error_);
  delete var;
}
void TdStackStorerCallStateError (struct TdCallStateError *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallStateError *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallStateError");
  M->new_field ("ID");
  TdStackStorer (var->error_, M);
  M->new_field ("error_");
}
struct TdCallStateError *TdStackFetcherCallStateError (struct TdStackFetcherMethods *M) {
  auto res = new TdCallStateError ();
  res->ID = CODE_CallStateError;
  res->refcnt = 1;
  M->get_field ("error_");
  if (M->is_nil ()) {
    res->error_ = nullptr;
  } else {
    res->error_ = TdStackFetcherError (M);
  }
  M->pop ();
  return res;
}
struct TdCallbackQueryAnswer *TdCreateObjectCallbackQueryAnswer (char *text_, int show_alert_, char *url_) {
  auto var = new struct TdCallbackQueryAnswer ();
  var->ID = CODE_CallbackQueryAnswer;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  var->show_alert_ = show_alert_;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::callbackQueryAnswer> TdConvertToInternal (struct TdCallbackQueryAnswer *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  bool v100;
  v100 = var->show_alert_ != 0;
  std::string v200;
  v200 = (var->url_) ? var->url_: "";
  return td::td_api::make_object<td::td_api::callbackQueryAnswer>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdCallbackQueryAnswer *TdConvertFromInternal (const td::td_api::callbackQueryAnswer &from) {
  auto res = new TdCallbackQueryAnswer ();
  res->ID = CODE_CallbackQueryAnswer;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  res->show_alert_ = from.show_alert_;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  return res;
}
char *TdSerializeCallbackQueryAnswer (struct TdCallbackQueryAnswer *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallbackQueryAnswer *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallbackQueryAnswer (struct TdCallbackQueryAnswer *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallbackQueryAnswer *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  free (var->url_);
  delete var;
}
void TdStackStorerCallbackQueryAnswer (struct TdCallbackQueryAnswer *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallbackQueryAnswer *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallbackQueryAnswer");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
  M->pack_bool (var->show_alert_);
  M->new_field ("show_alert_");
  M->pack_string (var->url_);
  M->new_field ("url_");
}
struct TdCallbackQueryAnswer *TdStackFetcherCallbackQueryAnswer (struct TdStackFetcherMethods *M) {
  auto res = new TdCallbackQueryAnswer ();
  res->ID = CODE_CallbackQueryAnswer;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  M->get_field ("show_alert_");
  res->show_alert_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::CallbackQueryPayload> TdConvertToInternal (struct TdCallbackQueryPayload *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallbackQueryPayloadData: return TdConvertToInternal ((struct TdCallbackQueryPayloadData *)var);
    case CODE_CallbackQueryPayloadGame: return TdConvertToInternal ((struct TdCallbackQueryPayloadGame *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdCallbackQueryPayload *TdConvertFromInternal (const td::td_api::CallbackQueryPayload &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_CallbackQueryPayloadData: return (struct TdCallbackQueryPayload *)TdConvertFromInternal(static_cast<const td::td_api::callbackQueryPayloadData &>(from));
    case CODE_CallbackQueryPayloadGame: return (struct TdCallbackQueryPayload *)TdConvertFromInternal(static_cast<const td::td_api::callbackQueryPayloadGame &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeCallbackQueryPayload (struct TdCallbackQueryPayload *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallbackQueryPayload *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallbackQueryPayload (struct TdCallbackQueryPayload *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallbackQueryPayload *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallbackQueryPayloadData: return TdDestroyObject ((struct TdCallbackQueryPayloadData *)var);
    case CODE_CallbackQueryPayloadGame: return TdDestroyObject ((struct TdCallbackQueryPayloadGame *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerCallbackQueryPayload (struct TdCallbackQueryPayload *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallbackQueryPayload *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CallbackQueryPayloadData: return TdStackStorer ((struct TdCallbackQueryPayloadData *)var, M);
    case CODE_CallbackQueryPayloadGame: return TdStackStorer ((struct TdCallbackQueryPayloadGame *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdCallbackQueryPayload *TdStackFetcherCallbackQueryPayload (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "CallbackQueryPayloadData") {
    return (struct TdCallbackQueryPayload *)TdStackFetcherCallbackQueryPayloadData (M);
  }
  if (constructor == "CallbackQueryPayloadGame") {
    return (struct TdCallbackQueryPayload *)TdStackFetcherCallbackQueryPayloadGame (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdCallbackQueryPayloadData *TdCreateObjectCallbackQueryPayloadData (struct TdBytes data_) {
  auto var = new struct TdCallbackQueryPayloadData ();
  var->ID = CODE_CallbackQueryPayloadData;
  var->refcnt = 1;
  var->data_ = data_;
  return var;
}
td::td_api::object_ptr<td::td_api::callbackQueryPayloadData> TdConvertToInternal (struct TdCallbackQueryPayloadData *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->data_.data, var->data_.len);
  return td::td_api::make_object<td::td_api::callbackQueryPayloadData>(std::move (v0));
}
struct TdCallbackQueryPayloadData *TdConvertFromInternal (const td::td_api::callbackQueryPayloadData &from) {
  auto res = new TdCallbackQueryPayloadData ();
  res->ID = CODE_CallbackQueryPayloadData;
  res->refcnt = 1;
  res->data_.len = (int)from.data_.length ();
  if (res->data_.len) {
    res->data_.data = new unsigned char[res->data_.len];
    memcpy (res->data_.data, from.data_.c_str (), res->data_.len);
  } else {
    res->data_.data = nullptr;
  }
  return res;
}
char *TdSerializeCallbackQueryPayloadData (struct TdCallbackQueryPayloadData *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallbackQueryPayloadData *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallbackQueryPayloadData (struct TdCallbackQueryPayloadData *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallbackQueryPayloadData *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->data_.data;
  delete var;
}
void TdStackStorerCallbackQueryPayloadData (struct TdCallbackQueryPayloadData *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallbackQueryPayloadData *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallbackQueryPayloadData");
  M->new_field ("ID");
  M->pack_bytes (var->data_.data, var->data_.len);
  M->new_field ("data_");
}
struct TdCallbackQueryPayloadData *TdStackFetcherCallbackQueryPayloadData (struct TdStackFetcherMethods *M) {
  auto res = new TdCallbackQueryPayloadData ();
  res->ID = CODE_CallbackQueryPayloadData;
  res->refcnt = 1;
  M->get_field ("data_");
  res->data_.data = M->get_bytes (&res->data_.len);
  M->pop ();
  return res;
}
struct TdCallbackQueryPayloadGame *TdCreateObjectCallbackQueryPayloadGame (char *game_short_name_) {
  auto var = new struct TdCallbackQueryPayloadGame ();
  var->ID = CODE_CallbackQueryPayloadGame;
  var->refcnt = 1;
  var->game_short_name_ = (game_short_name_) ? td::str_dup (td::Slice (game_short_name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::callbackQueryPayloadGame> TdConvertToInternal (struct TdCallbackQueryPayloadGame *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->game_short_name_) ? var->game_short_name_: "";
  return td::td_api::make_object<td::td_api::callbackQueryPayloadGame>(std::move (v0));
}
struct TdCallbackQueryPayloadGame *TdConvertFromInternal (const td::td_api::callbackQueryPayloadGame &from) {
  auto res = new TdCallbackQueryPayloadGame ();
  res->ID = CODE_CallbackQueryPayloadGame;
  res->refcnt = 1;
  res->game_short_name_ = (from.game_short_name_.length ()) ? td::str_dup (from.game_short_name_) : nullptr;
  return res;
}
char *TdSerializeCallbackQueryPayloadGame (struct TdCallbackQueryPayloadGame *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCallbackQueryPayloadGame *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCallbackQueryPayloadGame (struct TdCallbackQueryPayloadGame *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCallbackQueryPayloadGame *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->game_short_name_);
  delete var;
}
void TdStackStorerCallbackQueryPayloadGame (struct TdCallbackQueryPayloadGame *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCallbackQueryPayloadGame *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CallbackQueryPayloadGame");
  M->new_field ("ID");
  M->pack_string (var->game_short_name_);
  M->new_field ("game_short_name_");
}
struct TdCallbackQueryPayloadGame *TdStackFetcherCallbackQueryPayloadGame (struct TdStackFetcherMethods *M) {
  auto res = new TdCallbackQueryPayloadGame ();
  res->ID = CODE_CallbackQueryPayloadGame;
  res->refcnt = 1;
  M->get_field ("game_short_name_");
  res->game_short_name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdChat *TdCreateObjectChat (long long id_, struct TdChatType *type_, char *title_, struct TdChatPhoto *photo_, struct TdMessage *last_message_, long long order_, int is_pinned_, int is_marked_as_unread_, int is_sponsored_, int can_be_reported_, int default_disable_notification_, int unread_count_, long long last_read_inbox_message_id_, long long last_read_outbox_message_id_, int unread_mention_count_, struct TdChatNotificationSettings *notification_settings_, long long reply_markup_message_id_, struct TdDraftMessage *draft_message_, char *client_data_) {
  auto var = new struct TdChat ();
  var->ID = CODE_Chat;
  var->refcnt = 1;
  var->id_ = id_;
  var->type_ = type_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->photo_ = photo_;
  var->last_message_ = last_message_;
  var->order_ = order_;
  var->is_pinned_ = is_pinned_;
  var->is_marked_as_unread_ = is_marked_as_unread_;
  var->is_sponsored_ = is_sponsored_;
  var->can_be_reported_ = can_be_reported_;
  var->default_disable_notification_ = default_disable_notification_;
  var->unread_count_ = unread_count_;
  var->last_read_inbox_message_id_ = last_read_inbox_message_id_;
  var->last_read_outbox_message_id_ = last_read_outbox_message_id_;
  var->unread_mention_count_ = unread_mention_count_;
  var->notification_settings_ = notification_settings_;
  var->reply_markup_message_id_ = reply_markup_message_id_;
  var->draft_message_ = draft_message_;
  var->client_data_ = (client_data_) ? td::str_dup (td::Slice (client_data_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::chat> TdConvertToInternal (struct TdChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  td::td_api::object_ptr<td::td_api::ChatType> v100;
  v100 = TdConvertToInternal (var->type_);
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  td::td_api::object_ptr<td::td_api::chatPhoto> v300;
  v300 = TdConvertToInternal (var->photo_);
  td::td_api::object_ptr<td::td_api::message> v400;
  v400 = TdConvertToInternal (var->last_message_);
  std::int64_t v500;
  v500 = var->order_;
  bool v600;
  v600 = var->is_pinned_ != 0;
  bool v700;
  v700 = var->is_marked_as_unread_ != 0;
  bool v800;
  v800 = var->is_sponsored_ != 0;
  bool v900;
  v900 = var->can_be_reported_ != 0;
  bool v1000;
  v1000 = var->default_disable_notification_ != 0;
  std::int32_t v1100;
  v1100 = var->unread_count_;
  std::int64_t v1200;
  v1200 = var->last_read_inbox_message_id_;
  std::int64_t v1300;
  v1300 = var->last_read_outbox_message_id_;
  std::int32_t v1400;
  v1400 = var->unread_mention_count_;
  td::td_api::object_ptr<td::td_api::chatNotificationSettings> v1500;
  v1500 = TdConvertToInternal (var->notification_settings_);
  std::int64_t v1600;
  v1600 = var->reply_markup_message_id_;
  td::td_api::object_ptr<td::td_api::draftMessage> v1700;
  v1700 = TdConvertToInternal (var->draft_message_);
  std::string v1800;
  v1800 = (var->client_data_) ? var->client_data_: "";
  return td::td_api::make_object<td::td_api::chat>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000), std::move (v1100), std::move (v1200), std::move (v1300), std::move (v1400), std::move (v1500), std::move (v1600), std::move (v1700), std::move (v1800));
}
struct TdChat *TdConvertFromInternal (const td::td_api::chat &from) {
  auto res = new TdChat ();
  res->ID = CODE_Chat;
  res->refcnt = 1;
  res->id_ = from.id_;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::ChatType &>(*from.type_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::chatPhoto &>(*from.photo_));
  }
  if (!from.last_message_) {
    res->last_message_ = nullptr;
  } else {
    res->last_message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.last_message_));
  }
  res->order_ = from.order_;
  res->is_pinned_ = from.is_pinned_;
  res->is_marked_as_unread_ = from.is_marked_as_unread_;
  res->is_sponsored_ = from.is_sponsored_;
  res->can_be_reported_ = from.can_be_reported_;
  res->default_disable_notification_ = from.default_disable_notification_;
  res->unread_count_ = from.unread_count_;
  res->last_read_inbox_message_id_ = from.last_read_inbox_message_id_;
  res->last_read_outbox_message_id_ = from.last_read_outbox_message_id_;
  res->unread_mention_count_ = from.unread_mention_count_;
  if (!from.notification_settings_) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdConvertFromInternal (static_cast<const td::td_api::chatNotificationSettings &>(*from.notification_settings_));
  }
  res->reply_markup_message_id_ = from.reply_markup_message_id_;
  if (!from.draft_message_) {
    res->draft_message_ = nullptr;
  } else {
    res->draft_message_ = TdConvertFromInternal (static_cast<const td::td_api::draftMessage &>(*from.draft_message_));
  }
  res->client_data_ = (from.client_data_.length ()) ? td::str_dup (from.client_data_) : nullptr;
  return res;
}
char *TdSerializeChat (struct TdChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChat (struct TdChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  free (var->title_);
  TdDestroyObject (var->photo_);
  TdDestroyObject (var->last_message_);
  TdDestroyObject (var->notification_settings_);
  TdDestroyObject (var->draft_message_);
  free (var->client_data_);
  delete var;
}
void TdStackStorerChat (struct TdChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Chat");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  TdStackStorer (var->last_message_, M);
  M->new_field ("last_message_");
  M->pack_long (var->order_);
  M->new_field ("order_");
  M->pack_bool (var->is_pinned_);
  M->new_field ("is_pinned_");
  M->pack_bool (var->is_marked_as_unread_);
  M->new_field ("is_marked_as_unread_");
  M->pack_bool (var->is_sponsored_);
  M->new_field ("is_sponsored_");
  M->pack_bool (var->can_be_reported_);
  M->new_field ("can_be_reported_");
  M->pack_bool (var->default_disable_notification_);
  M->new_field ("default_disable_notification_");
  M->pack_long (var->unread_count_);
  M->new_field ("unread_count_");
  M->pack_long (var->last_read_inbox_message_id_);
  M->new_field ("last_read_inbox_message_id_");
  M->pack_long (var->last_read_outbox_message_id_);
  M->new_field ("last_read_outbox_message_id_");
  M->pack_long (var->unread_mention_count_);
  M->new_field ("unread_mention_count_");
  TdStackStorer (var->notification_settings_, M);
  M->new_field ("notification_settings_");
  M->pack_long (var->reply_markup_message_id_);
  M->new_field ("reply_markup_message_id_");
  TdStackStorer (var->draft_message_, M);
  M->new_field ("draft_message_");
  M->pack_string (var->client_data_);
  M->new_field ("client_data_");
}
struct TdChat *TdStackFetcherChat (struct TdStackFetcherMethods *M) {
  auto res = new TdChat ();
  res->ID = CODE_Chat;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherChatType (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherChatPhoto (M);
  }
  M->pop ();
  M->get_field ("last_message_");
  if (M->is_nil ()) {
    res->last_message_ = nullptr;
  } else {
    res->last_message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  M->get_field ("order_");
  res->order_ = M->get_long ();
  M->pop ();
  M->get_field ("is_pinned_");
  res->is_pinned_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_marked_as_unread_");
  res->is_marked_as_unread_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_sponsored_");
  res->is_sponsored_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_be_reported_");
  res->can_be_reported_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("default_disable_notification_");
  res->default_disable_notification_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("unread_count_");
  res->unread_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("last_read_inbox_message_id_");
  res->last_read_inbox_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("last_read_outbox_message_id_");
  res->last_read_outbox_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("unread_mention_count_");
  res->unread_mention_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("notification_settings_");
  if (M->is_nil ()) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdStackFetcherChatNotificationSettings (M);
  }
  M->pop ();
  M->get_field ("reply_markup_message_id_");
  res->reply_markup_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("draft_message_");
  if (M->is_nil ()) {
    res->draft_message_ = nullptr;
  } else {
    res->draft_message_ = TdStackFetcherDraftMessage (M);
  }
  M->pop ();
  M->get_field ("client_data_");
  res->client_data_ = M->get_string ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ChatAction> TdConvertToInternal (struct TdChatAction *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatActionTyping: return TdConvertToInternal ((struct TdChatActionTyping *)var);
    case CODE_ChatActionRecordingVideo: return TdConvertToInternal ((struct TdChatActionRecordingVideo *)var);
    case CODE_ChatActionUploadingVideo: return TdConvertToInternal ((struct TdChatActionUploadingVideo *)var);
    case CODE_ChatActionRecordingVoiceNote: return TdConvertToInternal ((struct TdChatActionRecordingVoiceNote *)var);
    case CODE_ChatActionUploadingVoiceNote: return TdConvertToInternal ((struct TdChatActionUploadingVoiceNote *)var);
    case CODE_ChatActionUploadingPhoto: return TdConvertToInternal ((struct TdChatActionUploadingPhoto *)var);
    case CODE_ChatActionUploadingDocument: return TdConvertToInternal ((struct TdChatActionUploadingDocument *)var);
    case CODE_ChatActionChoosingLocation: return TdConvertToInternal ((struct TdChatActionChoosingLocation *)var);
    case CODE_ChatActionChoosingContact: return TdConvertToInternal ((struct TdChatActionChoosingContact *)var);
    case CODE_ChatActionStartPlayingGame: return TdConvertToInternal ((struct TdChatActionStartPlayingGame *)var);
    case CODE_ChatActionRecordingVideoNote: return TdConvertToInternal ((struct TdChatActionRecordingVideoNote *)var);
    case CODE_ChatActionUploadingVideoNote: return TdConvertToInternal ((struct TdChatActionUploadingVideoNote *)var);
    case CODE_ChatActionCancel: return TdConvertToInternal ((struct TdChatActionCancel *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdChatAction *TdConvertFromInternal (const td::td_api::ChatAction &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ChatActionTyping: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionTyping &>(from));
    case CODE_ChatActionRecordingVideo: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionRecordingVideo &>(from));
    case CODE_ChatActionUploadingVideo: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingVideo &>(from));
    case CODE_ChatActionRecordingVoiceNote: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionRecordingVoiceNote &>(from));
    case CODE_ChatActionUploadingVoiceNote: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingVoiceNote &>(from));
    case CODE_ChatActionUploadingPhoto: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingPhoto &>(from));
    case CODE_ChatActionUploadingDocument: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingDocument &>(from));
    case CODE_ChatActionChoosingLocation: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionChoosingLocation &>(from));
    case CODE_ChatActionChoosingContact: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionChoosingContact &>(from));
    case CODE_ChatActionStartPlayingGame: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionStartPlayingGame &>(from));
    case CODE_ChatActionRecordingVideoNote: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionRecordingVideoNote &>(from));
    case CODE_ChatActionUploadingVideoNote: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionUploadingVideoNote &>(from));
    case CODE_ChatActionCancel: return (struct TdChatAction *)TdConvertFromInternal(static_cast<const td::td_api::chatActionCancel &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeChatAction (struct TdChatAction *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatAction *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatAction (struct TdChatAction *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatAction *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatActionTyping: return TdDestroyObject ((struct TdChatActionTyping *)var);
    case CODE_ChatActionRecordingVideo: return TdDestroyObject ((struct TdChatActionRecordingVideo *)var);
    case CODE_ChatActionUploadingVideo: return TdDestroyObject ((struct TdChatActionUploadingVideo *)var);
    case CODE_ChatActionRecordingVoiceNote: return TdDestroyObject ((struct TdChatActionRecordingVoiceNote *)var);
    case CODE_ChatActionUploadingVoiceNote: return TdDestroyObject ((struct TdChatActionUploadingVoiceNote *)var);
    case CODE_ChatActionUploadingPhoto: return TdDestroyObject ((struct TdChatActionUploadingPhoto *)var);
    case CODE_ChatActionUploadingDocument: return TdDestroyObject ((struct TdChatActionUploadingDocument *)var);
    case CODE_ChatActionChoosingLocation: return TdDestroyObject ((struct TdChatActionChoosingLocation *)var);
    case CODE_ChatActionChoosingContact: return TdDestroyObject ((struct TdChatActionChoosingContact *)var);
    case CODE_ChatActionStartPlayingGame: return TdDestroyObject ((struct TdChatActionStartPlayingGame *)var);
    case CODE_ChatActionRecordingVideoNote: return TdDestroyObject ((struct TdChatActionRecordingVideoNote *)var);
    case CODE_ChatActionUploadingVideoNote: return TdDestroyObject ((struct TdChatActionUploadingVideoNote *)var);
    case CODE_ChatActionCancel: return TdDestroyObject ((struct TdChatActionCancel *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerChatAction (struct TdChatAction *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatAction *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatActionTyping: return TdStackStorer ((struct TdChatActionTyping *)var, M);
    case CODE_ChatActionRecordingVideo: return TdStackStorer ((struct TdChatActionRecordingVideo *)var, M);
    case CODE_ChatActionUploadingVideo: return TdStackStorer ((struct TdChatActionUploadingVideo *)var, M);
    case CODE_ChatActionRecordingVoiceNote: return TdStackStorer ((struct TdChatActionRecordingVoiceNote *)var, M);
    case CODE_ChatActionUploadingVoiceNote: return TdStackStorer ((struct TdChatActionUploadingVoiceNote *)var, M);
    case CODE_ChatActionUploadingPhoto: return TdStackStorer ((struct TdChatActionUploadingPhoto *)var, M);
    case CODE_ChatActionUploadingDocument: return TdStackStorer ((struct TdChatActionUploadingDocument *)var, M);
    case CODE_ChatActionChoosingLocation: return TdStackStorer ((struct TdChatActionChoosingLocation *)var, M);
    case CODE_ChatActionChoosingContact: return TdStackStorer ((struct TdChatActionChoosingContact *)var, M);
    case CODE_ChatActionStartPlayingGame: return TdStackStorer ((struct TdChatActionStartPlayingGame *)var, M);
    case CODE_ChatActionRecordingVideoNote: return TdStackStorer ((struct TdChatActionRecordingVideoNote *)var, M);
    case CODE_ChatActionUploadingVideoNote: return TdStackStorer ((struct TdChatActionUploadingVideoNote *)var, M);
    case CODE_ChatActionCancel: return TdStackStorer ((struct TdChatActionCancel *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdChatAction *TdStackFetcherChatAction (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ChatActionTyping") {
    return (struct TdChatAction *)TdStackFetcherChatActionTyping (M);
  }
  if (constructor == "ChatActionRecordingVideo") {
    return (struct TdChatAction *)TdStackFetcherChatActionRecordingVideo (M);
  }
  if (constructor == "ChatActionUploadingVideo") {
    return (struct TdChatAction *)TdStackFetcherChatActionUploadingVideo (M);
  }
  if (constructor == "ChatActionRecordingVoiceNote") {
    return (struct TdChatAction *)TdStackFetcherChatActionRecordingVoiceNote (M);
  }
  if (constructor == "ChatActionUploadingVoiceNote") {
    return (struct TdChatAction *)TdStackFetcherChatActionUploadingVoiceNote (M);
  }
  if (constructor == "ChatActionUploadingPhoto") {
    return (struct TdChatAction *)TdStackFetcherChatActionUploadingPhoto (M);
  }
  if (constructor == "ChatActionUploadingDocument") {
    return (struct TdChatAction *)TdStackFetcherChatActionUploadingDocument (M);
  }
  if (constructor == "ChatActionChoosingLocation") {
    return (struct TdChatAction *)TdStackFetcherChatActionChoosingLocation (M);
  }
  if (constructor == "ChatActionChoosingContact") {
    return (struct TdChatAction *)TdStackFetcherChatActionChoosingContact (M);
  }
  if (constructor == "ChatActionStartPlayingGame") {
    return (struct TdChatAction *)TdStackFetcherChatActionStartPlayingGame (M);
  }
  if (constructor == "ChatActionRecordingVideoNote") {
    return (struct TdChatAction *)TdStackFetcherChatActionRecordingVideoNote (M);
  }
  if (constructor == "ChatActionUploadingVideoNote") {
    return (struct TdChatAction *)TdStackFetcherChatActionUploadingVideoNote (M);
  }
  if (constructor == "ChatActionCancel") {
    return (struct TdChatAction *)TdStackFetcherChatActionCancel (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdChatActionTyping *TdCreateObjectChatActionTyping (void) {
  auto var = new struct TdChatActionTyping ();
  var->ID = CODE_ChatActionTyping;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionTyping> TdConvertToInternal (struct TdChatActionTyping *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatActionTyping>();
}
struct TdChatActionTyping *TdConvertFromInternal (const td::td_api::chatActionTyping &from) {
  auto res = new TdChatActionTyping ();
  res->ID = CODE_ChatActionTyping;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatActionTyping (struct TdChatActionTyping *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionTyping *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionTyping (struct TdChatActionTyping *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionTyping *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionTyping (struct TdChatActionTyping *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionTyping *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionTyping");
  M->new_field ("ID");
}
struct TdChatActionTyping *TdStackFetcherChatActionTyping (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionTyping ();
  res->ID = CODE_ChatActionTyping;
  res->refcnt = 1;
  return res;
}
struct TdChatActionRecordingVideo *TdCreateObjectChatActionRecordingVideo (void) {
  auto var = new struct TdChatActionRecordingVideo ();
  var->ID = CODE_ChatActionRecordingVideo;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionRecordingVideo> TdConvertToInternal (struct TdChatActionRecordingVideo *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatActionRecordingVideo>();
}
struct TdChatActionRecordingVideo *TdConvertFromInternal (const td::td_api::chatActionRecordingVideo &from) {
  auto res = new TdChatActionRecordingVideo ();
  res->ID = CODE_ChatActionRecordingVideo;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatActionRecordingVideo (struct TdChatActionRecordingVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionRecordingVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionRecordingVideo (struct TdChatActionRecordingVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionRecordingVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionRecordingVideo (struct TdChatActionRecordingVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionRecordingVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionRecordingVideo");
  M->new_field ("ID");
}
struct TdChatActionRecordingVideo *TdStackFetcherChatActionRecordingVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionRecordingVideo ();
  res->ID = CODE_ChatActionRecordingVideo;
  res->refcnt = 1;
  return res;
}
struct TdChatActionUploadingVideo *TdCreateObjectChatActionUploadingVideo (int progress_) {
  auto var = new struct TdChatActionUploadingVideo ();
  var->ID = CODE_ChatActionUploadingVideo;
  var->refcnt = 1;
  var->progress_ = progress_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionUploadingVideo> TdConvertToInternal (struct TdChatActionUploadingVideo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->progress_;
  return td::td_api::make_object<td::td_api::chatActionUploadingVideo>(std::move (v0));
}
struct TdChatActionUploadingVideo *TdConvertFromInternal (const td::td_api::chatActionUploadingVideo &from) {
  auto res = new TdChatActionUploadingVideo ();
  res->ID = CODE_ChatActionUploadingVideo;
  res->refcnt = 1;
  res->progress_ = from.progress_;
  return res;
}
char *TdSerializeChatActionUploadingVideo (struct TdChatActionUploadingVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionUploadingVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionUploadingVideo (struct TdChatActionUploadingVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionUploadingVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionUploadingVideo (struct TdChatActionUploadingVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionUploadingVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionUploadingVideo");
  M->new_field ("ID");
  M->pack_long (var->progress_);
  M->new_field ("progress_");
}
struct TdChatActionUploadingVideo *TdStackFetcherChatActionUploadingVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionUploadingVideo ();
  res->ID = CODE_ChatActionUploadingVideo;
  res->refcnt = 1;
  M->get_field ("progress_");
  res->progress_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatActionRecordingVoiceNote *TdCreateObjectChatActionRecordingVoiceNote (void) {
  auto var = new struct TdChatActionRecordingVoiceNote ();
  var->ID = CODE_ChatActionRecordingVoiceNote;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionRecordingVoiceNote> TdConvertToInternal (struct TdChatActionRecordingVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatActionRecordingVoiceNote>();
}
struct TdChatActionRecordingVoiceNote *TdConvertFromInternal (const td::td_api::chatActionRecordingVoiceNote &from) {
  auto res = new TdChatActionRecordingVoiceNote ();
  res->ID = CODE_ChatActionRecordingVoiceNote;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatActionRecordingVoiceNote (struct TdChatActionRecordingVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionRecordingVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionRecordingVoiceNote (struct TdChatActionRecordingVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionRecordingVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionRecordingVoiceNote (struct TdChatActionRecordingVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionRecordingVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionRecordingVoiceNote");
  M->new_field ("ID");
}
struct TdChatActionRecordingVoiceNote *TdStackFetcherChatActionRecordingVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionRecordingVoiceNote ();
  res->ID = CODE_ChatActionRecordingVoiceNote;
  res->refcnt = 1;
  return res;
}
struct TdChatActionUploadingVoiceNote *TdCreateObjectChatActionUploadingVoiceNote (int progress_) {
  auto var = new struct TdChatActionUploadingVoiceNote ();
  var->ID = CODE_ChatActionUploadingVoiceNote;
  var->refcnt = 1;
  var->progress_ = progress_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionUploadingVoiceNote> TdConvertToInternal (struct TdChatActionUploadingVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->progress_;
  return td::td_api::make_object<td::td_api::chatActionUploadingVoiceNote>(std::move (v0));
}
struct TdChatActionUploadingVoiceNote *TdConvertFromInternal (const td::td_api::chatActionUploadingVoiceNote &from) {
  auto res = new TdChatActionUploadingVoiceNote ();
  res->ID = CODE_ChatActionUploadingVoiceNote;
  res->refcnt = 1;
  res->progress_ = from.progress_;
  return res;
}
char *TdSerializeChatActionUploadingVoiceNote (struct TdChatActionUploadingVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionUploadingVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionUploadingVoiceNote (struct TdChatActionUploadingVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionUploadingVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionUploadingVoiceNote (struct TdChatActionUploadingVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionUploadingVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionUploadingVoiceNote");
  M->new_field ("ID");
  M->pack_long (var->progress_);
  M->new_field ("progress_");
}
struct TdChatActionUploadingVoiceNote *TdStackFetcherChatActionUploadingVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionUploadingVoiceNote ();
  res->ID = CODE_ChatActionUploadingVoiceNote;
  res->refcnt = 1;
  M->get_field ("progress_");
  res->progress_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatActionUploadingPhoto *TdCreateObjectChatActionUploadingPhoto (int progress_) {
  auto var = new struct TdChatActionUploadingPhoto ();
  var->ID = CODE_ChatActionUploadingPhoto;
  var->refcnt = 1;
  var->progress_ = progress_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionUploadingPhoto> TdConvertToInternal (struct TdChatActionUploadingPhoto *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->progress_;
  return td::td_api::make_object<td::td_api::chatActionUploadingPhoto>(std::move (v0));
}
struct TdChatActionUploadingPhoto *TdConvertFromInternal (const td::td_api::chatActionUploadingPhoto &from) {
  auto res = new TdChatActionUploadingPhoto ();
  res->ID = CODE_ChatActionUploadingPhoto;
  res->refcnt = 1;
  res->progress_ = from.progress_;
  return res;
}
char *TdSerializeChatActionUploadingPhoto (struct TdChatActionUploadingPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionUploadingPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionUploadingPhoto (struct TdChatActionUploadingPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionUploadingPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionUploadingPhoto (struct TdChatActionUploadingPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionUploadingPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionUploadingPhoto");
  M->new_field ("ID");
  M->pack_long (var->progress_);
  M->new_field ("progress_");
}
struct TdChatActionUploadingPhoto *TdStackFetcherChatActionUploadingPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionUploadingPhoto ();
  res->ID = CODE_ChatActionUploadingPhoto;
  res->refcnt = 1;
  M->get_field ("progress_");
  res->progress_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatActionUploadingDocument *TdCreateObjectChatActionUploadingDocument (int progress_) {
  auto var = new struct TdChatActionUploadingDocument ();
  var->ID = CODE_ChatActionUploadingDocument;
  var->refcnt = 1;
  var->progress_ = progress_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionUploadingDocument> TdConvertToInternal (struct TdChatActionUploadingDocument *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->progress_;
  return td::td_api::make_object<td::td_api::chatActionUploadingDocument>(std::move (v0));
}
struct TdChatActionUploadingDocument *TdConvertFromInternal (const td::td_api::chatActionUploadingDocument &from) {
  auto res = new TdChatActionUploadingDocument ();
  res->ID = CODE_ChatActionUploadingDocument;
  res->refcnt = 1;
  res->progress_ = from.progress_;
  return res;
}
char *TdSerializeChatActionUploadingDocument (struct TdChatActionUploadingDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionUploadingDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionUploadingDocument (struct TdChatActionUploadingDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionUploadingDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionUploadingDocument (struct TdChatActionUploadingDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionUploadingDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionUploadingDocument");
  M->new_field ("ID");
  M->pack_long (var->progress_);
  M->new_field ("progress_");
}
struct TdChatActionUploadingDocument *TdStackFetcherChatActionUploadingDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionUploadingDocument ();
  res->ID = CODE_ChatActionUploadingDocument;
  res->refcnt = 1;
  M->get_field ("progress_");
  res->progress_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatActionChoosingLocation *TdCreateObjectChatActionChoosingLocation (void) {
  auto var = new struct TdChatActionChoosingLocation ();
  var->ID = CODE_ChatActionChoosingLocation;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionChoosingLocation> TdConvertToInternal (struct TdChatActionChoosingLocation *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatActionChoosingLocation>();
}
struct TdChatActionChoosingLocation *TdConvertFromInternal (const td::td_api::chatActionChoosingLocation &from) {
  auto res = new TdChatActionChoosingLocation ();
  res->ID = CODE_ChatActionChoosingLocation;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatActionChoosingLocation (struct TdChatActionChoosingLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionChoosingLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionChoosingLocation (struct TdChatActionChoosingLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionChoosingLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionChoosingLocation (struct TdChatActionChoosingLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionChoosingLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionChoosingLocation");
  M->new_field ("ID");
}
struct TdChatActionChoosingLocation *TdStackFetcherChatActionChoosingLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionChoosingLocation ();
  res->ID = CODE_ChatActionChoosingLocation;
  res->refcnt = 1;
  return res;
}
struct TdChatActionChoosingContact *TdCreateObjectChatActionChoosingContact (void) {
  auto var = new struct TdChatActionChoosingContact ();
  var->ID = CODE_ChatActionChoosingContact;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionChoosingContact> TdConvertToInternal (struct TdChatActionChoosingContact *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatActionChoosingContact>();
}
struct TdChatActionChoosingContact *TdConvertFromInternal (const td::td_api::chatActionChoosingContact &from) {
  auto res = new TdChatActionChoosingContact ();
  res->ID = CODE_ChatActionChoosingContact;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatActionChoosingContact (struct TdChatActionChoosingContact *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionChoosingContact *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionChoosingContact (struct TdChatActionChoosingContact *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionChoosingContact *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionChoosingContact (struct TdChatActionChoosingContact *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionChoosingContact *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionChoosingContact");
  M->new_field ("ID");
}
struct TdChatActionChoosingContact *TdStackFetcherChatActionChoosingContact (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionChoosingContact ();
  res->ID = CODE_ChatActionChoosingContact;
  res->refcnt = 1;
  return res;
}
struct TdChatActionStartPlayingGame *TdCreateObjectChatActionStartPlayingGame (void) {
  auto var = new struct TdChatActionStartPlayingGame ();
  var->ID = CODE_ChatActionStartPlayingGame;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionStartPlayingGame> TdConvertToInternal (struct TdChatActionStartPlayingGame *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatActionStartPlayingGame>();
}
struct TdChatActionStartPlayingGame *TdConvertFromInternal (const td::td_api::chatActionStartPlayingGame &from) {
  auto res = new TdChatActionStartPlayingGame ();
  res->ID = CODE_ChatActionStartPlayingGame;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatActionStartPlayingGame (struct TdChatActionStartPlayingGame *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionStartPlayingGame *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionStartPlayingGame (struct TdChatActionStartPlayingGame *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionStartPlayingGame *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionStartPlayingGame (struct TdChatActionStartPlayingGame *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionStartPlayingGame *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionStartPlayingGame");
  M->new_field ("ID");
}
struct TdChatActionStartPlayingGame *TdStackFetcherChatActionStartPlayingGame (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionStartPlayingGame ();
  res->ID = CODE_ChatActionStartPlayingGame;
  res->refcnt = 1;
  return res;
}
struct TdChatActionRecordingVideoNote *TdCreateObjectChatActionRecordingVideoNote (void) {
  auto var = new struct TdChatActionRecordingVideoNote ();
  var->ID = CODE_ChatActionRecordingVideoNote;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionRecordingVideoNote> TdConvertToInternal (struct TdChatActionRecordingVideoNote *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatActionRecordingVideoNote>();
}
struct TdChatActionRecordingVideoNote *TdConvertFromInternal (const td::td_api::chatActionRecordingVideoNote &from) {
  auto res = new TdChatActionRecordingVideoNote ();
  res->ID = CODE_ChatActionRecordingVideoNote;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatActionRecordingVideoNote (struct TdChatActionRecordingVideoNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionRecordingVideoNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionRecordingVideoNote (struct TdChatActionRecordingVideoNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionRecordingVideoNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionRecordingVideoNote (struct TdChatActionRecordingVideoNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionRecordingVideoNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionRecordingVideoNote");
  M->new_field ("ID");
}
struct TdChatActionRecordingVideoNote *TdStackFetcherChatActionRecordingVideoNote (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionRecordingVideoNote ();
  res->ID = CODE_ChatActionRecordingVideoNote;
  res->refcnt = 1;
  return res;
}
struct TdChatActionUploadingVideoNote *TdCreateObjectChatActionUploadingVideoNote (int progress_) {
  auto var = new struct TdChatActionUploadingVideoNote ();
  var->ID = CODE_ChatActionUploadingVideoNote;
  var->refcnt = 1;
  var->progress_ = progress_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionUploadingVideoNote> TdConvertToInternal (struct TdChatActionUploadingVideoNote *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->progress_;
  return td::td_api::make_object<td::td_api::chatActionUploadingVideoNote>(std::move (v0));
}
struct TdChatActionUploadingVideoNote *TdConvertFromInternal (const td::td_api::chatActionUploadingVideoNote &from) {
  auto res = new TdChatActionUploadingVideoNote ();
  res->ID = CODE_ChatActionUploadingVideoNote;
  res->refcnt = 1;
  res->progress_ = from.progress_;
  return res;
}
char *TdSerializeChatActionUploadingVideoNote (struct TdChatActionUploadingVideoNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionUploadingVideoNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionUploadingVideoNote (struct TdChatActionUploadingVideoNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionUploadingVideoNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionUploadingVideoNote (struct TdChatActionUploadingVideoNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionUploadingVideoNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionUploadingVideoNote");
  M->new_field ("ID");
  M->pack_long (var->progress_);
  M->new_field ("progress_");
}
struct TdChatActionUploadingVideoNote *TdStackFetcherChatActionUploadingVideoNote (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionUploadingVideoNote ();
  res->ID = CODE_ChatActionUploadingVideoNote;
  res->refcnt = 1;
  M->get_field ("progress_");
  res->progress_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatActionCancel *TdCreateObjectChatActionCancel (void) {
  auto var = new struct TdChatActionCancel ();
  var->ID = CODE_ChatActionCancel;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatActionCancel> TdConvertToInternal (struct TdChatActionCancel *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatActionCancel>();
}
struct TdChatActionCancel *TdConvertFromInternal (const td::td_api::chatActionCancel &from) {
  auto res = new TdChatActionCancel ();
  res->ID = CODE_ChatActionCancel;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatActionCancel (struct TdChatActionCancel *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatActionCancel *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatActionCancel (struct TdChatActionCancel *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatActionCancel *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatActionCancel (struct TdChatActionCancel *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatActionCancel *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatActionCancel");
  M->new_field ("ID");
}
struct TdChatActionCancel *TdStackFetcherChatActionCancel (struct TdStackFetcherMethods *M) {
  auto res = new TdChatActionCancel ();
  res->ID = CODE_ChatActionCancel;
  res->refcnt = 1;
  return res;
}
struct TdChatEvent *TdCreateObjectChatEvent (long long id_, int date_, int user_id_, struct TdChatEventAction *action_) {
  auto var = new struct TdChatEvent ();
  var->ID = CODE_ChatEvent;
  var->refcnt = 1;
  var->id_ = id_;
  var->date_ = date_;
  var->user_id_ = user_id_;
  var->action_ = action_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEvent> TdConvertToInternal (struct TdChatEvent *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->date_;
  std::int32_t v200;
  v200 = var->user_id_;
  td::td_api::object_ptr<td::td_api::ChatEventAction> v300;
  v300 = TdConvertToInternal (var->action_);
  return td::td_api::make_object<td::td_api::chatEvent>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdChatEvent *TdConvertFromInternal (const td::td_api::chatEvent &from) {
  auto res = new TdChatEvent ();
  res->ID = CODE_ChatEvent;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->date_ = from.date_;
  res->user_id_ = from.user_id_;
  if (!from.action_) {
    res->action_ = nullptr;
  } else {
    res->action_ = TdConvertFromInternal (static_cast<const td::td_api::ChatEventAction &>(*from.action_));
  }
  return res;
}
char *TdSerializeChatEvent (struct TdChatEvent *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEvent *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEvent (struct TdChatEvent *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEvent *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->action_);
  delete var;
}
void TdStackStorerChatEvent (struct TdChatEvent *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEvent *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEvent");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->date_);
  M->new_field ("date_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->action_, M);
  M->new_field ("action_");
}
struct TdChatEvent *TdStackFetcherChatEvent (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEvent ();
  res->ID = CODE_ChatEvent;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("action_");
  if (M->is_nil ()) {
    res->action_ = nullptr;
  } else {
    res->action_ = TdStackFetcherChatEventAction (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ChatEventAction> TdConvertToInternal (struct TdChatEventAction *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatEventMessageEdited: return TdConvertToInternal ((struct TdChatEventMessageEdited *)var);
    case CODE_ChatEventMessageDeleted: return TdConvertToInternal ((struct TdChatEventMessageDeleted *)var);
    case CODE_ChatEventMessagePinned: return TdConvertToInternal ((struct TdChatEventMessagePinned *)var);
    case CODE_ChatEventMessageUnpinned: return TdConvertToInternal ((struct TdChatEventMessageUnpinned *)var);
    case CODE_ChatEventMemberJoined: return TdConvertToInternal ((struct TdChatEventMemberJoined *)var);
    case CODE_ChatEventMemberLeft: return TdConvertToInternal ((struct TdChatEventMemberLeft *)var);
    case CODE_ChatEventMemberInvited: return TdConvertToInternal ((struct TdChatEventMemberInvited *)var);
    case CODE_ChatEventMemberPromoted: return TdConvertToInternal ((struct TdChatEventMemberPromoted *)var);
    case CODE_ChatEventMemberRestricted: return TdConvertToInternal ((struct TdChatEventMemberRestricted *)var);
    case CODE_ChatEventTitleChanged: return TdConvertToInternal ((struct TdChatEventTitleChanged *)var);
    case CODE_ChatEventDescriptionChanged: return TdConvertToInternal ((struct TdChatEventDescriptionChanged *)var);
    case CODE_ChatEventUsernameChanged: return TdConvertToInternal ((struct TdChatEventUsernameChanged *)var);
    case CODE_ChatEventPhotoChanged: return TdConvertToInternal ((struct TdChatEventPhotoChanged *)var);
    case CODE_ChatEventInvitesToggled: return TdConvertToInternal ((struct TdChatEventInvitesToggled *)var);
    case CODE_ChatEventSignMessagesToggled: return TdConvertToInternal ((struct TdChatEventSignMessagesToggled *)var);
    case CODE_ChatEventStickerSetChanged: return TdConvertToInternal ((struct TdChatEventStickerSetChanged *)var);
    case CODE_ChatEventIsAllHistoryAvailableToggled: return TdConvertToInternal ((struct TdChatEventIsAllHistoryAvailableToggled *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdChatEventAction *TdConvertFromInternal (const td::td_api::ChatEventAction &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ChatEventMessageEdited: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMessageEdited &>(from));
    case CODE_ChatEventMessageDeleted: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMessageDeleted &>(from));
    case CODE_ChatEventMessagePinned: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMessagePinned &>(from));
    case CODE_ChatEventMessageUnpinned: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMessageUnpinned &>(from));
    case CODE_ChatEventMemberJoined: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberJoined &>(from));
    case CODE_ChatEventMemberLeft: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberLeft &>(from));
    case CODE_ChatEventMemberInvited: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberInvited &>(from));
    case CODE_ChatEventMemberPromoted: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberPromoted &>(from));
    case CODE_ChatEventMemberRestricted: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventMemberRestricted &>(from));
    case CODE_ChatEventTitleChanged: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventTitleChanged &>(from));
    case CODE_ChatEventDescriptionChanged: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventDescriptionChanged &>(from));
    case CODE_ChatEventUsernameChanged: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventUsernameChanged &>(from));
    case CODE_ChatEventPhotoChanged: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventPhotoChanged &>(from));
    case CODE_ChatEventInvitesToggled: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventInvitesToggled &>(from));
    case CODE_ChatEventSignMessagesToggled: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventSignMessagesToggled &>(from));
    case CODE_ChatEventStickerSetChanged: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventStickerSetChanged &>(from));
    case CODE_ChatEventIsAllHistoryAvailableToggled: return (struct TdChatEventAction *)TdConvertFromInternal(static_cast<const td::td_api::chatEventIsAllHistoryAvailableToggled &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeChatEventAction (struct TdChatEventAction *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventAction *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventAction (struct TdChatEventAction *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventAction *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatEventMessageEdited: return TdDestroyObject ((struct TdChatEventMessageEdited *)var);
    case CODE_ChatEventMessageDeleted: return TdDestroyObject ((struct TdChatEventMessageDeleted *)var);
    case CODE_ChatEventMessagePinned: return TdDestroyObject ((struct TdChatEventMessagePinned *)var);
    case CODE_ChatEventMessageUnpinned: return TdDestroyObject ((struct TdChatEventMessageUnpinned *)var);
    case CODE_ChatEventMemberJoined: return TdDestroyObject ((struct TdChatEventMemberJoined *)var);
    case CODE_ChatEventMemberLeft: return TdDestroyObject ((struct TdChatEventMemberLeft *)var);
    case CODE_ChatEventMemberInvited: return TdDestroyObject ((struct TdChatEventMemberInvited *)var);
    case CODE_ChatEventMemberPromoted: return TdDestroyObject ((struct TdChatEventMemberPromoted *)var);
    case CODE_ChatEventMemberRestricted: return TdDestroyObject ((struct TdChatEventMemberRestricted *)var);
    case CODE_ChatEventTitleChanged: return TdDestroyObject ((struct TdChatEventTitleChanged *)var);
    case CODE_ChatEventDescriptionChanged: return TdDestroyObject ((struct TdChatEventDescriptionChanged *)var);
    case CODE_ChatEventUsernameChanged: return TdDestroyObject ((struct TdChatEventUsernameChanged *)var);
    case CODE_ChatEventPhotoChanged: return TdDestroyObject ((struct TdChatEventPhotoChanged *)var);
    case CODE_ChatEventInvitesToggled: return TdDestroyObject ((struct TdChatEventInvitesToggled *)var);
    case CODE_ChatEventSignMessagesToggled: return TdDestroyObject ((struct TdChatEventSignMessagesToggled *)var);
    case CODE_ChatEventStickerSetChanged: return TdDestroyObject ((struct TdChatEventStickerSetChanged *)var);
    case CODE_ChatEventIsAllHistoryAvailableToggled: return TdDestroyObject ((struct TdChatEventIsAllHistoryAvailableToggled *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerChatEventAction (struct TdChatEventAction *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventAction *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatEventMessageEdited: return TdStackStorer ((struct TdChatEventMessageEdited *)var, M);
    case CODE_ChatEventMessageDeleted: return TdStackStorer ((struct TdChatEventMessageDeleted *)var, M);
    case CODE_ChatEventMessagePinned: return TdStackStorer ((struct TdChatEventMessagePinned *)var, M);
    case CODE_ChatEventMessageUnpinned: return TdStackStorer ((struct TdChatEventMessageUnpinned *)var, M);
    case CODE_ChatEventMemberJoined: return TdStackStorer ((struct TdChatEventMemberJoined *)var, M);
    case CODE_ChatEventMemberLeft: return TdStackStorer ((struct TdChatEventMemberLeft *)var, M);
    case CODE_ChatEventMemberInvited: return TdStackStorer ((struct TdChatEventMemberInvited *)var, M);
    case CODE_ChatEventMemberPromoted: return TdStackStorer ((struct TdChatEventMemberPromoted *)var, M);
    case CODE_ChatEventMemberRestricted: return TdStackStorer ((struct TdChatEventMemberRestricted *)var, M);
    case CODE_ChatEventTitleChanged: return TdStackStorer ((struct TdChatEventTitleChanged *)var, M);
    case CODE_ChatEventDescriptionChanged: return TdStackStorer ((struct TdChatEventDescriptionChanged *)var, M);
    case CODE_ChatEventUsernameChanged: return TdStackStorer ((struct TdChatEventUsernameChanged *)var, M);
    case CODE_ChatEventPhotoChanged: return TdStackStorer ((struct TdChatEventPhotoChanged *)var, M);
    case CODE_ChatEventInvitesToggled: return TdStackStorer ((struct TdChatEventInvitesToggled *)var, M);
    case CODE_ChatEventSignMessagesToggled: return TdStackStorer ((struct TdChatEventSignMessagesToggled *)var, M);
    case CODE_ChatEventStickerSetChanged: return TdStackStorer ((struct TdChatEventStickerSetChanged *)var, M);
    case CODE_ChatEventIsAllHistoryAvailableToggled: return TdStackStorer ((struct TdChatEventIsAllHistoryAvailableToggled *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdChatEventAction *TdStackFetcherChatEventAction (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ChatEventMessageEdited") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMessageEdited (M);
  }
  if (constructor == "ChatEventMessageDeleted") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMessageDeleted (M);
  }
  if (constructor == "ChatEventMessagePinned") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMessagePinned (M);
  }
  if (constructor == "ChatEventMessageUnpinned") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMessageUnpinned (M);
  }
  if (constructor == "ChatEventMemberJoined") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMemberJoined (M);
  }
  if (constructor == "ChatEventMemberLeft") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMemberLeft (M);
  }
  if (constructor == "ChatEventMemberInvited") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMemberInvited (M);
  }
  if (constructor == "ChatEventMemberPromoted") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMemberPromoted (M);
  }
  if (constructor == "ChatEventMemberRestricted") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventMemberRestricted (M);
  }
  if (constructor == "ChatEventTitleChanged") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventTitleChanged (M);
  }
  if (constructor == "ChatEventDescriptionChanged") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventDescriptionChanged (M);
  }
  if (constructor == "ChatEventUsernameChanged") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventUsernameChanged (M);
  }
  if (constructor == "ChatEventPhotoChanged") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventPhotoChanged (M);
  }
  if (constructor == "ChatEventInvitesToggled") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventInvitesToggled (M);
  }
  if (constructor == "ChatEventSignMessagesToggled") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventSignMessagesToggled (M);
  }
  if (constructor == "ChatEventStickerSetChanged") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventStickerSetChanged (M);
  }
  if (constructor == "ChatEventIsAllHistoryAvailableToggled") {
    return (struct TdChatEventAction *)TdStackFetcherChatEventIsAllHistoryAvailableToggled (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdChatEventMessageEdited *TdCreateObjectChatEventMessageEdited (struct TdMessage *old_message_, struct TdMessage *new_message_) {
  auto var = new struct TdChatEventMessageEdited ();
  var->ID = CODE_ChatEventMessageEdited;
  var->refcnt = 1;
  var->old_message_ = old_message_;
  var->new_message_ = new_message_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMessageEdited> TdConvertToInternal (struct TdChatEventMessageEdited *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::message> v0;
  v0 = TdConvertToInternal (var->old_message_);
  td::td_api::object_ptr<td::td_api::message> v100;
  v100 = TdConvertToInternal (var->new_message_);
  return td::td_api::make_object<td::td_api::chatEventMessageEdited>(std::move (v0), std::move (v100));
}
struct TdChatEventMessageEdited *TdConvertFromInternal (const td::td_api::chatEventMessageEdited &from) {
  auto res = new TdChatEventMessageEdited ();
  res->ID = CODE_ChatEventMessageEdited;
  res->refcnt = 1;
  if (!from.old_message_) {
    res->old_message_ = nullptr;
  } else {
    res->old_message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.old_message_));
  }
  if (!from.new_message_) {
    res->new_message_ = nullptr;
  } else {
    res->new_message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.new_message_));
  }
  return res;
}
char *TdSerializeChatEventMessageEdited (struct TdChatEventMessageEdited *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMessageEdited *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMessageEdited (struct TdChatEventMessageEdited *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMessageEdited *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->old_message_);
  TdDestroyObject (var->new_message_);
  delete var;
}
void TdStackStorerChatEventMessageEdited (struct TdChatEventMessageEdited *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMessageEdited *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMessageEdited");
  M->new_field ("ID");
  TdStackStorer (var->old_message_, M);
  M->new_field ("old_message_");
  TdStackStorer (var->new_message_, M);
  M->new_field ("new_message_");
}
struct TdChatEventMessageEdited *TdStackFetcherChatEventMessageEdited (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMessageEdited ();
  res->ID = CODE_ChatEventMessageEdited;
  res->refcnt = 1;
  M->get_field ("old_message_");
  if (M->is_nil ()) {
    res->old_message_ = nullptr;
  } else {
    res->old_message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  M->get_field ("new_message_");
  if (M->is_nil ()) {
    res->new_message_ = nullptr;
  } else {
    res->new_message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  return res;
}
struct TdChatEventMessageDeleted *TdCreateObjectChatEventMessageDeleted (struct TdMessage *message_) {
  auto var = new struct TdChatEventMessageDeleted ();
  var->ID = CODE_ChatEventMessageDeleted;
  var->refcnt = 1;
  var->message_ = message_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMessageDeleted> TdConvertToInternal (struct TdChatEventMessageDeleted *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::message> v0;
  v0 = TdConvertToInternal (var->message_);
  return td::td_api::make_object<td::td_api::chatEventMessageDeleted>(std::move (v0));
}
struct TdChatEventMessageDeleted *TdConvertFromInternal (const td::td_api::chatEventMessageDeleted &from) {
  auto res = new TdChatEventMessageDeleted ();
  res->ID = CODE_ChatEventMessageDeleted;
  res->refcnt = 1;
  if (!from.message_) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.message_));
  }
  return res;
}
char *TdSerializeChatEventMessageDeleted (struct TdChatEventMessageDeleted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMessageDeleted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMessageDeleted (struct TdChatEventMessageDeleted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMessageDeleted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->message_);
  delete var;
}
void TdStackStorerChatEventMessageDeleted (struct TdChatEventMessageDeleted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMessageDeleted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMessageDeleted");
  M->new_field ("ID");
  TdStackStorer (var->message_, M);
  M->new_field ("message_");
}
struct TdChatEventMessageDeleted *TdStackFetcherChatEventMessageDeleted (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMessageDeleted ();
  res->ID = CODE_ChatEventMessageDeleted;
  res->refcnt = 1;
  M->get_field ("message_");
  if (M->is_nil ()) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  return res;
}
struct TdChatEventMessagePinned *TdCreateObjectChatEventMessagePinned (struct TdMessage *message_) {
  auto var = new struct TdChatEventMessagePinned ();
  var->ID = CODE_ChatEventMessagePinned;
  var->refcnt = 1;
  var->message_ = message_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMessagePinned> TdConvertToInternal (struct TdChatEventMessagePinned *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::message> v0;
  v0 = TdConvertToInternal (var->message_);
  return td::td_api::make_object<td::td_api::chatEventMessagePinned>(std::move (v0));
}
struct TdChatEventMessagePinned *TdConvertFromInternal (const td::td_api::chatEventMessagePinned &from) {
  auto res = new TdChatEventMessagePinned ();
  res->ID = CODE_ChatEventMessagePinned;
  res->refcnt = 1;
  if (!from.message_) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.message_));
  }
  return res;
}
char *TdSerializeChatEventMessagePinned (struct TdChatEventMessagePinned *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMessagePinned *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMessagePinned (struct TdChatEventMessagePinned *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMessagePinned *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->message_);
  delete var;
}
void TdStackStorerChatEventMessagePinned (struct TdChatEventMessagePinned *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMessagePinned *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMessagePinned");
  M->new_field ("ID");
  TdStackStorer (var->message_, M);
  M->new_field ("message_");
}
struct TdChatEventMessagePinned *TdStackFetcherChatEventMessagePinned (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMessagePinned ();
  res->ID = CODE_ChatEventMessagePinned;
  res->refcnt = 1;
  M->get_field ("message_");
  if (M->is_nil ()) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  return res;
}
struct TdChatEventMessageUnpinned *TdCreateObjectChatEventMessageUnpinned (void) {
  auto var = new struct TdChatEventMessageUnpinned ();
  var->ID = CODE_ChatEventMessageUnpinned;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMessageUnpinned> TdConvertToInternal (struct TdChatEventMessageUnpinned *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatEventMessageUnpinned>();
}
struct TdChatEventMessageUnpinned *TdConvertFromInternal (const td::td_api::chatEventMessageUnpinned &from) {
  auto res = new TdChatEventMessageUnpinned ();
  res->ID = CODE_ChatEventMessageUnpinned;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatEventMessageUnpinned (struct TdChatEventMessageUnpinned *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMessageUnpinned *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMessageUnpinned (struct TdChatEventMessageUnpinned *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMessageUnpinned *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatEventMessageUnpinned (struct TdChatEventMessageUnpinned *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMessageUnpinned *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMessageUnpinned");
  M->new_field ("ID");
}
struct TdChatEventMessageUnpinned *TdStackFetcherChatEventMessageUnpinned (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMessageUnpinned ();
  res->ID = CODE_ChatEventMessageUnpinned;
  res->refcnt = 1;
  return res;
}
struct TdChatEventMemberJoined *TdCreateObjectChatEventMemberJoined (void) {
  auto var = new struct TdChatEventMemberJoined ();
  var->ID = CODE_ChatEventMemberJoined;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMemberJoined> TdConvertToInternal (struct TdChatEventMemberJoined *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatEventMemberJoined>();
}
struct TdChatEventMemberJoined *TdConvertFromInternal (const td::td_api::chatEventMemberJoined &from) {
  auto res = new TdChatEventMemberJoined ();
  res->ID = CODE_ChatEventMemberJoined;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatEventMemberJoined (struct TdChatEventMemberJoined *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMemberJoined *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMemberJoined (struct TdChatEventMemberJoined *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMemberJoined *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatEventMemberJoined (struct TdChatEventMemberJoined *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMemberJoined *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMemberJoined");
  M->new_field ("ID");
}
struct TdChatEventMemberJoined *TdStackFetcherChatEventMemberJoined (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMemberJoined ();
  res->ID = CODE_ChatEventMemberJoined;
  res->refcnt = 1;
  return res;
}
struct TdChatEventMemberLeft *TdCreateObjectChatEventMemberLeft (void) {
  auto var = new struct TdChatEventMemberLeft ();
  var->ID = CODE_ChatEventMemberLeft;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMemberLeft> TdConvertToInternal (struct TdChatEventMemberLeft *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatEventMemberLeft>();
}
struct TdChatEventMemberLeft *TdConvertFromInternal (const td::td_api::chatEventMemberLeft &from) {
  auto res = new TdChatEventMemberLeft ();
  res->ID = CODE_ChatEventMemberLeft;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatEventMemberLeft (struct TdChatEventMemberLeft *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMemberLeft *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMemberLeft (struct TdChatEventMemberLeft *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMemberLeft *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatEventMemberLeft (struct TdChatEventMemberLeft *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMemberLeft *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMemberLeft");
  M->new_field ("ID");
}
struct TdChatEventMemberLeft *TdStackFetcherChatEventMemberLeft (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMemberLeft ();
  res->ID = CODE_ChatEventMemberLeft;
  res->refcnt = 1;
  return res;
}
struct TdChatEventMemberInvited *TdCreateObjectChatEventMemberInvited (int user_id_, struct TdChatMemberStatus *status_) {
  auto var = new struct TdChatEventMemberInvited ();
  var->ID = CODE_ChatEventMemberInvited;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->status_ = status_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMemberInvited> TdConvertToInternal (struct TdChatEventMemberInvited *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v100;
  v100 = TdConvertToInternal (var->status_);
  return td::td_api::make_object<td::td_api::chatEventMemberInvited>(std::move (v0), std::move (v100));
}
struct TdChatEventMemberInvited *TdConvertFromInternal (const td::td_api::chatEventMemberInvited &from) {
  auto res = new TdChatEventMemberInvited ();
  res->ID = CODE_ChatEventMemberInvited;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  if (!from.status_) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.status_));
  }
  return res;
}
char *TdSerializeChatEventMemberInvited (struct TdChatEventMemberInvited *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMemberInvited *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMemberInvited (struct TdChatEventMemberInvited *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMemberInvited *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->status_);
  delete var;
}
void TdStackStorerChatEventMemberInvited (struct TdChatEventMemberInvited *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMemberInvited *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMemberInvited");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->status_, M);
  M->new_field ("status_");
}
struct TdChatEventMemberInvited *TdStackFetcherChatEventMemberInvited (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMemberInvited ();
  res->ID = CODE_ChatEventMemberInvited;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("status_");
  if (M->is_nil ()) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  return res;
}
struct TdChatEventMemberPromoted *TdCreateObjectChatEventMemberPromoted (int user_id_, struct TdChatMemberStatus *old_status_, struct TdChatMemberStatus *new_status_) {
  auto var = new struct TdChatEventMemberPromoted ();
  var->ID = CODE_ChatEventMemberPromoted;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->old_status_ = old_status_;
  var->new_status_ = new_status_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMemberPromoted> TdConvertToInternal (struct TdChatEventMemberPromoted *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v100;
  v100 = TdConvertToInternal (var->old_status_);
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v200;
  v200 = TdConvertToInternal (var->new_status_);
  return td::td_api::make_object<td::td_api::chatEventMemberPromoted>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdChatEventMemberPromoted *TdConvertFromInternal (const td::td_api::chatEventMemberPromoted &from) {
  auto res = new TdChatEventMemberPromoted ();
  res->ID = CODE_ChatEventMemberPromoted;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  if (!from.old_status_) {
    res->old_status_ = nullptr;
  } else {
    res->old_status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.old_status_));
  }
  if (!from.new_status_) {
    res->new_status_ = nullptr;
  } else {
    res->new_status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.new_status_));
  }
  return res;
}
char *TdSerializeChatEventMemberPromoted (struct TdChatEventMemberPromoted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMemberPromoted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMemberPromoted (struct TdChatEventMemberPromoted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMemberPromoted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->old_status_);
  TdDestroyObject (var->new_status_);
  delete var;
}
void TdStackStorerChatEventMemberPromoted (struct TdChatEventMemberPromoted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMemberPromoted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMemberPromoted");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->old_status_, M);
  M->new_field ("old_status_");
  TdStackStorer (var->new_status_, M);
  M->new_field ("new_status_");
}
struct TdChatEventMemberPromoted *TdStackFetcherChatEventMemberPromoted (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMemberPromoted ();
  res->ID = CODE_ChatEventMemberPromoted;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("old_status_");
  if (M->is_nil ()) {
    res->old_status_ = nullptr;
  } else {
    res->old_status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  M->get_field ("new_status_");
  if (M->is_nil ()) {
    res->new_status_ = nullptr;
  } else {
    res->new_status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  return res;
}
struct TdChatEventMemberRestricted *TdCreateObjectChatEventMemberRestricted (int user_id_, struct TdChatMemberStatus *old_status_, struct TdChatMemberStatus *new_status_) {
  auto var = new struct TdChatEventMemberRestricted ();
  var->ID = CODE_ChatEventMemberRestricted;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->old_status_ = old_status_;
  var->new_status_ = new_status_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventMemberRestricted> TdConvertToInternal (struct TdChatEventMemberRestricted *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v100;
  v100 = TdConvertToInternal (var->old_status_);
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v200;
  v200 = TdConvertToInternal (var->new_status_);
  return td::td_api::make_object<td::td_api::chatEventMemberRestricted>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdChatEventMemberRestricted *TdConvertFromInternal (const td::td_api::chatEventMemberRestricted &from) {
  auto res = new TdChatEventMemberRestricted ();
  res->ID = CODE_ChatEventMemberRestricted;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  if (!from.old_status_) {
    res->old_status_ = nullptr;
  } else {
    res->old_status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.old_status_));
  }
  if (!from.new_status_) {
    res->new_status_ = nullptr;
  } else {
    res->new_status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.new_status_));
  }
  return res;
}
char *TdSerializeChatEventMemberRestricted (struct TdChatEventMemberRestricted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventMemberRestricted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventMemberRestricted (struct TdChatEventMemberRestricted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventMemberRestricted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->old_status_);
  TdDestroyObject (var->new_status_);
  delete var;
}
void TdStackStorerChatEventMemberRestricted (struct TdChatEventMemberRestricted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventMemberRestricted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventMemberRestricted");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->old_status_, M);
  M->new_field ("old_status_");
  TdStackStorer (var->new_status_, M);
  M->new_field ("new_status_");
}
struct TdChatEventMemberRestricted *TdStackFetcherChatEventMemberRestricted (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventMemberRestricted ();
  res->ID = CODE_ChatEventMemberRestricted;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("old_status_");
  if (M->is_nil ()) {
    res->old_status_ = nullptr;
  } else {
    res->old_status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  M->get_field ("new_status_");
  if (M->is_nil ()) {
    res->new_status_ = nullptr;
  } else {
    res->new_status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  return res;
}
struct TdChatEventTitleChanged *TdCreateObjectChatEventTitleChanged (char *old_title_, char *new_title_) {
  auto var = new struct TdChatEventTitleChanged ();
  var->ID = CODE_ChatEventTitleChanged;
  var->refcnt = 1;
  var->old_title_ = (old_title_) ? td::str_dup (td::Slice (old_title_)) : nullptr;
  var->new_title_ = (new_title_) ? td::str_dup (td::Slice (new_title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventTitleChanged> TdConvertToInternal (struct TdChatEventTitleChanged *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->old_title_) ? var->old_title_: "";
  std::string v100;
  v100 = (var->new_title_) ? var->new_title_: "";
  return td::td_api::make_object<td::td_api::chatEventTitleChanged>(std::move (v0), std::move (v100));
}
struct TdChatEventTitleChanged *TdConvertFromInternal (const td::td_api::chatEventTitleChanged &from) {
  auto res = new TdChatEventTitleChanged ();
  res->ID = CODE_ChatEventTitleChanged;
  res->refcnt = 1;
  res->old_title_ = (from.old_title_.length ()) ? td::str_dup (from.old_title_) : nullptr;
  res->new_title_ = (from.new_title_.length ()) ? td::str_dup (from.new_title_) : nullptr;
  return res;
}
char *TdSerializeChatEventTitleChanged (struct TdChatEventTitleChanged *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventTitleChanged *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventTitleChanged (struct TdChatEventTitleChanged *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventTitleChanged *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->old_title_);
  free (var->new_title_);
  delete var;
}
void TdStackStorerChatEventTitleChanged (struct TdChatEventTitleChanged *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventTitleChanged *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventTitleChanged");
  M->new_field ("ID");
  M->pack_string (var->old_title_);
  M->new_field ("old_title_");
  M->pack_string (var->new_title_);
  M->new_field ("new_title_");
}
struct TdChatEventTitleChanged *TdStackFetcherChatEventTitleChanged (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventTitleChanged ();
  res->ID = CODE_ChatEventTitleChanged;
  res->refcnt = 1;
  M->get_field ("old_title_");
  res->old_title_ = M->get_string ();
  M->pop ();
  M->get_field ("new_title_");
  res->new_title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdChatEventDescriptionChanged *TdCreateObjectChatEventDescriptionChanged (char *old_description_, char *new_description_) {
  auto var = new struct TdChatEventDescriptionChanged ();
  var->ID = CODE_ChatEventDescriptionChanged;
  var->refcnt = 1;
  var->old_description_ = (old_description_) ? td::str_dup (td::Slice (old_description_)) : nullptr;
  var->new_description_ = (new_description_) ? td::str_dup (td::Slice (new_description_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventDescriptionChanged> TdConvertToInternal (struct TdChatEventDescriptionChanged *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->old_description_) ? var->old_description_: "";
  std::string v100;
  v100 = (var->new_description_) ? var->new_description_: "";
  return td::td_api::make_object<td::td_api::chatEventDescriptionChanged>(std::move (v0), std::move (v100));
}
struct TdChatEventDescriptionChanged *TdConvertFromInternal (const td::td_api::chatEventDescriptionChanged &from) {
  auto res = new TdChatEventDescriptionChanged ();
  res->ID = CODE_ChatEventDescriptionChanged;
  res->refcnt = 1;
  res->old_description_ = (from.old_description_.length ()) ? td::str_dup (from.old_description_) : nullptr;
  res->new_description_ = (from.new_description_.length ()) ? td::str_dup (from.new_description_) : nullptr;
  return res;
}
char *TdSerializeChatEventDescriptionChanged (struct TdChatEventDescriptionChanged *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventDescriptionChanged *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventDescriptionChanged (struct TdChatEventDescriptionChanged *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventDescriptionChanged *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->old_description_);
  free (var->new_description_);
  delete var;
}
void TdStackStorerChatEventDescriptionChanged (struct TdChatEventDescriptionChanged *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventDescriptionChanged *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventDescriptionChanged");
  M->new_field ("ID");
  M->pack_string (var->old_description_);
  M->new_field ("old_description_");
  M->pack_string (var->new_description_);
  M->new_field ("new_description_");
}
struct TdChatEventDescriptionChanged *TdStackFetcherChatEventDescriptionChanged (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventDescriptionChanged ();
  res->ID = CODE_ChatEventDescriptionChanged;
  res->refcnt = 1;
  M->get_field ("old_description_");
  res->old_description_ = M->get_string ();
  M->pop ();
  M->get_field ("new_description_");
  res->new_description_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdChatEventUsernameChanged *TdCreateObjectChatEventUsernameChanged (char *old_username_, char *new_username_) {
  auto var = new struct TdChatEventUsernameChanged ();
  var->ID = CODE_ChatEventUsernameChanged;
  var->refcnt = 1;
  var->old_username_ = (old_username_) ? td::str_dup (td::Slice (old_username_)) : nullptr;
  var->new_username_ = (new_username_) ? td::str_dup (td::Slice (new_username_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventUsernameChanged> TdConvertToInternal (struct TdChatEventUsernameChanged *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->old_username_) ? var->old_username_: "";
  std::string v100;
  v100 = (var->new_username_) ? var->new_username_: "";
  return td::td_api::make_object<td::td_api::chatEventUsernameChanged>(std::move (v0), std::move (v100));
}
struct TdChatEventUsernameChanged *TdConvertFromInternal (const td::td_api::chatEventUsernameChanged &from) {
  auto res = new TdChatEventUsernameChanged ();
  res->ID = CODE_ChatEventUsernameChanged;
  res->refcnt = 1;
  res->old_username_ = (from.old_username_.length ()) ? td::str_dup (from.old_username_) : nullptr;
  res->new_username_ = (from.new_username_.length ()) ? td::str_dup (from.new_username_) : nullptr;
  return res;
}
char *TdSerializeChatEventUsernameChanged (struct TdChatEventUsernameChanged *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventUsernameChanged *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventUsernameChanged (struct TdChatEventUsernameChanged *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventUsernameChanged *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->old_username_);
  free (var->new_username_);
  delete var;
}
void TdStackStorerChatEventUsernameChanged (struct TdChatEventUsernameChanged *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventUsernameChanged *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventUsernameChanged");
  M->new_field ("ID");
  M->pack_string (var->old_username_);
  M->new_field ("old_username_");
  M->pack_string (var->new_username_);
  M->new_field ("new_username_");
}
struct TdChatEventUsernameChanged *TdStackFetcherChatEventUsernameChanged (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventUsernameChanged ();
  res->ID = CODE_ChatEventUsernameChanged;
  res->refcnt = 1;
  M->get_field ("old_username_");
  res->old_username_ = M->get_string ();
  M->pop ();
  M->get_field ("new_username_");
  res->new_username_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdChatEventPhotoChanged *TdCreateObjectChatEventPhotoChanged (struct TdChatPhoto *old_photo_, struct TdChatPhoto *new_photo_) {
  auto var = new struct TdChatEventPhotoChanged ();
  var->ID = CODE_ChatEventPhotoChanged;
  var->refcnt = 1;
  var->old_photo_ = old_photo_;
  var->new_photo_ = new_photo_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventPhotoChanged> TdConvertToInternal (struct TdChatEventPhotoChanged *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::chatPhoto> v0;
  v0 = TdConvertToInternal (var->old_photo_);
  td::td_api::object_ptr<td::td_api::chatPhoto> v100;
  v100 = TdConvertToInternal (var->new_photo_);
  return td::td_api::make_object<td::td_api::chatEventPhotoChanged>(std::move (v0), std::move (v100));
}
struct TdChatEventPhotoChanged *TdConvertFromInternal (const td::td_api::chatEventPhotoChanged &from) {
  auto res = new TdChatEventPhotoChanged ();
  res->ID = CODE_ChatEventPhotoChanged;
  res->refcnt = 1;
  if (!from.old_photo_) {
    res->old_photo_ = nullptr;
  } else {
    res->old_photo_ = TdConvertFromInternal (static_cast<const td::td_api::chatPhoto &>(*from.old_photo_));
  }
  if (!from.new_photo_) {
    res->new_photo_ = nullptr;
  } else {
    res->new_photo_ = TdConvertFromInternal (static_cast<const td::td_api::chatPhoto &>(*from.new_photo_));
  }
  return res;
}
char *TdSerializeChatEventPhotoChanged (struct TdChatEventPhotoChanged *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventPhotoChanged *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventPhotoChanged (struct TdChatEventPhotoChanged *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventPhotoChanged *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->old_photo_);
  TdDestroyObject (var->new_photo_);
  delete var;
}
void TdStackStorerChatEventPhotoChanged (struct TdChatEventPhotoChanged *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventPhotoChanged *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventPhotoChanged");
  M->new_field ("ID");
  TdStackStorer (var->old_photo_, M);
  M->new_field ("old_photo_");
  TdStackStorer (var->new_photo_, M);
  M->new_field ("new_photo_");
}
struct TdChatEventPhotoChanged *TdStackFetcherChatEventPhotoChanged (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventPhotoChanged ();
  res->ID = CODE_ChatEventPhotoChanged;
  res->refcnt = 1;
  M->get_field ("old_photo_");
  if (M->is_nil ()) {
    res->old_photo_ = nullptr;
  } else {
    res->old_photo_ = TdStackFetcherChatPhoto (M);
  }
  M->pop ();
  M->get_field ("new_photo_");
  if (M->is_nil ()) {
    res->new_photo_ = nullptr;
  } else {
    res->new_photo_ = TdStackFetcherChatPhoto (M);
  }
  M->pop ();
  return res;
}
struct TdChatEventInvitesToggled *TdCreateObjectChatEventInvitesToggled (int anyone_can_invite_) {
  auto var = new struct TdChatEventInvitesToggled ();
  var->ID = CODE_ChatEventInvitesToggled;
  var->refcnt = 1;
  var->anyone_can_invite_ = anyone_can_invite_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventInvitesToggled> TdConvertToInternal (struct TdChatEventInvitesToggled *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->anyone_can_invite_ != 0;
  return td::td_api::make_object<td::td_api::chatEventInvitesToggled>(std::move (v0));
}
struct TdChatEventInvitesToggled *TdConvertFromInternal (const td::td_api::chatEventInvitesToggled &from) {
  auto res = new TdChatEventInvitesToggled ();
  res->ID = CODE_ChatEventInvitesToggled;
  res->refcnt = 1;
  res->anyone_can_invite_ = from.anyone_can_invite_;
  return res;
}
char *TdSerializeChatEventInvitesToggled (struct TdChatEventInvitesToggled *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventInvitesToggled *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventInvitesToggled (struct TdChatEventInvitesToggled *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventInvitesToggled *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatEventInvitesToggled (struct TdChatEventInvitesToggled *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventInvitesToggled *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventInvitesToggled");
  M->new_field ("ID");
  M->pack_bool (var->anyone_can_invite_);
  M->new_field ("anyone_can_invite_");
}
struct TdChatEventInvitesToggled *TdStackFetcherChatEventInvitesToggled (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventInvitesToggled ();
  res->ID = CODE_ChatEventInvitesToggled;
  res->refcnt = 1;
  M->get_field ("anyone_can_invite_");
  res->anyone_can_invite_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatEventSignMessagesToggled *TdCreateObjectChatEventSignMessagesToggled (int sign_messages_) {
  auto var = new struct TdChatEventSignMessagesToggled ();
  var->ID = CODE_ChatEventSignMessagesToggled;
  var->refcnt = 1;
  var->sign_messages_ = sign_messages_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventSignMessagesToggled> TdConvertToInternal (struct TdChatEventSignMessagesToggled *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->sign_messages_ != 0;
  return td::td_api::make_object<td::td_api::chatEventSignMessagesToggled>(std::move (v0));
}
struct TdChatEventSignMessagesToggled *TdConvertFromInternal (const td::td_api::chatEventSignMessagesToggled &from) {
  auto res = new TdChatEventSignMessagesToggled ();
  res->ID = CODE_ChatEventSignMessagesToggled;
  res->refcnt = 1;
  res->sign_messages_ = from.sign_messages_;
  return res;
}
char *TdSerializeChatEventSignMessagesToggled (struct TdChatEventSignMessagesToggled *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventSignMessagesToggled *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventSignMessagesToggled (struct TdChatEventSignMessagesToggled *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventSignMessagesToggled *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatEventSignMessagesToggled (struct TdChatEventSignMessagesToggled *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventSignMessagesToggled *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventSignMessagesToggled");
  M->new_field ("ID");
  M->pack_bool (var->sign_messages_);
  M->new_field ("sign_messages_");
}
struct TdChatEventSignMessagesToggled *TdStackFetcherChatEventSignMessagesToggled (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventSignMessagesToggled ();
  res->ID = CODE_ChatEventSignMessagesToggled;
  res->refcnt = 1;
  M->get_field ("sign_messages_");
  res->sign_messages_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatEventStickerSetChanged *TdCreateObjectChatEventStickerSetChanged (long long old_sticker_set_id_, long long new_sticker_set_id_) {
  auto var = new struct TdChatEventStickerSetChanged ();
  var->ID = CODE_ChatEventStickerSetChanged;
  var->refcnt = 1;
  var->old_sticker_set_id_ = old_sticker_set_id_;
  var->new_sticker_set_id_ = new_sticker_set_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventStickerSetChanged> TdConvertToInternal (struct TdChatEventStickerSetChanged *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->old_sticker_set_id_;
  std::int64_t v100;
  v100 = var->new_sticker_set_id_;
  return td::td_api::make_object<td::td_api::chatEventStickerSetChanged>(std::move (v0), std::move (v100));
}
struct TdChatEventStickerSetChanged *TdConvertFromInternal (const td::td_api::chatEventStickerSetChanged &from) {
  auto res = new TdChatEventStickerSetChanged ();
  res->ID = CODE_ChatEventStickerSetChanged;
  res->refcnt = 1;
  res->old_sticker_set_id_ = from.old_sticker_set_id_;
  res->new_sticker_set_id_ = from.new_sticker_set_id_;
  return res;
}
char *TdSerializeChatEventStickerSetChanged (struct TdChatEventStickerSetChanged *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventStickerSetChanged *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventStickerSetChanged (struct TdChatEventStickerSetChanged *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventStickerSetChanged *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatEventStickerSetChanged (struct TdChatEventStickerSetChanged *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventStickerSetChanged *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventStickerSetChanged");
  M->new_field ("ID");
  M->pack_long (var->old_sticker_set_id_);
  M->new_field ("old_sticker_set_id_");
  M->pack_long (var->new_sticker_set_id_);
  M->new_field ("new_sticker_set_id_");
}
struct TdChatEventStickerSetChanged *TdStackFetcherChatEventStickerSetChanged (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventStickerSetChanged ();
  res->ID = CODE_ChatEventStickerSetChanged;
  res->refcnt = 1;
  M->get_field ("old_sticker_set_id_");
  res->old_sticker_set_id_ = M->get_long ();
  M->pop ();
  M->get_field ("new_sticker_set_id_");
  res->new_sticker_set_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdChatEventIsAllHistoryAvailableToggled *TdCreateObjectChatEventIsAllHistoryAvailableToggled (int is_all_history_available_) {
  auto var = new struct TdChatEventIsAllHistoryAvailableToggled ();
  var->ID = CODE_ChatEventIsAllHistoryAvailableToggled;
  var->refcnt = 1;
  var->is_all_history_available_ = is_all_history_available_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventIsAllHistoryAvailableToggled> TdConvertToInternal (struct TdChatEventIsAllHistoryAvailableToggled *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_all_history_available_ != 0;
  return td::td_api::make_object<td::td_api::chatEventIsAllHistoryAvailableToggled>(std::move (v0));
}
struct TdChatEventIsAllHistoryAvailableToggled *TdConvertFromInternal (const td::td_api::chatEventIsAllHistoryAvailableToggled &from) {
  auto res = new TdChatEventIsAllHistoryAvailableToggled ();
  res->ID = CODE_ChatEventIsAllHistoryAvailableToggled;
  res->refcnt = 1;
  res->is_all_history_available_ = from.is_all_history_available_;
  return res;
}
char *TdSerializeChatEventIsAllHistoryAvailableToggled (struct TdChatEventIsAllHistoryAvailableToggled *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventIsAllHistoryAvailableToggled *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventIsAllHistoryAvailableToggled (struct TdChatEventIsAllHistoryAvailableToggled *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventIsAllHistoryAvailableToggled *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatEventIsAllHistoryAvailableToggled (struct TdChatEventIsAllHistoryAvailableToggled *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventIsAllHistoryAvailableToggled *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventIsAllHistoryAvailableToggled");
  M->new_field ("ID");
  M->pack_bool (var->is_all_history_available_);
  M->new_field ("is_all_history_available_");
}
struct TdChatEventIsAllHistoryAvailableToggled *TdStackFetcherChatEventIsAllHistoryAvailableToggled (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventIsAllHistoryAvailableToggled ();
  res->ID = CODE_ChatEventIsAllHistoryAvailableToggled;
  res->refcnt = 1;
  M->get_field ("is_all_history_available_");
  res->is_all_history_available_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatEventLogFilters *TdCreateObjectChatEventLogFilters (int message_edits_, int message_deletions_, int message_pins_, int member_joins_, int member_leaves_, int member_invites_, int member_promotions_, int member_restrictions_, int info_changes_, int setting_changes_) {
  auto var = new struct TdChatEventLogFilters ();
  var->ID = CODE_ChatEventLogFilters;
  var->refcnt = 1;
  var->message_edits_ = message_edits_;
  var->message_deletions_ = message_deletions_;
  var->message_pins_ = message_pins_;
  var->member_joins_ = member_joins_;
  var->member_leaves_ = member_leaves_;
  var->member_invites_ = member_invites_;
  var->member_promotions_ = member_promotions_;
  var->member_restrictions_ = member_restrictions_;
  var->info_changes_ = info_changes_;
  var->setting_changes_ = setting_changes_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEventLogFilters> TdConvertToInternal (struct TdChatEventLogFilters *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->message_edits_ != 0;
  bool v100;
  v100 = var->message_deletions_ != 0;
  bool v200;
  v200 = var->message_pins_ != 0;
  bool v300;
  v300 = var->member_joins_ != 0;
  bool v400;
  v400 = var->member_leaves_ != 0;
  bool v500;
  v500 = var->member_invites_ != 0;
  bool v600;
  v600 = var->member_promotions_ != 0;
  bool v700;
  v700 = var->member_restrictions_ != 0;
  bool v800;
  v800 = var->info_changes_ != 0;
  bool v900;
  v900 = var->setting_changes_ != 0;
  return td::td_api::make_object<td::td_api::chatEventLogFilters>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900));
}
struct TdChatEventLogFilters *TdConvertFromInternal (const td::td_api::chatEventLogFilters &from) {
  auto res = new TdChatEventLogFilters ();
  res->ID = CODE_ChatEventLogFilters;
  res->refcnt = 1;
  res->message_edits_ = from.message_edits_;
  res->message_deletions_ = from.message_deletions_;
  res->message_pins_ = from.message_pins_;
  res->member_joins_ = from.member_joins_;
  res->member_leaves_ = from.member_leaves_;
  res->member_invites_ = from.member_invites_;
  res->member_promotions_ = from.member_promotions_;
  res->member_restrictions_ = from.member_restrictions_;
  res->info_changes_ = from.info_changes_;
  res->setting_changes_ = from.setting_changes_;
  return res;
}
char *TdSerializeChatEventLogFilters (struct TdChatEventLogFilters *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEventLogFilters *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEventLogFilters (struct TdChatEventLogFilters *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEventLogFilters *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatEventLogFilters (struct TdChatEventLogFilters *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEventLogFilters *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEventLogFilters");
  M->new_field ("ID");
  M->pack_bool (var->message_edits_);
  M->new_field ("message_edits_");
  M->pack_bool (var->message_deletions_);
  M->new_field ("message_deletions_");
  M->pack_bool (var->message_pins_);
  M->new_field ("message_pins_");
  M->pack_bool (var->member_joins_);
  M->new_field ("member_joins_");
  M->pack_bool (var->member_leaves_);
  M->new_field ("member_leaves_");
  M->pack_bool (var->member_invites_);
  M->new_field ("member_invites_");
  M->pack_bool (var->member_promotions_);
  M->new_field ("member_promotions_");
  M->pack_bool (var->member_restrictions_);
  M->new_field ("member_restrictions_");
  M->pack_bool (var->info_changes_);
  M->new_field ("info_changes_");
  M->pack_bool (var->setting_changes_);
  M->new_field ("setting_changes_");
}
struct TdChatEventLogFilters *TdStackFetcherChatEventLogFilters (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEventLogFilters ();
  res->ID = CODE_ChatEventLogFilters;
  res->refcnt = 1;
  M->get_field ("message_edits_");
  res->message_edits_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("message_deletions_");
  res->message_deletions_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("message_pins_");
  res->message_pins_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("member_joins_");
  res->member_joins_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("member_leaves_");
  res->member_leaves_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("member_invites_");
  res->member_invites_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("member_promotions_");
  res->member_promotions_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("member_restrictions_");
  res->member_restrictions_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("info_changes_");
  res->info_changes_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("setting_changes_");
  res->setting_changes_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatEvents *TdCreateObjectChatEvents (struct TdVectorChatEvent *events_) {
  auto var = new struct TdChatEvents ();
  var->ID = CODE_ChatEvents;
  var->refcnt = 1;
  var->events_ = events_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatEvents> TdConvertToInternal (struct TdChatEvents *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::chatEvent>> v0;
  for (int i0 = 0; i0 < var->events_->len; i0++) {
    td::td_api::object_ptr<td::td_api::chatEvent> v1;
    v1 = TdConvertToInternal (var->events_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::chatEvents>(std::move (v0));
}
struct TdChatEvents *TdConvertFromInternal (const td::td_api::chatEvents &from) {
  auto res = new TdChatEvents ();
  res->ID = CODE_ChatEvents;
  res->refcnt = 1;
  res->events_ = new TdVectorChatEvent ();
  res->events_->len = (int)from.events_.size ();
  res->events_->data = new struct TdChatEvent * [res->events_->len];
  for (int i0 = 0; i0 < res->events_->len; i0++) {
    if (!from.events_[i0]) {
      res->events_->data[i0] = nullptr;
    } else {
      res->events_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::chatEvent &>(*from.events_[i0]));
    }
  }
  return res;
}
char *TdSerializeChatEvents (struct TdChatEvents *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatEvents *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatEvents (struct TdChatEvents *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatEvents *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->events_->len; i0++) {
    TdDestroyObject (var->events_->data[i0]);
  }
  delete[] var->events_->data;
  delete var->events_;
  delete var;
}
void TdStackStorerChatEvents (struct TdChatEvents *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatEvents *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatEvents");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->events_->len; i0++) {
    TdStackStorer (var->events_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("events_");
}
struct TdChatEvents *TdStackFetcherChatEvents (struct TdStackFetcherMethods *M) {
  auto res = new TdChatEvents ();
  res->ID = CODE_ChatEvents;
  res->refcnt = 1;
  M->get_field ("events_");
  res->events_ = new TdVectorChatEvent ();
  res->events_->len = M->get_arr_size ();
  res->events_->data = new struct TdChatEvent * [res->events_->len];
  for (int i0 = 0; i0 < res->events_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->events_->data[i0] = nullptr;
    } else {
      res->events_->data[i0] = TdStackFetcherChatEvent (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdChatInviteLink *TdCreateObjectChatInviteLink (char *invite_link_) {
  auto var = new struct TdChatInviteLink ();
  var->ID = CODE_ChatInviteLink;
  var->refcnt = 1;
  var->invite_link_ = (invite_link_) ? td::str_dup (td::Slice (invite_link_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::chatInviteLink> TdConvertToInternal (struct TdChatInviteLink *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->invite_link_) ? var->invite_link_: "";
  return td::td_api::make_object<td::td_api::chatInviteLink>(std::move (v0));
}
struct TdChatInviteLink *TdConvertFromInternal (const td::td_api::chatInviteLink &from) {
  auto res = new TdChatInviteLink ();
  res->ID = CODE_ChatInviteLink;
  res->refcnt = 1;
  res->invite_link_ = (from.invite_link_.length ()) ? td::str_dup (from.invite_link_) : nullptr;
  return res;
}
char *TdSerializeChatInviteLink (struct TdChatInviteLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatInviteLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatInviteLink (struct TdChatInviteLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatInviteLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->invite_link_);
  delete var;
}
void TdStackStorerChatInviteLink (struct TdChatInviteLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatInviteLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatInviteLink");
  M->new_field ("ID");
  M->pack_string (var->invite_link_);
  M->new_field ("invite_link_");
}
struct TdChatInviteLink *TdStackFetcherChatInviteLink (struct TdStackFetcherMethods *M) {
  auto res = new TdChatInviteLink ();
  res->ID = CODE_ChatInviteLink;
  res->refcnt = 1;
  M->get_field ("invite_link_");
  res->invite_link_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdChatInviteLinkInfo *TdCreateObjectChatInviteLinkInfo (long long chat_id_, struct TdChatType *type_, char *title_, struct TdChatPhoto *photo_, int member_count_, struct TdVectorInt *member_user_ids_, int is_public_) {
  auto var = new struct TdChatInviteLinkInfo ();
  var->ID = CODE_ChatInviteLinkInfo;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->type_ = type_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->photo_ = photo_;
  var->member_count_ = member_count_;
  var->member_user_ids_ = member_user_ids_;
  var->is_public_ = is_public_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatInviteLinkInfo> TdConvertToInternal (struct TdChatInviteLinkInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::ChatType> v100;
  v100 = TdConvertToInternal (var->type_);
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  td::td_api::object_ptr<td::td_api::chatPhoto> v300;
  v300 = TdConvertToInternal (var->photo_);
  std::int32_t v400;
  v400 = var->member_count_;
  std::vector<std::int32_t> v500;
  for (int i500 = 0; i500 < var->member_user_ids_->len; i500++) {
    std::int32_t v501;
    v501 = var->member_user_ids_->data[i500];
    v500.push_back (std::move (v501));
  }
  bool v600;
  v600 = var->is_public_ != 0;
  return td::td_api::make_object<td::td_api::chatInviteLinkInfo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdChatInviteLinkInfo *TdConvertFromInternal (const td::td_api::chatInviteLinkInfo &from) {
  auto res = new TdChatInviteLinkInfo ();
  res->ID = CODE_ChatInviteLinkInfo;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::ChatType &>(*from.type_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::chatPhoto &>(*from.photo_));
  }
  res->member_count_ = from.member_count_;
  res->member_user_ids_ = new TdVectorInt ();
  res->member_user_ids_->len = (int)from.member_user_ids_.size ();
  res->member_user_ids_->data = new int  [res->member_user_ids_->len];
  for (int i500 = 0; i500 < res->member_user_ids_->len; i500++) {
    res->member_user_ids_->data[i500] = from.member_user_ids_[i500];
  }
  res->is_public_ = from.is_public_;
  return res;
}
char *TdSerializeChatInviteLinkInfo (struct TdChatInviteLinkInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatInviteLinkInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatInviteLinkInfo (struct TdChatInviteLinkInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatInviteLinkInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  free (var->title_);
  TdDestroyObject (var->photo_);
  for (int i500 = 0; i500 < var->member_user_ids_->len; i500++) {
  }
  delete[] var->member_user_ids_->data;
  delete var->member_user_ids_;
  delete var;
}
void TdStackStorerChatInviteLinkInfo (struct TdChatInviteLinkInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatInviteLinkInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatInviteLinkInfo");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  M->pack_long (var->member_count_);
  M->new_field ("member_count_");
  M->new_array ();
  for (int i500 = 0; i500 < var->member_user_ids_->len; i500++) {
    M->pack_long (var->member_user_ids_->data[i500]);
    M->new_arr_field (i500);
  }
  M->new_field ("member_user_ids_");
  M->pack_bool (var->is_public_);
  M->new_field ("is_public_");
}
struct TdChatInviteLinkInfo *TdStackFetcherChatInviteLinkInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdChatInviteLinkInfo ();
  res->ID = CODE_ChatInviteLinkInfo;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherChatType (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherChatPhoto (M);
  }
  M->pop ();
  M->get_field ("member_count_");
  res->member_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("member_user_ids_");
  res->member_user_ids_ = new TdVectorInt ();
  res->member_user_ids_->len = M->get_arr_size ();
  res->member_user_ids_->data = new int  [res->member_user_ids_->len];
  for (int i500 = 0; i500 < res->member_user_ids_->len; i500++) {
    M->get_arr_field (i500);
    res->member_user_ids_->data[i500] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("is_public_");
  res->is_public_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatMember *TdCreateObjectChatMember (int user_id_, int inviter_user_id_, int joined_chat_date_, struct TdChatMemberStatus *status_, struct TdBotInfo *bot_info_) {
  auto var = new struct TdChatMember ();
  var->ID = CODE_ChatMember;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->inviter_user_id_ = inviter_user_id_;
  var->joined_chat_date_ = joined_chat_date_;
  var->status_ = status_;
  var->bot_info_ = bot_info_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMember> TdConvertToInternal (struct TdChatMember *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  std::int32_t v100;
  v100 = var->inviter_user_id_;
  std::int32_t v200;
  v200 = var->joined_chat_date_;
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v300;
  v300 = TdConvertToInternal (var->status_);
  td::td_api::object_ptr<td::td_api::botInfo> v400;
  v400 = TdConvertToInternal (var->bot_info_);
  return td::td_api::make_object<td::td_api::chatMember>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdChatMember *TdConvertFromInternal (const td::td_api::chatMember &from) {
  auto res = new TdChatMember ();
  res->ID = CODE_ChatMember;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  res->inviter_user_id_ = from.inviter_user_id_;
  res->joined_chat_date_ = from.joined_chat_date_;
  if (!from.status_) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.status_));
  }
  if (!from.bot_info_) {
    res->bot_info_ = nullptr;
  } else {
    res->bot_info_ = TdConvertFromInternal (static_cast<const td::td_api::botInfo &>(*from.bot_info_));
  }
  return res;
}
char *TdSerializeChatMember (struct TdChatMember *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMember *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMember (struct TdChatMember *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMember *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->status_);
  TdDestroyObject (var->bot_info_);
  delete var;
}
void TdStackStorerChatMember (struct TdChatMember *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMember *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMember");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_long (var->inviter_user_id_);
  M->new_field ("inviter_user_id_");
  M->pack_long (var->joined_chat_date_);
  M->new_field ("joined_chat_date_");
  TdStackStorer (var->status_, M);
  M->new_field ("status_");
  TdStackStorer (var->bot_info_, M);
  M->new_field ("bot_info_");
}
struct TdChatMember *TdStackFetcherChatMember (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMember ();
  res->ID = CODE_ChatMember;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("inviter_user_id_");
  res->inviter_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("joined_chat_date_");
  res->joined_chat_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("status_");
  if (M->is_nil ()) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  M->get_field ("bot_info_");
  if (M->is_nil ()) {
    res->bot_info_ = nullptr;
  } else {
    res->bot_info_ = TdStackFetcherBotInfo (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ChatMemberStatus> TdConvertToInternal (struct TdChatMemberStatus *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatMemberStatusCreator: return TdConvertToInternal ((struct TdChatMemberStatusCreator *)var);
    case CODE_ChatMemberStatusAdministrator: return TdConvertToInternal ((struct TdChatMemberStatusAdministrator *)var);
    case CODE_ChatMemberStatusMember: return TdConvertToInternal ((struct TdChatMemberStatusMember *)var);
    case CODE_ChatMemberStatusRestricted: return TdConvertToInternal ((struct TdChatMemberStatusRestricted *)var);
    case CODE_ChatMemberStatusLeft: return TdConvertToInternal ((struct TdChatMemberStatusLeft *)var);
    case CODE_ChatMemberStatusBanned: return TdConvertToInternal ((struct TdChatMemberStatusBanned *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdChatMemberStatus *TdConvertFromInternal (const td::td_api::ChatMemberStatus &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ChatMemberStatusCreator: return (struct TdChatMemberStatus *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusCreator &>(from));
    case CODE_ChatMemberStatusAdministrator: return (struct TdChatMemberStatus *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusAdministrator &>(from));
    case CODE_ChatMemberStatusMember: return (struct TdChatMemberStatus *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusMember &>(from));
    case CODE_ChatMemberStatusRestricted: return (struct TdChatMemberStatus *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusRestricted &>(from));
    case CODE_ChatMemberStatusLeft: return (struct TdChatMemberStatus *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusLeft &>(from));
    case CODE_ChatMemberStatusBanned: return (struct TdChatMemberStatus *)TdConvertFromInternal(static_cast<const td::td_api::chatMemberStatusBanned &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeChatMemberStatus (struct TdChatMemberStatus *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMemberStatus *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMemberStatus (struct TdChatMemberStatus *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMemberStatus *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatMemberStatusCreator: return TdDestroyObject ((struct TdChatMemberStatusCreator *)var);
    case CODE_ChatMemberStatusAdministrator: return TdDestroyObject ((struct TdChatMemberStatusAdministrator *)var);
    case CODE_ChatMemberStatusMember: return TdDestroyObject ((struct TdChatMemberStatusMember *)var);
    case CODE_ChatMemberStatusRestricted: return TdDestroyObject ((struct TdChatMemberStatusRestricted *)var);
    case CODE_ChatMemberStatusLeft: return TdDestroyObject ((struct TdChatMemberStatusLeft *)var);
    case CODE_ChatMemberStatusBanned: return TdDestroyObject ((struct TdChatMemberStatusBanned *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerChatMemberStatus (struct TdChatMemberStatus *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMemberStatus *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatMemberStatusCreator: return TdStackStorer ((struct TdChatMemberStatusCreator *)var, M);
    case CODE_ChatMemberStatusAdministrator: return TdStackStorer ((struct TdChatMemberStatusAdministrator *)var, M);
    case CODE_ChatMemberStatusMember: return TdStackStorer ((struct TdChatMemberStatusMember *)var, M);
    case CODE_ChatMemberStatusRestricted: return TdStackStorer ((struct TdChatMemberStatusRestricted *)var, M);
    case CODE_ChatMemberStatusLeft: return TdStackStorer ((struct TdChatMemberStatusLeft *)var, M);
    case CODE_ChatMemberStatusBanned: return TdStackStorer ((struct TdChatMemberStatusBanned *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdChatMemberStatus *TdStackFetcherChatMemberStatus (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ChatMemberStatusCreator") {
    return (struct TdChatMemberStatus *)TdStackFetcherChatMemberStatusCreator (M);
  }
  if (constructor == "ChatMemberStatusAdministrator") {
    return (struct TdChatMemberStatus *)TdStackFetcherChatMemberStatusAdministrator (M);
  }
  if (constructor == "ChatMemberStatusMember") {
    return (struct TdChatMemberStatus *)TdStackFetcherChatMemberStatusMember (M);
  }
  if (constructor == "ChatMemberStatusRestricted") {
    return (struct TdChatMemberStatus *)TdStackFetcherChatMemberStatusRestricted (M);
  }
  if (constructor == "ChatMemberStatusLeft") {
    return (struct TdChatMemberStatus *)TdStackFetcherChatMemberStatusLeft (M);
  }
  if (constructor == "ChatMemberStatusBanned") {
    return (struct TdChatMemberStatus *)TdStackFetcherChatMemberStatusBanned (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdChatMemberStatusCreator *TdCreateObjectChatMemberStatusCreator (int is_member_) {
  auto var = new struct TdChatMemberStatusCreator ();
  var->ID = CODE_ChatMemberStatusCreator;
  var->refcnt = 1;
  var->is_member_ = is_member_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMemberStatusCreator> TdConvertToInternal (struct TdChatMemberStatusCreator *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_member_ != 0;
  return td::td_api::make_object<td::td_api::chatMemberStatusCreator>(std::move (v0));
}
struct TdChatMemberStatusCreator *TdConvertFromInternal (const td::td_api::chatMemberStatusCreator &from) {
  auto res = new TdChatMemberStatusCreator ();
  res->ID = CODE_ChatMemberStatusCreator;
  res->refcnt = 1;
  res->is_member_ = from.is_member_;
  return res;
}
char *TdSerializeChatMemberStatusCreator (struct TdChatMemberStatusCreator *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMemberStatusCreator *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMemberStatusCreator (struct TdChatMemberStatusCreator *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMemberStatusCreator *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMemberStatusCreator (struct TdChatMemberStatusCreator *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMemberStatusCreator *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMemberStatusCreator");
  M->new_field ("ID");
  M->pack_bool (var->is_member_);
  M->new_field ("is_member_");
}
struct TdChatMemberStatusCreator *TdStackFetcherChatMemberStatusCreator (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMemberStatusCreator ();
  res->ID = CODE_ChatMemberStatusCreator;
  res->refcnt = 1;
  M->get_field ("is_member_");
  res->is_member_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatMemberStatusAdministrator *TdCreateObjectChatMemberStatusAdministrator (int can_be_edited_, int can_change_info_, int can_post_messages_, int can_edit_messages_, int can_delete_messages_, int can_invite_users_, int can_restrict_members_, int can_pin_messages_, int can_promote_members_) {
  auto var = new struct TdChatMemberStatusAdministrator ();
  var->ID = CODE_ChatMemberStatusAdministrator;
  var->refcnt = 1;
  var->can_be_edited_ = can_be_edited_;
  var->can_change_info_ = can_change_info_;
  var->can_post_messages_ = can_post_messages_;
  var->can_edit_messages_ = can_edit_messages_;
  var->can_delete_messages_ = can_delete_messages_;
  var->can_invite_users_ = can_invite_users_;
  var->can_restrict_members_ = can_restrict_members_;
  var->can_pin_messages_ = can_pin_messages_;
  var->can_promote_members_ = can_promote_members_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMemberStatusAdministrator> TdConvertToInternal (struct TdChatMemberStatusAdministrator *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->can_be_edited_ != 0;
  bool v100;
  v100 = var->can_change_info_ != 0;
  bool v200;
  v200 = var->can_post_messages_ != 0;
  bool v300;
  v300 = var->can_edit_messages_ != 0;
  bool v400;
  v400 = var->can_delete_messages_ != 0;
  bool v500;
  v500 = var->can_invite_users_ != 0;
  bool v600;
  v600 = var->can_restrict_members_ != 0;
  bool v700;
  v700 = var->can_pin_messages_ != 0;
  bool v800;
  v800 = var->can_promote_members_ != 0;
  return td::td_api::make_object<td::td_api::chatMemberStatusAdministrator>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdChatMemberStatusAdministrator *TdConvertFromInternal (const td::td_api::chatMemberStatusAdministrator &from) {
  auto res = new TdChatMemberStatusAdministrator ();
  res->ID = CODE_ChatMemberStatusAdministrator;
  res->refcnt = 1;
  res->can_be_edited_ = from.can_be_edited_;
  res->can_change_info_ = from.can_change_info_;
  res->can_post_messages_ = from.can_post_messages_;
  res->can_edit_messages_ = from.can_edit_messages_;
  res->can_delete_messages_ = from.can_delete_messages_;
  res->can_invite_users_ = from.can_invite_users_;
  res->can_restrict_members_ = from.can_restrict_members_;
  res->can_pin_messages_ = from.can_pin_messages_;
  res->can_promote_members_ = from.can_promote_members_;
  return res;
}
char *TdSerializeChatMemberStatusAdministrator (struct TdChatMemberStatusAdministrator *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMemberStatusAdministrator *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMemberStatusAdministrator (struct TdChatMemberStatusAdministrator *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMemberStatusAdministrator *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMemberStatusAdministrator (struct TdChatMemberStatusAdministrator *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMemberStatusAdministrator *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMemberStatusAdministrator");
  M->new_field ("ID");
  M->pack_bool (var->can_be_edited_);
  M->new_field ("can_be_edited_");
  M->pack_bool (var->can_change_info_);
  M->new_field ("can_change_info_");
  M->pack_bool (var->can_post_messages_);
  M->new_field ("can_post_messages_");
  M->pack_bool (var->can_edit_messages_);
  M->new_field ("can_edit_messages_");
  M->pack_bool (var->can_delete_messages_);
  M->new_field ("can_delete_messages_");
  M->pack_bool (var->can_invite_users_);
  M->new_field ("can_invite_users_");
  M->pack_bool (var->can_restrict_members_);
  M->new_field ("can_restrict_members_");
  M->pack_bool (var->can_pin_messages_);
  M->new_field ("can_pin_messages_");
  M->pack_bool (var->can_promote_members_);
  M->new_field ("can_promote_members_");
}
struct TdChatMemberStatusAdministrator *TdStackFetcherChatMemberStatusAdministrator (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMemberStatusAdministrator ();
  res->ID = CODE_ChatMemberStatusAdministrator;
  res->refcnt = 1;
  M->get_field ("can_be_edited_");
  res->can_be_edited_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_change_info_");
  res->can_change_info_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_post_messages_");
  res->can_post_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_edit_messages_");
  res->can_edit_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_delete_messages_");
  res->can_delete_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_invite_users_");
  res->can_invite_users_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_restrict_members_");
  res->can_restrict_members_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_pin_messages_");
  res->can_pin_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_promote_members_");
  res->can_promote_members_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatMemberStatusMember *TdCreateObjectChatMemberStatusMember (void) {
  auto var = new struct TdChatMemberStatusMember ();
  var->ID = CODE_ChatMemberStatusMember;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMemberStatusMember> TdConvertToInternal (struct TdChatMemberStatusMember *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatMemberStatusMember>();
}
struct TdChatMemberStatusMember *TdConvertFromInternal (const td::td_api::chatMemberStatusMember &from) {
  auto res = new TdChatMemberStatusMember ();
  res->ID = CODE_ChatMemberStatusMember;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatMemberStatusMember (struct TdChatMemberStatusMember *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMemberStatusMember *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMemberStatusMember (struct TdChatMemberStatusMember *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMemberStatusMember *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMemberStatusMember (struct TdChatMemberStatusMember *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMemberStatusMember *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMemberStatusMember");
  M->new_field ("ID");
}
struct TdChatMemberStatusMember *TdStackFetcherChatMemberStatusMember (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMemberStatusMember ();
  res->ID = CODE_ChatMemberStatusMember;
  res->refcnt = 1;
  return res;
}
struct TdChatMemberStatusRestricted *TdCreateObjectChatMemberStatusRestricted (int is_member_, int restricted_until_date_, int can_send_messages_, int can_send_media_messages_, int can_send_other_messages_, int can_add_web_page_previews_) {
  auto var = new struct TdChatMemberStatusRestricted ();
  var->ID = CODE_ChatMemberStatusRestricted;
  var->refcnt = 1;
  var->is_member_ = is_member_;
  var->restricted_until_date_ = restricted_until_date_;
  var->can_send_messages_ = can_send_messages_;
  var->can_send_media_messages_ = can_send_media_messages_;
  var->can_send_other_messages_ = can_send_other_messages_;
  var->can_add_web_page_previews_ = can_add_web_page_previews_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMemberStatusRestricted> TdConvertToInternal (struct TdChatMemberStatusRestricted *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_member_ != 0;
  std::int32_t v100;
  v100 = var->restricted_until_date_;
  bool v200;
  v200 = var->can_send_messages_ != 0;
  bool v300;
  v300 = var->can_send_media_messages_ != 0;
  bool v400;
  v400 = var->can_send_other_messages_ != 0;
  bool v500;
  v500 = var->can_add_web_page_previews_ != 0;
  return td::td_api::make_object<td::td_api::chatMemberStatusRestricted>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdChatMemberStatusRestricted *TdConvertFromInternal (const td::td_api::chatMemberStatusRestricted &from) {
  auto res = new TdChatMemberStatusRestricted ();
  res->ID = CODE_ChatMemberStatusRestricted;
  res->refcnt = 1;
  res->is_member_ = from.is_member_;
  res->restricted_until_date_ = from.restricted_until_date_;
  res->can_send_messages_ = from.can_send_messages_;
  res->can_send_media_messages_ = from.can_send_media_messages_;
  res->can_send_other_messages_ = from.can_send_other_messages_;
  res->can_add_web_page_previews_ = from.can_add_web_page_previews_;
  return res;
}
char *TdSerializeChatMemberStatusRestricted (struct TdChatMemberStatusRestricted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMemberStatusRestricted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMemberStatusRestricted (struct TdChatMemberStatusRestricted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMemberStatusRestricted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMemberStatusRestricted (struct TdChatMemberStatusRestricted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMemberStatusRestricted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMemberStatusRestricted");
  M->new_field ("ID");
  M->pack_bool (var->is_member_);
  M->new_field ("is_member_");
  M->pack_long (var->restricted_until_date_);
  M->new_field ("restricted_until_date_");
  M->pack_bool (var->can_send_messages_);
  M->new_field ("can_send_messages_");
  M->pack_bool (var->can_send_media_messages_);
  M->new_field ("can_send_media_messages_");
  M->pack_bool (var->can_send_other_messages_);
  M->new_field ("can_send_other_messages_");
  M->pack_bool (var->can_add_web_page_previews_);
  M->new_field ("can_add_web_page_previews_");
}
struct TdChatMemberStatusRestricted *TdStackFetcherChatMemberStatusRestricted (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMemberStatusRestricted ();
  res->ID = CODE_ChatMemberStatusRestricted;
  res->refcnt = 1;
  M->get_field ("is_member_");
  res->is_member_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("restricted_until_date_");
  res->restricted_until_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_send_messages_");
  res->can_send_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_send_media_messages_");
  res->can_send_media_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_send_other_messages_");
  res->can_send_other_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_add_web_page_previews_");
  res->can_add_web_page_previews_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatMemberStatusLeft *TdCreateObjectChatMemberStatusLeft (void) {
  auto var = new struct TdChatMemberStatusLeft ();
  var->ID = CODE_ChatMemberStatusLeft;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMemberStatusLeft> TdConvertToInternal (struct TdChatMemberStatusLeft *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatMemberStatusLeft>();
}
struct TdChatMemberStatusLeft *TdConvertFromInternal (const td::td_api::chatMemberStatusLeft &from) {
  auto res = new TdChatMemberStatusLeft ();
  res->ID = CODE_ChatMemberStatusLeft;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatMemberStatusLeft (struct TdChatMemberStatusLeft *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMemberStatusLeft *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMemberStatusLeft (struct TdChatMemberStatusLeft *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMemberStatusLeft *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMemberStatusLeft (struct TdChatMemberStatusLeft *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMemberStatusLeft *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMemberStatusLeft");
  M->new_field ("ID");
}
struct TdChatMemberStatusLeft *TdStackFetcherChatMemberStatusLeft (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMemberStatusLeft ();
  res->ID = CODE_ChatMemberStatusLeft;
  res->refcnt = 1;
  return res;
}
struct TdChatMemberStatusBanned *TdCreateObjectChatMemberStatusBanned (int banned_until_date_) {
  auto var = new struct TdChatMemberStatusBanned ();
  var->ID = CODE_ChatMemberStatusBanned;
  var->refcnt = 1;
  var->banned_until_date_ = banned_until_date_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMemberStatusBanned> TdConvertToInternal (struct TdChatMemberStatusBanned *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->banned_until_date_;
  return td::td_api::make_object<td::td_api::chatMemberStatusBanned>(std::move (v0));
}
struct TdChatMemberStatusBanned *TdConvertFromInternal (const td::td_api::chatMemberStatusBanned &from) {
  auto res = new TdChatMemberStatusBanned ();
  res->ID = CODE_ChatMemberStatusBanned;
  res->refcnt = 1;
  res->banned_until_date_ = from.banned_until_date_;
  return res;
}
char *TdSerializeChatMemberStatusBanned (struct TdChatMemberStatusBanned *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMemberStatusBanned *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMemberStatusBanned (struct TdChatMemberStatusBanned *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMemberStatusBanned *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMemberStatusBanned (struct TdChatMemberStatusBanned *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMemberStatusBanned *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMemberStatusBanned");
  M->new_field ("ID");
  M->pack_long (var->banned_until_date_);
  M->new_field ("banned_until_date_");
}
struct TdChatMemberStatusBanned *TdStackFetcherChatMemberStatusBanned (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMemberStatusBanned ();
  res->ID = CODE_ChatMemberStatusBanned;
  res->refcnt = 1;
  M->get_field ("banned_until_date_");
  res->banned_until_date_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatMembers *TdCreateObjectChatMembers (int total_count_, struct TdVectorChatMember *members_) {
  auto var = new struct TdChatMembers ();
  var->ID = CODE_ChatMembers;
  var->refcnt = 1;
  var->total_count_ = total_count_;
  var->members_ = members_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMembers> TdConvertToInternal (struct TdChatMembers *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->total_count_;
  std::vector<td::td_api::object_ptr<td::td_api::chatMember>> v100;
  for (int i100 = 0; i100 < var->members_->len; i100++) {
    td::td_api::object_ptr<td::td_api::chatMember> v101;
    v101 = TdConvertToInternal (var->members_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::chatMembers>(std::move (v0), std::move (v100));
}
struct TdChatMembers *TdConvertFromInternal (const td::td_api::chatMembers &from) {
  auto res = new TdChatMembers ();
  res->ID = CODE_ChatMembers;
  res->refcnt = 1;
  res->total_count_ = from.total_count_;
  res->members_ = new TdVectorChatMember ();
  res->members_->len = (int)from.members_.size ();
  res->members_->data = new struct TdChatMember * [res->members_->len];
  for (int i100 = 0; i100 < res->members_->len; i100++) {
    if (!from.members_[i100]) {
      res->members_->data[i100] = nullptr;
    } else {
      res->members_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::chatMember &>(*from.members_[i100]));
    }
  }
  return res;
}
char *TdSerializeChatMembers (struct TdChatMembers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMembers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMembers (struct TdChatMembers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMembers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->members_->len; i100++) {
    TdDestroyObject (var->members_->data[i100]);
  }
  delete[] var->members_->data;
  delete var->members_;
  delete var;
}
void TdStackStorerChatMembers (struct TdChatMembers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMembers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMembers");
  M->new_field ("ID");
  M->pack_long (var->total_count_);
  M->new_field ("total_count_");
  M->new_array ();
  for (int i100 = 0; i100 < var->members_->len; i100++) {
    TdStackStorer (var->members_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("members_");
}
struct TdChatMembers *TdStackFetcherChatMembers (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMembers ();
  res->ID = CODE_ChatMembers;
  res->refcnt = 1;
  M->get_field ("total_count_");
  res->total_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("members_");
  res->members_ = new TdVectorChatMember ();
  res->members_->len = M->get_arr_size ();
  res->members_->data = new struct TdChatMember * [res->members_->len];
  for (int i100 = 0; i100 < res->members_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->members_->data[i100] = nullptr;
    } else {
      res->members_->data[i100] = TdStackFetcherChatMember (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ChatMembersFilter> TdConvertToInternal (struct TdChatMembersFilter *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatMembersFilterAdministrators: return TdConvertToInternal ((struct TdChatMembersFilterAdministrators *)var);
    case CODE_ChatMembersFilterMembers: return TdConvertToInternal ((struct TdChatMembersFilterMembers *)var);
    case CODE_ChatMembersFilterRestricted: return TdConvertToInternal ((struct TdChatMembersFilterRestricted *)var);
    case CODE_ChatMembersFilterBanned: return TdConvertToInternal ((struct TdChatMembersFilterBanned *)var);
    case CODE_ChatMembersFilterBots: return TdConvertToInternal ((struct TdChatMembersFilterBots *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdChatMembersFilter *TdConvertFromInternal (const td::td_api::ChatMembersFilter &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ChatMembersFilterAdministrators: return (struct TdChatMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterAdministrators &>(from));
    case CODE_ChatMembersFilterMembers: return (struct TdChatMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterMembers &>(from));
    case CODE_ChatMembersFilterRestricted: return (struct TdChatMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterRestricted &>(from));
    case CODE_ChatMembersFilterBanned: return (struct TdChatMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterBanned &>(from));
    case CODE_ChatMembersFilterBots: return (struct TdChatMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::chatMembersFilterBots &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeChatMembersFilter (struct TdChatMembersFilter *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMembersFilter *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMembersFilter (struct TdChatMembersFilter *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMembersFilter *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatMembersFilterAdministrators: return TdDestroyObject ((struct TdChatMembersFilterAdministrators *)var);
    case CODE_ChatMembersFilterMembers: return TdDestroyObject ((struct TdChatMembersFilterMembers *)var);
    case CODE_ChatMembersFilterRestricted: return TdDestroyObject ((struct TdChatMembersFilterRestricted *)var);
    case CODE_ChatMembersFilterBanned: return TdDestroyObject ((struct TdChatMembersFilterBanned *)var);
    case CODE_ChatMembersFilterBots: return TdDestroyObject ((struct TdChatMembersFilterBots *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerChatMembersFilter (struct TdChatMembersFilter *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMembersFilter *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatMembersFilterAdministrators: return TdStackStorer ((struct TdChatMembersFilterAdministrators *)var, M);
    case CODE_ChatMembersFilterMembers: return TdStackStorer ((struct TdChatMembersFilterMembers *)var, M);
    case CODE_ChatMembersFilterRestricted: return TdStackStorer ((struct TdChatMembersFilterRestricted *)var, M);
    case CODE_ChatMembersFilterBanned: return TdStackStorer ((struct TdChatMembersFilterBanned *)var, M);
    case CODE_ChatMembersFilterBots: return TdStackStorer ((struct TdChatMembersFilterBots *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdChatMembersFilter *TdStackFetcherChatMembersFilter (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ChatMembersFilterAdministrators") {
    return (struct TdChatMembersFilter *)TdStackFetcherChatMembersFilterAdministrators (M);
  }
  if (constructor == "ChatMembersFilterMembers") {
    return (struct TdChatMembersFilter *)TdStackFetcherChatMembersFilterMembers (M);
  }
  if (constructor == "ChatMembersFilterRestricted") {
    return (struct TdChatMembersFilter *)TdStackFetcherChatMembersFilterRestricted (M);
  }
  if (constructor == "ChatMembersFilterBanned") {
    return (struct TdChatMembersFilter *)TdStackFetcherChatMembersFilterBanned (M);
  }
  if (constructor == "ChatMembersFilterBots") {
    return (struct TdChatMembersFilter *)TdStackFetcherChatMembersFilterBots (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdChatMembersFilterAdministrators *TdCreateObjectChatMembersFilterAdministrators (void) {
  auto var = new struct TdChatMembersFilterAdministrators ();
  var->ID = CODE_ChatMembersFilterAdministrators;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMembersFilterAdministrators> TdConvertToInternal (struct TdChatMembersFilterAdministrators *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatMembersFilterAdministrators>();
}
struct TdChatMembersFilterAdministrators *TdConvertFromInternal (const td::td_api::chatMembersFilterAdministrators &from) {
  auto res = new TdChatMembersFilterAdministrators ();
  res->ID = CODE_ChatMembersFilterAdministrators;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatMembersFilterAdministrators (struct TdChatMembersFilterAdministrators *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMembersFilterAdministrators *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMembersFilterAdministrators (struct TdChatMembersFilterAdministrators *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMembersFilterAdministrators *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMembersFilterAdministrators (struct TdChatMembersFilterAdministrators *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMembersFilterAdministrators *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMembersFilterAdministrators");
  M->new_field ("ID");
}
struct TdChatMembersFilterAdministrators *TdStackFetcherChatMembersFilterAdministrators (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMembersFilterAdministrators ();
  res->ID = CODE_ChatMembersFilterAdministrators;
  res->refcnt = 1;
  return res;
}
struct TdChatMembersFilterMembers *TdCreateObjectChatMembersFilterMembers (void) {
  auto var = new struct TdChatMembersFilterMembers ();
  var->ID = CODE_ChatMembersFilterMembers;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMembersFilterMembers> TdConvertToInternal (struct TdChatMembersFilterMembers *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatMembersFilterMembers>();
}
struct TdChatMembersFilterMembers *TdConvertFromInternal (const td::td_api::chatMembersFilterMembers &from) {
  auto res = new TdChatMembersFilterMembers ();
  res->ID = CODE_ChatMembersFilterMembers;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatMembersFilterMembers (struct TdChatMembersFilterMembers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMembersFilterMembers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMembersFilterMembers (struct TdChatMembersFilterMembers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMembersFilterMembers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMembersFilterMembers (struct TdChatMembersFilterMembers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMembersFilterMembers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMembersFilterMembers");
  M->new_field ("ID");
}
struct TdChatMembersFilterMembers *TdStackFetcherChatMembersFilterMembers (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMembersFilterMembers ();
  res->ID = CODE_ChatMembersFilterMembers;
  res->refcnt = 1;
  return res;
}
struct TdChatMembersFilterRestricted *TdCreateObjectChatMembersFilterRestricted (void) {
  auto var = new struct TdChatMembersFilterRestricted ();
  var->ID = CODE_ChatMembersFilterRestricted;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMembersFilterRestricted> TdConvertToInternal (struct TdChatMembersFilterRestricted *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatMembersFilterRestricted>();
}
struct TdChatMembersFilterRestricted *TdConvertFromInternal (const td::td_api::chatMembersFilterRestricted &from) {
  auto res = new TdChatMembersFilterRestricted ();
  res->ID = CODE_ChatMembersFilterRestricted;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatMembersFilterRestricted (struct TdChatMembersFilterRestricted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMembersFilterRestricted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMembersFilterRestricted (struct TdChatMembersFilterRestricted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMembersFilterRestricted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMembersFilterRestricted (struct TdChatMembersFilterRestricted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMembersFilterRestricted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMembersFilterRestricted");
  M->new_field ("ID");
}
struct TdChatMembersFilterRestricted *TdStackFetcherChatMembersFilterRestricted (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMembersFilterRestricted ();
  res->ID = CODE_ChatMembersFilterRestricted;
  res->refcnt = 1;
  return res;
}
struct TdChatMembersFilterBanned *TdCreateObjectChatMembersFilterBanned (void) {
  auto var = new struct TdChatMembersFilterBanned ();
  var->ID = CODE_ChatMembersFilterBanned;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMembersFilterBanned> TdConvertToInternal (struct TdChatMembersFilterBanned *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatMembersFilterBanned>();
}
struct TdChatMembersFilterBanned *TdConvertFromInternal (const td::td_api::chatMembersFilterBanned &from) {
  auto res = new TdChatMembersFilterBanned ();
  res->ID = CODE_ChatMembersFilterBanned;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatMembersFilterBanned (struct TdChatMembersFilterBanned *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMembersFilterBanned *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMembersFilterBanned (struct TdChatMembersFilterBanned *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMembersFilterBanned *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMembersFilterBanned (struct TdChatMembersFilterBanned *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMembersFilterBanned *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMembersFilterBanned");
  M->new_field ("ID");
}
struct TdChatMembersFilterBanned *TdStackFetcherChatMembersFilterBanned (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMembersFilterBanned ();
  res->ID = CODE_ChatMembersFilterBanned;
  res->refcnt = 1;
  return res;
}
struct TdChatMembersFilterBots *TdCreateObjectChatMembersFilterBots (void) {
  auto var = new struct TdChatMembersFilterBots ();
  var->ID = CODE_ChatMembersFilterBots;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatMembersFilterBots> TdConvertToInternal (struct TdChatMembersFilterBots *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatMembersFilterBots>();
}
struct TdChatMembersFilterBots *TdConvertFromInternal (const td::td_api::chatMembersFilterBots &from) {
  auto res = new TdChatMembersFilterBots ();
  res->ID = CODE_ChatMembersFilterBots;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatMembersFilterBots (struct TdChatMembersFilterBots *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatMembersFilterBots *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatMembersFilterBots (struct TdChatMembersFilterBots *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatMembersFilterBots *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatMembersFilterBots (struct TdChatMembersFilterBots *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatMembersFilterBots *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatMembersFilterBots");
  M->new_field ("ID");
}
struct TdChatMembersFilterBots *TdStackFetcherChatMembersFilterBots (struct TdStackFetcherMethods *M) {
  auto res = new TdChatMembersFilterBots ();
  res->ID = CODE_ChatMembersFilterBots;
  res->refcnt = 1;
  return res;
}
struct TdChatNotificationSettings *TdCreateObjectChatNotificationSettings (int use_default_mute_for_, int mute_for_, int use_default_sound_, char *sound_, int use_default_show_preview_, int show_preview_) {
  auto var = new struct TdChatNotificationSettings ();
  var->ID = CODE_ChatNotificationSettings;
  var->refcnt = 1;
  var->use_default_mute_for_ = use_default_mute_for_;
  var->mute_for_ = mute_for_;
  var->use_default_sound_ = use_default_sound_;
  var->sound_ = (sound_) ? td::str_dup (td::Slice (sound_)) : nullptr;
  var->use_default_show_preview_ = use_default_show_preview_;
  var->show_preview_ = show_preview_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatNotificationSettings> TdConvertToInternal (struct TdChatNotificationSettings *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->use_default_mute_for_ != 0;
  std::int32_t v100;
  v100 = var->mute_for_;
  bool v200;
  v200 = var->use_default_sound_ != 0;
  std::string v300;
  v300 = (var->sound_) ? var->sound_: "";
  bool v400;
  v400 = var->use_default_show_preview_ != 0;
  bool v500;
  v500 = var->show_preview_ != 0;
  return td::td_api::make_object<td::td_api::chatNotificationSettings>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdChatNotificationSettings *TdConvertFromInternal (const td::td_api::chatNotificationSettings &from) {
  auto res = new TdChatNotificationSettings ();
  res->ID = CODE_ChatNotificationSettings;
  res->refcnt = 1;
  res->use_default_mute_for_ = from.use_default_mute_for_;
  res->mute_for_ = from.mute_for_;
  res->use_default_sound_ = from.use_default_sound_;
  res->sound_ = (from.sound_.length ()) ? td::str_dup (from.sound_) : nullptr;
  res->use_default_show_preview_ = from.use_default_show_preview_;
  res->show_preview_ = from.show_preview_;
  return res;
}
char *TdSerializeChatNotificationSettings (struct TdChatNotificationSettings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatNotificationSettings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatNotificationSettings (struct TdChatNotificationSettings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatNotificationSettings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->sound_);
  delete var;
}
void TdStackStorerChatNotificationSettings (struct TdChatNotificationSettings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatNotificationSettings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatNotificationSettings");
  M->new_field ("ID");
  M->pack_bool (var->use_default_mute_for_);
  M->new_field ("use_default_mute_for_");
  M->pack_long (var->mute_for_);
  M->new_field ("mute_for_");
  M->pack_bool (var->use_default_sound_);
  M->new_field ("use_default_sound_");
  M->pack_string (var->sound_);
  M->new_field ("sound_");
  M->pack_bool (var->use_default_show_preview_);
  M->new_field ("use_default_show_preview_");
  M->pack_bool (var->show_preview_);
  M->new_field ("show_preview_");
}
struct TdChatNotificationSettings *TdStackFetcherChatNotificationSettings (struct TdStackFetcherMethods *M) {
  auto res = new TdChatNotificationSettings ();
  res->ID = CODE_ChatNotificationSettings;
  res->refcnt = 1;
  M->get_field ("use_default_mute_for_");
  res->use_default_mute_for_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("mute_for_");
  res->mute_for_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("use_default_sound_");
  res->use_default_sound_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sound_");
  res->sound_ = M->get_string ();
  M->pop ();
  M->get_field ("use_default_show_preview_");
  res->use_default_show_preview_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("show_preview_");
  res->show_preview_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatPhoto *TdCreateObjectChatPhoto (struct TdFile *small_, struct TdFile *big_) {
  auto var = new struct TdChatPhoto ();
  var->ID = CODE_ChatPhoto;
  var->refcnt = 1;
  var->small_ = small_;
  var->big_ = big_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatPhoto> TdConvertToInternal (struct TdChatPhoto *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::file> v0;
  v0 = TdConvertToInternal (var->small_);
  td::td_api::object_ptr<td::td_api::file> v100;
  v100 = TdConvertToInternal (var->big_);
  return td::td_api::make_object<td::td_api::chatPhoto>(std::move (v0), std::move (v100));
}
struct TdChatPhoto *TdConvertFromInternal (const td::td_api::chatPhoto &from) {
  auto res = new TdChatPhoto ();
  res->ID = CODE_ChatPhoto;
  res->refcnt = 1;
  if (!from.small_) {
    res->small_ = nullptr;
  } else {
    res->small_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.small_));
  }
  if (!from.big_) {
    res->big_ = nullptr;
  } else {
    res->big_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.big_));
  }
  return res;
}
char *TdSerializeChatPhoto (struct TdChatPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatPhoto (struct TdChatPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->small_);
  TdDestroyObject (var->big_);
  delete var;
}
void TdStackStorerChatPhoto (struct TdChatPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatPhoto");
  M->new_field ("ID");
  TdStackStorer (var->small_, M);
  M->new_field ("small_");
  TdStackStorer (var->big_, M);
  M->new_field ("big_");
}
struct TdChatPhoto *TdStackFetcherChatPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdChatPhoto ();
  res->ID = CODE_ChatPhoto;
  res->refcnt = 1;
  M->get_field ("small_");
  if (M->is_nil ()) {
    res->small_ = nullptr;
  } else {
    res->small_ = TdStackFetcherFile (M);
  }
  M->pop ();
  M->get_field ("big_");
  if (M->is_nil ()) {
    res->big_ = nullptr;
  } else {
    res->big_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ChatReportReason> TdConvertToInternal (struct TdChatReportReason *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatReportReasonSpam: return TdConvertToInternal ((struct TdChatReportReasonSpam *)var);
    case CODE_ChatReportReasonViolence: return TdConvertToInternal ((struct TdChatReportReasonViolence *)var);
    case CODE_ChatReportReasonPornography: return TdConvertToInternal ((struct TdChatReportReasonPornography *)var);
    case CODE_ChatReportReasonCopyright: return TdConvertToInternal ((struct TdChatReportReasonCopyright *)var);
    case CODE_ChatReportReasonCustom: return TdConvertToInternal ((struct TdChatReportReasonCustom *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdChatReportReason *TdConvertFromInternal (const td::td_api::ChatReportReason &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ChatReportReasonSpam: return (struct TdChatReportReason *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonSpam &>(from));
    case CODE_ChatReportReasonViolence: return (struct TdChatReportReason *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonViolence &>(from));
    case CODE_ChatReportReasonPornography: return (struct TdChatReportReason *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonPornography &>(from));
    case CODE_ChatReportReasonCopyright: return (struct TdChatReportReason *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonCopyright &>(from));
    case CODE_ChatReportReasonCustom: return (struct TdChatReportReason *)TdConvertFromInternal(static_cast<const td::td_api::chatReportReasonCustom &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeChatReportReason (struct TdChatReportReason *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatReportReason *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatReportReason (struct TdChatReportReason *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatReportReason *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatReportReasonSpam: return TdDestroyObject ((struct TdChatReportReasonSpam *)var);
    case CODE_ChatReportReasonViolence: return TdDestroyObject ((struct TdChatReportReasonViolence *)var);
    case CODE_ChatReportReasonPornography: return TdDestroyObject ((struct TdChatReportReasonPornography *)var);
    case CODE_ChatReportReasonCopyright: return TdDestroyObject ((struct TdChatReportReasonCopyright *)var);
    case CODE_ChatReportReasonCustom: return TdDestroyObject ((struct TdChatReportReasonCustom *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerChatReportReason (struct TdChatReportReason *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatReportReason *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatReportReasonSpam: return TdStackStorer ((struct TdChatReportReasonSpam *)var, M);
    case CODE_ChatReportReasonViolence: return TdStackStorer ((struct TdChatReportReasonViolence *)var, M);
    case CODE_ChatReportReasonPornography: return TdStackStorer ((struct TdChatReportReasonPornography *)var, M);
    case CODE_ChatReportReasonCopyright: return TdStackStorer ((struct TdChatReportReasonCopyright *)var, M);
    case CODE_ChatReportReasonCustom: return TdStackStorer ((struct TdChatReportReasonCustom *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdChatReportReason *TdStackFetcherChatReportReason (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ChatReportReasonSpam") {
    return (struct TdChatReportReason *)TdStackFetcherChatReportReasonSpam (M);
  }
  if (constructor == "ChatReportReasonViolence") {
    return (struct TdChatReportReason *)TdStackFetcherChatReportReasonViolence (M);
  }
  if (constructor == "ChatReportReasonPornography") {
    return (struct TdChatReportReason *)TdStackFetcherChatReportReasonPornography (M);
  }
  if (constructor == "ChatReportReasonCopyright") {
    return (struct TdChatReportReason *)TdStackFetcherChatReportReasonCopyright (M);
  }
  if (constructor == "ChatReportReasonCustom") {
    return (struct TdChatReportReason *)TdStackFetcherChatReportReasonCustom (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdChatReportReasonSpam *TdCreateObjectChatReportReasonSpam (void) {
  auto var = new struct TdChatReportReasonSpam ();
  var->ID = CODE_ChatReportReasonSpam;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatReportReasonSpam> TdConvertToInternal (struct TdChatReportReasonSpam *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatReportReasonSpam>();
}
struct TdChatReportReasonSpam *TdConvertFromInternal (const td::td_api::chatReportReasonSpam &from) {
  auto res = new TdChatReportReasonSpam ();
  res->ID = CODE_ChatReportReasonSpam;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatReportReasonSpam (struct TdChatReportReasonSpam *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatReportReasonSpam *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatReportReasonSpam (struct TdChatReportReasonSpam *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatReportReasonSpam *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatReportReasonSpam (struct TdChatReportReasonSpam *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatReportReasonSpam *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatReportReasonSpam");
  M->new_field ("ID");
}
struct TdChatReportReasonSpam *TdStackFetcherChatReportReasonSpam (struct TdStackFetcherMethods *M) {
  auto res = new TdChatReportReasonSpam ();
  res->ID = CODE_ChatReportReasonSpam;
  res->refcnt = 1;
  return res;
}
struct TdChatReportReasonViolence *TdCreateObjectChatReportReasonViolence (void) {
  auto var = new struct TdChatReportReasonViolence ();
  var->ID = CODE_ChatReportReasonViolence;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatReportReasonViolence> TdConvertToInternal (struct TdChatReportReasonViolence *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatReportReasonViolence>();
}
struct TdChatReportReasonViolence *TdConvertFromInternal (const td::td_api::chatReportReasonViolence &from) {
  auto res = new TdChatReportReasonViolence ();
  res->ID = CODE_ChatReportReasonViolence;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatReportReasonViolence (struct TdChatReportReasonViolence *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatReportReasonViolence *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatReportReasonViolence (struct TdChatReportReasonViolence *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatReportReasonViolence *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatReportReasonViolence (struct TdChatReportReasonViolence *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatReportReasonViolence *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatReportReasonViolence");
  M->new_field ("ID");
}
struct TdChatReportReasonViolence *TdStackFetcherChatReportReasonViolence (struct TdStackFetcherMethods *M) {
  auto res = new TdChatReportReasonViolence ();
  res->ID = CODE_ChatReportReasonViolence;
  res->refcnt = 1;
  return res;
}
struct TdChatReportReasonPornography *TdCreateObjectChatReportReasonPornography (void) {
  auto var = new struct TdChatReportReasonPornography ();
  var->ID = CODE_ChatReportReasonPornography;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatReportReasonPornography> TdConvertToInternal (struct TdChatReportReasonPornography *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatReportReasonPornography>();
}
struct TdChatReportReasonPornography *TdConvertFromInternal (const td::td_api::chatReportReasonPornography &from) {
  auto res = new TdChatReportReasonPornography ();
  res->ID = CODE_ChatReportReasonPornography;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatReportReasonPornography (struct TdChatReportReasonPornography *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatReportReasonPornography *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatReportReasonPornography (struct TdChatReportReasonPornography *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatReportReasonPornography *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatReportReasonPornography (struct TdChatReportReasonPornography *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatReportReasonPornography *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatReportReasonPornography");
  M->new_field ("ID");
}
struct TdChatReportReasonPornography *TdStackFetcherChatReportReasonPornography (struct TdStackFetcherMethods *M) {
  auto res = new TdChatReportReasonPornography ();
  res->ID = CODE_ChatReportReasonPornography;
  res->refcnt = 1;
  return res;
}
struct TdChatReportReasonCopyright *TdCreateObjectChatReportReasonCopyright (void) {
  auto var = new struct TdChatReportReasonCopyright ();
  var->ID = CODE_ChatReportReasonCopyright;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::chatReportReasonCopyright> TdConvertToInternal (struct TdChatReportReasonCopyright *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::chatReportReasonCopyright>();
}
struct TdChatReportReasonCopyright *TdConvertFromInternal (const td::td_api::chatReportReasonCopyright &from) {
  auto res = new TdChatReportReasonCopyright ();
  res->ID = CODE_ChatReportReasonCopyright;
  res->refcnt = 1;
  return res;
}
char *TdSerializeChatReportReasonCopyright (struct TdChatReportReasonCopyright *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatReportReasonCopyright *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatReportReasonCopyright (struct TdChatReportReasonCopyright *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatReportReasonCopyright *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatReportReasonCopyright (struct TdChatReportReasonCopyright *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatReportReasonCopyright *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatReportReasonCopyright");
  M->new_field ("ID");
}
struct TdChatReportReasonCopyright *TdStackFetcherChatReportReasonCopyright (struct TdStackFetcherMethods *M) {
  auto res = new TdChatReportReasonCopyright ();
  res->ID = CODE_ChatReportReasonCopyright;
  res->refcnt = 1;
  return res;
}
struct TdChatReportReasonCustom *TdCreateObjectChatReportReasonCustom (char *text_) {
  auto var = new struct TdChatReportReasonCustom ();
  var->ID = CODE_ChatReportReasonCustom;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::chatReportReasonCustom> TdConvertToInternal (struct TdChatReportReasonCustom *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  return td::td_api::make_object<td::td_api::chatReportReasonCustom>(std::move (v0));
}
struct TdChatReportReasonCustom *TdConvertFromInternal (const td::td_api::chatReportReasonCustom &from) {
  auto res = new TdChatReportReasonCustom ();
  res->ID = CODE_ChatReportReasonCustom;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  return res;
}
char *TdSerializeChatReportReasonCustom (struct TdChatReportReasonCustom *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatReportReasonCustom *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatReportReasonCustom (struct TdChatReportReasonCustom *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatReportReasonCustom *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  delete var;
}
void TdStackStorerChatReportReasonCustom (struct TdChatReportReasonCustom *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatReportReasonCustom *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatReportReasonCustom");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
}
struct TdChatReportReasonCustom *TdStackFetcherChatReportReasonCustom (struct TdStackFetcherMethods *M) {
  auto res = new TdChatReportReasonCustom ();
  res->ID = CODE_ChatReportReasonCustom;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdChatReportSpamState *TdCreateObjectChatReportSpamState (int can_report_spam_) {
  auto var = new struct TdChatReportSpamState ();
  var->ID = CODE_ChatReportSpamState;
  var->refcnt = 1;
  var->can_report_spam_ = can_report_spam_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatReportSpamState> TdConvertToInternal (struct TdChatReportSpamState *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->can_report_spam_ != 0;
  return td::td_api::make_object<td::td_api::chatReportSpamState>(std::move (v0));
}
struct TdChatReportSpamState *TdConvertFromInternal (const td::td_api::chatReportSpamState &from) {
  auto res = new TdChatReportSpamState ();
  res->ID = CODE_ChatReportSpamState;
  res->refcnt = 1;
  res->can_report_spam_ = from.can_report_spam_;
  return res;
}
char *TdSerializeChatReportSpamState (struct TdChatReportSpamState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatReportSpamState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatReportSpamState (struct TdChatReportSpamState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatReportSpamState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatReportSpamState (struct TdChatReportSpamState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatReportSpamState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatReportSpamState");
  M->new_field ("ID");
  M->pack_bool (var->can_report_spam_);
  M->new_field ("can_report_spam_");
}
struct TdChatReportSpamState *TdStackFetcherChatReportSpamState (struct TdStackFetcherMethods *M) {
  auto res = new TdChatReportSpamState ();
  res->ID = CODE_ChatReportSpamState;
  res->refcnt = 1;
  M->get_field ("can_report_spam_");
  res->can_report_spam_ = (int)M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ChatType> TdConvertToInternal (struct TdChatType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatTypePrivate: return TdConvertToInternal ((struct TdChatTypePrivate *)var);
    case CODE_ChatTypeBasicGroup: return TdConvertToInternal ((struct TdChatTypeBasicGroup *)var);
    case CODE_ChatTypeSupergroup: return TdConvertToInternal ((struct TdChatTypeSupergroup *)var);
    case CODE_ChatTypeSecret: return TdConvertToInternal ((struct TdChatTypeSecret *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdChatType *TdConvertFromInternal (const td::td_api::ChatType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ChatTypePrivate: return (struct TdChatType *)TdConvertFromInternal(static_cast<const td::td_api::chatTypePrivate &>(from));
    case CODE_ChatTypeBasicGroup: return (struct TdChatType *)TdConvertFromInternal(static_cast<const td::td_api::chatTypeBasicGroup &>(from));
    case CODE_ChatTypeSupergroup: return (struct TdChatType *)TdConvertFromInternal(static_cast<const td::td_api::chatTypeSupergroup &>(from));
    case CODE_ChatTypeSecret: return (struct TdChatType *)TdConvertFromInternal(static_cast<const td::td_api::chatTypeSecret &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeChatType (struct TdChatType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatType (struct TdChatType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatTypePrivate: return TdDestroyObject ((struct TdChatTypePrivate *)var);
    case CODE_ChatTypeBasicGroup: return TdDestroyObject ((struct TdChatTypeBasicGroup *)var);
    case CODE_ChatTypeSupergroup: return TdDestroyObject ((struct TdChatTypeSupergroup *)var);
    case CODE_ChatTypeSecret: return TdDestroyObject ((struct TdChatTypeSecret *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerChatType (struct TdChatType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ChatTypePrivate: return TdStackStorer ((struct TdChatTypePrivate *)var, M);
    case CODE_ChatTypeBasicGroup: return TdStackStorer ((struct TdChatTypeBasicGroup *)var, M);
    case CODE_ChatTypeSupergroup: return TdStackStorer ((struct TdChatTypeSupergroup *)var, M);
    case CODE_ChatTypeSecret: return TdStackStorer ((struct TdChatTypeSecret *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdChatType *TdStackFetcherChatType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ChatTypePrivate") {
    return (struct TdChatType *)TdStackFetcherChatTypePrivate (M);
  }
  if (constructor == "ChatTypeBasicGroup") {
    return (struct TdChatType *)TdStackFetcherChatTypeBasicGroup (M);
  }
  if (constructor == "ChatTypeSupergroup") {
    return (struct TdChatType *)TdStackFetcherChatTypeSupergroup (M);
  }
  if (constructor == "ChatTypeSecret") {
    return (struct TdChatType *)TdStackFetcherChatTypeSecret (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdChatTypePrivate *TdCreateObjectChatTypePrivate (int user_id_) {
  auto var = new struct TdChatTypePrivate ();
  var->ID = CODE_ChatTypePrivate;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatTypePrivate> TdConvertToInternal (struct TdChatTypePrivate *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::chatTypePrivate>(std::move (v0));
}
struct TdChatTypePrivate *TdConvertFromInternal (const td::td_api::chatTypePrivate &from) {
  auto res = new TdChatTypePrivate ();
  res->ID = CODE_ChatTypePrivate;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeChatTypePrivate (struct TdChatTypePrivate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatTypePrivate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatTypePrivate (struct TdChatTypePrivate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatTypePrivate *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatTypePrivate (struct TdChatTypePrivate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatTypePrivate *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatTypePrivate");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdChatTypePrivate *TdStackFetcherChatTypePrivate (struct TdStackFetcherMethods *M) {
  auto res = new TdChatTypePrivate ();
  res->ID = CODE_ChatTypePrivate;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatTypeBasicGroup *TdCreateObjectChatTypeBasicGroup (int basic_group_id_) {
  auto var = new struct TdChatTypeBasicGroup ();
  var->ID = CODE_ChatTypeBasicGroup;
  var->refcnt = 1;
  var->basic_group_id_ = basic_group_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatTypeBasicGroup> TdConvertToInternal (struct TdChatTypeBasicGroup *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->basic_group_id_;
  return td::td_api::make_object<td::td_api::chatTypeBasicGroup>(std::move (v0));
}
struct TdChatTypeBasicGroup *TdConvertFromInternal (const td::td_api::chatTypeBasicGroup &from) {
  auto res = new TdChatTypeBasicGroup ();
  res->ID = CODE_ChatTypeBasicGroup;
  res->refcnt = 1;
  res->basic_group_id_ = from.basic_group_id_;
  return res;
}
char *TdSerializeChatTypeBasicGroup (struct TdChatTypeBasicGroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatTypeBasicGroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatTypeBasicGroup (struct TdChatTypeBasicGroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatTypeBasicGroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatTypeBasicGroup (struct TdChatTypeBasicGroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatTypeBasicGroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatTypeBasicGroup");
  M->new_field ("ID");
  M->pack_long (var->basic_group_id_);
  M->new_field ("basic_group_id_");
}
struct TdChatTypeBasicGroup *TdStackFetcherChatTypeBasicGroup (struct TdStackFetcherMethods *M) {
  auto res = new TdChatTypeBasicGroup ();
  res->ID = CODE_ChatTypeBasicGroup;
  res->refcnt = 1;
  M->get_field ("basic_group_id_");
  res->basic_group_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatTypeSupergroup *TdCreateObjectChatTypeSupergroup (int supergroup_id_, int is_channel_) {
  auto var = new struct TdChatTypeSupergroup ();
  var->ID = CODE_ChatTypeSupergroup;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->is_channel_ = is_channel_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatTypeSupergroup> TdConvertToInternal (struct TdChatTypeSupergroup *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  bool v100;
  v100 = var->is_channel_ != 0;
  return td::td_api::make_object<td::td_api::chatTypeSupergroup>(std::move (v0), std::move (v100));
}
struct TdChatTypeSupergroup *TdConvertFromInternal (const td::td_api::chatTypeSupergroup &from) {
  auto res = new TdChatTypeSupergroup ();
  res->ID = CODE_ChatTypeSupergroup;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->is_channel_ = from.is_channel_;
  return res;
}
char *TdSerializeChatTypeSupergroup (struct TdChatTypeSupergroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatTypeSupergroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatTypeSupergroup (struct TdChatTypeSupergroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatTypeSupergroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatTypeSupergroup (struct TdChatTypeSupergroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatTypeSupergroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatTypeSupergroup");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_bool (var->is_channel_);
  M->new_field ("is_channel_");
}
struct TdChatTypeSupergroup *TdStackFetcherChatTypeSupergroup (struct TdStackFetcherMethods *M) {
  auto res = new TdChatTypeSupergroup ();
  res->ID = CODE_ChatTypeSupergroup;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_channel_");
  res->is_channel_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChatTypeSecret *TdCreateObjectChatTypeSecret (int secret_chat_id_, int user_id_) {
  auto var = new struct TdChatTypeSecret ();
  var->ID = CODE_ChatTypeSecret;
  var->refcnt = 1;
  var->secret_chat_id_ = secret_chat_id_;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::chatTypeSecret> TdConvertToInternal (struct TdChatTypeSecret *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->secret_chat_id_;
  std::int32_t v100;
  v100 = var->user_id_;
  return td::td_api::make_object<td::td_api::chatTypeSecret>(std::move (v0), std::move (v100));
}
struct TdChatTypeSecret *TdConvertFromInternal (const td::td_api::chatTypeSecret &from) {
  auto res = new TdChatTypeSecret ();
  res->ID = CODE_ChatTypeSecret;
  res->refcnt = 1;
  res->secret_chat_id_ = from.secret_chat_id_;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeChatTypeSecret (struct TdChatTypeSecret *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChatTypeSecret *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChatTypeSecret (struct TdChatTypeSecret *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChatTypeSecret *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChatTypeSecret (struct TdChatTypeSecret *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChatTypeSecret *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChatTypeSecret");
  M->new_field ("ID");
  M->pack_long (var->secret_chat_id_);
  M->new_field ("secret_chat_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdChatTypeSecret *TdStackFetcherChatTypeSecret (struct TdStackFetcherMethods *M) {
  auto res = new TdChatTypeSecret ();
  res->ID = CODE_ChatTypeSecret;
  res->refcnt = 1;
  M->get_field ("secret_chat_id_");
  res->secret_chat_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChats *TdCreateObjectChats (struct TdVectorLong *chat_ids_) {
  auto var = new struct TdChats ();
  var->ID = CODE_Chats;
  var->refcnt = 1;
  var->chat_ids_ = chat_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::chats> TdConvertToInternal (struct TdChats *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int64_t> v0;
  for (int i0 = 0; i0 < var->chat_ids_->len; i0++) {
    std::int64_t v1;
    v1 = var->chat_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::chats>(std::move (v0));
}
struct TdChats *TdConvertFromInternal (const td::td_api::chats &from) {
  auto res = new TdChats ();
  res->ID = CODE_Chats;
  res->refcnt = 1;
  res->chat_ids_ = new TdVectorLong ();
  res->chat_ids_->len = (int)from.chat_ids_.size ();
  res->chat_ids_->data = new long long  [res->chat_ids_->len];
  for (int i0 = 0; i0 < res->chat_ids_->len; i0++) {
    res->chat_ids_->data[i0] = from.chat_ids_[i0];
  }
  return res;
}
char *TdSerializeChats (struct TdChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChats (struct TdChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->chat_ids_->len; i0++) {
  }
  delete[] var->chat_ids_->data;
  delete var->chat_ids_;
  delete var;
}
void TdStackStorerChats (struct TdChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Chats");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->chat_ids_->len; i0++) {
    M->pack_long (var->chat_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("chat_ids_");
}
struct TdChats *TdStackFetcherChats (struct TdStackFetcherMethods *M) {
  auto res = new TdChats ();
  res->ID = CODE_Chats;
  res->refcnt = 1;
  M->get_field ("chat_ids_");
  res->chat_ids_ = new TdVectorLong ();
  res->chat_ids_->len = M->get_arr_size ();
  res->chat_ids_->data = new long long  [res->chat_ids_->len];
  for (int i0 = 0; i0 < res->chat_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->chat_ids_->data[i0] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::CheckChatUsernameResult> TdConvertToInternal (struct TdCheckChatUsernameResult *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CheckChatUsernameResultOk: return TdConvertToInternal ((struct TdCheckChatUsernameResultOk *)var);
    case CODE_CheckChatUsernameResultUsernameInvalid: return TdConvertToInternal ((struct TdCheckChatUsernameResultUsernameInvalid *)var);
    case CODE_CheckChatUsernameResultUsernameOccupied: return TdConvertToInternal ((struct TdCheckChatUsernameResultUsernameOccupied *)var);
    case CODE_CheckChatUsernameResultPublicChatsTooMuch: return TdConvertToInternal ((struct TdCheckChatUsernameResultPublicChatsTooMuch *)var);
    case CODE_CheckChatUsernameResultPublicGroupsUnavailable: return TdConvertToInternal ((struct TdCheckChatUsernameResultPublicGroupsUnavailable *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdCheckChatUsernameResult *TdConvertFromInternal (const td::td_api::CheckChatUsernameResult &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_CheckChatUsernameResultOk: return (struct TdCheckChatUsernameResult *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultOk &>(from));
    case CODE_CheckChatUsernameResultUsernameInvalid: return (struct TdCheckChatUsernameResult *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultUsernameInvalid &>(from));
    case CODE_CheckChatUsernameResultUsernameOccupied: return (struct TdCheckChatUsernameResult *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultUsernameOccupied &>(from));
    case CODE_CheckChatUsernameResultPublicChatsTooMuch: return (struct TdCheckChatUsernameResult *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultPublicChatsTooMuch &>(from));
    case CODE_CheckChatUsernameResultPublicGroupsUnavailable: return (struct TdCheckChatUsernameResult *)TdConvertFromInternal(static_cast<const td::td_api::checkChatUsernameResultPublicGroupsUnavailable &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeCheckChatUsernameResult (struct TdCheckChatUsernameResult *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChatUsernameResult *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChatUsernameResult (struct TdCheckChatUsernameResult *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChatUsernameResult *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CheckChatUsernameResultOk: return TdDestroyObject ((struct TdCheckChatUsernameResultOk *)var);
    case CODE_CheckChatUsernameResultUsernameInvalid: return TdDestroyObject ((struct TdCheckChatUsernameResultUsernameInvalid *)var);
    case CODE_CheckChatUsernameResultUsernameOccupied: return TdDestroyObject ((struct TdCheckChatUsernameResultUsernameOccupied *)var);
    case CODE_CheckChatUsernameResultPublicChatsTooMuch: return TdDestroyObject ((struct TdCheckChatUsernameResultPublicChatsTooMuch *)var);
    case CODE_CheckChatUsernameResultPublicGroupsUnavailable: return TdDestroyObject ((struct TdCheckChatUsernameResultPublicGroupsUnavailable *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerCheckChatUsernameResult (struct TdCheckChatUsernameResult *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChatUsernameResult *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_CheckChatUsernameResultOk: return TdStackStorer ((struct TdCheckChatUsernameResultOk *)var, M);
    case CODE_CheckChatUsernameResultUsernameInvalid: return TdStackStorer ((struct TdCheckChatUsernameResultUsernameInvalid *)var, M);
    case CODE_CheckChatUsernameResultUsernameOccupied: return TdStackStorer ((struct TdCheckChatUsernameResultUsernameOccupied *)var, M);
    case CODE_CheckChatUsernameResultPublicChatsTooMuch: return TdStackStorer ((struct TdCheckChatUsernameResultPublicChatsTooMuch *)var, M);
    case CODE_CheckChatUsernameResultPublicGroupsUnavailable: return TdStackStorer ((struct TdCheckChatUsernameResultPublicGroupsUnavailable *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdCheckChatUsernameResult *TdStackFetcherCheckChatUsernameResult (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "CheckChatUsernameResultOk") {
    return (struct TdCheckChatUsernameResult *)TdStackFetcherCheckChatUsernameResultOk (M);
  }
  if (constructor == "CheckChatUsernameResultUsernameInvalid") {
    return (struct TdCheckChatUsernameResult *)TdStackFetcherCheckChatUsernameResultUsernameInvalid (M);
  }
  if (constructor == "CheckChatUsernameResultUsernameOccupied") {
    return (struct TdCheckChatUsernameResult *)TdStackFetcherCheckChatUsernameResultUsernameOccupied (M);
  }
  if (constructor == "CheckChatUsernameResultPublicChatsTooMuch") {
    return (struct TdCheckChatUsernameResult *)TdStackFetcherCheckChatUsernameResultPublicChatsTooMuch (M);
  }
  if (constructor == "CheckChatUsernameResultPublicGroupsUnavailable") {
    return (struct TdCheckChatUsernameResult *)TdStackFetcherCheckChatUsernameResultPublicGroupsUnavailable (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdCheckChatUsernameResultOk *TdCreateObjectCheckChatUsernameResultOk (void) {
  auto var = new struct TdCheckChatUsernameResultOk ();
  var->ID = CODE_CheckChatUsernameResultOk;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::checkChatUsernameResultOk> TdConvertToInternal (struct TdCheckChatUsernameResultOk *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::checkChatUsernameResultOk>();
}
struct TdCheckChatUsernameResultOk *TdConvertFromInternal (const td::td_api::checkChatUsernameResultOk &from) {
  auto res = new TdCheckChatUsernameResultOk ();
  res->ID = CODE_CheckChatUsernameResultOk;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCheckChatUsernameResultOk (struct TdCheckChatUsernameResultOk *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChatUsernameResultOk *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChatUsernameResultOk (struct TdCheckChatUsernameResultOk *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChatUsernameResultOk *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCheckChatUsernameResultOk (struct TdCheckChatUsernameResultOk *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChatUsernameResultOk *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckChatUsernameResultOk");
  M->new_field ("ID");
}
struct TdCheckChatUsernameResultOk *TdStackFetcherCheckChatUsernameResultOk (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckChatUsernameResultOk ();
  res->ID = CODE_CheckChatUsernameResultOk;
  res->refcnt = 1;
  return res;
}
struct TdCheckChatUsernameResultUsernameInvalid *TdCreateObjectCheckChatUsernameResultUsernameInvalid (void) {
  auto var = new struct TdCheckChatUsernameResultUsernameInvalid ();
  var->ID = CODE_CheckChatUsernameResultUsernameInvalid;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::checkChatUsernameResultUsernameInvalid> TdConvertToInternal (struct TdCheckChatUsernameResultUsernameInvalid *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::checkChatUsernameResultUsernameInvalid>();
}
struct TdCheckChatUsernameResultUsernameInvalid *TdConvertFromInternal (const td::td_api::checkChatUsernameResultUsernameInvalid &from) {
  auto res = new TdCheckChatUsernameResultUsernameInvalid ();
  res->ID = CODE_CheckChatUsernameResultUsernameInvalid;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCheckChatUsernameResultUsernameInvalid (struct TdCheckChatUsernameResultUsernameInvalid *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChatUsernameResultUsernameInvalid *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChatUsernameResultUsernameInvalid (struct TdCheckChatUsernameResultUsernameInvalid *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChatUsernameResultUsernameInvalid *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCheckChatUsernameResultUsernameInvalid (struct TdCheckChatUsernameResultUsernameInvalid *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChatUsernameResultUsernameInvalid *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckChatUsernameResultUsernameInvalid");
  M->new_field ("ID");
}
struct TdCheckChatUsernameResultUsernameInvalid *TdStackFetcherCheckChatUsernameResultUsernameInvalid (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckChatUsernameResultUsernameInvalid ();
  res->ID = CODE_CheckChatUsernameResultUsernameInvalid;
  res->refcnt = 1;
  return res;
}
struct TdCheckChatUsernameResultUsernameOccupied *TdCreateObjectCheckChatUsernameResultUsernameOccupied (void) {
  auto var = new struct TdCheckChatUsernameResultUsernameOccupied ();
  var->ID = CODE_CheckChatUsernameResultUsernameOccupied;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::checkChatUsernameResultUsernameOccupied> TdConvertToInternal (struct TdCheckChatUsernameResultUsernameOccupied *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::checkChatUsernameResultUsernameOccupied>();
}
struct TdCheckChatUsernameResultUsernameOccupied *TdConvertFromInternal (const td::td_api::checkChatUsernameResultUsernameOccupied &from) {
  auto res = new TdCheckChatUsernameResultUsernameOccupied ();
  res->ID = CODE_CheckChatUsernameResultUsernameOccupied;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCheckChatUsernameResultUsernameOccupied (struct TdCheckChatUsernameResultUsernameOccupied *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChatUsernameResultUsernameOccupied *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChatUsernameResultUsernameOccupied (struct TdCheckChatUsernameResultUsernameOccupied *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChatUsernameResultUsernameOccupied *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCheckChatUsernameResultUsernameOccupied (struct TdCheckChatUsernameResultUsernameOccupied *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChatUsernameResultUsernameOccupied *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckChatUsernameResultUsernameOccupied");
  M->new_field ("ID");
}
struct TdCheckChatUsernameResultUsernameOccupied *TdStackFetcherCheckChatUsernameResultUsernameOccupied (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckChatUsernameResultUsernameOccupied ();
  res->ID = CODE_CheckChatUsernameResultUsernameOccupied;
  res->refcnt = 1;
  return res;
}
struct TdCheckChatUsernameResultPublicChatsTooMuch *TdCreateObjectCheckChatUsernameResultPublicChatsTooMuch (void) {
  auto var = new struct TdCheckChatUsernameResultPublicChatsTooMuch ();
  var->ID = CODE_CheckChatUsernameResultPublicChatsTooMuch;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::checkChatUsernameResultPublicChatsTooMuch> TdConvertToInternal (struct TdCheckChatUsernameResultPublicChatsTooMuch *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::checkChatUsernameResultPublicChatsTooMuch>();
}
struct TdCheckChatUsernameResultPublicChatsTooMuch *TdConvertFromInternal (const td::td_api::checkChatUsernameResultPublicChatsTooMuch &from) {
  auto res = new TdCheckChatUsernameResultPublicChatsTooMuch ();
  res->ID = CODE_CheckChatUsernameResultPublicChatsTooMuch;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCheckChatUsernameResultPublicChatsTooMuch (struct TdCheckChatUsernameResultPublicChatsTooMuch *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChatUsernameResultPublicChatsTooMuch *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChatUsernameResultPublicChatsTooMuch (struct TdCheckChatUsernameResultPublicChatsTooMuch *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChatUsernameResultPublicChatsTooMuch *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCheckChatUsernameResultPublicChatsTooMuch (struct TdCheckChatUsernameResultPublicChatsTooMuch *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChatUsernameResultPublicChatsTooMuch *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckChatUsernameResultPublicChatsTooMuch");
  M->new_field ("ID");
}
struct TdCheckChatUsernameResultPublicChatsTooMuch *TdStackFetcherCheckChatUsernameResultPublicChatsTooMuch (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckChatUsernameResultPublicChatsTooMuch ();
  res->ID = CODE_CheckChatUsernameResultPublicChatsTooMuch;
  res->refcnt = 1;
  return res;
}
struct TdCheckChatUsernameResultPublicGroupsUnavailable *TdCreateObjectCheckChatUsernameResultPublicGroupsUnavailable (void) {
  auto var = new struct TdCheckChatUsernameResultPublicGroupsUnavailable ();
  var->ID = CODE_CheckChatUsernameResultPublicGroupsUnavailable;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::checkChatUsernameResultPublicGroupsUnavailable> TdConvertToInternal (struct TdCheckChatUsernameResultPublicGroupsUnavailable *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::checkChatUsernameResultPublicGroupsUnavailable>();
}
struct TdCheckChatUsernameResultPublicGroupsUnavailable *TdConvertFromInternal (const td::td_api::checkChatUsernameResultPublicGroupsUnavailable &from) {
  auto res = new TdCheckChatUsernameResultPublicGroupsUnavailable ();
  res->ID = CODE_CheckChatUsernameResultPublicGroupsUnavailable;
  res->refcnt = 1;
  return res;
}
char *TdSerializeCheckChatUsernameResultPublicGroupsUnavailable (struct TdCheckChatUsernameResultPublicGroupsUnavailable *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChatUsernameResultPublicGroupsUnavailable *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChatUsernameResultPublicGroupsUnavailable (struct TdCheckChatUsernameResultPublicGroupsUnavailable *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChatUsernameResultPublicGroupsUnavailable *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCheckChatUsernameResultPublicGroupsUnavailable (struct TdCheckChatUsernameResultPublicGroupsUnavailable *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChatUsernameResultPublicGroupsUnavailable *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckChatUsernameResultPublicGroupsUnavailable");
  M->new_field ("ID");
}
struct TdCheckChatUsernameResultPublicGroupsUnavailable *TdStackFetcherCheckChatUsernameResultPublicGroupsUnavailable (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckChatUsernameResultPublicGroupsUnavailable ();
  res->ID = CODE_CheckChatUsernameResultPublicGroupsUnavailable;
  res->refcnt = 1;
  return res;
}
struct TdConnectedWebsite *TdCreateObjectConnectedWebsite (long long id_, char *domain_name_, int bot_user_id_, char *browser_, char *platform_, int log_in_date_, int last_active_date_, char *ip_, char *location_) {
  auto var = new struct TdConnectedWebsite ();
  var->ID = CODE_ConnectedWebsite;
  var->refcnt = 1;
  var->id_ = id_;
  var->domain_name_ = (domain_name_) ? td::str_dup (td::Slice (domain_name_)) : nullptr;
  var->bot_user_id_ = bot_user_id_;
  var->browser_ = (browser_) ? td::str_dup (td::Slice (browser_)) : nullptr;
  var->platform_ = (platform_) ? td::str_dup (td::Slice (platform_)) : nullptr;
  var->log_in_date_ = log_in_date_;
  var->last_active_date_ = last_active_date_;
  var->ip_ = (ip_) ? td::str_dup (td::Slice (ip_)) : nullptr;
  var->location_ = (location_) ? td::str_dup (td::Slice (location_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::connectedWebsite> TdConvertToInternal (struct TdConnectedWebsite *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->domain_name_) ? var->domain_name_: "";
  std::int32_t v200;
  v200 = var->bot_user_id_;
  std::string v300;
  v300 = (var->browser_) ? var->browser_: "";
  std::string v400;
  v400 = (var->platform_) ? var->platform_: "";
  std::int32_t v500;
  v500 = var->log_in_date_;
  std::int32_t v600;
  v600 = var->last_active_date_;
  std::string v700;
  v700 = (var->ip_) ? var->ip_: "";
  std::string v800;
  v800 = (var->location_) ? var->location_: "";
  return td::td_api::make_object<td::td_api::connectedWebsite>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdConnectedWebsite *TdConvertFromInternal (const td::td_api::connectedWebsite &from) {
  auto res = new TdConnectedWebsite ();
  res->ID = CODE_ConnectedWebsite;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->domain_name_ = (from.domain_name_.length ()) ? td::str_dup (from.domain_name_) : nullptr;
  res->bot_user_id_ = from.bot_user_id_;
  res->browser_ = (from.browser_.length ()) ? td::str_dup (from.browser_) : nullptr;
  res->platform_ = (from.platform_.length ()) ? td::str_dup (from.platform_) : nullptr;
  res->log_in_date_ = from.log_in_date_;
  res->last_active_date_ = from.last_active_date_;
  res->ip_ = (from.ip_.length ()) ? td::str_dup (from.ip_) : nullptr;
  res->location_ = (from.location_.length ()) ? td::str_dup (from.location_) : nullptr;
  return res;
}
char *TdSerializeConnectedWebsite (struct TdConnectedWebsite *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdConnectedWebsite *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectConnectedWebsite (struct TdConnectedWebsite *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdConnectedWebsite *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->domain_name_);
  free (var->browser_);
  free (var->platform_);
  free (var->ip_);
  free (var->location_);
  delete var;
}
void TdStackStorerConnectedWebsite (struct TdConnectedWebsite *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdConnectedWebsite *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ConnectedWebsite");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->domain_name_);
  M->new_field ("domain_name_");
  M->pack_long (var->bot_user_id_);
  M->new_field ("bot_user_id_");
  M->pack_string (var->browser_);
  M->new_field ("browser_");
  M->pack_string (var->platform_);
  M->new_field ("platform_");
  M->pack_long (var->log_in_date_);
  M->new_field ("log_in_date_");
  M->pack_long (var->last_active_date_);
  M->new_field ("last_active_date_");
  M->pack_string (var->ip_);
  M->new_field ("ip_");
  M->pack_string (var->location_);
  M->new_field ("location_");
}
struct TdConnectedWebsite *TdStackFetcherConnectedWebsite (struct TdStackFetcherMethods *M) {
  auto res = new TdConnectedWebsite ();
  res->ID = CODE_ConnectedWebsite;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("domain_name_");
  res->domain_name_ = M->get_string ();
  M->pop ();
  M->get_field ("bot_user_id_");
  res->bot_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("browser_");
  res->browser_ = M->get_string ();
  M->pop ();
  M->get_field ("platform_");
  res->platform_ = M->get_string ();
  M->pop ();
  M->get_field ("log_in_date_");
  res->log_in_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("last_active_date_");
  res->last_active_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("ip_");
  res->ip_ = M->get_string ();
  M->pop ();
  M->get_field ("location_");
  res->location_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdConnectedWebsites *TdCreateObjectConnectedWebsites (struct TdVectorConnectedWebsite *websites_) {
  auto var = new struct TdConnectedWebsites ();
  var->ID = CODE_ConnectedWebsites;
  var->refcnt = 1;
  var->websites_ = websites_;
  return var;
}
td::td_api::object_ptr<td::td_api::connectedWebsites> TdConvertToInternal (struct TdConnectedWebsites *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::connectedWebsite>> v0;
  for (int i0 = 0; i0 < var->websites_->len; i0++) {
    td::td_api::object_ptr<td::td_api::connectedWebsite> v1;
    v1 = TdConvertToInternal (var->websites_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::connectedWebsites>(std::move (v0));
}
struct TdConnectedWebsites *TdConvertFromInternal (const td::td_api::connectedWebsites &from) {
  auto res = new TdConnectedWebsites ();
  res->ID = CODE_ConnectedWebsites;
  res->refcnt = 1;
  res->websites_ = new TdVectorConnectedWebsite ();
  res->websites_->len = (int)from.websites_.size ();
  res->websites_->data = new struct TdConnectedWebsite * [res->websites_->len];
  for (int i0 = 0; i0 < res->websites_->len; i0++) {
    if (!from.websites_[i0]) {
      res->websites_->data[i0] = nullptr;
    } else {
      res->websites_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::connectedWebsite &>(*from.websites_[i0]));
    }
  }
  return res;
}
char *TdSerializeConnectedWebsites (struct TdConnectedWebsites *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdConnectedWebsites *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectConnectedWebsites (struct TdConnectedWebsites *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdConnectedWebsites *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->websites_->len; i0++) {
    TdDestroyObject (var->websites_->data[i0]);
  }
  delete[] var->websites_->data;
  delete var->websites_;
  delete var;
}
void TdStackStorerConnectedWebsites (struct TdConnectedWebsites *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdConnectedWebsites *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ConnectedWebsites");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->websites_->len; i0++) {
    TdStackStorer (var->websites_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("websites_");
}
struct TdConnectedWebsites *TdStackFetcherConnectedWebsites (struct TdStackFetcherMethods *M) {
  auto res = new TdConnectedWebsites ();
  res->ID = CODE_ConnectedWebsites;
  res->refcnt = 1;
  M->get_field ("websites_");
  res->websites_ = new TdVectorConnectedWebsite ();
  res->websites_->len = M->get_arr_size ();
  res->websites_->data = new struct TdConnectedWebsite * [res->websites_->len];
  for (int i0 = 0; i0 < res->websites_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->websites_->data[i0] = nullptr;
    } else {
      res->websites_->data[i0] = TdStackFetcherConnectedWebsite (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ConnectionState> TdConvertToInternal (struct TdConnectionState *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ConnectionStateWaitingForNetwork: return TdConvertToInternal ((struct TdConnectionStateWaitingForNetwork *)var);
    case CODE_ConnectionStateConnectingToProxy: return TdConvertToInternal ((struct TdConnectionStateConnectingToProxy *)var);
    case CODE_ConnectionStateConnecting: return TdConvertToInternal ((struct TdConnectionStateConnecting *)var);
    case CODE_ConnectionStateUpdating: return TdConvertToInternal ((struct TdConnectionStateUpdating *)var);
    case CODE_ConnectionStateReady: return TdConvertToInternal ((struct TdConnectionStateReady *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdConnectionState *TdConvertFromInternal (const td::td_api::ConnectionState &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ConnectionStateWaitingForNetwork: return (struct TdConnectionState *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateWaitingForNetwork &>(from));
    case CODE_ConnectionStateConnectingToProxy: return (struct TdConnectionState *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateConnectingToProxy &>(from));
    case CODE_ConnectionStateConnecting: return (struct TdConnectionState *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateConnecting &>(from));
    case CODE_ConnectionStateUpdating: return (struct TdConnectionState *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateUpdating &>(from));
    case CODE_ConnectionStateReady: return (struct TdConnectionState *)TdConvertFromInternal(static_cast<const td::td_api::connectionStateReady &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeConnectionState (struct TdConnectionState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdConnectionState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectConnectionState (struct TdConnectionState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdConnectionState *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ConnectionStateWaitingForNetwork: return TdDestroyObject ((struct TdConnectionStateWaitingForNetwork *)var);
    case CODE_ConnectionStateConnectingToProxy: return TdDestroyObject ((struct TdConnectionStateConnectingToProxy *)var);
    case CODE_ConnectionStateConnecting: return TdDestroyObject ((struct TdConnectionStateConnecting *)var);
    case CODE_ConnectionStateUpdating: return TdDestroyObject ((struct TdConnectionStateUpdating *)var);
    case CODE_ConnectionStateReady: return TdDestroyObject ((struct TdConnectionStateReady *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerConnectionState (struct TdConnectionState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdConnectionState *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ConnectionStateWaitingForNetwork: return TdStackStorer ((struct TdConnectionStateWaitingForNetwork *)var, M);
    case CODE_ConnectionStateConnectingToProxy: return TdStackStorer ((struct TdConnectionStateConnectingToProxy *)var, M);
    case CODE_ConnectionStateConnecting: return TdStackStorer ((struct TdConnectionStateConnecting *)var, M);
    case CODE_ConnectionStateUpdating: return TdStackStorer ((struct TdConnectionStateUpdating *)var, M);
    case CODE_ConnectionStateReady: return TdStackStorer ((struct TdConnectionStateReady *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdConnectionState *TdStackFetcherConnectionState (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ConnectionStateWaitingForNetwork") {
    return (struct TdConnectionState *)TdStackFetcherConnectionStateWaitingForNetwork (M);
  }
  if (constructor == "ConnectionStateConnectingToProxy") {
    return (struct TdConnectionState *)TdStackFetcherConnectionStateConnectingToProxy (M);
  }
  if (constructor == "ConnectionStateConnecting") {
    return (struct TdConnectionState *)TdStackFetcherConnectionStateConnecting (M);
  }
  if (constructor == "ConnectionStateUpdating") {
    return (struct TdConnectionState *)TdStackFetcherConnectionStateUpdating (M);
  }
  if (constructor == "ConnectionStateReady") {
    return (struct TdConnectionState *)TdStackFetcherConnectionStateReady (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdConnectionStateWaitingForNetwork *TdCreateObjectConnectionStateWaitingForNetwork (void) {
  auto var = new struct TdConnectionStateWaitingForNetwork ();
  var->ID = CODE_ConnectionStateWaitingForNetwork;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::connectionStateWaitingForNetwork> TdConvertToInternal (struct TdConnectionStateWaitingForNetwork *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::connectionStateWaitingForNetwork>();
}
struct TdConnectionStateWaitingForNetwork *TdConvertFromInternal (const td::td_api::connectionStateWaitingForNetwork &from) {
  auto res = new TdConnectionStateWaitingForNetwork ();
  res->ID = CODE_ConnectionStateWaitingForNetwork;
  res->refcnt = 1;
  return res;
}
char *TdSerializeConnectionStateWaitingForNetwork (struct TdConnectionStateWaitingForNetwork *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdConnectionStateWaitingForNetwork *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectConnectionStateWaitingForNetwork (struct TdConnectionStateWaitingForNetwork *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdConnectionStateWaitingForNetwork *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerConnectionStateWaitingForNetwork (struct TdConnectionStateWaitingForNetwork *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdConnectionStateWaitingForNetwork *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ConnectionStateWaitingForNetwork");
  M->new_field ("ID");
}
struct TdConnectionStateWaitingForNetwork *TdStackFetcherConnectionStateWaitingForNetwork (struct TdStackFetcherMethods *M) {
  auto res = new TdConnectionStateWaitingForNetwork ();
  res->ID = CODE_ConnectionStateWaitingForNetwork;
  res->refcnt = 1;
  return res;
}
struct TdConnectionStateConnectingToProxy *TdCreateObjectConnectionStateConnectingToProxy (void) {
  auto var = new struct TdConnectionStateConnectingToProxy ();
  var->ID = CODE_ConnectionStateConnectingToProxy;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::connectionStateConnectingToProxy> TdConvertToInternal (struct TdConnectionStateConnectingToProxy *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::connectionStateConnectingToProxy>();
}
struct TdConnectionStateConnectingToProxy *TdConvertFromInternal (const td::td_api::connectionStateConnectingToProxy &from) {
  auto res = new TdConnectionStateConnectingToProxy ();
  res->ID = CODE_ConnectionStateConnectingToProxy;
  res->refcnt = 1;
  return res;
}
char *TdSerializeConnectionStateConnectingToProxy (struct TdConnectionStateConnectingToProxy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdConnectionStateConnectingToProxy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectConnectionStateConnectingToProxy (struct TdConnectionStateConnectingToProxy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdConnectionStateConnectingToProxy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerConnectionStateConnectingToProxy (struct TdConnectionStateConnectingToProxy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdConnectionStateConnectingToProxy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ConnectionStateConnectingToProxy");
  M->new_field ("ID");
}
struct TdConnectionStateConnectingToProxy *TdStackFetcherConnectionStateConnectingToProxy (struct TdStackFetcherMethods *M) {
  auto res = new TdConnectionStateConnectingToProxy ();
  res->ID = CODE_ConnectionStateConnectingToProxy;
  res->refcnt = 1;
  return res;
}
struct TdConnectionStateConnecting *TdCreateObjectConnectionStateConnecting (void) {
  auto var = new struct TdConnectionStateConnecting ();
  var->ID = CODE_ConnectionStateConnecting;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::connectionStateConnecting> TdConvertToInternal (struct TdConnectionStateConnecting *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::connectionStateConnecting>();
}
struct TdConnectionStateConnecting *TdConvertFromInternal (const td::td_api::connectionStateConnecting &from) {
  auto res = new TdConnectionStateConnecting ();
  res->ID = CODE_ConnectionStateConnecting;
  res->refcnt = 1;
  return res;
}
char *TdSerializeConnectionStateConnecting (struct TdConnectionStateConnecting *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdConnectionStateConnecting *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectConnectionStateConnecting (struct TdConnectionStateConnecting *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdConnectionStateConnecting *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerConnectionStateConnecting (struct TdConnectionStateConnecting *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdConnectionStateConnecting *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ConnectionStateConnecting");
  M->new_field ("ID");
}
struct TdConnectionStateConnecting *TdStackFetcherConnectionStateConnecting (struct TdStackFetcherMethods *M) {
  auto res = new TdConnectionStateConnecting ();
  res->ID = CODE_ConnectionStateConnecting;
  res->refcnt = 1;
  return res;
}
struct TdConnectionStateUpdating *TdCreateObjectConnectionStateUpdating (void) {
  auto var = new struct TdConnectionStateUpdating ();
  var->ID = CODE_ConnectionStateUpdating;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::connectionStateUpdating> TdConvertToInternal (struct TdConnectionStateUpdating *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::connectionStateUpdating>();
}
struct TdConnectionStateUpdating *TdConvertFromInternal (const td::td_api::connectionStateUpdating &from) {
  auto res = new TdConnectionStateUpdating ();
  res->ID = CODE_ConnectionStateUpdating;
  res->refcnt = 1;
  return res;
}
char *TdSerializeConnectionStateUpdating (struct TdConnectionStateUpdating *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdConnectionStateUpdating *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectConnectionStateUpdating (struct TdConnectionStateUpdating *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdConnectionStateUpdating *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerConnectionStateUpdating (struct TdConnectionStateUpdating *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdConnectionStateUpdating *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ConnectionStateUpdating");
  M->new_field ("ID");
}
struct TdConnectionStateUpdating *TdStackFetcherConnectionStateUpdating (struct TdStackFetcherMethods *M) {
  auto res = new TdConnectionStateUpdating ();
  res->ID = CODE_ConnectionStateUpdating;
  res->refcnt = 1;
  return res;
}
struct TdConnectionStateReady *TdCreateObjectConnectionStateReady (void) {
  auto var = new struct TdConnectionStateReady ();
  var->ID = CODE_ConnectionStateReady;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::connectionStateReady> TdConvertToInternal (struct TdConnectionStateReady *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::connectionStateReady>();
}
struct TdConnectionStateReady *TdConvertFromInternal (const td::td_api::connectionStateReady &from) {
  auto res = new TdConnectionStateReady ();
  res->ID = CODE_ConnectionStateReady;
  res->refcnt = 1;
  return res;
}
char *TdSerializeConnectionStateReady (struct TdConnectionStateReady *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdConnectionStateReady *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectConnectionStateReady (struct TdConnectionStateReady *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdConnectionStateReady *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerConnectionStateReady (struct TdConnectionStateReady *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdConnectionStateReady *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ConnectionStateReady");
  M->new_field ("ID");
}
struct TdConnectionStateReady *TdStackFetcherConnectionStateReady (struct TdStackFetcherMethods *M) {
  auto res = new TdConnectionStateReady ();
  res->ID = CODE_ConnectionStateReady;
  res->refcnt = 1;
  return res;
}
struct TdContact *TdCreateObjectContact (char *phone_number_, char *first_name_, char *last_name_, char *vcard_, int user_id_) {
  auto var = new struct TdContact ();
  var->ID = CODE_Contact;
  var->refcnt = 1;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  var->first_name_ = (first_name_) ? td::str_dup (td::Slice (first_name_)) : nullptr;
  var->last_name_ = (last_name_) ? td::str_dup (td::Slice (last_name_)) : nullptr;
  var->vcard_ = (vcard_) ? td::str_dup (td::Slice (vcard_)) : nullptr;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::contact> TdConvertToInternal (struct TdContact *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->phone_number_) ? var->phone_number_: "";
  std::string v100;
  v100 = (var->first_name_) ? var->first_name_: "";
  std::string v200;
  v200 = (var->last_name_) ? var->last_name_: "";
  std::string v300;
  v300 = (var->vcard_) ? var->vcard_: "";
  std::int32_t v400;
  v400 = var->user_id_;
  return td::td_api::make_object<td::td_api::contact>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdContact *TdConvertFromInternal (const td::td_api::contact &from) {
  auto res = new TdContact ();
  res->ID = CODE_Contact;
  res->refcnt = 1;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  res->first_name_ = (from.first_name_.length ()) ? td::str_dup (from.first_name_) : nullptr;
  res->last_name_ = (from.last_name_.length ()) ? td::str_dup (from.last_name_) : nullptr;
  res->vcard_ = (from.vcard_.length ()) ? td::str_dup (from.vcard_) : nullptr;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeContact (struct TdContact *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdContact *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectContact (struct TdContact *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdContact *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->phone_number_);
  free (var->first_name_);
  free (var->last_name_);
  free (var->vcard_);
  delete var;
}
void TdStackStorerContact (struct TdContact *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdContact *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Contact");
  M->new_field ("ID");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
  M->pack_string (var->first_name_);
  M->new_field ("first_name_");
  M->pack_string (var->last_name_);
  M->new_field ("last_name_");
  M->pack_string (var->vcard_);
  M->new_field ("vcard_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdContact *TdStackFetcherContact (struct TdStackFetcherMethods *M) {
  auto res = new TdContact ();
  res->ID = CODE_Contact;
  res->refcnt = 1;
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  M->get_field ("first_name_");
  res->first_name_ = M->get_string ();
  M->pop ();
  M->get_field ("last_name_");
  res->last_name_ = M->get_string ();
  M->pop ();
  M->get_field ("vcard_");
  res->vcard_ = M->get_string ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCount *TdCreateObjectCount (int count_) {
  auto var = new struct TdCount ();
  var->ID = CODE_Count;
  var->refcnt = 1;
  var->count_ = count_;
  return var;
}
td::td_api::object_ptr<td::td_api::count> TdConvertToInternal (struct TdCount *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->count_;
  return td::td_api::make_object<td::td_api::count>(std::move (v0));
}
struct TdCount *TdConvertFromInternal (const td::td_api::count &from) {
  auto res = new TdCount ();
  res->ID = CODE_Count;
  res->refcnt = 1;
  res->count_ = from.count_;
  return res;
}
char *TdSerializeCount (struct TdCount *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCount *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCount (struct TdCount *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCount *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCount (struct TdCount *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCount *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Count");
  M->new_field ("ID");
  M->pack_long (var->count_);
  M->new_field ("count_");
}
struct TdCount *TdStackFetcherCount (struct TdStackFetcherMethods *M) {
  auto res = new TdCount ();
  res->ID = CODE_Count;
  res->refcnt = 1;
  M->get_field ("count_");
  res->count_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCustomRequestResult *TdCreateObjectCustomRequestResult (char *result_) {
  auto var = new struct TdCustomRequestResult ();
  var->ID = CODE_CustomRequestResult;
  var->refcnt = 1;
  var->result_ = (result_) ? td::str_dup (td::Slice (result_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::customRequestResult> TdConvertToInternal (struct TdCustomRequestResult *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->result_) ? var->result_: "";
  return td::td_api::make_object<td::td_api::customRequestResult>(std::move (v0));
}
struct TdCustomRequestResult *TdConvertFromInternal (const td::td_api::customRequestResult &from) {
  auto res = new TdCustomRequestResult ();
  res->ID = CODE_CustomRequestResult;
  res->refcnt = 1;
  res->result_ = (from.result_.length ()) ? td::str_dup (from.result_) : nullptr;
  return res;
}
char *TdSerializeCustomRequestResult (struct TdCustomRequestResult *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCustomRequestResult *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCustomRequestResult (struct TdCustomRequestResult *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCustomRequestResult *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->result_);
  delete var;
}
void TdStackStorerCustomRequestResult (struct TdCustomRequestResult *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCustomRequestResult *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CustomRequestResult");
  M->new_field ("ID");
  M->pack_string (var->result_);
  M->new_field ("result_");
}
struct TdCustomRequestResult *TdStackFetcherCustomRequestResult (struct TdStackFetcherMethods *M) {
  auto res = new TdCustomRequestResult ();
  res->ID = CODE_CustomRequestResult;
  res->refcnt = 1;
  M->get_field ("result_");
  res->result_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDate *TdCreateObjectDate (int day_, int month_, int year_) {
  auto var = new struct TdDate ();
  var->ID = CODE_Date;
  var->refcnt = 1;
  var->day_ = day_;
  var->month_ = month_;
  var->year_ = year_;
  return var;
}
td::td_api::object_ptr<td::td_api::date> TdConvertToInternal (struct TdDate *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->day_;
  std::int32_t v100;
  v100 = var->month_;
  std::int32_t v200;
  v200 = var->year_;
  return td::td_api::make_object<td::td_api::date>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdDate *TdConvertFromInternal (const td::td_api::date &from) {
  auto res = new TdDate ();
  res->ID = CODE_Date;
  res->refcnt = 1;
  res->day_ = from.day_;
  res->month_ = from.month_;
  res->year_ = from.year_;
  return res;
}
char *TdSerializeDate (struct TdDate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDate (struct TdDate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDate *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDate (struct TdDate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDate *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Date");
  M->new_field ("ID");
  M->pack_long (var->day_);
  M->new_field ("day_");
  M->pack_long (var->month_);
  M->new_field ("month_");
  M->pack_long (var->year_);
  M->new_field ("year_");
}
struct TdDate *TdStackFetcherDate (struct TdStackFetcherMethods *M) {
  auto res = new TdDate ();
  res->ID = CODE_Date;
  res->refcnt = 1;
  M->get_field ("day_");
  res->day_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("month_");
  res->month_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("year_");
  res->year_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDatedFile *TdCreateObjectDatedFile (struct TdFile *file_, int date_) {
  auto var = new struct TdDatedFile ();
  var->ID = CODE_DatedFile;
  var->refcnt = 1;
  var->file_ = file_;
  var->date_ = date_;
  return var;
}
td::td_api::object_ptr<td::td_api::datedFile> TdConvertToInternal (struct TdDatedFile *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::file> v0;
  v0 = TdConvertToInternal (var->file_);
  std::int32_t v100;
  v100 = var->date_;
  return td::td_api::make_object<td::td_api::datedFile>(std::move (v0), std::move (v100));
}
struct TdDatedFile *TdConvertFromInternal (const td::td_api::datedFile &from) {
  auto res = new TdDatedFile ();
  res->ID = CODE_DatedFile;
  res->refcnt = 1;
  if (!from.file_) {
    res->file_ = nullptr;
  } else {
    res->file_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.file_));
  }
  res->date_ = from.date_;
  return res;
}
char *TdSerializeDatedFile (struct TdDatedFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDatedFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDatedFile (struct TdDatedFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDatedFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->file_);
  delete var;
}
void TdStackStorerDatedFile (struct TdDatedFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDatedFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DatedFile");
  M->new_field ("ID");
  TdStackStorer (var->file_, M);
  M->new_field ("file_");
  M->pack_long (var->date_);
  M->new_field ("date_");
}
struct TdDatedFile *TdStackFetcherDatedFile (struct TdStackFetcherMethods *M) {
  auto res = new TdDatedFile ();
  res->ID = CODE_DatedFile;
  res->refcnt = 1;
  M->get_field ("file_");
  if (M->is_nil ()) {
    res->file_ = nullptr;
  } else {
    res->file_ = TdStackFetcherFile (M);
  }
  M->pop ();
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDeepLinkInfo *TdCreateObjectDeepLinkInfo (struct TdFormattedText *text_, int need_update_application_) {
  auto var = new struct TdDeepLinkInfo ();
  var->ID = CODE_DeepLinkInfo;
  var->refcnt = 1;
  var->text_ = text_;
  var->need_update_application_ = need_update_application_;
  return var;
}
td::td_api::object_ptr<td::td_api::deepLinkInfo> TdConvertToInternal (struct TdDeepLinkInfo *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::formattedText> v0;
  v0 = TdConvertToInternal (var->text_);
  bool v100;
  v100 = var->need_update_application_ != 0;
  return td::td_api::make_object<td::td_api::deepLinkInfo>(std::move (v0), std::move (v100));
}
struct TdDeepLinkInfo *TdConvertFromInternal (const td::td_api::deepLinkInfo &from) {
  auto res = new TdDeepLinkInfo ();
  res->ID = CODE_DeepLinkInfo;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.text_));
  }
  res->need_update_application_ = from.need_update_application_;
  return res;
}
char *TdSerializeDeepLinkInfo (struct TdDeepLinkInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeepLinkInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeepLinkInfo (struct TdDeepLinkInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeepLinkInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerDeepLinkInfo (struct TdDeepLinkInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeepLinkInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeepLinkInfo");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  M->pack_bool (var->need_update_application_);
  M->new_field ("need_update_application_");
}
struct TdDeepLinkInfo *TdStackFetcherDeepLinkInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdDeepLinkInfo ();
  res->ID = CODE_DeepLinkInfo;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("need_update_application_");
  res->need_update_application_ = (int)M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::DeviceToken> TdConvertToInternal (struct TdDeviceToken *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_DeviceTokenGoogleCloudMessaging: return TdConvertToInternal ((struct TdDeviceTokenGoogleCloudMessaging *)var);
    case CODE_DeviceTokenApplePush: return TdConvertToInternal ((struct TdDeviceTokenApplePush *)var);
    case CODE_DeviceTokenApplePushVoIP: return TdConvertToInternal ((struct TdDeviceTokenApplePushVoIP *)var);
    case CODE_DeviceTokenWindowsPush: return TdConvertToInternal ((struct TdDeviceTokenWindowsPush *)var);
    case CODE_DeviceTokenMicrosoftPush: return TdConvertToInternal ((struct TdDeviceTokenMicrosoftPush *)var);
    case CODE_DeviceTokenMicrosoftPushVoIP: return TdConvertToInternal ((struct TdDeviceTokenMicrosoftPushVoIP *)var);
    case CODE_DeviceTokenWebPush: return TdConvertToInternal ((struct TdDeviceTokenWebPush *)var);
    case CODE_DeviceTokenSimplePush: return TdConvertToInternal ((struct TdDeviceTokenSimplePush *)var);
    case CODE_DeviceTokenUbuntuPush: return TdConvertToInternal ((struct TdDeviceTokenUbuntuPush *)var);
    case CODE_DeviceTokenBlackBerryPush: return TdConvertToInternal ((struct TdDeviceTokenBlackBerryPush *)var);
    case CODE_DeviceTokenTizenPush: return TdConvertToInternal ((struct TdDeviceTokenTizenPush *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdDeviceToken *TdConvertFromInternal (const td::td_api::DeviceToken &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_DeviceTokenGoogleCloudMessaging: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenGoogleCloudMessaging &>(from));
    case CODE_DeviceTokenApplePush: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenApplePush &>(from));
    case CODE_DeviceTokenApplePushVoIP: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenApplePushVoIP &>(from));
    case CODE_DeviceTokenWindowsPush: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenWindowsPush &>(from));
    case CODE_DeviceTokenMicrosoftPush: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenMicrosoftPush &>(from));
    case CODE_DeviceTokenMicrosoftPushVoIP: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenMicrosoftPushVoIP &>(from));
    case CODE_DeviceTokenWebPush: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenWebPush &>(from));
    case CODE_DeviceTokenSimplePush: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenSimplePush &>(from));
    case CODE_DeviceTokenUbuntuPush: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenUbuntuPush &>(from));
    case CODE_DeviceTokenBlackBerryPush: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenBlackBerryPush &>(from));
    case CODE_DeviceTokenTizenPush: return (struct TdDeviceToken *)TdConvertFromInternal(static_cast<const td::td_api::deviceTokenTizenPush &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeDeviceToken (struct TdDeviceToken *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceToken *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceToken (struct TdDeviceToken *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceToken *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_DeviceTokenGoogleCloudMessaging: return TdDestroyObject ((struct TdDeviceTokenGoogleCloudMessaging *)var);
    case CODE_DeviceTokenApplePush: return TdDestroyObject ((struct TdDeviceTokenApplePush *)var);
    case CODE_DeviceTokenApplePushVoIP: return TdDestroyObject ((struct TdDeviceTokenApplePushVoIP *)var);
    case CODE_DeviceTokenWindowsPush: return TdDestroyObject ((struct TdDeviceTokenWindowsPush *)var);
    case CODE_DeviceTokenMicrosoftPush: return TdDestroyObject ((struct TdDeviceTokenMicrosoftPush *)var);
    case CODE_DeviceTokenMicrosoftPushVoIP: return TdDestroyObject ((struct TdDeviceTokenMicrosoftPushVoIP *)var);
    case CODE_DeviceTokenWebPush: return TdDestroyObject ((struct TdDeviceTokenWebPush *)var);
    case CODE_DeviceTokenSimplePush: return TdDestroyObject ((struct TdDeviceTokenSimplePush *)var);
    case CODE_DeviceTokenUbuntuPush: return TdDestroyObject ((struct TdDeviceTokenUbuntuPush *)var);
    case CODE_DeviceTokenBlackBerryPush: return TdDestroyObject ((struct TdDeviceTokenBlackBerryPush *)var);
    case CODE_DeviceTokenTizenPush: return TdDestroyObject ((struct TdDeviceTokenTizenPush *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerDeviceToken (struct TdDeviceToken *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceToken *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_DeviceTokenGoogleCloudMessaging: return TdStackStorer ((struct TdDeviceTokenGoogleCloudMessaging *)var, M);
    case CODE_DeviceTokenApplePush: return TdStackStorer ((struct TdDeviceTokenApplePush *)var, M);
    case CODE_DeviceTokenApplePushVoIP: return TdStackStorer ((struct TdDeviceTokenApplePushVoIP *)var, M);
    case CODE_DeviceTokenWindowsPush: return TdStackStorer ((struct TdDeviceTokenWindowsPush *)var, M);
    case CODE_DeviceTokenMicrosoftPush: return TdStackStorer ((struct TdDeviceTokenMicrosoftPush *)var, M);
    case CODE_DeviceTokenMicrosoftPushVoIP: return TdStackStorer ((struct TdDeviceTokenMicrosoftPushVoIP *)var, M);
    case CODE_DeviceTokenWebPush: return TdStackStorer ((struct TdDeviceTokenWebPush *)var, M);
    case CODE_DeviceTokenSimplePush: return TdStackStorer ((struct TdDeviceTokenSimplePush *)var, M);
    case CODE_DeviceTokenUbuntuPush: return TdStackStorer ((struct TdDeviceTokenUbuntuPush *)var, M);
    case CODE_DeviceTokenBlackBerryPush: return TdStackStorer ((struct TdDeviceTokenBlackBerryPush *)var, M);
    case CODE_DeviceTokenTizenPush: return TdStackStorer ((struct TdDeviceTokenTizenPush *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdDeviceToken *TdStackFetcherDeviceToken (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "DeviceTokenGoogleCloudMessaging") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenGoogleCloudMessaging (M);
  }
  if (constructor == "DeviceTokenApplePush") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenApplePush (M);
  }
  if (constructor == "DeviceTokenApplePushVoIP") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenApplePushVoIP (M);
  }
  if (constructor == "DeviceTokenWindowsPush") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenWindowsPush (M);
  }
  if (constructor == "DeviceTokenMicrosoftPush") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenMicrosoftPush (M);
  }
  if (constructor == "DeviceTokenMicrosoftPushVoIP") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenMicrosoftPushVoIP (M);
  }
  if (constructor == "DeviceTokenWebPush") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenWebPush (M);
  }
  if (constructor == "DeviceTokenSimplePush") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenSimplePush (M);
  }
  if (constructor == "DeviceTokenUbuntuPush") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenUbuntuPush (M);
  }
  if (constructor == "DeviceTokenBlackBerryPush") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenBlackBerryPush (M);
  }
  if (constructor == "DeviceTokenTizenPush") {
    return (struct TdDeviceToken *)TdStackFetcherDeviceTokenTizenPush (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdDeviceTokenGoogleCloudMessaging *TdCreateObjectDeviceTokenGoogleCloudMessaging (char *token_) {
  auto var = new struct TdDeviceTokenGoogleCloudMessaging ();
  var->ID = CODE_DeviceTokenGoogleCloudMessaging;
  var->refcnt = 1;
  var->token_ = (token_) ? td::str_dup (td::Slice (token_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenGoogleCloudMessaging> TdConvertToInternal (struct TdDeviceTokenGoogleCloudMessaging *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->token_) ? var->token_: "";
  return td::td_api::make_object<td::td_api::deviceTokenGoogleCloudMessaging>(std::move (v0));
}
struct TdDeviceTokenGoogleCloudMessaging *TdConvertFromInternal (const td::td_api::deviceTokenGoogleCloudMessaging &from) {
  auto res = new TdDeviceTokenGoogleCloudMessaging ();
  res->ID = CODE_DeviceTokenGoogleCloudMessaging;
  res->refcnt = 1;
  res->token_ = (from.token_.length ()) ? td::str_dup (from.token_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenGoogleCloudMessaging (struct TdDeviceTokenGoogleCloudMessaging *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenGoogleCloudMessaging *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenGoogleCloudMessaging (struct TdDeviceTokenGoogleCloudMessaging *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenGoogleCloudMessaging *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->token_);
  delete var;
}
void TdStackStorerDeviceTokenGoogleCloudMessaging (struct TdDeviceTokenGoogleCloudMessaging *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenGoogleCloudMessaging *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenGoogleCloudMessaging");
  M->new_field ("ID");
  M->pack_string (var->token_);
  M->new_field ("token_");
}
struct TdDeviceTokenGoogleCloudMessaging *TdStackFetcherDeviceTokenGoogleCloudMessaging (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenGoogleCloudMessaging ();
  res->ID = CODE_DeviceTokenGoogleCloudMessaging;
  res->refcnt = 1;
  M->get_field ("token_");
  res->token_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeviceTokenApplePush *TdCreateObjectDeviceTokenApplePush (char *device_token_, int is_app_sandbox_) {
  auto var = new struct TdDeviceTokenApplePush ();
  var->ID = CODE_DeviceTokenApplePush;
  var->refcnt = 1;
  var->device_token_ = (device_token_) ? td::str_dup (td::Slice (device_token_)) : nullptr;
  var->is_app_sandbox_ = is_app_sandbox_;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenApplePush> TdConvertToInternal (struct TdDeviceTokenApplePush *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->device_token_) ? var->device_token_: "";
  bool v100;
  v100 = var->is_app_sandbox_ != 0;
  return td::td_api::make_object<td::td_api::deviceTokenApplePush>(std::move (v0), std::move (v100));
}
struct TdDeviceTokenApplePush *TdConvertFromInternal (const td::td_api::deviceTokenApplePush &from) {
  auto res = new TdDeviceTokenApplePush ();
  res->ID = CODE_DeviceTokenApplePush;
  res->refcnt = 1;
  res->device_token_ = (from.device_token_.length ()) ? td::str_dup (from.device_token_) : nullptr;
  res->is_app_sandbox_ = from.is_app_sandbox_;
  return res;
}
char *TdSerializeDeviceTokenApplePush (struct TdDeviceTokenApplePush *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenApplePush *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenApplePush (struct TdDeviceTokenApplePush *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenApplePush *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->device_token_);
  delete var;
}
void TdStackStorerDeviceTokenApplePush (struct TdDeviceTokenApplePush *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenApplePush *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenApplePush");
  M->new_field ("ID");
  M->pack_string (var->device_token_);
  M->new_field ("device_token_");
  M->pack_bool (var->is_app_sandbox_);
  M->new_field ("is_app_sandbox_");
}
struct TdDeviceTokenApplePush *TdStackFetcherDeviceTokenApplePush (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenApplePush ();
  res->ID = CODE_DeviceTokenApplePush;
  res->refcnt = 1;
  M->get_field ("device_token_");
  res->device_token_ = M->get_string ();
  M->pop ();
  M->get_field ("is_app_sandbox_");
  res->is_app_sandbox_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDeviceTokenApplePushVoIP *TdCreateObjectDeviceTokenApplePushVoIP (char *device_token_, int is_app_sandbox_) {
  auto var = new struct TdDeviceTokenApplePushVoIP ();
  var->ID = CODE_DeviceTokenApplePushVoIP;
  var->refcnt = 1;
  var->device_token_ = (device_token_) ? td::str_dup (td::Slice (device_token_)) : nullptr;
  var->is_app_sandbox_ = is_app_sandbox_;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenApplePushVoIP> TdConvertToInternal (struct TdDeviceTokenApplePushVoIP *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->device_token_) ? var->device_token_: "";
  bool v100;
  v100 = var->is_app_sandbox_ != 0;
  return td::td_api::make_object<td::td_api::deviceTokenApplePushVoIP>(std::move (v0), std::move (v100));
}
struct TdDeviceTokenApplePushVoIP *TdConvertFromInternal (const td::td_api::deviceTokenApplePushVoIP &from) {
  auto res = new TdDeviceTokenApplePushVoIP ();
  res->ID = CODE_DeviceTokenApplePushVoIP;
  res->refcnt = 1;
  res->device_token_ = (from.device_token_.length ()) ? td::str_dup (from.device_token_) : nullptr;
  res->is_app_sandbox_ = from.is_app_sandbox_;
  return res;
}
char *TdSerializeDeviceTokenApplePushVoIP (struct TdDeviceTokenApplePushVoIP *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenApplePushVoIP *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenApplePushVoIP (struct TdDeviceTokenApplePushVoIP *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenApplePushVoIP *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->device_token_);
  delete var;
}
void TdStackStorerDeviceTokenApplePushVoIP (struct TdDeviceTokenApplePushVoIP *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenApplePushVoIP *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenApplePushVoIP");
  M->new_field ("ID");
  M->pack_string (var->device_token_);
  M->new_field ("device_token_");
  M->pack_bool (var->is_app_sandbox_);
  M->new_field ("is_app_sandbox_");
}
struct TdDeviceTokenApplePushVoIP *TdStackFetcherDeviceTokenApplePushVoIP (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenApplePushVoIP ();
  res->ID = CODE_DeviceTokenApplePushVoIP;
  res->refcnt = 1;
  M->get_field ("device_token_");
  res->device_token_ = M->get_string ();
  M->pop ();
  M->get_field ("is_app_sandbox_");
  res->is_app_sandbox_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDeviceTokenWindowsPush *TdCreateObjectDeviceTokenWindowsPush (char *access_token_) {
  auto var = new struct TdDeviceTokenWindowsPush ();
  var->ID = CODE_DeviceTokenWindowsPush;
  var->refcnt = 1;
  var->access_token_ = (access_token_) ? td::str_dup (td::Slice (access_token_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenWindowsPush> TdConvertToInternal (struct TdDeviceTokenWindowsPush *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->access_token_) ? var->access_token_: "";
  return td::td_api::make_object<td::td_api::deviceTokenWindowsPush>(std::move (v0));
}
struct TdDeviceTokenWindowsPush *TdConvertFromInternal (const td::td_api::deviceTokenWindowsPush &from) {
  auto res = new TdDeviceTokenWindowsPush ();
  res->ID = CODE_DeviceTokenWindowsPush;
  res->refcnt = 1;
  res->access_token_ = (from.access_token_.length ()) ? td::str_dup (from.access_token_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenWindowsPush (struct TdDeviceTokenWindowsPush *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenWindowsPush *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenWindowsPush (struct TdDeviceTokenWindowsPush *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenWindowsPush *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->access_token_);
  delete var;
}
void TdStackStorerDeviceTokenWindowsPush (struct TdDeviceTokenWindowsPush *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenWindowsPush *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenWindowsPush");
  M->new_field ("ID");
  M->pack_string (var->access_token_);
  M->new_field ("access_token_");
}
struct TdDeviceTokenWindowsPush *TdStackFetcherDeviceTokenWindowsPush (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenWindowsPush ();
  res->ID = CODE_DeviceTokenWindowsPush;
  res->refcnt = 1;
  M->get_field ("access_token_");
  res->access_token_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeviceTokenMicrosoftPush *TdCreateObjectDeviceTokenMicrosoftPush (char *channel_uri_) {
  auto var = new struct TdDeviceTokenMicrosoftPush ();
  var->ID = CODE_DeviceTokenMicrosoftPush;
  var->refcnt = 1;
  var->channel_uri_ = (channel_uri_) ? td::str_dup (td::Slice (channel_uri_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenMicrosoftPush> TdConvertToInternal (struct TdDeviceTokenMicrosoftPush *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->channel_uri_) ? var->channel_uri_: "";
  return td::td_api::make_object<td::td_api::deviceTokenMicrosoftPush>(std::move (v0));
}
struct TdDeviceTokenMicrosoftPush *TdConvertFromInternal (const td::td_api::deviceTokenMicrosoftPush &from) {
  auto res = new TdDeviceTokenMicrosoftPush ();
  res->ID = CODE_DeviceTokenMicrosoftPush;
  res->refcnt = 1;
  res->channel_uri_ = (from.channel_uri_.length ()) ? td::str_dup (from.channel_uri_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenMicrosoftPush (struct TdDeviceTokenMicrosoftPush *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenMicrosoftPush *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenMicrosoftPush (struct TdDeviceTokenMicrosoftPush *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenMicrosoftPush *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->channel_uri_);
  delete var;
}
void TdStackStorerDeviceTokenMicrosoftPush (struct TdDeviceTokenMicrosoftPush *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenMicrosoftPush *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenMicrosoftPush");
  M->new_field ("ID");
  M->pack_string (var->channel_uri_);
  M->new_field ("channel_uri_");
}
struct TdDeviceTokenMicrosoftPush *TdStackFetcherDeviceTokenMicrosoftPush (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenMicrosoftPush ();
  res->ID = CODE_DeviceTokenMicrosoftPush;
  res->refcnt = 1;
  M->get_field ("channel_uri_");
  res->channel_uri_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeviceTokenMicrosoftPushVoIP *TdCreateObjectDeviceTokenMicrosoftPushVoIP (char *channel_uri_) {
  auto var = new struct TdDeviceTokenMicrosoftPushVoIP ();
  var->ID = CODE_DeviceTokenMicrosoftPushVoIP;
  var->refcnt = 1;
  var->channel_uri_ = (channel_uri_) ? td::str_dup (td::Slice (channel_uri_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenMicrosoftPushVoIP> TdConvertToInternal (struct TdDeviceTokenMicrosoftPushVoIP *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->channel_uri_) ? var->channel_uri_: "";
  return td::td_api::make_object<td::td_api::deviceTokenMicrosoftPushVoIP>(std::move (v0));
}
struct TdDeviceTokenMicrosoftPushVoIP *TdConvertFromInternal (const td::td_api::deviceTokenMicrosoftPushVoIP &from) {
  auto res = new TdDeviceTokenMicrosoftPushVoIP ();
  res->ID = CODE_DeviceTokenMicrosoftPushVoIP;
  res->refcnt = 1;
  res->channel_uri_ = (from.channel_uri_.length ()) ? td::str_dup (from.channel_uri_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenMicrosoftPushVoIP (struct TdDeviceTokenMicrosoftPushVoIP *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenMicrosoftPushVoIP *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenMicrosoftPushVoIP (struct TdDeviceTokenMicrosoftPushVoIP *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenMicrosoftPushVoIP *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->channel_uri_);
  delete var;
}
void TdStackStorerDeviceTokenMicrosoftPushVoIP (struct TdDeviceTokenMicrosoftPushVoIP *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenMicrosoftPushVoIP *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenMicrosoftPushVoIP");
  M->new_field ("ID");
  M->pack_string (var->channel_uri_);
  M->new_field ("channel_uri_");
}
struct TdDeviceTokenMicrosoftPushVoIP *TdStackFetcherDeviceTokenMicrosoftPushVoIP (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenMicrosoftPushVoIP ();
  res->ID = CODE_DeviceTokenMicrosoftPushVoIP;
  res->refcnt = 1;
  M->get_field ("channel_uri_");
  res->channel_uri_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeviceTokenWebPush *TdCreateObjectDeviceTokenWebPush (char *endpoint_, char *p256dh_base64url_, char *auth_base64url_) {
  auto var = new struct TdDeviceTokenWebPush ();
  var->ID = CODE_DeviceTokenWebPush;
  var->refcnt = 1;
  var->endpoint_ = (endpoint_) ? td::str_dup (td::Slice (endpoint_)) : nullptr;
  var->p256dh_base64url_ = (p256dh_base64url_) ? td::str_dup (td::Slice (p256dh_base64url_)) : nullptr;
  var->auth_base64url_ = (auth_base64url_) ? td::str_dup (td::Slice (auth_base64url_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenWebPush> TdConvertToInternal (struct TdDeviceTokenWebPush *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->endpoint_) ? var->endpoint_: "";
  std::string v100;
  v100 = (var->p256dh_base64url_) ? var->p256dh_base64url_: "";
  std::string v200;
  v200 = (var->auth_base64url_) ? var->auth_base64url_: "";
  return td::td_api::make_object<td::td_api::deviceTokenWebPush>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdDeviceTokenWebPush *TdConvertFromInternal (const td::td_api::deviceTokenWebPush &from) {
  auto res = new TdDeviceTokenWebPush ();
  res->ID = CODE_DeviceTokenWebPush;
  res->refcnt = 1;
  res->endpoint_ = (from.endpoint_.length ()) ? td::str_dup (from.endpoint_) : nullptr;
  res->p256dh_base64url_ = (from.p256dh_base64url_.length ()) ? td::str_dup (from.p256dh_base64url_) : nullptr;
  res->auth_base64url_ = (from.auth_base64url_.length ()) ? td::str_dup (from.auth_base64url_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenWebPush (struct TdDeviceTokenWebPush *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenWebPush *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenWebPush (struct TdDeviceTokenWebPush *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenWebPush *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->endpoint_);
  free (var->p256dh_base64url_);
  free (var->auth_base64url_);
  delete var;
}
void TdStackStorerDeviceTokenWebPush (struct TdDeviceTokenWebPush *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenWebPush *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenWebPush");
  M->new_field ("ID");
  M->pack_string (var->endpoint_);
  M->new_field ("endpoint_");
  M->pack_string (var->p256dh_base64url_);
  M->new_field ("p256dh_base64url_");
  M->pack_string (var->auth_base64url_);
  M->new_field ("auth_base64url_");
}
struct TdDeviceTokenWebPush *TdStackFetcherDeviceTokenWebPush (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenWebPush ();
  res->ID = CODE_DeviceTokenWebPush;
  res->refcnt = 1;
  M->get_field ("endpoint_");
  res->endpoint_ = M->get_string ();
  M->pop ();
  M->get_field ("p256dh_base64url_");
  res->p256dh_base64url_ = M->get_string ();
  M->pop ();
  M->get_field ("auth_base64url_");
  res->auth_base64url_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeviceTokenSimplePush *TdCreateObjectDeviceTokenSimplePush (char *endpoint_) {
  auto var = new struct TdDeviceTokenSimplePush ();
  var->ID = CODE_DeviceTokenSimplePush;
  var->refcnt = 1;
  var->endpoint_ = (endpoint_) ? td::str_dup (td::Slice (endpoint_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenSimplePush> TdConvertToInternal (struct TdDeviceTokenSimplePush *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->endpoint_) ? var->endpoint_: "";
  return td::td_api::make_object<td::td_api::deviceTokenSimplePush>(std::move (v0));
}
struct TdDeviceTokenSimplePush *TdConvertFromInternal (const td::td_api::deviceTokenSimplePush &from) {
  auto res = new TdDeviceTokenSimplePush ();
  res->ID = CODE_DeviceTokenSimplePush;
  res->refcnt = 1;
  res->endpoint_ = (from.endpoint_.length ()) ? td::str_dup (from.endpoint_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenSimplePush (struct TdDeviceTokenSimplePush *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenSimplePush *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenSimplePush (struct TdDeviceTokenSimplePush *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenSimplePush *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->endpoint_);
  delete var;
}
void TdStackStorerDeviceTokenSimplePush (struct TdDeviceTokenSimplePush *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenSimplePush *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenSimplePush");
  M->new_field ("ID");
  M->pack_string (var->endpoint_);
  M->new_field ("endpoint_");
}
struct TdDeviceTokenSimplePush *TdStackFetcherDeviceTokenSimplePush (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenSimplePush ();
  res->ID = CODE_DeviceTokenSimplePush;
  res->refcnt = 1;
  M->get_field ("endpoint_");
  res->endpoint_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeviceTokenUbuntuPush *TdCreateObjectDeviceTokenUbuntuPush (char *token_) {
  auto var = new struct TdDeviceTokenUbuntuPush ();
  var->ID = CODE_DeviceTokenUbuntuPush;
  var->refcnt = 1;
  var->token_ = (token_) ? td::str_dup (td::Slice (token_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenUbuntuPush> TdConvertToInternal (struct TdDeviceTokenUbuntuPush *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->token_) ? var->token_: "";
  return td::td_api::make_object<td::td_api::deviceTokenUbuntuPush>(std::move (v0));
}
struct TdDeviceTokenUbuntuPush *TdConvertFromInternal (const td::td_api::deviceTokenUbuntuPush &from) {
  auto res = new TdDeviceTokenUbuntuPush ();
  res->ID = CODE_DeviceTokenUbuntuPush;
  res->refcnt = 1;
  res->token_ = (from.token_.length ()) ? td::str_dup (from.token_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenUbuntuPush (struct TdDeviceTokenUbuntuPush *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenUbuntuPush *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenUbuntuPush (struct TdDeviceTokenUbuntuPush *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenUbuntuPush *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->token_);
  delete var;
}
void TdStackStorerDeviceTokenUbuntuPush (struct TdDeviceTokenUbuntuPush *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenUbuntuPush *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenUbuntuPush");
  M->new_field ("ID");
  M->pack_string (var->token_);
  M->new_field ("token_");
}
struct TdDeviceTokenUbuntuPush *TdStackFetcherDeviceTokenUbuntuPush (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenUbuntuPush ();
  res->ID = CODE_DeviceTokenUbuntuPush;
  res->refcnt = 1;
  M->get_field ("token_");
  res->token_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeviceTokenBlackBerryPush *TdCreateObjectDeviceTokenBlackBerryPush (char *token_) {
  auto var = new struct TdDeviceTokenBlackBerryPush ();
  var->ID = CODE_DeviceTokenBlackBerryPush;
  var->refcnt = 1;
  var->token_ = (token_) ? td::str_dup (td::Slice (token_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenBlackBerryPush> TdConvertToInternal (struct TdDeviceTokenBlackBerryPush *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->token_) ? var->token_: "";
  return td::td_api::make_object<td::td_api::deviceTokenBlackBerryPush>(std::move (v0));
}
struct TdDeviceTokenBlackBerryPush *TdConvertFromInternal (const td::td_api::deviceTokenBlackBerryPush &from) {
  auto res = new TdDeviceTokenBlackBerryPush ();
  res->ID = CODE_DeviceTokenBlackBerryPush;
  res->refcnt = 1;
  res->token_ = (from.token_.length ()) ? td::str_dup (from.token_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenBlackBerryPush (struct TdDeviceTokenBlackBerryPush *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenBlackBerryPush *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenBlackBerryPush (struct TdDeviceTokenBlackBerryPush *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenBlackBerryPush *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->token_);
  delete var;
}
void TdStackStorerDeviceTokenBlackBerryPush (struct TdDeviceTokenBlackBerryPush *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenBlackBerryPush *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenBlackBerryPush");
  M->new_field ("ID");
  M->pack_string (var->token_);
  M->new_field ("token_");
}
struct TdDeviceTokenBlackBerryPush *TdStackFetcherDeviceTokenBlackBerryPush (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenBlackBerryPush ();
  res->ID = CODE_DeviceTokenBlackBerryPush;
  res->refcnt = 1;
  M->get_field ("token_");
  res->token_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeviceTokenTizenPush *TdCreateObjectDeviceTokenTizenPush (char *reg_id_) {
  auto var = new struct TdDeviceTokenTizenPush ();
  var->ID = CODE_DeviceTokenTizenPush;
  var->refcnt = 1;
  var->reg_id_ = (reg_id_) ? td::str_dup (td::Slice (reg_id_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deviceTokenTizenPush> TdConvertToInternal (struct TdDeviceTokenTizenPush *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->reg_id_) ? var->reg_id_: "";
  return td::td_api::make_object<td::td_api::deviceTokenTizenPush>(std::move (v0));
}
struct TdDeviceTokenTizenPush *TdConvertFromInternal (const td::td_api::deviceTokenTizenPush &from) {
  auto res = new TdDeviceTokenTizenPush ();
  res->ID = CODE_DeviceTokenTizenPush;
  res->refcnt = 1;
  res->reg_id_ = (from.reg_id_.length ()) ? td::str_dup (from.reg_id_) : nullptr;
  return res;
}
char *TdSerializeDeviceTokenTizenPush (struct TdDeviceTokenTizenPush *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeviceTokenTizenPush *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeviceTokenTizenPush (struct TdDeviceTokenTizenPush *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeviceTokenTizenPush *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->reg_id_);
  delete var;
}
void TdStackStorerDeviceTokenTizenPush (struct TdDeviceTokenTizenPush *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeviceTokenTizenPush *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeviceTokenTizenPush");
  M->new_field ("ID");
  M->pack_string (var->reg_id_);
  M->new_field ("reg_id_");
}
struct TdDeviceTokenTizenPush *TdStackFetcherDeviceTokenTizenPush (struct TdStackFetcherMethods *M) {
  auto res = new TdDeviceTokenTizenPush ();
  res->ID = CODE_DeviceTokenTizenPush;
  res->refcnt = 1;
  M->get_field ("reg_id_");
  res->reg_id_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDocument *TdCreateObjectDocument (char *file_name_, char *mime_type_, struct TdPhotoSize *thumbnail_, struct TdFile *document_) {
  auto var = new struct TdDocument ();
  var->ID = CODE_Document;
  var->refcnt = 1;
  var->file_name_ = (file_name_) ? td::str_dup (td::Slice (file_name_)) : nullptr;
  var->mime_type_ = (mime_type_) ? td::str_dup (td::Slice (mime_type_)) : nullptr;
  var->thumbnail_ = thumbnail_;
  var->document_ = document_;
  return var;
}
td::td_api::object_ptr<td::td_api::document> TdConvertToInternal (struct TdDocument *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->file_name_) ? var->file_name_: "";
  std::string v100;
  v100 = (var->mime_type_) ? var->mime_type_: "";
  td::td_api::object_ptr<td::td_api::photoSize> v200;
  v200 = TdConvertToInternal (var->thumbnail_);
  td::td_api::object_ptr<td::td_api::file> v300;
  v300 = TdConvertToInternal (var->document_);
  return td::td_api::make_object<td::td_api::document>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdDocument *TdConvertFromInternal (const td::td_api::document &from) {
  auto res = new TdDocument ();
  res->ID = CODE_Document;
  res->refcnt = 1;
  res->file_name_ = (from.file_name_.length ()) ? td::str_dup (from.file_name_) : nullptr;
  res->mime_type_ = (from.mime_type_.length ()) ? td::str_dup (from.mime_type_) : nullptr;
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  if (!from.document_) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.document_));
  }
  return res;
}
char *TdSerializeDocument (struct TdDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDocument (struct TdDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->file_name_);
  free (var->mime_type_);
  TdDestroyObject (var->thumbnail_);
  TdDestroyObject (var->document_);
  delete var;
}
void TdStackStorerDocument (struct TdDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Document");
  M->new_field ("ID");
  M->pack_string (var->file_name_);
  M->new_field ("file_name_");
  M->pack_string (var->mime_type_);
  M->new_field ("mime_type_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  TdStackStorer (var->document_, M);
  M->new_field ("document_");
}
struct TdDocument *TdStackFetcherDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdDocument ();
  res->ID = CODE_Document;
  res->refcnt = 1;
  M->get_field ("file_name_");
  res->file_name_ = M->get_string ();
  M->pop ();
  M->get_field ("mime_type_");
  res->mime_type_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  M->get_field ("document_");
  if (M->is_nil ()) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdDraftMessage *TdCreateObjectDraftMessage (long long reply_to_message_id_, struct TdInputMessageContent *input_message_text_) {
  auto var = new struct TdDraftMessage ();
  var->ID = CODE_DraftMessage;
  var->refcnt = 1;
  var->reply_to_message_id_ = reply_to_message_id_;
  var->input_message_text_ = input_message_text_;
  return var;
}
td::td_api::object_ptr<td::td_api::draftMessage> TdConvertToInternal (struct TdDraftMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->reply_to_message_id_;
  td::td_api::object_ptr<td::td_api::InputMessageContent> v100;
  v100 = TdConvertToInternal (var->input_message_text_);
  return td::td_api::make_object<td::td_api::draftMessage>(std::move (v0), std::move (v100));
}
struct TdDraftMessage *TdConvertFromInternal (const td::td_api::draftMessage &from) {
  auto res = new TdDraftMessage ();
  res->ID = CODE_DraftMessage;
  res->refcnt = 1;
  res->reply_to_message_id_ = from.reply_to_message_id_;
  if (!from.input_message_text_) {
    res->input_message_text_ = nullptr;
  } else {
    res->input_message_text_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_text_));
  }
  return res;
}
char *TdSerializeDraftMessage (struct TdDraftMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDraftMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDraftMessage (struct TdDraftMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDraftMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->input_message_text_);
  delete var;
}
void TdStackStorerDraftMessage (struct TdDraftMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDraftMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DraftMessage");
  M->new_field ("ID");
  M->pack_long (var->reply_to_message_id_);
  M->new_field ("reply_to_message_id_");
  TdStackStorer (var->input_message_text_, M);
  M->new_field ("input_message_text_");
}
struct TdDraftMessage *TdStackFetcherDraftMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdDraftMessage ();
  res->ID = CODE_DraftMessage;
  res->refcnt = 1;
  M->get_field ("reply_to_message_id_");
  res->reply_to_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("input_message_text_");
  if (M->is_nil ()) {
    res->input_message_text_ = nullptr;
  } else {
    res->input_message_text_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdEmailAddressAuthenticationCodeInfo *TdCreateObjectEmailAddressAuthenticationCodeInfo (char *email_address_pattern_, int length_) {
  auto var = new struct TdEmailAddressAuthenticationCodeInfo ();
  var->ID = CODE_EmailAddressAuthenticationCodeInfo;
  var->refcnt = 1;
  var->email_address_pattern_ = (email_address_pattern_) ? td::str_dup (td::Slice (email_address_pattern_)) : nullptr;
  var->length_ = length_;
  return var;
}
td::td_api::object_ptr<td::td_api::emailAddressAuthenticationCodeInfo> TdConvertToInternal (struct TdEmailAddressAuthenticationCodeInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->email_address_pattern_) ? var->email_address_pattern_: "";
  std::int32_t v100;
  v100 = var->length_;
  return td::td_api::make_object<td::td_api::emailAddressAuthenticationCodeInfo>(std::move (v0), std::move (v100));
}
struct TdEmailAddressAuthenticationCodeInfo *TdConvertFromInternal (const td::td_api::emailAddressAuthenticationCodeInfo &from) {
  auto res = new TdEmailAddressAuthenticationCodeInfo ();
  res->ID = CODE_EmailAddressAuthenticationCodeInfo;
  res->refcnt = 1;
  res->email_address_pattern_ = (from.email_address_pattern_.length ()) ? td::str_dup (from.email_address_pattern_) : nullptr;
  res->length_ = from.length_;
  return res;
}
char *TdSerializeEmailAddressAuthenticationCodeInfo (struct TdEmailAddressAuthenticationCodeInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEmailAddressAuthenticationCodeInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEmailAddressAuthenticationCodeInfo (struct TdEmailAddressAuthenticationCodeInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEmailAddressAuthenticationCodeInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->email_address_pattern_);
  delete var;
}
void TdStackStorerEmailAddressAuthenticationCodeInfo (struct TdEmailAddressAuthenticationCodeInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEmailAddressAuthenticationCodeInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EmailAddressAuthenticationCodeInfo");
  M->new_field ("ID");
  M->pack_string (var->email_address_pattern_);
  M->new_field ("email_address_pattern_");
  M->pack_long (var->length_);
  M->new_field ("length_");
}
struct TdEmailAddressAuthenticationCodeInfo *TdStackFetcherEmailAddressAuthenticationCodeInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdEmailAddressAuthenticationCodeInfo ();
  res->ID = CODE_EmailAddressAuthenticationCodeInfo;
  res->refcnt = 1;
  M->get_field ("email_address_pattern_");
  res->email_address_pattern_ = M->get_string ();
  M->pop ();
  M->get_field ("length_");
  res->length_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdEncryptedCredentials *TdCreateObjectEncryptedCredentials (struct TdBytes data_, struct TdBytes hash_, struct TdBytes secret_) {
  auto var = new struct TdEncryptedCredentials ();
  var->ID = CODE_EncryptedCredentials;
  var->refcnt = 1;
  var->data_ = data_;
  var->hash_ = hash_;
  var->secret_ = secret_;
  return var;
}
td::td_api::object_ptr<td::td_api::encryptedCredentials> TdConvertToInternal (struct TdEncryptedCredentials *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->data_.data, var->data_.len);
  std::string v100;
  v100 = std::string ((char *)var->hash_.data, var->hash_.len);
  std::string v200;
  v200 = std::string ((char *)var->secret_.data, var->secret_.len);
  return td::td_api::make_object<td::td_api::encryptedCredentials>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdEncryptedCredentials *TdConvertFromInternal (const td::td_api::encryptedCredentials &from) {
  auto res = new TdEncryptedCredentials ();
  res->ID = CODE_EncryptedCredentials;
  res->refcnt = 1;
  res->data_.len = (int)from.data_.length ();
  if (res->data_.len) {
    res->data_.data = new unsigned char[res->data_.len];
    memcpy (res->data_.data, from.data_.c_str (), res->data_.len);
  } else {
    res->data_.data = nullptr;
  }
  res->hash_.len = (int)from.hash_.length ();
  if (res->hash_.len) {
    res->hash_.data = new unsigned char[res->hash_.len];
    memcpy (res->hash_.data, from.hash_.c_str (), res->hash_.len);
  } else {
    res->hash_.data = nullptr;
  }
  res->secret_.len = (int)from.secret_.length ();
  if (res->secret_.len) {
    res->secret_.data = new unsigned char[res->secret_.len];
    memcpy (res->secret_.data, from.secret_.c_str (), res->secret_.len);
  } else {
    res->secret_.data = nullptr;
  }
  return res;
}
char *TdSerializeEncryptedCredentials (struct TdEncryptedCredentials *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEncryptedCredentials *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEncryptedCredentials (struct TdEncryptedCredentials *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEncryptedCredentials *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->data_.data;
  delete[]var->hash_.data;
  delete[]var->secret_.data;
  delete var;
}
void TdStackStorerEncryptedCredentials (struct TdEncryptedCredentials *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEncryptedCredentials *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EncryptedCredentials");
  M->new_field ("ID");
  M->pack_bytes (var->data_.data, var->data_.len);
  M->new_field ("data_");
  M->pack_bytes (var->hash_.data, var->hash_.len);
  M->new_field ("hash_");
  M->pack_bytes (var->secret_.data, var->secret_.len);
  M->new_field ("secret_");
}
struct TdEncryptedCredentials *TdStackFetcherEncryptedCredentials (struct TdStackFetcherMethods *M) {
  auto res = new TdEncryptedCredentials ();
  res->ID = CODE_EncryptedCredentials;
  res->refcnt = 1;
  M->get_field ("data_");
  res->data_.data = M->get_bytes (&res->data_.len);
  M->pop ();
  M->get_field ("hash_");
  res->hash_.data = M->get_bytes (&res->hash_.len);
  M->pop ();
  M->get_field ("secret_");
  res->secret_.data = M->get_bytes (&res->secret_.len);
  M->pop ();
  return res;
}
struct TdEncryptedPassportElement *TdCreateObjectEncryptedPassportElement (struct TdPassportElementType *type_, struct TdBytes data_, struct TdDatedFile *front_side_, struct TdDatedFile *reverse_side_, struct TdDatedFile *selfie_, struct TdVectorDatedFile *translation_, struct TdVectorDatedFile *files_, char *value_, char *hash_) {
  auto var = new struct TdEncryptedPassportElement ();
  var->ID = CODE_EncryptedPassportElement;
  var->refcnt = 1;
  var->type_ = type_;
  var->data_ = data_;
  var->front_side_ = front_side_;
  var->reverse_side_ = reverse_side_;
  var->selfie_ = selfie_;
  var->translation_ = translation_;
  var->files_ = files_;
  var->value_ = (value_) ? td::str_dup (td::Slice (value_)) : nullptr;
  var->hash_ = (hash_) ? td::str_dup (td::Slice (hash_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::encryptedPassportElement> TdConvertToInternal (struct TdEncryptedPassportElement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::PassportElementType> v0;
  v0 = TdConvertToInternal (var->type_);
  std::string v100;
  v100 = std::string ((char *)var->data_.data, var->data_.len);
  td::td_api::object_ptr<td::td_api::datedFile> v200;
  v200 = TdConvertToInternal (var->front_side_);
  td::td_api::object_ptr<td::td_api::datedFile> v300;
  v300 = TdConvertToInternal (var->reverse_side_);
  td::td_api::object_ptr<td::td_api::datedFile> v400;
  v400 = TdConvertToInternal (var->selfie_);
  std::vector<td::td_api::object_ptr<td::td_api::datedFile>> v500;
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    td::td_api::object_ptr<td::td_api::datedFile> v501;
    v501 = TdConvertToInternal (var->translation_->data[i500]);
    v500.push_back (std::move (v501));
  }
  std::vector<td::td_api::object_ptr<td::td_api::datedFile>> v600;
  for (int i600 = 0; i600 < var->files_->len; i600++) {
    td::td_api::object_ptr<td::td_api::datedFile> v601;
    v601 = TdConvertToInternal (var->files_->data[i600]);
    v600.push_back (std::move (v601));
  }
  std::string v700;
  v700 = (var->value_) ? var->value_: "";
  std::string v800;
  v800 = (var->hash_) ? var->hash_: "";
  return td::td_api::make_object<td::td_api::encryptedPassportElement>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdEncryptedPassportElement *TdConvertFromInternal (const td::td_api::encryptedPassportElement &from) {
  auto res = new TdEncryptedPassportElement ();
  res->ID = CODE_EncryptedPassportElement;
  res->refcnt = 1;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::PassportElementType &>(*from.type_));
  }
  res->data_.len = (int)from.data_.length ();
  if (res->data_.len) {
    res->data_.data = new unsigned char[res->data_.len];
    memcpy (res->data_.data, from.data_.c_str (), res->data_.len);
  } else {
    res->data_.data = nullptr;
  }
  if (!from.front_side_) {
    res->front_side_ = nullptr;
  } else {
    res->front_side_ = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.front_side_));
  }
  if (!from.reverse_side_) {
    res->reverse_side_ = nullptr;
  } else {
    res->reverse_side_ = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.reverse_side_));
  }
  if (!from.selfie_) {
    res->selfie_ = nullptr;
  } else {
    res->selfie_ = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.selfie_));
  }
  res->translation_ = new TdVectorDatedFile ();
  res->translation_->len = (int)from.translation_.size ();
  res->translation_->data = new struct TdDatedFile * [res->translation_->len];
  for (int i500 = 0; i500 < res->translation_->len; i500++) {
    if (!from.translation_[i500]) {
      res->translation_->data[i500] = nullptr;
    } else {
      res->translation_->data[i500] = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.translation_[i500]));
    }
  }
  res->files_ = new TdVectorDatedFile ();
  res->files_->len = (int)from.files_.size ();
  res->files_->data = new struct TdDatedFile * [res->files_->len];
  for (int i600 = 0; i600 < res->files_->len; i600++) {
    if (!from.files_[i600]) {
      res->files_->data[i600] = nullptr;
    } else {
      res->files_->data[i600] = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.files_[i600]));
    }
  }
  res->value_ = (from.value_.length ()) ? td::str_dup (from.value_) : nullptr;
  res->hash_ = (from.hash_.length ()) ? td::str_dup (from.hash_) : nullptr;
  return res;
}
char *TdSerializeEncryptedPassportElement (struct TdEncryptedPassportElement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEncryptedPassportElement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEncryptedPassportElement (struct TdEncryptedPassportElement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEncryptedPassportElement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  delete[]var->data_.data;
  TdDestroyObject (var->front_side_);
  TdDestroyObject (var->reverse_side_);
  TdDestroyObject (var->selfie_);
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    TdDestroyObject (var->translation_->data[i500]);
  }
  delete[] var->translation_->data;
  delete var->translation_;
  for (int i600 = 0; i600 < var->files_->len; i600++) {
    TdDestroyObject (var->files_->data[i600]);
  }
  delete[] var->files_->data;
  delete var->files_;
  free (var->value_);
  free (var->hash_);
  delete var;
}
void TdStackStorerEncryptedPassportElement (struct TdEncryptedPassportElement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEncryptedPassportElement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EncryptedPassportElement");
  M->new_field ("ID");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  M->pack_bytes (var->data_.data, var->data_.len);
  M->new_field ("data_");
  TdStackStorer (var->front_side_, M);
  M->new_field ("front_side_");
  TdStackStorer (var->reverse_side_, M);
  M->new_field ("reverse_side_");
  TdStackStorer (var->selfie_, M);
  M->new_field ("selfie_");
  M->new_array ();
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    TdStackStorer (var->translation_->data[i500], M);
    M->new_arr_field (i500);
  }
  M->new_field ("translation_");
  M->new_array ();
  for (int i600 = 0; i600 < var->files_->len; i600++) {
    TdStackStorer (var->files_->data[i600], M);
    M->new_arr_field (i600);
  }
  M->new_field ("files_");
  M->pack_string (var->value_);
  M->new_field ("value_");
  M->pack_string (var->hash_);
  M->new_field ("hash_");
}
struct TdEncryptedPassportElement *TdStackFetcherEncryptedPassportElement (struct TdStackFetcherMethods *M) {
  auto res = new TdEncryptedPassportElement ();
  res->ID = CODE_EncryptedPassportElement;
  res->refcnt = 1;
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherPassportElementType (M);
  }
  M->pop ();
  M->get_field ("data_");
  res->data_.data = M->get_bytes (&res->data_.len);
  M->pop ();
  M->get_field ("front_side_");
  if (M->is_nil ()) {
    res->front_side_ = nullptr;
  } else {
    res->front_side_ = TdStackFetcherDatedFile (M);
  }
  M->pop ();
  M->get_field ("reverse_side_");
  if (M->is_nil ()) {
    res->reverse_side_ = nullptr;
  } else {
    res->reverse_side_ = TdStackFetcherDatedFile (M);
  }
  M->pop ();
  M->get_field ("selfie_");
  if (M->is_nil ()) {
    res->selfie_ = nullptr;
  } else {
    res->selfie_ = TdStackFetcherDatedFile (M);
  }
  M->pop ();
  M->get_field ("translation_");
  res->translation_ = new TdVectorDatedFile ();
  res->translation_->len = M->get_arr_size ();
  res->translation_->data = new struct TdDatedFile * [res->translation_->len];
  for (int i500 = 0; i500 < res->translation_->len; i500++) {
    M->get_arr_field (i500);
    if (M->is_nil ()) {
      res->translation_->data[i500] = nullptr;
    } else {
      res->translation_->data[i500] = TdStackFetcherDatedFile (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("files_");
  res->files_ = new TdVectorDatedFile ();
  res->files_->len = M->get_arr_size ();
  res->files_->data = new struct TdDatedFile * [res->files_->len];
  for (int i600 = 0; i600 < res->files_->len; i600++) {
    M->get_arr_field (i600);
    if (M->is_nil ()) {
      res->files_->data[i600] = nullptr;
    } else {
      res->files_->data[i600] = TdStackFetcherDatedFile (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("value_");
  res->value_ = M->get_string ();
  M->pop ();
  M->get_field ("hash_");
  res->hash_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdError *TdCreateObjectError (int code_, char *message_) {
  auto var = new struct TdError ();
  var->ID = CODE_Error;
  var->refcnt = 1;
  var->code_ = code_;
  var->message_ = (message_) ? td::str_dup (td::Slice (message_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::error> TdConvertToInternal (struct TdError *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->code_;
  std::string v100;
  v100 = (var->message_) ? var->message_: "";
  return td::td_api::make_object<td::td_api::error>(std::move (v0), std::move (v100));
}
struct TdError *TdConvertFromInternal (const td::td_api::error &from) {
  auto res = new TdError ();
  res->ID = CODE_Error;
  res->refcnt = 1;
  res->code_ = from.code_;
  res->message_ = (from.message_.length ()) ? td::str_dup (from.message_) : nullptr;
  return res;
}
char *TdSerializeError (struct TdError *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdError *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectError (struct TdError *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdError *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->message_);
  delete var;
}
void TdStackStorerError (struct TdError *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdError *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Error");
  M->new_field ("ID");
  M->pack_long (var->code_);
  M->new_field ("code_");
  M->pack_string (var->message_);
  M->new_field ("message_");
}
struct TdError *TdStackFetcherError (struct TdStackFetcherMethods *M) {
  auto res = new TdError ();
  res->ID = CODE_Error;
  res->refcnt = 1;
  M->get_field ("code_");
  res->code_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("message_");
  res->message_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdFile *TdCreateObjectFile (int id_, int size_, int expected_size_, struct TdLocalFile *local_, struct TdRemoteFile *remote_) {
  auto var = new struct TdFile ();
  var->ID = CODE_File;
  var->refcnt = 1;
  var->id_ = id_;
  var->size_ = size_;
  var->expected_size_ = expected_size_;
  var->local_ = local_;
  var->remote_ = remote_;
  return var;
}
td::td_api::object_ptr<td::td_api::file> TdConvertToInternal (struct TdFile *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->size_;
  std::int32_t v200;
  v200 = var->expected_size_;
  td::td_api::object_ptr<td::td_api::localFile> v300;
  v300 = TdConvertToInternal (var->local_);
  td::td_api::object_ptr<td::td_api::remoteFile> v400;
  v400 = TdConvertToInternal (var->remote_);
  return td::td_api::make_object<td::td_api::file>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdFile *TdConvertFromInternal (const td::td_api::file &from) {
  auto res = new TdFile ();
  res->ID = CODE_File;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->size_ = from.size_;
  res->expected_size_ = from.expected_size_;
  if (!from.local_) {
    res->local_ = nullptr;
  } else {
    res->local_ = TdConvertFromInternal (static_cast<const td::td_api::localFile &>(*from.local_));
  }
  if (!from.remote_) {
    res->remote_ = nullptr;
  } else {
    res->remote_ = TdConvertFromInternal (static_cast<const td::td_api::remoteFile &>(*from.remote_));
  }
  return res;
}
char *TdSerializeFile (struct TdFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFile (struct TdFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->local_);
  TdDestroyObject (var->remote_);
  delete var;
}
void TdStackStorerFile (struct TdFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("File");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->size_);
  M->new_field ("size_");
  M->pack_long (var->expected_size_);
  M->new_field ("expected_size_");
  TdStackStorer (var->local_, M);
  M->new_field ("local_");
  TdStackStorer (var->remote_, M);
  M->new_field ("remote_");
}
struct TdFile *TdStackFetcherFile (struct TdStackFetcherMethods *M) {
  auto res = new TdFile ();
  res->ID = CODE_File;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("size_");
  res->size_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("expected_size_");
  res->expected_size_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("local_");
  if (M->is_nil ()) {
    res->local_ = nullptr;
  } else {
    res->local_ = TdStackFetcherLocalFile (M);
  }
  M->pop ();
  M->get_field ("remote_");
  if (M->is_nil ()) {
    res->remote_ = nullptr;
  } else {
    res->remote_ = TdStackFetcherRemoteFile (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::FileType> TdConvertToInternal (struct TdFileType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_FileTypeNone: return TdConvertToInternal ((struct TdFileTypeNone *)var);
    case CODE_FileTypeAnimation: return TdConvertToInternal ((struct TdFileTypeAnimation *)var);
    case CODE_FileTypeAudio: return TdConvertToInternal ((struct TdFileTypeAudio *)var);
    case CODE_FileTypeDocument: return TdConvertToInternal ((struct TdFileTypeDocument *)var);
    case CODE_FileTypePhoto: return TdConvertToInternal ((struct TdFileTypePhoto *)var);
    case CODE_FileTypeProfilePhoto: return TdConvertToInternal ((struct TdFileTypeProfilePhoto *)var);
    case CODE_FileTypeSecret: return TdConvertToInternal ((struct TdFileTypeSecret *)var);
    case CODE_FileTypeSecretThumbnail: return TdConvertToInternal ((struct TdFileTypeSecretThumbnail *)var);
    case CODE_FileTypeSecure: return TdConvertToInternal ((struct TdFileTypeSecure *)var);
    case CODE_FileTypeSticker: return TdConvertToInternal ((struct TdFileTypeSticker *)var);
    case CODE_FileTypeThumbnail: return TdConvertToInternal ((struct TdFileTypeThumbnail *)var);
    case CODE_FileTypeUnknown: return TdConvertToInternal ((struct TdFileTypeUnknown *)var);
    case CODE_FileTypeVideo: return TdConvertToInternal ((struct TdFileTypeVideo *)var);
    case CODE_FileTypeVideoNote: return TdConvertToInternal ((struct TdFileTypeVideoNote *)var);
    case CODE_FileTypeVoiceNote: return TdConvertToInternal ((struct TdFileTypeVoiceNote *)var);
    case CODE_FileTypeWallpaper: return TdConvertToInternal ((struct TdFileTypeWallpaper *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdFileType *TdConvertFromInternal (const td::td_api::FileType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_FileTypeNone: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeNone &>(from));
    case CODE_FileTypeAnimation: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeAnimation &>(from));
    case CODE_FileTypeAudio: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeAudio &>(from));
    case CODE_FileTypeDocument: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeDocument &>(from));
    case CODE_FileTypePhoto: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypePhoto &>(from));
    case CODE_FileTypeProfilePhoto: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeProfilePhoto &>(from));
    case CODE_FileTypeSecret: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeSecret &>(from));
    case CODE_FileTypeSecretThumbnail: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeSecretThumbnail &>(from));
    case CODE_FileTypeSecure: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeSecure &>(from));
    case CODE_FileTypeSticker: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeSticker &>(from));
    case CODE_FileTypeThumbnail: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeThumbnail &>(from));
    case CODE_FileTypeUnknown: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeUnknown &>(from));
    case CODE_FileTypeVideo: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeVideo &>(from));
    case CODE_FileTypeVideoNote: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeVideoNote &>(from));
    case CODE_FileTypeVoiceNote: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeVoiceNote &>(from));
    case CODE_FileTypeWallpaper: return (struct TdFileType *)TdConvertFromInternal(static_cast<const td::td_api::fileTypeWallpaper &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeFileType (struct TdFileType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileType (struct TdFileType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_FileTypeNone: return TdDestroyObject ((struct TdFileTypeNone *)var);
    case CODE_FileTypeAnimation: return TdDestroyObject ((struct TdFileTypeAnimation *)var);
    case CODE_FileTypeAudio: return TdDestroyObject ((struct TdFileTypeAudio *)var);
    case CODE_FileTypeDocument: return TdDestroyObject ((struct TdFileTypeDocument *)var);
    case CODE_FileTypePhoto: return TdDestroyObject ((struct TdFileTypePhoto *)var);
    case CODE_FileTypeProfilePhoto: return TdDestroyObject ((struct TdFileTypeProfilePhoto *)var);
    case CODE_FileTypeSecret: return TdDestroyObject ((struct TdFileTypeSecret *)var);
    case CODE_FileTypeSecretThumbnail: return TdDestroyObject ((struct TdFileTypeSecretThumbnail *)var);
    case CODE_FileTypeSecure: return TdDestroyObject ((struct TdFileTypeSecure *)var);
    case CODE_FileTypeSticker: return TdDestroyObject ((struct TdFileTypeSticker *)var);
    case CODE_FileTypeThumbnail: return TdDestroyObject ((struct TdFileTypeThumbnail *)var);
    case CODE_FileTypeUnknown: return TdDestroyObject ((struct TdFileTypeUnknown *)var);
    case CODE_FileTypeVideo: return TdDestroyObject ((struct TdFileTypeVideo *)var);
    case CODE_FileTypeVideoNote: return TdDestroyObject ((struct TdFileTypeVideoNote *)var);
    case CODE_FileTypeVoiceNote: return TdDestroyObject ((struct TdFileTypeVoiceNote *)var);
    case CODE_FileTypeWallpaper: return TdDestroyObject ((struct TdFileTypeWallpaper *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerFileType (struct TdFileType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_FileTypeNone: return TdStackStorer ((struct TdFileTypeNone *)var, M);
    case CODE_FileTypeAnimation: return TdStackStorer ((struct TdFileTypeAnimation *)var, M);
    case CODE_FileTypeAudio: return TdStackStorer ((struct TdFileTypeAudio *)var, M);
    case CODE_FileTypeDocument: return TdStackStorer ((struct TdFileTypeDocument *)var, M);
    case CODE_FileTypePhoto: return TdStackStorer ((struct TdFileTypePhoto *)var, M);
    case CODE_FileTypeProfilePhoto: return TdStackStorer ((struct TdFileTypeProfilePhoto *)var, M);
    case CODE_FileTypeSecret: return TdStackStorer ((struct TdFileTypeSecret *)var, M);
    case CODE_FileTypeSecretThumbnail: return TdStackStorer ((struct TdFileTypeSecretThumbnail *)var, M);
    case CODE_FileTypeSecure: return TdStackStorer ((struct TdFileTypeSecure *)var, M);
    case CODE_FileTypeSticker: return TdStackStorer ((struct TdFileTypeSticker *)var, M);
    case CODE_FileTypeThumbnail: return TdStackStorer ((struct TdFileTypeThumbnail *)var, M);
    case CODE_FileTypeUnknown: return TdStackStorer ((struct TdFileTypeUnknown *)var, M);
    case CODE_FileTypeVideo: return TdStackStorer ((struct TdFileTypeVideo *)var, M);
    case CODE_FileTypeVideoNote: return TdStackStorer ((struct TdFileTypeVideoNote *)var, M);
    case CODE_FileTypeVoiceNote: return TdStackStorer ((struct TdFileTypeVoiceNote *)var, M);
    case CODE_FileTypeWallpaper: return TdStackStorer ((struct TdFileTypeWallpaper *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdFileType *TdStackFetcherFileType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "FileTypeNone") {
    return (struct TdFileType *)TdStackFetcherFileTypeNone (M);
  }
  if (constructor == "FileTypeAnimation") {
    return (struct TdFileType *)TdStackFetcherFileTypeAnimation (M);
  }
  if (constructor == "FileTypeAudio") {
    return (struct TdFileType *)TdStackFetcherFileTypeAudio (M);
  }
  if (constructor == "FileTypeDocument") {
    return (struct TdFileType *)TdStackFetcherFileTypeDocument (M);
  }
  if (constructor == "FileTypePhoto") {
    return (struct TdFileType *)TdStackFetcherFileTypePhoto (M);
  }
  if (constructor == "FileTypeProfilePhoto") {
    return (struct TdFileType *)TdStackFetcherFileTypeProfilePhoto (M);
  }
  if (constructor == "FileTypeSecret") {
    return (struct TdFileType *)TdStackFetcherFileTypeSecret (M);
  }
  if (constructor == "FileTypeSecretThumbnail") {
    return (struct TdFileType *)TdStackFetcherFileTypeSecretThumbnail (M);
  }
  if (constructor == "FileTypeSecure") {
    return (struct TdFileType *)TdStackFetcherFileTypeSecure (M);
  }
  if (constructor == "FileTypeSticker") {
    return (struct TdFileType *)TdStackFetcherFileTypeSticker (M);
  }
  if (constructor == "FileTypeThumbnail") {
    return (struct TdFileType *)TdStackFetcherFileTypeThumbnail (M);
  }
  if (constructor == "FileTypeUnknown") {
    return (struct TdFileType *)TdStackFetcherFileTypeUnknown (M);
  }
  if (constructor == "FileTypeVideo") {
    return (struct TdFileType *)TdStackFetcherFileTypeVideo (M);
  }
  if (constructor == "FileTypeVideoNote") {
    return (struct TdFileType *)TdStackFetcherFileTypeVideoNote (M);
  }
  if (constructor == "FileTypeVoiceNote") {
    return (struct TdFileType *)TdStackFetcherFileTypeVoiceNote (M);
  }
  if (constructor == "FileTypeWallpaper") {
    return (struct TdFileType *)TdStackFetcherFileTypeWallpaper (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdFileTypeNone *TdCreateObjectFileTypeNone (void) {
  auto var = new struct TdFileTypeNone ();
  var->ID = CODE_FileTypeNone;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeNone> TdConvertToInternal (struct TdFileTypeNone *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeNone>();
}
struct TdFileTypeNone *TdConvertFromInternal (const td::td_api::fileTypeNone &from) {
  auto res = new TdFileTypeNone ();
  res->ID = CODE_FileTypeNone;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeNone (struct TdFileTypeNone *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeNone *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeNone (struct TdFileTypeNone *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeNone *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeNone (struct TdFileTypeNone *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeNone *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeNone");
  M->new_field ("ID");
}
struct TdFileTypeNone *TdStackFetcherFileTypeNone (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeNone ();
  res->ID = CODE_FileTypeNone;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeAnimation *TdCreateObjectFileTypeAnimation (void) {
  auto var = new struct TdFileTypeAnimation ();
  var->ID = CODE_FileTypeAnimation;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeAnimation> TdConvertToInternal (struct TdFileTypeAnimation *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeAnimation>();
}
struct TdFileTypeAnimation *TdConvertFromInternal (const td::td_api::fileTypeAnimation &from) {
  auto res = new TdFileTypeAnimation ();
  res->ID = CODE_FileTypeAnimation;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeAnimation (struct TdFileTypeAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeAnimation (struct TdFileTypeAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeAnimation (struct TdFileTypeAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeAnimation");
  M->new_field ("ID");
}
struct TdFileTypeAnimation *TdStackFetcherFileTypeAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeAnimation ();
  res->ID = CODE_FileTypeAnimation;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeAudio *TdCreateObjectFileTypeAudio (void) {
  auto var = new struct TdFileTypeAudio ();
  var->ID = CODE_FileTypeAudio;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeAudio> TdConvertToInternal (struct TdFileTypeAudio *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeAudio>();
}
struct TdFileTypeAudio *TdConvertFromInternal (const td::td_api::fileTypeAudio &from) {
  auto res = new TdFileTypeAudio ();
  res->ID = CODE_FileTypeAudio;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeAudio (struct TdFileTypeAudio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeAudio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeAudio (struct TdFileTypeAudio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeAudio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeAudio (struct TdFileTypeAudio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeAudio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeAudio");
  M->new_field ("ID");
}
struct TdFileTypeAudio *TdStackFetcherFileTypeAudio (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeAudio ();
  res->ID = CODE_FileTypeAudio;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeDocument *TdCreateObjectFileTypeDocument (void) {
  auto var = new struct TdFileTypeDocument ();
  var->ID = CODE_FileTypeDocument;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeDocument> TdConvertToInternal (struct TdFileTypeDocument *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeDocument>();
}
struct TdFileTypeDocument *TdConvertFromInternal (const td::td_api::fileTypeDocument &from) {
  auto res = new TdFileTypeDocument ();
  res->ID = CODE_FileTypeDocument;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeDocument (struct TdFileTypeDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeDocument (struct TdFileTypeDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeDocument (struct TdFileTypeDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeDocument");
  M->new_field ("ID");
}
struct TdFileTypeDocument *TdStackFetcherFileTypeDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeDocument ();
  res->ID = CODE_FileTypeDocument;
  res->refcnt = 1;
  return res;
}
struct TdFileTypePhoto *TdCreateObjectFileTypePhoto (void) {
  auto var = new struct TdFileTypePhoto ();
  var->ID = CODE_FileTypePhoto;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypePhoto> TdConvertToInternal (struct TdFileTypePhoto *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypePhoto>();
}
struct TdFileTypePhoto *TdConvertFromInternal (const td::td_api::fileTypePhoto &from) {
  auto res = new TdFileTypePhoto ();
  res->ID = CODE_FileTypePhoto;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypePhoto (struct TdFileTypePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypePhoto (struct TdFileTypePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypePhoto (struct TdFileTypePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypePhoto");
  M->new_field ("ID");
}
struct TdFileTypePhoto *TdStackFetcherFileTypePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypePhoto ();
  res->ID = CODE_FileTypePhoto;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeProfilePhoto *TdCreateObjectFileTypeProfilePhoto (void) {
  auto var = new struct TdFileTypeProfilePhoto ();
  var->ID = CODE_FileTypeProfilePhoto;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeProfilePhoto> TdConvertToInternal (struct TdFileTypeProfilePhoto *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeProfilePhoto>();
}
struct TdFileTypeProfilePhoto *TdConvertFromInternal (const td::td_api::fileTypeProfilePhoto &from) {
  auto res = new TdFileTypeProfilePhoto ();
  res->ID = CODE_FileTypeProfilePhoto;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeProfilePhoto (struct TdFileTypeProfilePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeProfilePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeProfilePhoto (struct TdFileTypeProfilePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeProfilePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeProfilePhoto (struct TdFileTypeProfilePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeProfilePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeProfilePhoto");
  M->new_field ("ID");
}
struct TdFileTypeProfilePhoto *TdStackFetcherFileTypeProfilePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeProfilePhoto ();
  res->ID = CODE_FileTypeProfilePhoto;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeSecret *TdCreateObjectFileTypeSecret (void) {
  auto var = new struct TdFileTypeSecret ();
  var->ID = CODE_FileTypeSecret;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeSecret> TdConvertToInternal (struct TdFileTypeSecret *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeSecret>();
}
struct TdFileTypeSecret *TdConvertFromInternal (const td::td_api::fileTypeSecret &from) {
  auto res = new TdFileTypeSecret ();
  res->ID = CODE_FileTypeSecret;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeSecret (struct TdFileTypeSecret *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeSecret *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeSecret (struct TdFileTypeSecret *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeSecret *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeSecret (struct TdFileTypeSecret *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeSecret *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeSecret");
  M->new_field ("ID");
}
struct TdFileTypeSecret *TdStackFetcherFileTypeSecret (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeSecret ();
  res->ID = CODE_FileTypeSecret;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeSecretThumbnail *TdCreateObjectFileTypeSecretThumbnail (void) {
  auto var = new struct TdFileTypeSecretThumbnail ();
  var->ID = CODE_FileTypeSecretThumbnail;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeSecretThumbnail> TdConvertToInternal (struct TdFileTypeSecretThumbnail *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeSecretThumbnail>();
}
struct TdFileTypeSecretThumbnail *TdConvertFromInternal (const td::td_api::fileTypeSecretThumbnail &from) {
  auto res = new TdFileTypeSecretThumbnail ();
  res->ID = CODE_FileTypeSecretThumbnail;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeSecretThumbnail (struct TdFileTypeSecretThumbnail *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeSecretThumbnail *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeSecretThumbnail (struct TdFileTypeSecretThumbnail *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeSecretThumbnail *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeSecretThumbnail (struct TdFileTypeSecretThumbnail *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeSecretThumbnail *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeSecretThumbnail");
  M->new_field ("ID");
}
struct TdFileTypeSecretThumbnail *TdStackFetcherFileTypeSecretThumbnail (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeSecretThumbnail ();
  res->ID = CODE_FileTypeSecretThumbnail;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeSecure *TdCreateObjectFileTypeSecure (void) {
  auto var = new struct TdFileTypeSecure ();
  var->ID = CODE_FileTypeSecure;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeSecure> TdConvertToInternal (struct TdFileTypeSecure *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeSecure>();
}
struct TdFileTypeSecure *TdConvertFromInternal (const td::td_api::fileTypeSecure &from) {
  auto res = new TdFileTypeSecure ();
  res->ID = CODE_FileTypeSecure;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeSecure (struct TdFileTypeSecure *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeSecure *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeSecure (struct TdFileTypeSecure *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeSecure *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeSecure (struct TdFileTypeSecure *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeSecure *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeSecure");
  M->new_field ("ID");
}
struct TdFileTypeSecure *TdStackFetcherFileTypeSecure (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeSecure ();
  res->ID = CODE_FileTypeSecure;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeSticker *TdCreateObjectFileTypeSticker (void) {
  auto var = new struct TdFileTypeSticker ();
  var->ID = CODE_FileTypeSticker;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeSticker> TdConvertToInternal (struct TdFileTypeSticker *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeSticker>();
}
struct TdFileTypeSticker *TdConvertFromInternal (const td::td_api::fileTypeSticker &from) {
  auto res = new TdFileTypeSticker ();
  res->ID = CODE_FileTypeSticker;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeSticker (struct TdFileTypeSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeSticker (struct TdFileTypeSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeSticker (struct TdFileTypeSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeSticker");
  M->new_field ("ID");
}
struct TdFileTypeSticker *TdStackFetcherFileTypeSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeSticker ();
  res->ID = CODE_FileTypeSticker;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeThumbnail *TdCreateObjectFileTypeThumbnail (void) {
  auto var = new struct TdFileTypeThumbnail ();
  var->ID = CODE_FileTypeThumbnail;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeThumbnail> TdConvertToInternal (struct TdFileTypeThumbnail *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeThumbnail>();
}
struct TdFileTypeThumbnail *TdConvertFromInternal (const td::td_api::fileTypeThumbnail &from) {
  auto res = new TdFileTypeThumbnail ();
  res->ID = CODE_FileTypeThumbnail;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeThumbnail (struct TdFileTypeThumbnail *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeThumbnail *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeThumbnail (struct TdFileTypeThumbnail *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeThumbnail *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeThumbnail (struct TdFileTypeThumbnail *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeThumbnail *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeThumbnail");
  M->new_field ("ID");
}
struct TdFileTypeThumbnail *TdStackFetcherFileTypeThumbnail (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeThumbnail ();
  res->ID = CODE_FileTypeThumbnail;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeUnknown *TdCreateObjectFileTypeUnknown (void) {
  auto var = new struct TdFileTypeUnknown ();
  var->ID = CODE_FileTypeUnknown;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeUnknown> TdConvertToInternal (struct TdFileTypeUnknown *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeUnknown>();
}
struct TdFileTypeUnknown *TdConvertFromInternal (const td::td_api::fileTypeUnknown &from) {
  auto res = new TdFileTypeUnknown ();
  res->ID = CODE_FileTypeUnknown;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeUnknown (struct TdFileTypeUnknown *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeUnknown *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeUnknown (struct TdFileTypeUnknown *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeUnknown *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeUnknown (struct TdFileTypeUnknown *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeUnknown *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeUnknown");
  M->new_field ("ID");
}
struct TdFileTypeUnknown *TdStackFetcherFileTypeUnknown (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeUnknown ();
  res->ID = CODE_FileTypeUnknown;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeVideo *TdCreateObjectFileTypeVideo (void) {
  auto var = new struct TdFileTypeVideo ();
  var->ID = CODE_FileTypeVideo;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeVideo> TdConvertToInternal (struct TdFileTypeVideo *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeVideo>();
}
struct TdFileTypeVideo *TdConvertFromInternal (const td::td_api::fileTypeVideo &from) {
  auto res = new TdFileTypeVideo ();
  res->ID = CODE_FileTypeVideo;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeVideo (struct TdFileTypeVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeVideo (struct TdFileTypeVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeVideo (struct TdFileTypeVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeVideo");
  M->new_field ("ID");
}
struct TdFileTypeVideo *TdStackFetcherFileTypeVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeVideo ();
  res->ID = CODE_FileTypeVideo;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeVideoNote *TdCreateObjectFileTypeVideoNote (void) {
  auto var = new struct TdFileTypeVideoNote ();
  var->ID = CODE_FileTypeVideoNote;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeVideoNote> TdConvertToInternal (struct TdFileTypeVideoNote *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeVideoNote>();
}
struct TdFileTypeVideoNote *TdConvertFromInternal (const td::td_api::fileTypeVideoNote &from) {
  auto res = new TdFileTypeVideoNote ();
  res->ID = CODE_FileTypeVideoNote;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeVideoNote (struct TdFileTypeVideoNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeVideoNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeVideoNote (struct TdFileTypeVideoNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeVideoNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeVideoNote (struct TdFileTypeVideoNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeVideoNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeVideoNote");
  M->new_field ("ID");
}
struct TdFileTypeVideoNote *TdStackFetcherFileTypeVideoNote (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeVideoNote ();
  res->ID = CODE_FileTypeVideoNote;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeVoiceNote *TdCreateObjectFileTypeVoiceNote (void) {
  auto var = new struct TdFileTypeVoiceNote ();
  var->ID = CODE_FileTypeVoiceNote;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeVoiceNote> TdConvertToInternal (struct TdFileTypeVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeVoiceNote>();
}
struct TdFileTypeVoiceNote *TdConvertFromInternal (const td::td_api::fileTypeVoiceNote &from) {
  auto res = new TdFileTypeVoiceNote ();
  res->ID = CODE_FileTypeVoiceNote;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeVoiceNote (struct TdFileTypeVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeVoiceNote (struct TdFileTypeVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeVoiceNote (struct TdFileTypeVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeVoiceNote");
  M->new_field ("ID");
}
struct TdFileTypeVoiceNote *TdStackFetcherFileTypeVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeVoiceNote ();
  res->ID = CODE_FileTypeVoiceNote;
  res->refcnt = 1;
  return res;
}
struct TdFileTypeWallpaper *TdCreateObjectFileTypeWallpaper (void) {
  auto var = new struct TdFileTypeWallpaper ();
  var->ID = CODE_FileTypeWallpaper;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::fileTypeWallpaper> TdConvertToInternal (struct TdFileTypeWallpaper *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::fileTypeWallpaper>();
}
struct TdFileTypeWallpaper *TdConvertFromInternal (const td::td_api::fileTypeWallpaper &from) {
  auto res = new TdFileTypeWallpaper ();
  res->ID = CODE_FileTypeWallpaper;
  res->refcnt = 1;
  return res;
}
char *TdSerializeFileTypeWallpaper (struct TdFileTypeWallpaper *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFileTypeWallpaper *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFileTypeWallpaper (struct TdFileTypeWallpaper *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFileTypeWallpaper *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerFileTypeWallpaper (struct TdFileTypeWallpaper *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFileTypeWallpaper *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FileTypeWallpaper");
  M->new_field ("ID");
}
struct TdFileTypeWallpaper *TdStackFetcherFileTypeWallpaper (struct TdStackFetcherMethods *M) {
  auto res = new TdFileTypeWallpaper ();
  res->ID = CODE_FileTypeWallpaper;
  res->refcnt = 1;
  return res;
}
struct TdFormattedText *TdCreateObjectFormattedText (char *text_, struct TdVectorTextEntity *entities_) {
  auto var = new struct TdFormattedText ();
  var->ID = CODE_FormattedText;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  var->entities_ = entities_;
  return var;
}
td::td_api::object_ptr<td::td_api::formattedText> TdConvertToInternal (struct TdFormattedText *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  std::vector<td::td_api::object_ptr<td::td_api::textEntity>> v100;
  for (int i100 = 0; i100 < var->entities_->len; i100++) {
    td::td_api::object_ptr<td::td_api::textEntity> v101;
    v101 = TdConvertToInternal (var->entities_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::formattedText>(std::move (v0), std::move (v100));
}
struct TdFormattedText *TdConvertFromInternal (const td::td_api::formattedText &from) {
  auto res = new TdFormattedText ();
  res->ID = CODE_FormattedText;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  res->entities_ = new TdVectorTextEntity ();
  res->entities_->len = (int)from.entities_.size ();
  res->entities_->data = new struct TdTextEntity * [res->entities_->len];
  for (int i100 = 0; i100 < res->entities_->len; i100++) {
    if (!from.entities_[i100]) {
      res->entities_->data[i100] = nullptr;
    } else {
      res->entities_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::textEntity &>(*from.entities_[i100]));
    }
  }
  return res;
}
char *TdSerializeFormattedText (struct TdFormattedText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFormattedText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFormattedText (struct TdFormattedText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFormattedText *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  for (int i100 = 0; i100 < var->entities_->len; i100++) {
    TdDestroyObject (var->entities_->data[i100]);
  }
  delete[] var->entities_->data;
  delete var->entities_;
  delete var;
}
void TdStackStorerFormattedText (struct TdFormattedText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFormattedText *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FormattedText");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
  M->new_array ();
  for (int i100 = 0; i100 < var->entities_->len; i100++) {
    TdStackStorer (var->entities_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("entities_");
}
struct TdFormattedText *TdStackFetcherFormattedText (struct TdStackFetcherMethods *M) {
  auto res = new TdFormattedText ();
  res->ID = CODE_FormattedText;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  M->get_field ("entities_");
  res->entities_ = new TdVectorTextEntity ();
  res->entities_->len = M->get_arr_size ();
  res->entities_->data = new struct TdTextEntity * [res->entities_->len];
  for (int i100 = 0; i100 < res->entities_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->entities_->data[i100] = nullptr;
    } else {
      res->entities_->data[i100] = TdStackFetcherTextEntity (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdFoundMessages *TdCreateObjectFoundMessages (struct TdVectorMessage *messages_, long long next_from_search_id_) {
  auto var = new struct TdFoundMessages ();
  var->ID = CODE_FoundMessages;
  var->refcnt = 1;
  var->messages_ = messages_;
  var->next_from_search_id_ = next_from_search_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::foundMessages> TdConvertToInternal (struct TdFoundMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::message>> v0;
  for (int i0 = 0; i0 < var->messages_->len; i0++) {
    td::td_api::object_ptr<td::td_api::message> v1;
    v1 = TdConvertToInternal (var->messages_->data[i0]);
    v0.push_back (std::move (v1));
  }
  std::int64_t v100;
  v100 = var->next_from_search_id_;
  return td::td_api::make_object<td::td_api::foundMessages>(std::move (v0), std::move (v100));
}
struct TdFoundMessages *TdConvertFromInternal (const td::td_api::foundMessages &from) {
  auto res = new TdFoundMessages ();
  res->ID = CODE_FoundMessages;
  res->refcnt = 1;
  res->messages_ = new TdVectorMessage ();
  res->messages_->len = (int)from.messages_.size ();
  res->messages_->data = new struct TdMessage * [res->messages_->len];
  for (int i0 = 0; i0 < res->messages_->len; i0++) {
    if (!from.messages_[i0]) {
      res->messages_->data[i0] = nullptr;
    } else {
      res->messages_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.messages_[i0]));
    }
  }
  res->next_from_search_id_ = from.next_from_search_id_;
  return res;
}
char *TdSerializeFoundMessages (struct TdFoundMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFoundMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFoundMessages (struct TdFoundMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFoundMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->messages_->len; i0++) {
    TdDestroyObject (var->messages_->data[i0]);
  }
  delete[] var->messages_->data;
  delete var->messages_;
  delete var;
}
void TdStackStorerFoundMessages (struct TdFoundMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFoundMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FoundMessages");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->messages_->len; i0++) {
    TdStackStorer (var->messages_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("messages_");
  M->pack_long (var->next_from_search_id_);
  M->new_field ("next_from_search_id_");
}
struct TdFoundMessages *TdStackFetcherFoundMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdFoundMessages ();
  res->ID = CODE_FoundMessages;
  res->refcnt = 1;
  M->get_field ("messages_");
  res->messages_ = new TdVectorMessage ();
  res->messages_->len = M->get_arr_size ();
  res->messages_->data = new struct TdMessage * [res->messages_->len];
  for (int i0 = 0; i0 < res->messages_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->messages_->data[i0] = nullptr;
    } else {
      res->messages_->data[i0] = TdStackFetcherMessage (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("next_from_search_id_");
  res->next_from_search_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGame *TdCreateObjectGame (long long id_, char *short_name_, char *title_, struct TdFormattedText *text_, char *description_, struct TdPhoto *photo_, struct TdAnimation *animation_) {
  auto var = new struct TdGame ();
  var->ID = CODE_Game;
  var->refcnt = 1;
  var->id_ = id_;
  var->short_name_ = (short_name_) ? td::str_dup (td::Slice (short_name_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->text_ = text_;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->photo_ = photo_;
  var->animation_ = animation_;
  return var;
}
td::td_api::object_ptr<td::td_api::game> TdConvertToInternal (struct TdGame *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->short_name_) ? var->short_name_: "";
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  td::td_api::object_ptr<td::td_api::formattedText> v300;
  v300 = TdConvertToInternal (var->text_);
  std::string v400;
  v400 = (var->description_) ? var->description_: "";
  td::td_api::object_ptr<td::td_api::photo> v500;
  v500 = TdConvertToInternal (var->photo_);
  td::td_api::object_ptr<td::td_api::animation> v600;
  v600 = TdConvertToInternal (var->animation_);
  return td::td_api::make_object<td::td_api::game>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdGame *TdConvertFromInternal (const td::td_api::game &from) {
  auto res = new TdGame ();
  res->ID = CODE_Game;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->short_name_ = (from.short_name_.length ()) ? td::str_dup (from.short_name_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.text_));
  }
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.photo_));
  }
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::animation &>(*from.animation_));
  }
  return res;
}
char *TdSerializeGame (struct TdGame *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGame *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGame (struct TdGame *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGame *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->short_name_);
  free (var->title_);
  TdDestroyObject (var->text_);
  free (var->description_);
  TdDestroyObject (var->photo_);
  TdDestroyObject (var->animation_);
  delete var;
}
void TdStackStorerGame (struct TdGame *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGame *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Game");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->short_name_);
  M->new_field ("short_name_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
}
struct TdGame *TdStackFetcherGame (struct TdStackFetcherMethods *M) {
  auto res = new TdGame ();
  res->ID = CODE_Game;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("short_name_");
  res->short_name_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherAnimation (M);
  }
  M->pop ();
  return res;
}
struct TdGameHighScore *TdCreateObjectGameHighScore (int position_, int user_id_, int score_) {
  auto var = new struct TdGameHighScore ();
  var->ID = CODE_GameHighScore;
  var->refcnt = 1;
  var->position_ = position_;
  var->user_id_ = user_id_;
  var->score_ = score_;
  return var;
}
td::td_api::object_ptr<td::td_api::gameHighScore> TdConvertToInternal (struct TdGameHighScore *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->position_;
  std::int32_t v100;
  v100 = var->user_id_;
  std::int32_t v200;
  v200 = var->score_;
  return td::td_api::make_object<td::td_api::gameHighScore>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGameHighScore *TdConvertFromInternal (const td::td_api::gameHighScore &from) {
  auto res = new TdGameHighScore ();
  res->ID = CODE_GameHighScore;
  res->refcnt = 1;
  res->position_ = from.position_;
  res->user_id_ = from.user_id_;
  res->score_ = from.score_;
  return res;
}
char *TdSerializeGameHighScore (struct TdGameHighScore *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGameHighScore *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGameHighScore (struct TdGameHighScore *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGameHighScore *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGameHighScore (struct TdGameHighScore *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGameHighScore *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GameHighScore");
  M->new_field ("ID");
  M->pack_long (var->position_);
  M->new_field ("position_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_long (var->score_);
  M->new_field ("score_");
}
struct TdGameHighScore *TdStackFetcherGameHighScore (struct TdStackFetcherMethods *M) {
  auto res = new TdGameHighScore ();
  res->ID = CODE_GameHighScore;
  res->refcnt = 1;
  M->get_field ("position_");
  res->position_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("score_");
  res->score_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGameHighScores *TdCreateObjectGameHighScores (struct TdVectorGameHighScore *scores_) {
  auto var = new struct TdGameHighScores ();
  var->ID = CODE_GameHighScores;
  var->refcnt = 1;
  var->scores_ = scores_;
  return var;
}
td::td_api::object_ptr<td::td_api::gameHighScores> TdConvertToInternal (struct TdGameHighScores *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::gameHighScore>> v0;
  for (int i0 = 0; i0 < var->scores_->len; i0++) {
    td::td_api::object_ptr<td::td_api::gameHighScore> v1;
    v1 = TdConvertToInternal (var->scores_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::gameHighScores>(std::move (v0));
}
struct TdGameHighScores *TdConvertFromInternal (const td::td_api::gameHighScores &from) {
  auto res = new TdGameHighScores ();
  res->ID = CODE_GameHighScores;
  res->refcnt = 1;
  res->scores_ = new TdVectorGameHighScore ();
  res->scores_->len = (int)from.scores_.size ();
  res->scores_->data = new struct TdGameHighScore * [res->scores_->len];
  for (int i0 = 0; i0 < res->scores_->len; i0++) {
    if (!from.scores_[i0]) {
      res->scores_->data[i0] = nullptr;
    } else {
      res->scores_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::gameHighScore &>(*from.scores_[i0]));
    }
  }
  return res;
}
char *TdSerializeGameHighScores (struct TdGameHighScores *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGameHighScores *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGameHighScores (struct TdGameHighScores *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGameHighScores *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->scores_->len; i0++) {
    TdDestroyObject (var->scores_->data[i0]);
  }
  delete[] var->scores_->data;
  delete var->scores_;
  delete var;
}
void TdStackStorerGameHighScores (struct TdGameHighScores *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGameHighScores *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GameHighScores");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->scores_->len; i0++) {
    TdStackStorer (var->scores_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("scores_");
}
struct TdGameHighScores *TdStackFetcherGameHighScores (struct TdStackFetcherMethods *M) {
  auto res = new TdGameHighScores ();
  res->ID = CODE_GameHighScores;
  res->refcnt = 1;
  M->get_field ("scores_");
  res->scores_ = new TdVectorGameHighScore ();
  res->scores_->len = M->get_arr_size ();
  res->scores_->data = new struct TdGameHighScore * [res->scores_->len];
  for (int i0 = 0; i0 < res->scores_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->scores_->data[i0] = nullptr;
    } else {
      res->scores_->data[i0] = TdStackFetcherGameHighScore (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdHashtags *TdCreateObjectHashtags (struct TdVectorString *hashtags_) {
  auto var = new struct TdHashtags ();
  var->ID = CODE_Hashtags;
  var->refcnt = 1;
  var->hashtags_ = hashtags_;
  return var;
}
td::td_api::object_ptr<td::td_api::hashtags> TdConvertToInternal (struct TdHashtags *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::string> v0;
  for (int i0 = 0; i0 < var->hashtags_->len; i0++) {
    std::string v1;
    v1 = (var->hashtags_->data[i0]) ? var->hashtags_->data[i0]: "";
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::hashtags>(std::move (v0));
}
struct TdHashtags *TdConvertFromInternal (const td::td_api::hashtags &from) {
  auto res = new TdHashtags ();
  res->ID = CODE_Hashtags;
  res->refcnt = 1;
  res->hashtags_ = new TdVectorString ();
  res->hashtags_->len = (int)from.hashtags_.size ();
  res->hashtags_->data = new char * [res->hashtags_->len];
  for (int i0 = 0; i0 < res->hashtags_->len; i0++) {
    res->hashtags_->data[i0] = (from.hashtags_[i0].length ()) ? td::str_dup (from.hashtags_[i0]) : nullptr;
  }
  return res;
}
char *TdSerializeHashtags (struct TdHashtags *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdHashtags *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectHashtags (struct TdHashtags *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdHashtags *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->hashtags_->len; i0++) {
    free (var->hashtags_->data[i0]);
  }
  delete[] var->hashtags_->data;
  delete var->hashtags_;
  delete var;
}
void TdStackStorerHashtags (struct TdHashtags *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdHashtags *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Hashtags");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->hashtags_->len; i0++) {
    M->pack_string (var->hashtags_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("hashtags_");
}
struct TdHashtags *TdStackFetcherHashtags (struct TdStackFetcherMethods *M) {
  auto res = new TdHashtags ();
  res->ID = CODE_Hashtags;
  res->refcnt = 1;
  M->get_field ("hashtags_");
  res->hashtags_ = new TdVectorString ();
  res->hashtags_->len = M->get_arr_size ();
  res->hashtags_->data = new char * [res->hashtags_->len];
  for (int i0 = 0; i0 < res->hashtags_->len; i0++) {
    M->get_arr_field (i0);
    res->hashtags_->data[i0] = M->get_string ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdIdentityDocument *TdCreateObjectIdentityDocument (char *number_, struct TdDate *expiry_date_, struct TdDatedFile *front_side_, struct TdDatedFile *reverse_side_, struct TdDatedFile *selfie_, struct TdVectorDatedFile *translation_) {
  auto var = new struct TdIdentityDocument ();
  var->ID = CODE_IdentityDocument;
  var->refcnt = 1;
  var->number_ = (number_) ? td::str_dup (td::Slice (number_)) : nullptr;
  var->expiry_date_ = expiry_date_;
  var->front_side_ = front_side_;
  var->reverse_side_ = reverse_side_;
  var->selfie_ = selfie_;
  var->translation_ = translation_;
  return var;
}
td::td_api::object_ptr<td::td_api::identityDocument> TdConvertToInternal (struct TdIdentityDocument *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->number_) ? var->number_: "";
  td::td_api::object_ptr<td::td_api::date> v100;
  v100 = TdConvertToInternal (var->expiry_date_);
  td::td_api::object_ptr<td::td_api::datedFile> v200;
  v200 = TdConvertToInternal (var->front_side_);
  td::td_api::object_ptr<td::td_api::datedFile> v300;
  v300 = TdConvertToInternal (var->reverse_side_);
  td::td_api::object_ptr<td::td_api::datedFile> v400;
  v400 = TdConvertToInternal (var->selfie_);
  std::vector<td::td_api::object_ptr<td::td_api::datedFile>> v500;
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    td::td_api::object_ptr<td::td_api::datedFile> v501;
    v501 = TdConvertToInternal (var->translation_->data[i500]);
    v500.push_back (std::move (v501));
  }
  return td::td_api::make_object<td::td_api::identityDocument>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdIdentityDocument *TdConvertFromInternal (const td::td_api::identityDocument &from) {
  auto res = new TdIdentityDocument ();
  res->ID = CODE_IdentityDocument;
  res->refcnt = 1;
  res->number_ = (from.number_.length ()) ? td::str_dup (from.number_) : nullptr;
  if (!from.expiry_date_) {
    res->expiry_date_ = nullptr;
  } else {
    res->expiry_date_ = TdConvertFromInternal (static_cast<const td::td_api::date &>(*from.expiry_date_));
  }
  if (!from.front_side_) {
    res->front_side_ = nullptr;
  } else {
    res->front_side_ = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.front_side_));
  }
  if (!from.reverse_side_) {
    res->reverse_side_ = nullptr;
  } else {
    res->reverse_side_ = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.reverse_side_));
  }
  if (!from.selfie_) {
    res->selfie_ = nullptr;
  } else {
    res->selfie_ = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.selfie_));
  }
  res->translation_ = new TdVectorDatedFile ();
  res->translation_->len = (int)from.translation_.size ();
  res->translation_->data = new struct TdDatedFile * [res->translation_->len];
  for (int i500 = 0; i500 < res->translation_->len; i500++) {
    if (!from.translation_[i500]) {
      res->translation_->data[i500] = nullptr;
    } else {
      res->translation_->data[i500] = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.translation_[i500]));
    }
  }
  return res;
}
char *TdSerializeIdentityDocument (struct TdIdentityDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdIdentityDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectIdentityDocument (struct TdIdentityDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdIdentityDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->number_);
  TdDestroyObject (var->expiry_date_);
  TdDestroyObject (var->front_side_);
  TdDestroyObject (var->reverse_side_);
  TdDestroyObject (var->selfie_);
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    TdDestroyObject (var->translation_->data[i500]);
  }
  delete[] var->translation_->data;
  delete var->translation_;
  delete var;
}
void TdStackStorerIdentityDocument (struct TdIdentityDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdIdentityDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("IdentityDocument");
  M->new_field ("ID");
  M->pack_string (var->number_);
  M->new_field ("number_");
  TdStackStorer (var->expiry_date_, M);
  M->new_field ("expiry_date_");
  TdStackStorer (var->front_side_, M);
  M->new_field ("front_side_");
  TdStackStorer (var->reverse_side_, M);
  M->new_field ("reverse_side_");
  TdStackStorer (var->selfie_, M);
  M->new_field ("selfie_");
  M->new_array ();
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    TdStackStorer (var->translation_->data[i500], M);
    M->new_arr_field (i500);
  }
  M->new_field ("translation_");
}
struct TdIdentityDocument *TdStackFetcherIdentityDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdIdentityDocument ();
  res->ID = CODE_IdentityDocument;
  res->refcnt = 1;
  M->get_field ("number_");
  res->number_ = M->get_string ();
  M->pop ();
  M->get_field ("expiry_date_");
  if (M->is_nil ()) {
    res->expiry_date_ = nullptr;
  } else {
    res->expiry_date_ = TdStackFetcherDate (M);
  }
  M->pop ();
  M->get_field ("front_side_");
  if (M->is_nil ()) {
    res->front_side_ = nullptr;
  } else {
    res->front_side_ = TdStackFetcherDatedFile (M);
  }
  M->pop ();
  M->get_field ("reverse_side_");
  if (M->is_nil ()) {
    res->reverse_side_ = nullptr;
  } else {
    res->reverse_side_ = TdStackFetcherDatedFile (M);
  }
  M->pop ();
  M->get_field ("selfie_");
  if (M->is_nil ()) {
    res->selfie_ = nullptr;
  } else {
    res->selfie_ = TdStackFetcherDatedFile (M);
  }
  M->pop ();
  M->get_field ("translation_");
  res->translation_ = new TdVectorDatedFile ();
  res->translation_->len = M->get_arr_size ();
  res->translation_->data = new struct TdDatedFile * [res->translation_->len];
  for (int i500 = 0; i500 < res->translation_->len; i500++) {
    M->get_arr_field (i500);
    if (M->is_nil ()) {
      res->translation_->data[i500] = nullptr;
    } else {
      res->translation_->data[i500] = TdStackFetcherDatedFile (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdImportedContacts *TdCreateObjectImportedContacts (struct TdVectorInt *user_ids_, struct TdVectorInt *importer_count_) {
  auto var = new struct TdImportedContacts ();
  var->ID = CODE_ImportedContacts;
  var->refcnt = 1;
  var->user_ids_ = user_ids_;
  var->importer_count_ = importer_count_;
  return var;
}
td::td_api::object_ptr<td::td_api::importedContacts> TdConvertToInternal (struct TdImportedContacts *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    std::int32_t v1;
    v1 = var->user_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  std::vector<std::int32_t> v100;
  for (int i100 = 0; i100 < var->importer_count_->len; i100++) {
    std::int32_t v101;
    v101 = var->importer_count_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::importedContacts>(std::move (v0), std::move (v100));
}
struct TdImportedContacts *TdConvertFromInternal (const td::td_api::importedContacts &from) {
  auto res = new TdImportedContacts ();
  res->ID = CODE_ImportedContacts;
  res->refcnt = 1;
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = (int)from.user_ids_.size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    res->user_ids_->data[i0] = from.user_ids_[i0];
  }
  res->importer_count_ = new TdVectorInt ();
  res->importer_count_->len = (int)from.importer_count_.size ();
  res->importer_count_->data = new int  [res->importer_count_->len];
  for (int i100 = 0; i100 < res->importer_count_->len; i100++) {
    res->importer_count_->data[i100] = from.importer_count_[i100];
  }
  return res;
}
char *TdSerializeImportedContacts (struct TdImportedContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdImportedContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectImportedContacts (struct TdImportedContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdImportedContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
  }
  delete[] var->user_ids_->data;
  delete var->user_ids_;
  for (int i100 = 0; i100 < var->importer_count_->len; i100++) {
  }
  delete[] var->importer_count_->data;
  delete var->importer_count_;
  delete var;
}
void TdStackStorerImportedContacts (struct TdImportedContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdImportedContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ImportedContacts");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    M->pack_long (var->user_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("user_ids_");
  M->new_array ();
  for (int i100 = 0; i100 < var->importer_count_->len; i100++) {
    M->pack_long (var->importer_count_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("importer_count_");
}
struct TdImportedContacts *TdStackFetcherImportedContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdImportedContacts ();
  res->ID = CODE_ImportedContacts;
  res->refcnt = 1;
  M->get_field ("user_ids_");
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = M->get_arr_size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->user_ids_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("importer_count_");
  res->importer_count_ = new TdVectorInt ();
  res->importer_count_->len = M->get_arr_size ();
  res->importer_count_->data = new int  [res->importer_count_->len];
  for (int i100 = 0; i100 < res->importer_count_->len; i100++) {
    M->get_arr_field (i100);
    res->importer_count_->data[i100] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdInlineKeyboardButton *TdCreateObjectInlineKeyboardButton (char *text_, struct TdInlineKeyboardButtonType *type_) {
  auto var = new struct TdInlineKeyboardButton ();
  var->ID = CODE_InlineKeyboardButton;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineKeyboardButton> TdConvertToInternal (struct TdInlineKeyboardButton *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  td::td_api::object_ptr<td::td_api::InlineKeyboardButtonType> v100;
  v100 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::inlineKeyboardButton>(std::move (v0), std::move (v100));
}
struct TdInlineKeyboardButton *TdConvertFromInternal (const td::td_api::inlineKeyboardButton &from) {
  auto res = new TdInlineKeyboardButton ();
  res->ID = CODE_InlineKeyboardButton;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::InlineKeyboardButtonType &>(*from.type_));
  }
  return res;
}
char *TdSerializeInlineKeyboardButton (struct TdInlineKeyboardButton *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineKeyboardButton *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineKeyboardButton (struct TdInlineKeyboardButton *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineKeyboardButton *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerInlineKeyboardButton (struct TdInlineKeyboardButton *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineKeyboardButton *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineKeyboardButton");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdInlineKeyboardButton *TdStackFetcherInlineKeyboardButton (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineKeyboardButton ();
  res->ID = CODE_InlineKeyboardButton;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherInlineKeyboardButtonType (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::InlineKeyboardButtonType> TdConvertToInternal (struct TdInlineKeyboardButtonType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InlineKeyboardButtonTypeUrl: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeUrl *)var);
    case CODE_InlineKeyboardButtonTypeCallback: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeCallback *)var);
    case CODE_InlineKeyboardButtonTypeCallbackGame: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeCallbackGame *)var);
    case CODE_InlineKeyboardButtonTypeSwitchInline: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeSwitchInline *)var);
    case CODE_InlineKeyboardButtonTypeBuy: return TdConvertToInternal ((struct TdInlineKeyboardButtonTypeBuy *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdInlineKeyboardButtonType *TdConvertFromInternal (const td::td_api::InlineKeyboardButtonType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_InlineKeyboardButtonTypeUrl: return (struct TdInlineKeyboardButtonType *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeUrl &>(from));
    case CODE_InlineKeyboardButtonTypeCallback: return (struct TdInlineKeyboardButtonType *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeCallback &>(from));
    case CODE_InlineKeyboardButtonTypeCallbackGame: return (struct TdInlineKeyboardButtonType *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeCallbackGame &>(from));
    case CODE_InlineKeyboardButtonTypeSwitchInline: return (struct TdInlineKeyboardButtonType *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeSwitchInline &>(from));
    case CODE_InlineKeyboardButtonTypeBuy: return (struct TdInlineKeyboardButtonType *)TdConvertFromInternal(static_cast<const td::td_api::inlineKeyboardButtonTypeBuy &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeInlineKeyboardButtonType (struct TdInlineKeyboardButtonType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineKeyboardButtonType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineKeyboardButtonType (struct TdInlineKeyboardButtonType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineKeyboardButtonType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InlineKeyboardButtonTypeUrl: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeUrl *)var);
    case CODE_InlineKeyboardButtonTypeCallback: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeCallback *)var);
    case CODE_InlineKeyboardButtonTypeCallbackGame: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeCallbackGame *)var);
    case CODE_InlineKeyboardButtonTypeSwitchInline: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeSwitchInline *)var);
    case CODE_InlineKeyboardButtonTypeBuy: return TdDestroyObject ((struct TdInlineKeyboardButtonTypeBuy *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerInlineKeyboardButtonType (struct TdInlineKeyboardButtonType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineKeyboardButtonType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InlineKeyboardButtonTypeUrl: return TdStackStorer ((struct TdInlineKeyboardButtonTypeUrl *)var, M);
    case CODE_InlineKeyboardButtonTypeCallback: return TdStackStorer ((struct TdInlineKeyboardButtonTypeCallback *)var, M);
    case CODE_InlineKeyboardButtonTypeCallbackGame: return TdStackStorer ((struct TdInlineKeyboardButtonTypeCallbackGame *)var, M);
    case CODE_InlineKeyboardButtonTypeSwitchInline: return TdStackStorer ((struct TdInlineKeyboardButtonTypeSwitchInline *)var, M);
    case CODE_InlineKeyboardButtonTypeBuy: return TdStackStorer ((struct TdInlineKeyboardButtonTypeBuy *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdInlineKeyboardButtonType *TdStackFetcherInlineKeyboardButtonType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "InlineKeyboardButtonTypeUrl") {
    return (struct TdInlineKeyboardButtonType *)TdStackFetcherInlineKeyboardButtonTypeUrl (M);
  }
  if (constructor == "InlineKeyboardButtonTypeCallback") {
    return (struct TdInlineKeyboardButtonType *)TdStackFetcherInlineKeyboardButtonTypeCallback (M);
  }
  if (constructor == "InlineKeyboardButtonTypeCallbackGame") {
    return (struct TdInlineKeyboardButtonType *)TdStackFetcherInlineKeyboardButtonTypeCallbackGame (M);
  }
  if (constructor == "InlineKeyboardButtonTypeSwitchInline") {
    return (struct TdInlineKeyboardButtonType *)TdStackFetcherInlineKeyboardButtonTypeSwitchInline (M);
  }
  if (constructor == "InlineKeyboardButtonTypeBuy") {
    return (struct TdInlineKeyboardButtonType *)TdStackFetcherInlineKeyboardButtonTypeBuy (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdInlineKeyboardButtonTypeUrl *TdCreateObjectInlineKeyboardButtonTypeUrl (char *url_) {
  auto var = new struct TdInlineKeyboardButtonTypeUrl ();
  var->ID = CODE_InlineKeyboardButtonTypeUrl;
  var->refcnt = 1;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineKeyboardButtonTypeUrl> TdConvertToInternal (struct TdInlineKeyboardButtonTypeUrl *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->url_) ? var->url_: "";
  return td::td_api::make_object<td::td_api::inlineKeyboardButtonTypeUrl>(std::move (v0));
}
struct TdInlineKeyboardButtonTypeUrl *TdConvertFromInternal (const td::td_api::inlineKeyboardButtonTypeUrl &from) {
  auto res = new TdInlineKeyboardButtonTypeUrl ();
  res->ID = CODE_InlineKeyboardButtonTypeUrl;
  res->refcnt = 1;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  return res;
}
char *TdSerializeInlineKeyboardButtonTypeUrl (struct TdInlineKeyboardButtonTypeUrl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineKeyboardButtonTypeUrl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineKeyboardButtonTypeUrl (struct TdInlineKeyboardButtonTypeUrl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineKeyboardButtonTypeUrl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->url_);
  delete var;
}
void TdStackStorerInlineKeyboardButtonTypeUrl (struct TdInlineKeyboardButtonTypeUrl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineKeyboardButtonTypeUrl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineKeyboardButtonTypeUrl");
  M->new_field ("ID");
  M->pack_string (var->url_);
  M->new_field ("url_");
}
struct TdInlineKeyboardButtonTypeUrl *TdStackFetcherInlineKeyboardButtonTypeUrl (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineKeyboardButtonTypeUrl ();
  res->ID = CODE_InlineKeyboardButtonTypeUrl;
  res->refcnt = 1;
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInlineKeyboardButtonTypeCallback *TdCreateObjectInlineKeyboardButtonTypeCallback (struct TdBytes data_) {
  auto var = new struct TdInlineKeyboardButtonTypeCallback ();
  var->ID = CODE_InlineKeyboardButtonTypeCallback;
  var->refcnt = 1;
  var->data_ = data_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineKeyboardButtonTypeCallback> TdConvertToInternal (struct TdInlineKeyboardButtonTypeCallback *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->data_.data, var->data_.len);
  return td::td_api::make_object<td::td_api::inlineKeyboardButtonTypeCallback>(std::move (v0));
}
struct TdInlineKeyboardButtonTypeCallback *TdConvertFromInternal (const td::td_api::inlineKeyboardButtonTypeCallback &from) {
  auto res = new TdInlineKeyboardButtonTypeCallback ();
  res->ID = CODE_InlineKeyboardButtonTypeCallback;
  res->refcnt = 1;
  res->data_.len = (int)from.data_.length ();
  if (res->data_.len) {
    res->data_.data = new unsigned char[res->data_.len];
    memcpy (res->data_.data, from.data_.c_str (), res->data_.len);
  } else {
    res->data_.data = nullptr;
  }
  return res;
}
char *TdSerializeInlineKeyboardButtonTypeCallback (struct TdInlineKeyboardButtonTypeCallback *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineKeyboardButtonTypeCallback *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineKeyboardButtonTypeCallback (struct TdInlineKeyboardButtonTypeCallback *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineKeyboardButtonTypeCallback *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->data_.data;
  delete var;
}
void TdStackStorerInlineKeyboardButtonTypeCallback (struct TdInlineKeyboardButtonTypeCallback *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineKeyboardButtonTypeCallback *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineKeyboardButtonTypeCallback");
  M->new_field ("ID");
  M->pack_bytes (var->data_.data, var->data_.len);
  M->new_field ("data_");
}
struct TdInlineKeyboardButtonTypeCallback *TdStackFetcherInlineKeyboardButtonTypeCallback (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineKeyboardButtonTypeCallback ();
  res->ID = CODE_InlineKeyboardButtonTypeCallback;
  res->refcnt = 1;
  M->get_field ("data_");
  res->data_.data = M->get_bytes (&res->data_.len);
  M->pop ();
  return res;
}
struct TdInlineKeyboardButtonTypeCallbackGame *TdCreateObjectInlineKeyboardButtonTypeCallbackGame (void) {
  auto var = new struct TdInlineKeyboardButtonTypeCallbackGame ();
  var->ID = CODE_InlineKeyboardButtonTypeCallbackGame;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineKeyboardButtonTypeCallbackGame> TdConvertToInternal (struct TdInlineKeyboardButtonTypeCallbackGame *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::inlineKeyboardButtonTypeCallbackGame>();
}
struct TdInlineKeyboardButtonTypeCallbackGame *TdConvertFromInternal (const td::td_api::inlineKeyboardButtonTypeCallbackGame &from) {
  auto res = new TdInlineKeyboardButtonTypeCallbackGame ();
  res->ID = CODE_InlineKeyboardButtonTypeCallbackGame;
  res->refcnt = 1;
  return res;
}
char *TdSerializeInlineKeyboardButtonTypeCallbackGame (struct TdInlineKeyboardButtonTypeCallbackGame *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineKeyboardButtonTypeCallbackGame *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineKeyboardButtonTypeCallbackGame (struct TdInlineKeyboardButtonTypeCallbackGame *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineKeyboardButtonTypeCallbackGame *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerInlineKeyboardButtonTypeCallbackGame (struct TdInlineKeyboardButtonTypeCallbackGame *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineKeyboardButtonTypeCallbackGame *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineKeyboardButtonTypeCallbackGame");
  M->new_field ("ID");
}
struct TdInlineKeyboardButtonTypeCallbackGame *TdStackFetcherInlineKeyboardButtonTypeCallbackGame (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineKeyboardButtonTypeCallbackGame ();
  res->ID = CODE_InlineKeyboardButtonTypeCallbackGame;
  res->refcnt = 1;
  return res;
}
struct TdInlineKeyboardButtonTypeSwitchInline *TdCreateObjectInlineKeyboardButtonTypeSwitchInline (char *query_, int in_current_chat_) {
  auto var = new struct TdInlineKeyboardButtonTypeSwitchInline ();
  var->ID = CODE_InlineKeyboardButtonTypeSwitchInline;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->in_current_chat_ = in_current_chat_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineKeyboardButtonTypeSwitchInline> TdConvertToInternal (struct TdInlineKeyboardButtonTypeSwitchInline *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  bool v100;
  v100 = var->in_current_chat_ != 0;
  return td::td_api::make_object<td::td_api::inlineKeyboardButtonTypeSwitchInline>(std::move (v0), std::move (v100));
}
struct TdInlineKeyboardButtonTypeSwitchInline *TdConvertFromInternal (const td::td_api::inlineKeyboardButtonTypeSwitchInline &from) {
  auto res = new TdInlineKeyboardButtonTypeSwitchInline ();
  res->ID = CODE_InlineKeyboardButtonTypeSwitchInline;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->in_current_chat_ = from.in_current_chat_;
  return res;
}
char *TdSerializeInlineKeyboardButtonTypeSwitchInline (struct TdInlineKeyboardButtonTypeSwitchInline *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineKeyboardButtonTypeSwitchInline *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineKeyboardButtonTypeSwitchInline (struct TdInlineKeyboardButtonTypeSwitchInline *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineKeyboardButtonTypeSwitchInline *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerInlineKeyboardButtonTypeSwitchInline (struct TdInlineKeyboardButtonTypeSwitchInline *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineKeyboardButtonTypeSwitchInline *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineKeyboardButtonTypeSwitchInline");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_bool (var->in_current_chat_);
  M->new_field ("in_current_chat_");
}
struct TdInlineKeyboardButtonTypeSwitchInline *TdStackFetcherInlineKeyboardButtonTypeSwitchInline (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineKeyboardButtonTypeSwitchInline ();
  res->ID = CODE_InlineKeyboardButtonTypeSwitchInline;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("in_current_chat_");
  res->in_current_chat_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInlineKeyboardButtonTypeBuy *TdCreateObjectInlineKeyboardButtonTypeBuy (void) {
  auto var = new struct TdInlineKeyboardButtonTypeBuy ();
  var->ID = CODE_InlineKeyboardButtonTypeBuy;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineKeyboardButtonTypeBuy> TdConvertToInternal (struct TdInlineKeyboardButtonTypeBuy *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::inlineKeyboardButtonTypeBuy>();
}
struct TdInlineKeyboardButtonTypeBuy *TdConvertFromInternal (const td::td_api::inlineKeyboardButtonTypeBuy &from) {
  auto res = new TdInlineKeyboardButtonTypeBuy ();
  res->ID = CODE_InlineKeyboardButtonTypeBuy;
  res->refcnt = 1;
  return res;
}
char *TdSerializeInlineKeyboardButtonTypeBuy (struct TdInlineKeyboardButtonTypeBuy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineKeyboardButtonTypeBuy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineKeyboardButtonTypeBuy (struct TdInlineKeyboardButtonTypeBuy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineKeyboardButtonTypeBuy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerInlineKeyboardButtonTypeBuy (struct TdInlineKeyboardButtonTypeBuy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineKeyboardButtonTypeBuy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineKeyboardButtonTypeBuy");
  M->new_field ("ID");
}
struct TdInlineKeyboardButtonTypeBuy *TdStackFetcherInlineKeyboardButtonTypeBuy (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineKeyboardButtonTypeBuy ();
  res->ID = CODE_InlineKeyboardButtonTypeBuy;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::InlineQueryResult> TdConvertToInternal (struct TdInlineQueryResult *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InlineQueryResultArticle: return TdConvertToInternal ((struct TdInlineQueryResultArticle *)var);
    case CODE_InlineQueryResultContact: return TdConvertToInternal ((struct TdInlineQueryResultContact *)var);
    case CODE_InlineQueryResultLocation: return TdConvertToInternal ((struct TdInlineQueryResultLocation *)var);
    case CODE_InlineQueryResultVenue: return TdConvertToInternal ((struct TdInlineQueryResultVenue *)var);
    case CODE_InlineQueryResultGame: return TdConvertToInternal ((struct TdInlineQueryResultGame *)var);
    case CODE_InlineQueryResultAnimation: return TdConvertToInternal ((struct TdInlineQueryResultAnimation *)var);
    case CODE_InlineQueryResultAudio: return TdConvertToInternal ((struct TdInlineQueryResultAudio *)var);
    case CODE_InlineQueryResultDocument: return TdConvertToInternal ((struct TdInlineQueryResultDocument *)var);
    case CODE_InlineQueryResultPhoto: return TdConvertToInternal ((struct TdInlineQueryResultPhoto *)var);
    case CODE_InlineQueryResultSticker: return TdConvertToInternal ((struct TdInlineQueryResultSticker *)var);
    case CODE_InlineQueryResultVideo: return TdConvertToInternal ((struct TdInlineQueryResultVideo *)var);
    case CODE_InlineQueryResultVoiceNote: return TdConvertToInternal ((struct TdInlineQueryResultVoiceNote *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdInlineQueryResult *TdConvertFromInternal (const td::td_api::InlineQueryResult &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_InlineQueryResultArticle: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultArticle &>(from));
    case CODE_InlineQueryResultContact: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultContact &>(from));
    case CODE_InlineQueryResultLocation: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultLocation &>(from));
    case CODE_InlineQueryResultVenue: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultVenue &>(from));
    case CODE_InlineQueryResultGame: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultGame &>(from));
    case CODE_InlineQueryResultAnimation: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultAnimation &>(from));
    case CODE_InlineQueryResultAudio: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultAudio &>(from));
    case CODE_InlineQueryResultDocument: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultDocument &>(from));
    case CODE_InlineQueryResultPhoto: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultPhoto &>(from));
    case CODE_InlineQueryResultSticker: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultSticker &>(from));
    case CODE_InlineQueryResultVideo: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultVideo &>(from));
    case CODE_InlineQueryResultVoiceNote: return (struct TdInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inlineQueryResultVoiceNote &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeInlineQueryResult (struct TdInlineQueryResult *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResult *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResult (struct TdInlineQueryResult *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResult *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InlineQueryResultArticle: return TdDestroyObject ((struct TdInlineQueryResultArticle *)var);
    case CODE_InlineQueryResultContact: return TdDestroyObject ((struct TdInlineQueryResultContact *)var);
    case CODE_InlineQueryResultLocation: return TdDestroyObject ((struct TdInlineQueryResultLocation *)var);
    case CODE_InlineQueryResultVenue: return TdDestroyObject ((struct TdInlineQueryResultVenue *)var);
    case CODE_InlineQueryResultGame: return TdDestroyObject ((struct TdInlineQueryResultGame *)var);
    case CODE_InlineQueryResultAnimation: return TdDestroyObject ((struct TdInlineQueryResultAnimation *)var);
    case CODE_InlineQueryResultAudio: return TdDestroyObject ((struct TdInlineQueryResultAudio *)var);
    case CODE_InlineQueryResultDocument: return TdDestroyObject ((struct TdInlineQueryResultDocument *)var);
    case CODE_InlineQueryResultPhoto: return TdDestroyObject ((struct TdInlineQueryResultPhoto *)var);
    case CODE_InlineQueryResultSticker: return TdDestroyObject ((struct TdInlineQueryResultSticker *)var);
    case CODE_InlineQueryResultVideo: return TdDestroyObject ((struct TdInlineQueryResultVideo *)var);
    case CODE_InlineQueryResultVoiceNote: return TdDestroyObject ((struct TdInlineQueryResultVoiceNote *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerInlineQueryResult (struct TdInlineQueryResult *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResult *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InlineQueryResultArticle: return TdStackStorer ((struct TdInlineQueryResultArticle *)var, M);
    case CODE_InlineQueryResultContact: return TdStackStorer ((struct TdInlineQueryResultContact *)var, M);
    case CODE_InlineQueryResultLocation: return TdStackStorer ((struct TdInlineQueryResultLocation *)var, M);
    case CODE_InlineQueryResultVenue: return TdStackStorer ((struct TdInlineQueryResultVenue *)var, M);
    case CODE_InlineQueryResultGame: return TdStackStorer ((struct TdInlineQueryResultGame *)var, M);
    case CODE_InlineQueryResultAnimation: return TdStackStorer ((struct TdInlineQueryResultAnimation *)var, M);
    case CODE_InlineQueryResultAudio: return TdStackStorer ((struct TdInlineQueryResultAudio *)var, M);
    case CODE_InlineQueryResultDocument: return TdStackStorer ((struct TdInlineQueryResultDocument *)var, M);
    case CODE_InlineQueryResultPhoto: return TdStackStorer ((struct TdInlineQueryResultPhoto *)var, M);
    case CODE_InlineQueryResultSticker: return TdStackStorer ((struct TdInlineQueryResultSticker *)var, M);
    case CODE_InlineQueryResultVideo: return TdStackStorer ((struct TdInlineQueryResultVideo *)var, M);
    case CODE_InlineQueryResultVoiceNote: return TdStackStorer ((struct TdInlineQueryResultVoiceNote *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdInlineQueryResult *TdStackFetcherInlineQueryResult (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "InlineQueryResultArticle") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultArticle (M);
  }
  if (constructor == "InlineQueryResultContact") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultContact (M);
  }
  if (constructor == "InlineQueryResultLocation") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultLocation (M);
  }
  if (constructor == "InlineQueryResultVenue") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultVenue (M);
  }
  if (constructor == "InlineQueryResultGame") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultGame (M);
  }
  if (constructor == "InlineQueryResultAnimation") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultAnimation (M);
  }
  if (constructor == "InlineQueryResultAudio") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultAudio (M);
  }
  if (constructor == "InlineQueryResultDocument") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultDocument (M);
  }
  if (constructor == "InlineQueryResultPhoto") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultPhoto (M);
  }
  if (constructor == "InlineQueryResultSticker") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultSticker (M);
  }
  if (constructor == "InlineQueryResultVideo") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultVideo (M);
  }
  if (constructor == "InlineQueryResultVoiceNote") {
    return (struct TdInlineQueryResult *)TdStackFetcherInlineQueryResultVoiceNote (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdInlineQueryResultArticle *TdCreateObjectInlineQueryResultArticle (char *id_, char *url_, int hide_url_, char *title_, char *description_, struct TdPhotoSize *thumbnail_) {
  auto var = new struct TdInlineQueryResultArticle ();
  var->ID = CODE_InlineQueryResultArticle;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->hide_url_ = hide_url_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->thumbnail_ = thumbnail_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultArticle> TdConvertToInternal (struct TdInlineQueryResultArticle *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->url_) ? var->url_: "";
  bool v200;
  v200 = var->hide_url_ != 0;
  std::string v300;
  v300 = (var->title_) ? var->title_: "";
  std::string v400;
  v400 = (var->description_) ? var->description_: "";
  td::td_api::object_ptr<td::td_api::photoSize> v500;
  v500 = TdConvertToInternal (var->thumbnail_);
  return td::td_api::make_object<td::td_api::inlineQueryResultArticle>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdInlineQueryResultArticle *TdConvertFromInternal (const td::td_api::inlineQueryResultArticle &from) {
  auto res = new TdInlineQueryResultArticle ();
  res->ID = CODE_InlineQueryResultArticle;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  res->hide_url_ = from.hide_url_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  return res;
}
char *TdSerializeInlineQueryResultArticle (struct TdInlineQueryResultArticle *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultArticle *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultArticle (struct TdInlineQueryResultArticle *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultArticle *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->url_);
  free (var->title_);
  free (var->description_);
  TdDestroyObject (var->thumbnail_);
  delete var;
}
void TdStackStorerInlineQueryResultArticle (struct TdInlineQueryResultArticle *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultArticle *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultArticle");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->url_);
  M->new_field ("url_");
  M->pack_bool (var->hide_url_);
  M->new_field ("hide_url_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
}
struct TdInlineQueryResultArticle *TdStackFetcherInlineQueryResultArticle (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultArticle ();
  res->ID = CODE_InlineQueryResultArticle;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("hide_url_");
  res->hide_url_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  return res;
}
struct TdInlineQueryResultContact *TdCreateObjectInlineQueryResultContact (char *id_, struct TdContact *contact_, struct TdPhotoSize *thumbnail_) {
  auto var = new struct TdInlineQueryResultContact ();
  var->ID = CODE_InlineQueryResultContact;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->contact_ = contact_;
  var->thumbnail_ = thumbnail_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultContact> TdConvertToInternal (struct TdInlineQueryResultContact *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::contact> v100;
  v100 = TdConvertToInternal (var->contact_);
  td::td_api::object_ptr<td::td_api::photoSize> v200;
  v200 = TdConvertToInternal (var->thumbnail_);
  return td::td_api::make_object<td::td_api::inlineQueryResultContact>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInlineQueryResultContact *TdConvertFromInternal (const td::td_api::inlineQueryResultContact &from) {
  auto res = new TdInlineQueryResultContact ();
  res->ID = CODE_InlineQueryResultContact;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.contact_) {
    res->contact_ = nullptr;
  } else {
    res->contact_ = TdConvertFromInternal (static_cast<const td::td_api::contact &>(*from.contact_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  return res;
}
char *TdSerializeInlineQueryResultContact (struct TdInlineQueryResultContact *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultContact *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultContact (struct TdInlineQueryResultContact *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultContact *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->contact_);
  TdDestroyObject (var->thumbnail_);
  delete var;
}
void TdStackStorerInlineQueryResultContact (struct TdInlineQueryResultContact *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultContact *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultContact");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->contact_, M);
  M->new_field ("contact_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
}
struct TdInlineQueryResultContact *TdStackFetcherInlineQueryResultContact (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultContact ();
  res->ID = CODE_InlineQueryResultContact;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("contact_");
  if (M->is_nil ()) {
    res->contact_ = nullptr;
  } else {
    res->contact_ = TdStackFetcherContact (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  return res;
}
struct TdInlineQueryResultLocation *TdCreateObjectInlineQueryResultLocation (char *id_, struct TdLocation *location_, char *title_, struct TdPhotoSize *thumbnail_) {
  auto var = new struct TdInlineQueryResultLocation ();
  var->ID = CODE_InlineQueryResultLocation;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->location_ = location_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->thumbnail_ = thumbnail_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultLocation> TdConvertToInternal (struct TdInlineQueryResultLocation *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::location> v100;
  v100 = TdConvertToInternal (var->location_);
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  td::td_api::object_ptr<td::td_api::photoSize> v300;
  v300 = TdConvertToInternal (var->thumbnail_);
  return td::td_api::make_object<td::td_api::inlineQueryResultLocation>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdInlineQueryResultLocation *TdConvertFromInternal (const td::td_api::inlineQueryResultLocation &from) {
  auto res = new TdInlineQueryResultLocation ();
  res->ID = CODE_InlineQueryResultLocation;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.location_) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.location_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  return res;
}
char *TdSerializeInlineQueryResultLocation (struct TdInlineQueryResultLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultLocation (struct TdInlineQueryResultLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->location_);
  free (var->title_);
  TdDestroyObject (var->thumbnail_);
  delete var;
}
void TdStackStorerInlineQueryResultLocation (struct TdInlineQueryResultLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultLocation");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->location_, M);
  M->new_field ("location_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
}
struct TdInlineQueryResultLocation *TdStackFetcherInlineQueryResultLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultLocation ();
  res->ID = CODE_InlineQueryResultLocation;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("location_");
  if (M->is_nil ()) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  return res;
}
struct TdInlineQueryResultVenue *TdCreateObjectInlineQueryResultVenue (char *id_, struct TdVenue *venue_, struct TdPhotoSize *thumbnail_) {
  auto var = new struct TdInlineQueryResultVenue ();
  var->ID = CODE_InlineQueryResultVenue;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->venue_ = venue_;
  var->thumbnail_ = thumbnail_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultVenue> TdConvertToInternal (struct TdInlineQueryResultVenue *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::venue> v100;
  v100 = TdConvertToInternal (var->venue_);
  td::td_api::object_ptr<td::td_api::photoSize> v200;
  v200 = TdConvertToInternal (var->thumbnail_);
  return td::td_api::make_object<td::td_api::inlineQueryResultVenue>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInlineQueryResultVenue *TdConvertFromInternal (const td::td_api::inlineQueryResultVenue &from) {
  auto res = new TdInlineQueryResultVenue ();
  res->ID = CODE_InlineQueryResultVenue;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.venue_) {
    res->venue_ = nullptr;
  } else {
    res->venue_ = TdConvertFromInternal (static_cast<const td::td_api::venue &>(*from.venue_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  return res;
}
char *TdSerializeInlineQueryResultVenue (struct TdInlineQueryResultVenue *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultVenue *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultVenue (struct TdInlineQueryResultVenue *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultVenue *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->venue_);
  TdDestroyObject (var->thumbnail_);
  delete var;
}
void TdStackStorerInlineQueryResultVenue (struct TdInlineQueryResultVenue *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultVenue *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultVenue");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->venue_, M);
  M->new_field ("venue_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
}
struct TdInlineQueryResultVenue *TdStackFetcherInlineQueryResultVenue (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultVenue ();
  res->ID = CODE_InlineQueryResultVenue;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("venue_");
  if (M->is_nil ()) {
    res->venue_ = nullptr;
  } else {
    res->venue_ = TdStackFetcherVenue (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  return res;
}
struct TdInlineQueryResultGame *TdCreateObjectInlineQueryResultGame (char *id_, struct TdGame *game_) {
  auto var = new struct TdInlineQueryResultGame ();
  var->ID = CODE_InlineQueryResultGame;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->game_ = game_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultGame> TdConvertToInternal (struct TdInlineQueryResultGame *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::game> v100;
  v100 = TdConvertToInternal (var->game_);
  return td::td_api::make_object<td::td_api::inlineQueryResultGame>(std::move (v0), std::move (v100));
}
struct TdInlineQueryResultGame *TdConvertFromInternal (const td::td_api::inlineQueryResultGame &from) {
  auto res = new TdInlineQueryResultGame ();
  res->ID = CODE_InlineQueryResultGame;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.game_) {
    res->game_ = nullptr;
  } else {
    res->game_ = TdConvertFromInternal (static_cast<const td::td_api::game &>(*from.game_));
  }
  return res;
}
char *TdSerializeInlineQueryResultGame (struct TdInlineQueryResultGame *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultGame *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultGame (struct TdInlineQueryResultGame *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultGame *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->game_);
  delete var;
}
void TdStackStorerInlineQueryResultGame (struct TdInlineQueryResultGame *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultGame *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultGame");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->game_, M);
  M->new_field ("game_");
}
struct TdInlineQueryResultGame *TdStackFetcherInlineQueryResultGame (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultGame ();
  res->ID = CODE_InlineQueryResultGame;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("game_");
  if (M->is_nil ()) {
    res->game_ = nullptr;
  } else {
    res->game_ = TdStackFetcherGame (M);
  }
  M->pop ();
  return res;
}
struct TdInlineQueryResultAnimation *TdCreateObjectInlineQueryResultAnimation (char *id_, struct TdAnimation *animation_, char *title_) {
  auto var = new struct TdInlineQueryResultAnimation ();
  var->ID = CODE_InlineQueryResultAnimation;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->animation_ = animation_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultAnimation> TdConvertToInternal (struct TdInlineQueryResultAnimation *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::animation> v100;
  v100 = TdConvertToInternal (var->animation_);
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  return td::td_api::make_object<td::td_api::inlineQueryResultAnimation>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInlineQueryResultAnimation *TdConvertFromInternal (const td::td_api::inlineQueryResultAnimation &from) {
  auto res = new TdInlineQueryResultAnimation ();
  res->ID = CODE_InlineQueryResultAnimation;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::animation &>(*from.animation_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  return res;
}
char *TdSerializeInlineQueryResultAnimation (struct TdInlineQueryResultAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultAnimation (struct TdInlineQueryResultAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->animation_);
  free (var->title_);
  delete var;
}
void TdStackStorerInlineQueryResultAnimation (struct TdInlineQueryResultAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultAnimation");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
  M->pack_string (var->title_);
  M->new_field ("title_");
}
struct TdInlineQueryResultAnimation *TdStackFetcherInlineQueryResultAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultAnimation ();
  res->ID = CODE_InlineQueryResultAnimation;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherAnimation (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInlineQueryResultAudio *TdCreateObjectInlineQueryResultAudio (char *id_, struct TdAudio *audio_) {
  auto var = new struct TdInlineQueryResultAudio ();
  var->ID = CODE_InlineQueryResultAudio;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->audio_ = audio_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultAudio> TdConvertToInternal (struct TdInlineQueryResultAudio *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::audio> v100;
  v100 = TdConvertToInternal (var->audio_);
  return td::td_api::make_object<td::td_api::inlineQueryResultAudio>(std::move (v0), std::move (v100));
}
struct TdInlineQueryResultAudio *TdConvertFromInternal (const td::td_api::inlineQueryResultAudio &from) {
  auto res = new TdInlineQueryResultAudio ();
  res->ID = CODE_InlineQueryResultAudio;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.audio_) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdConvertFromInternal (static_cast<const td::td_api::audio &>(*from.audio_));
  }
  return res;
}
char *TdSerializeInlineQueryResultAudio (struct TdInlineQueryResultAudio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultAudio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultAudio (struct TdInlineQueryResultAudio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultAudio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->audio_);
  delete var;
}
void TdStackStorerInlineQueryResultAudio (struct TdInlineQueryResultAudio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultAudio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultAudio");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->audio_, M);
  M->new_field ("audio_");
}
struct TdInlineQueryResultAudio *TdStackFetcherInlineQueryResultAudio (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultAudio ();
  res->ID = CODE_InlineQueryResultAudio;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("audio_");
  if (M->is_nil ()) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdStackFetcherAudio (M);
  }
  M->pop ();
  return res;
}
struct TdInlineQueryResultDocument *TdCreateObjectInlineQueryResultDocument (char *id_, struct TdDocument *document_, char *title_, char *description_) {
  auto var = new struct TdInlineQueryResultDocument ();
  var->ID = CODE_InlineQueryResultDocument;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->document_ = document_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultDocument> TdConvertToInternal (struct TdInlineQueryResultDocument *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::document> v100;
  v100 = TdConvertToInternal (var->document_);
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  std::string v300;
  v300 = (var->description_) ? var->description_: "";
  return td::td_api::make_object<td::td_api::inlineQueryResultDocument>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdInlineQueryResultDocument *TdConvertFromInternal (const td::td_api::inlineQueryResultDocument &from) {
  auto res = new TdInlineQueryResultDocument ();
  res->ID = CODE_InlineQueryResultDocument;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.document_) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdConvertFromInternal (static_cast<const td::td_api::document &>(*from.document_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  return res;
}
char *TdSerializeInlineQueryResultDocument (struct TdInlineQueryResultDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultDocument (struct TdInlineQueryResultDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->document_);
  free (var->title_);
  free (var->description_);
  delete var;
}
void TdStackStorerInlineQueryResultDocument (struct TdInlineQueryResultDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultDocument");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->document_, M);
  M->new_field ("document_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
}
struct TdInlineQueryResultDocument *TdStackFetcherInlineQueryResultDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultDocument ();
  res->ID = CODE_InlineQueryResultDocument;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("document_");
  if (M->is_nil ()) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdStackFetcherDocument (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInlineQueryResultPhoto *TdCreateObjectInlineQueryResultPhoto (char *id_, struct TdPhoto *photo_, char *title_, char *description_) {
  auto var = new struct TdInlineQueryResultPhoto ();
  var->ID = CODE_InlineQueryResultPhoto;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->photo_ = photo_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultPhoto> TdConvertToInternal (struct TdInlineQueryResultPhoto *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::photo> v100;
  v100 = TdConvertToInternal (var->photo_);
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  std::string v300;
  v300 = (var->description_) ? var->description_: "";
  return td::td_api::make_object<td::td_api::inlineQueryResultPhoto>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdInlineQueryResultPhoto *TdConvertFromInternal (const td::td_api::inlineQueryResultPhoto &from) {
  auto res = new TdInlineQueryResultPhoto ();
  res->ID = CODE_InlineQueryResultPhoto;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.photo_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  return res;
}
char *TdSerializeInlineQueryResultPhoto (struct TdInlineQueryResultPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultPhoto (struct TdInlineQueryResultPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->photo_);
  free (var->title_);
  free (var->description_);
  delete var;
}
void TdStackStorerInlineQueryResultPhoto (struct TdInlineQueryResultPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultPhoto");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
}
struct TdInlineQueryResultPhoto *TdStackFetcherInlineQueryResultPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultPhoto ();
  res->ID = CODE_InlineQueryResultPhoto;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInlineQueryResultSticker *TdCreateObjectInlineQueryResultSticker (char *id_, struct TdSticker *sticker_) {
  auto var = new struct TdInlineQueryResultSticker ();
  var->ID = CODE_InlineQueryResultSticker;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultSticker> TdConvertToInternal (struct TdInlineQueryResultSticker *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::sticker> v100;
  v100 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::inlineQueryResultSticker>(std::move (v0), std::move (v100));
}
struct TdInlineQueryResultSticker *TdConvertFromInternal (const td::td_api::inlineQueryResultSticker &from) {
  auto res = new TdInlineQueryResultSticker ();
  res->ID = CODE_InlineQueryResultSticker;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::sticker &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeInlineQueryResultSticker (struct TdInlineQueryResultSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultSticker (struct TdInlineQueryResultSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerInlineQueryResultSticker (struct TdInlineQueryResultSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultSticker");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdInlineQueryResultSticker *TdStackFetcherInlineQueryResultSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultSticker ();
  res->ID = CODE_InlineQueryResultSticker;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherSticker (M);
  }
  M->pop ();
  return res;
}
struct TdInlineQueryResultVideo *TdCreateObjectInlineQueryResultVideo (char *id_, struct TdVideo *video_, char *title_, char *description_) {
  auto var = new struct TdInlineQueryResultVideo ();
  var->ID = CODE_InlineQueryResultVideo;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->video_ = video_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultVideo> TdConvertToInternal (struct TdInlineQueryResultVideo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::video> v100;
  v100 = TdConvertToInternal (var->video_);
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  std::string v300;
  v300 = (var->description_) ? var->description_: "";
  return td::td_api::make_object<td::td_api::inlineQueryResultVideo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdInlineQueryResultVideo *TdConvertFromInternal (const td::td_api::inlineQueryResultVideo &from) {
  auto res = new TdInlineQueryResultVideo ();
  res->ID = CODE_InlineQueryResultVideo;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.video_) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdConvertFromInternal (static_cast<const td::td_api::video &>(*from.video_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  return res;
}
char *TdSerializeInlineQueryResultVideo (struct TdInlineQueryResultVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultVideo (struct TdInlineQueryResultVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->video_);
  free (var->title_);
  free (var->description_);
  delete var;
}
void TdStackStorerInlineQueryResultVideo (struct TdInlineQueryResultVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultVideo");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->video_, M);
  M->new_field ("video_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
}
struct TdInlineQueryResultVideo *TdStackFetcherInlineQueryResultVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultVideo ();
  res->ID = CODE_InlineQueryResultVideo;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("video_");
  if (M->is_nil ()) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdStackFetcherVideo (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInlineQueryResultVoiceNote *TdCreateObjectInlineQueryResultVoiceNote (char *id_, struct TdVoiceNote *voice_note_, char *title_) {
  auto var = new struct TdInlineQueryResultVoiceNote ();
  var->ID = CODE_InlineQueryResultVoiceNote;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->voice_note_ = voice_note_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResultVoiceNote> TdConvertToInternal (struct TdInlineQueryResultVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::voiceNote> v100;
  v100 = TdConvertToInternal (var->voice_note_);
  std::string v200;
  v200 = (var->title_) ? var->title_: "";
  return td::td_api::make_object<td::td_api::inlineQueryResultVoiceNote>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInlineQueryResultVoiceNote *TdConvertFromInternal (const td::td_api::inlineQueryResultVoiceNote &from) {
  auto res = new TdInlineQueryResultVoiceNote ();
  res->ID = CODE_InlineQueryResultVoiceNote;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.voice_note_) {
    res->voice_note_ = nullptr;
  } else {
    res->voice_note_ = TdConvertFromInternal (static_cast<const td::td_api::voiceNote &>(*from.voice_note_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  return res;
}
char *TdSerializeInlineQueryResultVoiceNote (struct TdInlineQueryResultVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResultVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResultVoiceNote (struct TdInlineQueryResultVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResultVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->voice_note_);
  free (var->title_);
  delete var;
}
void TdStackStorerInlineQueryResultVoiceNote (struct TdInlineQueryResultVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResultVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResultVoiceNote");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->voice_note_, M);
  M->new_field ("voice_note_");
  M->pack_string (var->title_);
  M->new_field ("title_");
}
struct TdInlineQueryResultVoiceNote *TdStackFetcherInlineQueryResultVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResultVoiceNote ();
  res->ID = CODE_InlineQueryResultVoiceNote;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("voice_note_");
  if (M->is_nil ()) {
    res->voice_note_ = nullptr;
  } else {
    res->voice_note_ = TdStackFetcherVoiceNote (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInlineQueryResults *TdCreateObjectInlineQueryResults (long long inline_query_id_, char *next_offset_, struct TdVectorInlineQueryResult *results_, char *switch_pm_text_, char *switch_pm_parameter_) {
  auto var = new struct TdInlineQueryResults ();
  var->ID = CODE_InlineQueryResults;
  var->refcnt = 1;
  var->inline_query_id_ = inline_query_id_;
  var->next_offset_ = (next_offset_) ? td::str_dup (td::Slice (next_offset_)) : nullptr;
  var->results_ = results_;
  var->switch_pm_text_ = (switch_pm_text_) ? td::str_dup (td::Slice (switch_pm_text_)) : nullptr;
  var->switch_pm_parameter_ = (switch_pm_parameter_) ? td::str_dup (td::Slice (switch_pm_parameter_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inlineQueryResults> TdConvertToInternal (struct TdInlineQueryResults *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->inline_query_id_;
  std::string v100;
  v100 = (var->next_offset_) ? var->next_offset_: "";
  std::vector<td::td_api::object_ptr<td::td_api::InlineQueryResult>> v200;
  for (int i200 = 0; i200 < var->results_->len; i200++) {
    td::td_api::object_ptr<td::td_api::InlineQueryResult> v201;
    v201 = TdConvertToInternal (var->results_->data[i200]);
    v200.push_back (std::move (v201));
  }
  std::string v300;
  v300 = (var->switch_pm_text_) ? var->switch_pm_text_: "";
  std::string v400;
  v400 = (var->switch_pm_parameter_) ? var->switch_pm_parameter_: "";
  return td::td_api::make_object<td::td_api::inlineQueryResults>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdInlineQueryResults *TdConvertFromInternal (const td::td_api::inlineQueryResults &from) {
  auto res = new TdInlineQueryResults ();
  res->ID = CODE_InlineQueryResults;
  res->refcnt = 1;
  res->inline_query_id_ = from.inline_query_id_;
  res->next_offset_ = (from.next_offset_.length ()) ? td::str_dup (from.next_offset_) : nullptr;
  res->results_ = new TdVectorInlineQueryResult ();
  res->results_->len = (int)from.results_.size ();
  res->results_->data = new struct TdInlineQueryResult * [res->results_->len];
  for (int i200 = 0; i200 < res->results_->len; i200++) {
    if (!from.results_[i200]) {
      res->results_->data[i200] = nullptr;
    } else {
      res->results_->data[i200] = TdConvertFromInternal (static_cast<const td::td_api::InlineQueryResult &>(*from.results_[i200]));
    }
  }
  res->switch_pm_text_ = (from.switch_pm_text_.length ()) ? td::str_dup (from.switch_pm_text_) : nullptr;
  res->switch_pm_parameter_ = (from.switch_pm_parameter_.length ()) ? td::str_dup (from.switch_pm_parameter_) : nullptr;
  return res;
}
char *TdSerializeInlineQueryResults (struct TdInlineQueryResults *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInlineQueryResults *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInlineQueryResults (struct TdInlineQueryResults *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInlineQueryResults *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->next_offset_);
  for (int i200 = 0; i200 < var->results_->len; i200++) {
    TdDestroyObject (var->results_->data[i200]);
  }
  delete[] var->results_->data;
  delete var->results_;
  free (var->switch_pm_text_);
  free (var->switch_pm_parameter_);
  delete var;
}
void TdStackStorerInlineQueryResults (struct TdInlineQueryResults *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInlineQueryResults *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InlineQueryResults");
  M->new_field ("ID");
  M->pack_long (var->inline_query_id_);
  M->new_field ("inline_query_id_");
  M->pack_string (var->next_offset_);
  M->new_field ("next_offset_");
  M->new_array ();
  for (int i200 = 0; i200 < var->results_->len; i200++) {
    TdStackStorer (var->results_->data[i200], M);
    M->new_arr_field (i200);
  }
  M->new_field ("results_");
  M->pack_string (var->switch_pm_text_);
  M->new_field ("switch_pm_text_");
  M->pack_string (var->switch_pm_parameter_);
  M->new_field ("switch_pm_parameter_");
}
struct TdInlineQueryResults *TdStackFetcherInlineQueryResults (struct TdStackFetcherMethods *M) {
  auto res = new TdInlineQueryResults ();
  res->ID = CODE_InlineQueryResults;
  res->refcnt = 1;
  M->get_field ("inline_query_id_");
  res->inline_query_id_ = M->get_long ();
  M->pop ();
  M->get_field ("next_offset_");
  res->next_offset_ = M->get_string ();
  M->pop ();
  M->get_field ("results_");
  res->results_ = new TdVectorInlineQueryResult ();
  res->results_->len = M->get_arr_size ();
  res->results_->data = new struct TdInlineQueryResult * [res->results_->len];
  for (int i200 = 0; i200 < res->results_->len; i200++) {
    M->get_arr_field (i200);
    if (M->is_nil ()) {
      res->results_->data[i200] = nullptr;
    } else {
      res->results_->data[i200] = TdStackFetcherInlineQueryResult (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("switch_pm_text_");
  res->switch_pm_text_ = M->get_string ();
  M->pop ();
  M->get_field ("switch_pm_parameter_");
  res->switch_pm_parameter_ = M->get_string ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::InputCredentials> TdConvertToInternal (struct TdInputCredentials *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputCredentialsSaved: return TdConvertToInternal ((struct TdInputCredentialsSaved *)var);
    case CODE_InputCredentialsNew: return TdConvertToInternal ((struct TdInputCredentialsNew *)var);
    case CODE_InputCredentialsAndroidPay: return TdConvertToInternal ((struct TdInputCredentialsAndroidPay *)var);
    case CODE_InputCredentialsApplePay: return TdConvertToInternal ((struct TdInputCredentialsApplePay *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdInputCredentials *TdConvertFromInternal (const td::td_api::InputCredentials &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_InputCredentialsSaved: return (struct TdInputCredentials *)TdConvertFromInternal(static_cast<const td::td_api::inputCredentialsSaved &>(from));
    case CODE_InputCredentialsNew: return (struct TdInputCredentials *)TdConvertFromInternal(static_cast<const td::td_api::inputCredentialsNew &>(from));
    case CODE_InputCredentialsAndroidPay: return (struct TdInputCredentials *)TdConvertFromInternal(static_cast<const td::td_api::inputCredentialsAndroidPay &>(from));
    case CODE_InputCredentialsApplePay: return (struct TdInputCredentials *)TdConvertFromInternal(static_cast<const td::td_api::inputCredentialsApplePay &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeInputCredentials (struct TdInputCredentials *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputCredentials *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputCredentials (struct TdInputCredentials *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputCredentials *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputCredentialsSaved: return TdDestroyObject ((struct TdInputCredentialsSaved *)var);
    case CODE_InputCredentialsNew: return TdDestroyObject ((struct TdInputCredentialsNew *)var);
    case CODE_InputCredentialsAndroidPay: return TdDestroyObject ((struct TdInputCredentialsAndroidPay *)var);
    case CODE_InputCredentialsApplePay: return TdDestroyObject ((struct TdInputCredentialsApplePay *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerInputCredentials (struct TdInputCredentials *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputCredentials *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputCredentialsSaved: return TdStackStorer ((struct TdInputCredentialsSaved *)var, M);
    case CODE_InputCredentialsNew: return TdStackStorer ((struct TdInputCredentialsNew *)var, M);
    case CODE_InputCredentialsAndroidPay: return TdStackStorer ((struct TdInputCredentialsAndroidPay *)var, M);
    case CODE_InputCredentialsApplePay: return TdStackStorer ((struct TdInputCredentialsApplePay *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdInputCredentials *TdStackFetcherInputCredentials (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "InputCredentialsSaved") {
    return (struct TdInputCredentials *)TdStackFetcherInputCredentialsSaved (M);
  }
  if (constructor == "InputCredentialsNew") {
    return (struct TdInputCredentials *)TdStackFetcherInputCredentialsNew (M);
  }
  if (constructor == "InputCredentialsAndroidPay") {
    return (struct TdInputCredentials *)TdStackFetcherInputCredentialsAndroidPay (M);
  }
  if (constructor == "InputCredentialsApplePay") {
    return (struct TdInputCredentials *)TdStackFetcherInputCredentialsApplePay (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdInputCredentialsSaved *TdCreateObjectInputCredentialsSaved (char *saved_credentials_id_) {
  auto var = new struct TdInputCredentialsSaved ();
  var->ID = CODE_InputCredentialsSaved;
  var->refcnt = 1;
  var->saved_credentials_id_ = (saved_credentials_id_) ? td::str_dup (td::Slice (saved_credentials_id_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputCredentialsSaved> TdConvertToInternal (struct TdInputCredentialsSaved *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->saved_credentials_id_) ? var->saved_credentials_id_: "";
  return td::td_api::make_object<td::td_api::inputCredentialsSaved>(std::move (v0));
}
struct TdInputCredentialsSaved *TdConvertFromInternal (const td::td_api::inputCredentialsSaved &from) {
  auto res = new TdInputCredentialsSaved ();
  res->ID = CODE_InputCredentialsSaved;
  res->refcnt = 1;
  res->saved_credentials_id_ = (from.saved_credentials_id_.length ()) ? td::str_dup (from.saved_credentials_id_) : nullptr;
  return res;
}
char *TdSerializeInputCredentialsSaved (struct TdInputCredentialsSaved *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputCredentialsSaved *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputCredentialsSaved (struct TdInputCredentialsSaved *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputCredentialsSaved *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->saved_credentials_id_);
  delete var;
}
void TdStackStorerInputCredentialsSaved (struct TdInputCredentialsSaved *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputCredentialsSaved *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputCredentialsSaved");
  M->new_field ("ID");
  M->pack_string (var->saved_credentials_id_);
  M->new_field ("saved_credentials_id_");
}
struct TdInputCredentialsSaved *TdStackFetcherInputCredentialsSaved (struct TdStackFetcherMethods *M) {
  auto res = new TdInputCredentialsSaved ();
  res->ID = CODE_InputCredentialsSaved;
  res->refcnt = 1;
  M->get_field ("saved_credentials_id_");
  res->saved_credentials_id_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInputCredentialsNew *TdCreateObjectInputCredentialsNew (char *data_, int allow_save_) {
  auto var = new struct TdInputCredentialsNew ();
  var->ID = CODE_InputCredentialsNew;
  var->refcnt = 1;
  var->data_ = (data_) ? td::str_dup (td::Slice (data_)) : nullptr;
  var->allow_save_ = allow_save_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputCredentialsNew> TdConvertToInternal (struct TdInputCredentialsNew *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->data_) ? var->data_: "";
  bool v100;
  v100 = var->allow_save_ != 0;
  return td::td_api::make_object<td::td_api::inputCredentialsNew>(std::move (v0), std::move (v100));
}
struct TdInputCredentialsNew *TdConvertFromInternal (const td::td_api::inputCredentialsNew &from) {
  auto res = new TdInputCredentialsNew ();
  res->ID = CODE_InputCredentialsNew;
  res->refcnt = 1;
  res->data_ = (from.data_.length ()) ? td::str_dup (from.data_) : nullptr;
  res->allow_save_ = from.allow_save_;
  return res;
}
char *TdSerializeInputCredentialsNew (struct TdInputCredentialsNew *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputCredentialsNew *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputCredentialsNew (struct TdInputCredentialsNew *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputCredentialsNew *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->data_);
  delete var;
}
void TdStackStorerInputCredentialsNew (struct TdInputCredentialsNew *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputCredentialsNew *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputCredentialsNew");
  M->new_field ("ID");
  M->pack_string (var->data_);
  M->new_field ("data_");
  M->pack_bool (var->allow_save_);
  M->new_field ("allow_save_");
}
struct TdInputCredentialsNew *TdStackFetcherInputCredentialsNew (struct TdStackFetcherMethods *M) {
  auto res = new TdInputCredentialsNew ();
  res->ID = CODE_InputCredentialsNew;
  res->refcnt = 1;
  M->get_field ("data_");
  res->data_ = M->get_string ();
  M->pop ();
  M->get_field ("allow_save_");
  res->allow_save_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputCredentialsAndroidPay *TdCreateObjectInputCredentialsAndroidPay (char *data_) {
  auto var = new struct TdInputCredentialsAndroidPay ();
  var->ID = CODE_InputCredentialsAndroidPay;
  var->refcnt = 1;
  var->data_ = (data_) ? td::str_dup (td::Slice (data_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputCredentialsAndroidPay> TdConvertToInternal (struct TdInputCredentialsAndroidPay *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->data_) ? var->data_: "";
  return td::td_api::make_object<td::td_api::inputCredentialsAndroidPay>(std::move (v0));
}
struct TdInputCredentialsAndroidPay *TdConvertFromInternal (const td::td_api::inputCredentialsAndroidPay &from) {
  auto res = new TdInputCredentialsAndroidPay ();
  res->ID = CODE_InputCredentialsAndroidPay;
  res->refcnt = 1;
  res->data_ = (from.data_.length ()) ? td::str_dup (from.data_) : nullptr;
  return res;
}
char *TdSerializeInputCredentialsAndroidPay (struct TdInputCredentialsAndroidPay *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputCredentialsAndroidPay *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputCredentialsAndroidPay (struct TdInputCredentialsAndroidPay *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputCredentialsAndroidPay *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->data_);
  delete var;
}
void TdStackStorerInputCredentialsAndroidPay (struct TdInputCredentialsAndroidPay *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputCredentialsAndroidPay *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputCredentialsAndroidPay");
  M->new_field ("ID");
  M->pack_string (var->data_);
  M->new_field ("data_");
}
struct TdInputCredentialsAndroidPay *TdStackFetcherInputCredentialsAndroidPay (struct TdStackFetcherMethods *M) {
  auto res = new TdInputCredentialsAndroidPay ();
  res->ID = CODE_InputCredentialsAndroidPay;
  res->refcnt = 1;
  M->get_field ("data_");
  res->data_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInputCredentialsApplePay *TdCreateObjectInputCredentialsApplePay (char *data_) {
  auto var = new struct TdInputCredentialsApplePay ();
  var->ID = CODE_InputCredentialsApplePay;
  var->refcnt = 1;
  var->data_ = (data_) ? td::str_dup (td::Slice (data_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputCredentialsApplePay> TdConvertToInternal (struct TdInputCredentialsApplePay *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->data_) ? var->data_: "";
  return td::td_api::make_object<td::td_api::inputCredentialsApplePay>(std::move (v0));
}
struct TdInputCredentialsApplePay *TdConvertFromInternal (const td::td_api::inputCredentialsApplePay &from) {
  auto res = new TdInputCredentialsApplePay ();
  res->ID = CODE_InputCredentialsApplePay;
  res->refcnt = 1;
  res->data_ = (from.data_.length ()) ? td::str_dup (from.data_) : nullptr;
  return res;
}
char *TdSerializeInputCredentialsApplePay (struct TdInputCredentialsApplePay *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputCredentialsApplePay *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputCredentialsApplePay (struct TdInputCredentialsApplePay *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputCredentialsApplePay *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->data_);
  delete var;
}
void TdStackStorerInputCredentialsApplePay (struct TdInputCredentialsApplePay *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputCredentialsApplePay *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputCredentialsApplePay");
  M->new_field ("ID");
  M->pack_string (var->data_);
  M->new_field ("data_");
}
struct TdInputCredentialsApplePay *TdStackFetcherInputCredentialsApplePay (struct TdStackFetcherMethods *M) {
  auto res = new TdInputCredentialsApplePay ();
  res->ID = CODE_InputCredentialsApplePay;
  res->refcnt = 1;
  M->get_field ("data_");
  res->data_ = M->get_string ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::InputFile> TdConvertToInternal (struct TdInputFile *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputFileId: return TdConvertToInternal ((struct TdInputFileId *)var);
    case CODE_InputFileRemote: return TdConvertToInternal ((struct TdInputFileRemote *)var);
    case CODE_InputFileLocal: return TdConvertToInternal ((struct TdInputFileLocal *)var);
    case CODE_InputFileGenerated: return TdConvertToInternal ((struct TdInputFileGenerated *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdInputFile *TdConvertFromInternal (const td::td_api::InputFile &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_InputFileId: return (struct TdInputFile *)TdConvertFromInternal(static_cast<const td::td_api::inputFileId &>(from));
    case CODE_InputFileRemote: return (struct TdInputFile *)TdConvertFromInternal(static_cast<const td::td_api::inputFileRemote &>(from));
    case CODE_InputFileLocal: return (struct TdInputFile *)TdConvertFromInternal(static_cast<const td::td_api::inputFileLocal &>(from));
    case CODE_InputFileGenerated: return (struct TdInputFile *)TdConvertFromInternal(static_cast<const td::td_api::inputFileGenerated &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeInputFile (struct TdInputFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputFile (struct TdInputFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputFile *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputFileId: return TdDestroyObject ((struct TdInputFileId *)var);
    case CODE_InputFileRemote: return TdDestroyObject ((struct TdInputFileRemote *)var);
    case CODE_InputFileLocal: return TdDestroyObject ((struct TdInputFileLocal *)var);
    case CODE_InputFileGenerated: return TdDestroyObject ((struct TdInputFileGenerated *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerInputFile (struct TdInputFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputFile *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputFileId: return TdStackStorer ((struct TdInputFileId *)var, M);
    case CODE_InputFileRemote: return TdStackStorer ((struct TdInputFileRemote *)var, M);
    case CODE_InputFileLocal: return TdStackStorer ((struct TdInputFileLocal *)var, M);
    case CODE_InputFileGenerated: return TdStackStorer ((struct TdInputFileGenerated *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdInputFile *TdStackFetcherInputFile (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "InputFileId") {
    return (struct TdInputFile *)TdStackFetcherInputFileId (M);
  }
  if (constructor == "InputFileRemote") {
    return (struct TdInputFile *)TdStackFetcherInputFileRemote (M);
  }
  if (constructor == "InputFileLocal") {
    return (struct TdInputFile *)TdStackFetcherInputFileLocal (M);
  }
  if (constructor == "InputFileGenerated") {
    return (struct TdInputFile *)TdStackFetcherInputFileGenerated (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdInputFileId *TdCreateObjectInputFileId (int id_) {
  auto var = new struct TdInputFileId ();
  var->ID = CODE_InputFileId;
  var->refcnt = 1;
  var->id_ = id_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputFileId> TdConvertToInternal (struct TdInputFileId *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  return td::td_api::make_object<td::td_api::inputFileId>(std::move (v0));
}
struct TdInputFileId *TdConvertFromInternal (const td::td_api::inputFileId &from) {
  auto res = new TdInputFileId ();
  res->ID = CODE_InputFileId;
  res->refcnt = 1;
  res->id_ = from.id_;
  return res;
}
char *TdSerializeInputFileId (struct TdInputFileId *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputFileId *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputFileId (struct TdInputFileId *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputFileId *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerInputFileId (struct TdInputFileId *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputFileId *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputFileId");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
}
struct TdInputFileId *TdStackFetcherInputFileId (struct TdStackFetcherMethods *M) {
  auto res = new TdInputFileId ();
  res->ID = CODE_InputFileId;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputFileRemote *TdCreateObjectInputFileRemote (char *id_) {
  auto var = new struct TdInputFileRemote ();
  var->ID = CODE_InputFileRemote;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputFileRemote> TdConvertToInternal (struct TdInputFileRemote *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  return td::td_api::make_object<td::td_api::inputFileRemote>(std::move (v0));
}
struct TdInputFileRemote *TdConvertFromInternal (const td::td_api::inputFileRemote &from) {
  auto res = new TdInputFileRemote ();
  res->ID = CODE_InputFileRemote;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  return res;
}
char *TdSerializeInputFileRemote (struct TdInputFileRemote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputFileRemote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputFileRemote (struct TdInputFileRemote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputFileRemote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  delete var;
}
void TdStackStorerInputFileRemote (struct TdInputFileRemote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputFileRemote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputFileRemote");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
}
struct TdInputFileRemote *TdStackFetcherInputFileRemote (struct TdStackFetcherMethods *M) {
  auto res = new TdInputFileRemote ();
  res->ID = CODE_InputFileRemote;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInputFileLocal *TdCreateObjectInputFileLocal (char *path_) {
  auto var = new struct TdInputFileLocal ();
  var->ID = CODE_InputFileLocal;
  var->refcnt = 1;
  var->path_ = (path_) ? td::str_dup (td::Slice (path_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputFileLocal> TdConvertToInternal (struct TdInputFileLocal *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->path_) ? var->path_: "";
  return td::td_api::make_object<td::td_api::inputFileLocal>(std::move (v0));
}
struct TdInputFileLocal *TdConvertFromInternal (const td::td_api::inputFileLocal &from) {
  auto res = new TdInputFileLocal ();
  res->ID = CODE_InputFileLocal;
  res->refcnt = 1;
  res->path_ = (from.path_.length ()) ? td::str_dup (from.path_) : nullptr;
  return res;
}
char *TdSerializeInputFileLocal (struct TdInputFileLocal *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputFileLocal *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputFileLocal (struct TdInputFileLocal *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputFileLocal *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->path_);
  delete var;
}
void TdStackStorerInputFileLocal (struct TdInputFileLocal *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputFileLocal *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputFileLocal");
  M->new_field ("ID");
  M->pack_string (var->path_);
  M->new_field ("path_");
}
struct TdInputFileLocal *TdStackFetcherInputFileLocal (struct TdStackFetcherMethods *M) {
  auto res = new TdInputFileLocal ();
  res->ID = CODE_InputFileLocal;
  res->refcnt = 1;
  M->get_field ("path_");
  res->path_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInputFileGenerated *TdCreateObjectInputFileGenerated (char *original_path_, char *conversion_, int expected_size_) {
  auto var = new struct TdInputFileGenerated ();
  var->ID = CODE_InputFileGenerated;
  var->refcnt = 1;
  var->original_path_ = (original_path_) ? td::str_dup (td::Slice (original_path_)) : nullptr;
  var->conversion_ = (conversion_) ? td::str_dup (td::Slice (conversion_)) : nullptr;
  var->expected_size_ = expected_size_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputFileGenerated> TdConvertToInternal (struct TdInputFileGenerated *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->original_path_) ? var->original_path_: "";
  std::string v100;
  v100 = (var->conversion_) ? var->conversion_: "";
  std::int32_t v200;
  v200 = var->expected_size_;
  return td::td_api::make_object<td::td_api::inputFileGenerated>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInputFileGenerated *TdConvertFromInternal (const td::td_api::inputFileGenerated &from) {
  auto res = new TdInputFileGenerated ();
  res->ID = CODE_InputFileGenerated;
  res->refcnt = 1;
  res->original_path_ = (from.original_path_.length ()) ? td::str_dup (from.original_path_) : nullptr;
  res->conversion_ = (from.conversion_.length ()) ? td::str_dup (from.conversion_) : nullptr;
  res->expected_size_ = from.expected_size_;
  return res;
}
char *TdSerializeInputFileGenerated (struct TdInputFileGenerated *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputFileGenerated *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputFileGenerated (struct TdInputFileGenerated *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputFileGenerated *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->original_path_);
  free (var->conversion_);
  delete var;
}
void TdStackStorerInputFileGenerated (struct TdInputFileGenerated *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputFileGenerated *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputFileGenerated");
  M->new_field ("ID");
  M->pack_string (var->original_path_);
  M->new_field ("original_path_");
  M->pack_string (var->conversion_);
  M->new_field ("conversion_");
  M->pack_long (var->expected_size_);
  M->new_field ("expected_size_");
}
struct TdInputFileGenerated *TdStackFetcherInputFileGenerated (struct TdStackFetcherMethods *M) {
  auto res = new TdInputFileGenerated ();
  res->ID = CODE_InputFileGenerated;
  res->refcnt = 1;
  M->get_field ("original_path_");
  res->original_path_ = M->get_string ();
  M->pop ();
  M->get_field ("conversion_");
  res->conversion_ = M->get_string ();
  M->pop ();
  M->get_field ("expected_size_");
  res->expected_size_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputIdentityDocument *TdCreateObjectInputIdentityDocument (char *number_, struct TdDate *expiry_date_, struct TdInputFile *front_side_, struct TdInputFile *reverse_side_, struct TdInputFile *selfie_, struct TdVectorInputFile *translation_) {
  auto var = new struct TdInputIdentityDocument ();
  var->ID = CODE_InputIdentityDocument;
  var->refcnt = 1;
  var->number_ = (number_) ? td::str_dup (td::Slice (number_)) : nullptr;
  var->expiry_date_ = expiry_date_;
  var->front_side_ = front_side_;
  var->reverse_side_ = reverse_side_;
  var->selfie_ = selfie_;
  var->translation_ = translation_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputIdentityDocument> TdConvertToInternal (struct TdInputIdentityDocument *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->number_) ? var->number_: "";
  td::td_api::object_ptr<td::td_api::date> v100;
  v100 = TdConvertToInternal (var->expiry_date_);
  td::td_api::object_ptr<td::td_api::InputFile> v200;
  v200 = TdConvertToInternal (var->front_side_);
  td::td_api::object_ptr<td::td_api::InputFile> v300;
  v300 = TdConvertToInternal (var->reverse_side_);
  td::td_api::object_ptr<td::td_api::InputFile> v400;
  v400 = TdConvertToInternal (var->selfie_);
  std::vector<td::td_api::object_ptr<td::td_api::InputFile>> v500;
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    td::td_api::object_ptr<td::td_api::InputFile> v501;
    v501 = TdConvertToInternal (var->translation_->data[i500]);
    v500.push_back (std::move (v501));
  }
  return td::td_api::make_object<td::td_api::inputIdentityDocument>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdInputIdentityDocument *TdConvertFromInternal (const td::td_api::inputIdentityDocument &from) {
  auto res = new TdInputIdentityDocument ();
  res->ID = CODE_InputIdentityDocument;
  res->refcnt = 1;
  res->number_ = (from.number_.length ()) ? td::str_dup (from.number_) : nullptr;
  if (!from.expiry_date_) {
    res->expiry_date_ = nullptr;
  } else {
    res->expiry_date_ = TdConvertFromInternal (static_cast<const td::td_api::date &>(*from.expiry_date_));
  }
  if (!from.front_side_) {
    res->front_side_ = nullptr;
  } else {
    res->front_side_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.front_side_));
  }
  if (!from.reverse_side_) {
    res->reverse_side_ = nullptr;
  } else {
    res->reverse_side_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.reverse_side_));
  }
  if (!from.selfie_) {
    res->selfie_ = nullptr;
  } else {
    res->selfie_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.selfie_));
  }
  res->translation_ = new TdVectorInputFile ();
  res->translation_->len = (int)from.translation_.size ();
  res->translation_->data = new struct TdInputFile * [res->translation_->len];
  for (int i500 = 0; i500 < res->translation_->len; i500++) {
    if (!from.translation_[i500]) {
      res->translation_->data[i500] = nullptr;
    } else {
      res->translation_->data[i500] = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.translation_[i500]));
    }
  }
  return res;
}
char *TdSerializeInputIdentityDocument (struct TdInputIdentityDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputIdentityDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputIdentityDocument (struct TdInputIdentityDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputIdentityDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->number_);
  TdDestroyObject (var->expiry_date_);
  TdDestroyObject (var->front_side_);
  TdDestroyObject (var->reverse_side_);
  TdDestroyObject (var->selfie_);
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    TdDestroyObject (var->translation_->data[i500]);
  }
  delete[] var->translation_->data;
  delete var->translation_;
  delete var;
}
void TdStackStorerInputIdentityDocument (struct TdInputIdentityDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputIdentityDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputIdentityDocument");
  M->new_field ("ID");
  M->pack_string (var->number_);
  M->new_field ("number_");
  TdStackStorer (var->expiry_date_, M);
  M->new_field ("expiry_date_");
  TdStackStorer (var->front_side_, M);
  M->new_field ("front_side_");
  TdStackStorer (var->reverse_side_, M);
  M->new_field ("reverse_side_");
  TdStackStorer (var->selfie_, M);
  M->new_field ("selfie_");
  M->new_array ();
  for (int i500 = 0; i500 < var->translation_->len; i500++) {
    TdStackStorer (var->translation_->data[i500], M);
    M->new_arr_field (i500);
  }
  M->new_field ("translation_");
}
struct TdInputIdentityDocument *TdStackFetcherInputIdentityDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdInputIdentityDocument ();
  res->ID = CODE_InputIdentityDocument;
  res->refcnt = 1;
  M->get_field ("number_");
  res->number_ = M->get_string ();
  M->pop ();
  M->get_field ("expiry_date_");
  if (M->is_nil ()) {
    res->expiry_date_ = nullptr;
  } else {
    res->expiry_date_ = TdStackFetcherDate (M);
  }
  M->pop ();
  M->get_field ("front_side_");
  if (M->is_nil ()) {
    res->front_side_ = nullptr;
  } else {
    res->front_side_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("reverse_side_");
  if (M->is_nil ()) {
    res->reverse_side_ = nullptr;
  } else {
    res->reverse_side_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("selfie_");
  if (M->is_nil ()) {
    res->selfie_ = nullptr;
  } else {
    res->selfie_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("translation_");
  res->translation_ = new TdVectorInputFile ();
  res->translation_->len = M->get_arr_size ();
  res->translation_->data = new struct TdInputFile * [res->translation_->len];
  for (int i500 = 0; i500 < res->translation_->len; i500++) {
    M->get_arr_field (i500);
    if (M->is_nil ()) {
      res->translation_->data[i500] = nullptr;
    } else {
      res->translation_->data[i500] = TdStackFetcherInputFile (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::InputInlineQueryResult> TdConvertToInternal (struct TdInputInlineQueryResult *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputInlineQueryResultAnimatedGif: return TdConvertToInternal ((struct TdInputInlineQueryResultAnimatedGif *)var);
    case CODE_InputInlineQueryResultAnimatedMpeg4: return TdConvertToInternal ((struct TdInputInlineQueryResultAnimatedMpeg4 *)var);
    case CODE_InputInlineQueryResultArticle: return TdConvertToInternal ((struct TdInputInlineQueryResultArticle *)var);
    case CODE_InputInlineQueryResultAudio: return TdConvertToInternal ((struct TdInputInlineQueryResultAudio *)var);
    case CODE_InputInlineQueryResultContact: return TdConvertToInternal ((struct TdInputInlineQueryResultContact *)var);
    case CODE_InputInlineQueryResultDocument: return TdConvertToInternal ((struct TdInputInlineQueryResultDocument *)var);
    case CODE_InputInlineQueryResultGame: return TdConvertToInternal ((struct TdInputInlineQueryResultGame *)var);
    case CODE_InputInlineQueryResultLocation: return TdConvertToInternal ((struct TdInputInlineQueryResultLocation *)var);
    case CODE_InputInlineQueryResultPhoto: return TdConvertToInternal ((struct TdInputInlineQueryResultPhoto *)var);
    case CODE_InputInlineQueryResultSticker: return TdConvertToInternal ((struct TdInputInlineQueryResultSticker *)var);
    case CODE_InputInlineQueryResultVenue: return TdConvertToInternal ((struct TdInputInlineQueryResultVenue *)var);
    case CODE_InputInlineQueryResultVideo: return TdConvertToInternal ((struct TdInputInlineQueryResultVideo *)var);
    case CODE_InputInlineQueryResultVoiceNote: return TdConvertToInternal ((struct TdInputInlineQueryResultVoiceNote *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdInputInlineQueryResult *TdConvertFromInternal (const td::td_api::InputInlineQueryResult &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_InputInlineQueryResultAnimatedGif: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultAnimatedGif &>(from));
    case CODE_InputInlineQueryResultAnimatedMpeg4: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultAnimatedMpeg4 &>(from));
    case CODE_InputInlineQueryResultArticle: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultArticle &>(from));
    case CODE_InputInlineQueryResultAudio: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultAudio &>(from));
    case CODE_InputInlineQueryResultContact: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultContact &>(from));
    case CODE_InputInlineQueryResultDocument: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultDocument &>(from));
    case CODE_InputInlineQueryResultGame: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultGame &>(from));
    case CODE_InputInlineQueryResultLocation: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultLocation &>(from));
    case CODE_InputInlineQueryResultPhoto: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultPhoto &>(from));
    case CODE_InputInlineQueryResultSticker: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultSticker &>(from));
    case CODE_InputInlineQueryResultVenue: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultVenue &>(from));
    case CODE_InputInlineQueryResultVideo: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultVideo &>(from));
    case CODE_InputInlineQueryResultVoiceNote: return (struct TdInputInlineQueryResult *)TdConvertFromInternal(static_cast<const td::td_api::inputInlineQueryResultVoiceNote &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeInputInlineQueryResult (struct TdInputInlineQueryResult *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResult *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResult (struct TdInputInlineQueryResult *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResult *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputInlineQueryResultAnimatedGif: return TdDestroyObject ((struct TdInputInlineQueryResultAnimatedGif *)var);
    case CODE_InputInlineQueryResultAnimatedMpeg4: return TdDestroyObject ((struct TdInputInlineQueryResultAnimatedMpeg4 *)var);
    case CODE_InputInlineQueryResultArticle: return TdDestroyObject ((struct TdInputInlineQueryResultArticle *)var);
    case CODE_InputInlineQueryResultAudio: return TdDestroyObject ((struct TdInputInlineQueryResultAudio *)var);
    case CODE_InputInlineQueryResultContact: return TdDestroyObject ((struct TdInputInlineQueryResultContact *)var);
    case CODE_InputInlineQueryResultDocument: return TdDestroyObject ((struct TdInputInlineQueryResultDocument *)var);
    case CODE_InputInlineQueryResultGame: return TdDestroyObject ((struct TdInputInlineQueryResultGame *)var);
    case CODE_InputInlineQueryResultLocation: return TdDestroyObject ((struct TdInputInlineQueryResultLocation *)var);
    case CODE_InputInlineQueryResultPhoto: return TdDestroyObject ((struct TdInputInlineQueryResultPhoto *)var);
    case CODE_InputInlineQueryResultSticker: return TdDestroyObject ((struct TdInputInlineQueryResultSticker *)var);
    case CODE_InputInlineQueryResultVenue: return TdDestroyObject ((struct TdInputInlineQueryResultVenue *)var);
    case CODE_InputInlineQueryResultVideo: return TdDestroyObject ((struct TdInputInlineQueryResultVideo *)var);
    case CODE_InputInlineQueryResultVoiceNote: return TdDestroyObject ((struct TdInputInlineQueryResultVoiceNote *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerInputInlineQueryResult (struct TdInputInlineQueryResult *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResult *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputInlineQueryResultAnimatedGif: return TdStackStorer ((struct TdInputInlineQueryResultAnimatedGif *)var, M);
    case CODE_InputInlineQueryResultAnimatedMpeg4: return TdStackStorer ((struct TdInputInlineQueryResultAnimatedMpeg4 *)var, M);
    case CODE_InputInlineQueryResultArticle: return TdStackStorer ((struct TdInputInlineQueryResultArticle *)var, M);
    case CODE_InputInlineQueryResultAudio: return TdStackStorer ((struct TdInputInlineQueryResultAudio *)var, M);
    case CODE_InputInlineQueryResultContact: return TdStackStorer ((struct TdInputInlineQueryResultContact *)var, M);
    case CODE_InputInlineQueryResultDocument: return TdStackStorer ((struct TdInputInlineQueryResultDocument *)var, M);
    case CODE_InputInlineQueryResultGame: return TdStackStorer ((struct TdInputInlineQueryResultGame *)var, M);
    case CODE_InputInlineQueryResultLocation: return TdStackStorer ((struct TdInputInlineQueryResultLocation *)var, M);
    case CODE_InputInlineQueryResultPhoto: return TdStackStorer ((struct TdInputInlineQueryResultPhoto *)var, M);
    case CODE_InputInlineQueryResultSticker: return TdStackStorer ((struct TdInputInlineQueryResultSticker *)var, M);
    case CODE_InputInlineQueryResultVenue: return TdStackStorer ((struct TdInputInlineQueryResultVenue *)var, M);
    case CODE_InputInlineQueryResultVideo: return TdStackStorer ((struct TdInputInlineQueryResultVideo *)var, M);
    case CODE_InputInlineQueryResultVoiceNote: return TdStackStorer ((struct TdInputInlineQueryResultVoiceNote *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdInputInlineQueryResult *TdStackFetcherInputInlineQueryResult (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "InputInlineQueryResultAnimatedGif") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultAnimatedGif (M);
  }
  if (constructor == "InputInlineQueryResultAnimatedMpeg4") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultAnimatedMpeg4 (M);
  }
  if (constructor == "InputInlineQueryResultArticle") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultArticle (M);
  }
  if (constructor == "InputInlineQueryResultAudio") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultAudio (M);
  }
  if (constructor == "InputInlineQueryResultContact") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultContact (M);
  }
  if (constructor == "InputInlineQueryResultDocument") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultDocument (M);
  }
  if (constructor == "InputInlineQueryResultGame") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultGame (M);
  }
  if (constructor == "InputInlineQueryResultLocation") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultLocation (M);
  }
  if (constructor == "InputInlineQueryResultPhoto") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultPhoto (M);
  }
  if (constructor == "InputInlineQueryResultSticker") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultSticker (M);
  }
  if (constructor == "InputInlineQueryResultVenue") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultVenue (M);
  }
  if (constructor == "InputInlineQueryResultVideo") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultVideo (M);
  }
  if (constructor == "InputInlineQueryResultVoiceNote") {
    return (struct TdInputInlineQueryResult *)TdStackFetcherInputInlineQueryResultVoiceNote (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdInputInlineQueryResultAnimatedGif *TdCreateObjectInputInlineQueryResultAnimatedGif (char *id_, char *title_, char *thumbnail_url_, char *gif_url_, int gif_duration_, int gif_width_, int gif_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultAnimatedGif ();
  var->ID = CODE_InputInlineQueryResultAnimatedGif;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->gif_url_ = (gif_url_) ? td::str_dup (td::Slice (gif_url_)) : nullptr;
  var->gif_duration_ = gif_duration_;
  var->gif_width_ = gif_width_;
  var->gif_height_ = gif_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultAnimatedGif> TdConvertToInternal (struct TdInputInlineQueryResultAnimatedGif *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::string v300;
  v300 = (var->gif_url_) ? var->gif_url_: "";
  std::int32_t v400;
  v400 = var->gif_duration_;
  std::int32_t v500;
  v500 = var->gif_width_;
  std::int32_t v600;
  v600 = var->gif_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v700;
  v700 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v800;
  v800 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultAnimatedGif>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdInputInlineQueryResultAnimatedGif *TdConvertFromInternal (const td::td_api::inputInlineQueryResultAnimatedGif &from) {
  auto res = new TdInputInlineQueryResultAnimatedGif ();
  res->ID = CODE_InputInlineQueryResultAnimatedGif;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->gif_url_ = (from.gif_url_.length ()) ? td::str_dup (from.gif_url_) : nullptr;
  res->gif_duration_ = from.gif_duration_;
  res->gif_width_ = from.gif_width_;
  res->gif_height_ = from.gif_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultAnimatedGif (struct TdInputInlineQueryResultAnimatedGif *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultAnimatedGif *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultAnimatedGif (struct TdInputInlineQueryResultAnimatedGif *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultAnimatedGif *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  free (var->thumbnail_url_);
  free (var->gif_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultAnimatedGif (struct TdInputInlineQueryResultAnimatedGif *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultAnimatedGif *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultAnimatedGif");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_string (var->gif_url_);
  M->new_field ("gif_url_");
  M->pack_long (var->gif_duration_);
  M->new_field ("gif_duration_");
  M->pack_long (var->gif_width_);
  M->new_field ("gif_width_");
  M->pack_long (var->gif_height_);
  M->new_field ("gif_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultAnimatedGif *TdStackFetcherInputInlineQueryResultAnimatedGif (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultAnimatedGif ();
  res->ID = CODE_InputInlineQueryResultAnimatedGif;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("gif_url_");
  res->gif_url_ = M->get_string ();
  M->pop ();
  M->get_field ("gif_duration_");
  res->gif_duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("gif_width_");
  res->gif_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("gif_height_");
  res->gif_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultAnimatedMpeg4 *TdCreateObjectInputInlineQueryResultAnimatedMpeg4 (char *id_, char *title_, char *thumbnail_url_, char *mpeg4_url_, int mpeg4_duration_, int mpeg4_width_, int mpeg4_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultAnimatedMpeg4 ();
  var->ID = CODE_InputInlineQueryResultAnimatedMpeg4;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->mpeg4_url_ = (mpeg4_url_) ? td::str_dup (td::Slice (mpeg4_url_)) : nullptr;
  var->mpeg4_duration_ = mpeg4_duration_;
  var->mpeg4_width_ = mpeg4_width_;
  var->mpeg4_height_ = mpeg4_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultAnimatedMpeg4> TdConvertToInternal (struct TdInputInlineQueryResultAnimatedMpeg4 *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::string v300;
  v300 = (var->mpeg4_url_) ? var->mpeg4_url_: "";
  std::int32_t v400;
  v400 = var->mpeg4_duration_;
  std::int32_t v500;
  v500 = var->mpeg4_width_;
  std::int32_t v600;
  v600 = var->mpeg4_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v700;
  v700 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v800;
  v800 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultAnimatedMpeg4>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdInputInlineQueryResultAnimatedMpeg4 *TdConvertFromInternal (const td::td_api::inputInlineQueryResultAnimatedMpeg4 &from) {
  auto res = new TdInputInlineQueryResultAnimatedMpeg4 ();
  res->ID = CODE_InputInlineQueryResultAnimatedMpeg4;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->mpeg4_url_ = (from.mpeg4_url_.length ()) ? td::str_dup (from.mpeg4_url_) : nullptr;
  res->mpeg4_duration_ = from.mpeg4_duration_;
  res->mpeg4_width_ = from.mpeg4_width_;
  res->mpeg4_height_ = from.mpeg4_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultAnimatedMpeg4 (struct TdInputInlineQueryResultAnimatedMpeg4 *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultAnimatedMpeg4 *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultAnimatedMpeg4 (struct TdInputInlineQueryResultAnimatedMpeg4 *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultAnimatedMpeg4 *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  free (var->thumbnail_url_);
  free (var->mpeg4_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultAnimatedMpeg4 (struct TdInputInlineQueryResultAnimatedMpeg4 *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultAnimatedMpeg4 *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultAnimatedMpeg4");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_string (var->mpeg4_url_);
  M->new_field ("mpeg4_url_");
  M->pack_long (var->mpeg4_duration_);
  M->new_field ("mpeg4_duration_");
  M->pack_long (var->mpeg4_width_);
  M->new_field ("mpeg4_width_");
  M->pack_long (var->mpeg4_height_);
  M->new_field ("mpeg4_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultAnimatedMpeg4 *TdStackFetcherInputInlineQueryResultAnimatedMpeg4 (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultAnimatedMpeg4 ();
  res->ID = CODE_InputInlineQueryResultAnimatedMpeg4;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("mpeg4_url_");
  res->mpeg4_url_ = M->get_string ();
  M->pop ();
  M->get_field ("mpeg4_duration_");
  res->mpeg4_duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("mpeg4_width_");
  res->mpeg4_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("mpeg4_height_");
  res->mpeg4_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultArticle *TdCreateObjectInputInlineQueryResultArticle (char *id_, char *url_, int hide_url_, char *title_, char *description_, char *thumbnail_url_, int thumbnail_width_, int thumbnail_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultArticle ();
  var->ID = CODE_InputInlineQueryResultArticle;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->hide_url_ = hide_url_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->thumbnail_width_ = thumbnail_width_;
  var->thumbnail_height_ = thumbnail_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultArticle> TdConvertToInternal (struct TdInputInlineQueryResultArticle *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->url_) ? var->url_: "";
  bool v200;
  v200 = var->hide_url_ != 0;
  std::string v300;
  v300 = (var->title_) ? var->title_: "";
  std::string v400;
  v400 = (var->description_) ? var->description_: "";
  std::string v500;
  v500 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::int32_t v600;
  v600 = var->thumbnail_width_;
  std::int32_t v700;
  v700 = var->thumbnail_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v800;
  v800 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v900;
  v900 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultArticle>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900));
}
struct TdInputInlineQueryResultArticle *TdConvertFromInternal (const td::td_api::inputInlineQueryResultArticle &from) {
  auto res = new TdInputInlineQueryResultArticle ();
  res->ID = CODE_InputInlineQueryResultArticle;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  res->hide_url_ = from.hide_url_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->thumbnail_width_ = from.thumbnail_width_;
  res->thumbnail_height_ = from.thumbnail_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultArticle (struct TdInputInlineQueryResultArticle *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultArticle *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultArticle (struct TdInputInlineQueryResultArticle *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultArticle *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->url_);
  free (var->title_);
  free (var->description_);
  free (var->thumbnail_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultArticle (struct TdInputInlineQueryResultArticle *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultArticle *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultArticle");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->url_);
  M->new_field ("url_");
  M->pack_bool (var->hide_url_);
  M->new_field ("hide_url_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_long (var->thumbnail_width_);
  M->new_field ("thumbnail_width_");
  M->pack_long (var->thumbnail_height_);
  M->new_field ("thumbnail_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultArticle *TdStackFetcherInputInlineQueryResultArticle (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultArticle ();
  res->ID = CODE_InputInlineQueryResultArticle;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("hide_url_");
  res->hide_url_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_width_");
  res->thumbnail_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("thumbnail_height_");
  res->thumbnail_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultAudio *TdCreateObjectInputInlineQueryResultAudio (char *id_, char *title_, char *performer_, char *audio_url_, int audio_duration_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultAudio ();
  var->ID = CODE_InputInlineQueryResultAudio;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->performer_ = (performer_) ? td::str_dup (td::Slice (performer_)) : nullptr;
  var->audio_url_ = (audio_url_) ? td::str_dup (td::Slice (audio_url_)) : nullptr;
  var->audio_duration_ = audio_duration_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultAudio> TdConvertToInternal (struct TdInputInlineQueryResultAudio *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->performer_) ? var->performer_: "";
  std::string v300;
  v300 = (var->audio_url_) ? var->audio_url_: "";
  std::int32_t v400;
  v400 = var->audio_duration_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v500;
  v500 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v600;
  v600 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultAudio>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdInputInlineQueryResultAudio *TdConvertFromInternal (const td::td_api::inputInlineQueryResultAudio &from) {
  auto res = new TdInputInlineQueryResultAudio ();
  res->ID = CODE_InputInlineQueryResultAudio;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->performer_ = (from.performer_.length ()) ? td::str_dup (from.performer_) : nullptr;
  res->audio_url_ = (from.audio_url_.length ()) ? td::str_dup (from.audio_url_) : nullptr;
  res->audio_duration_ = from.audio_duration_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultAudio (struct TdInputInlineQueryResultAudio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultAudio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultAudio (struct TdInputInlineQueryResultAudio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultAudio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  free (var->performer_);
  free (var->audio_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultAudio (struct TdInputInlineQueryResultAudio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultAudio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultAudio");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->performer_);
  M->new_field ("performer_");
  M->pack_string (var->audio_url_);
  M->new_field ("audio_url_");
  M->pack_long (var->audio_duration_);
  M->new_field ("audio_duration_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultAudio *TdStackFetcherInputInlineQueryResultAudio (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultAudio ();
  res->ID = CODE_InputInlineQueryResultAudio;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("performer_");
  res->performer_ = M->get_string ();
  M->pop ();
  M->get_field ("audio_url_");
  res->audio_url_ = M->get_string ();
  M->pop ();
  M->get_field ("audio_duration_");
  res->audio_duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultContact *TdCreateObjectInputInlineQueryResultContact (char *id_, struct TdContact *contact_, char *thumbnail_url_, int thumbnail_width_, int thumbnail_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultContact ();
  var->ID = CODE_InputInlineQueryResultContact;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->contact_ = contact_;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->thumbnail_width_ = thumbnail_width_;
  var->thumbnail_height_ = thumbnail_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultContact> TdConvertToInternal (struct TdInputInlineQueryResultContact *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::contact> v100;
  v100 = TdConvertToInternal (var->contact_);
  std::string v200;
  v200 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::int32_t v300;
  v300 = var->thumbnail_width_;
  std::int32_t v400;
  v400 = var->thumbnail_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v500;
  v500 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v600;
  v600 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultContact>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdInputInlineQueryResultContact *TdConvertFromInternal (const td::td_api::inputInlineQueryResultContact &from) {
  auto res = new TdInputInlineQueryResultContact ();
  res->ID = CODE_InputInlineQueryResultContact;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.contact_) {
    res->contact_ = nullptr;
  } else {
    res->contact_ = TdConvertFromInternal (static_cast<const td::td_api::contact &>(*from.contact_));
  }
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->thumbnail_width_ = from.thumbnail_width_;
  res->thumbnail_height_ = from.thumbnail_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultContact (struct TdInputInlineQueryResultContact *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultContact *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultContact (struct TdInputInlineQueryResultContact *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultContact *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->contact_);
  free (var->thumbnail_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultContact (struct TdInputInlineQueryResultContact *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultContact *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultContact");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->contact_, M);
  M->new_field ("contact_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_long (var->thumbnail_width_);
  M->new_field ("thumbnail_width_");
  M->pack_long (var->thumbnail_height_);
  M->new_field ("thumbnail_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultContact *TdStackFetcherInputInlineQueryResultContact (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultContact ();
  res->ID = CODE_InputInlineQueryResultContact;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("contact_");
  if (M->is_nil ()) {
    res->contact_ = nullptr;
  } else {
    res->contact_ = TdStackFetcherContact (M);
  }
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_width_");
  res->thumbnail_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("thumbnail_height_");
  res->thumbnail_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultDocument *TdCreateObjectInputInlineQueryResultDocument (char *id_, char *title_, char *description_, char *document_url_, char *mime_type_, char *thumbnail_url_, int thumbnail_width_, int thumbnail_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultDocument ();
  var->ID = CODE_InputInlineQueryResultDocument;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->document_url_ = (document_url_) ? td::str_dup (td::Slice (document_url_)) : nullptr;
  var->mime_type_ = (mime_type_) ? td::str_dup (td::Slice (mime_type_)) : nullptr;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->thumbnail_width_ = thumbnail_width_;
  var->thumbnail_height_ = thumbnail_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultDocument> TdConvertToInternal (struct TdInputInlineQueryResultDocument *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->description_) ? var->description_: "";
  std::string v300;
  v300 = (var->document_url_) ? var->document_url_: "";
  std::string v400;
  v400 = (var->mime_type_) ? var->mime_type_: "";
  std::string v500;
  v500 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::int32_t v600;
  v600 = var->thumbnail_width_;
  std::int32_t v700;
  v700 = var->thumbnail_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v800;
  v800 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v900;
  v900 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultDocument>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900));
}
struct TdInputInlineQueryResultDocument *TdConvertFromInternal (const td::td_api::inputInlineQueryResultDocument &from) {
  auto res = new TdInputInlineQueryResultDocument ();
  res->ID = CODE_InputInlineQueryResultDocument;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  res->document_url_ = (from.document_url_.length ()) ? td::str_dup (from.document_url_) : nullptr;
  res->mime_type_ = (from.mime_type_.length ()) ? td::str_dup (from.mime_type_) : nullptr;
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->thumbnail_width_ = from.thumbnail_width_;
  res->thumbnail_height_ = from.thumbnail_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultDocument (struct TdInputInlineQueryResultDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultDocument (struct TdInputInlineQueryResultDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  free (var->description_);
  free (var->document_url_);
  free (var->mime_type_);
  free (var->thumbnail_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultDocument (struct TdInputInlineQueryResultDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultDocument");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  M->pack_string (var->document_url_);
  M->new_field ("document_url_");
  M->pack_string (var->mime_type_);
  M->new_field ("mime_type_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_long (var->thumbnail_width_);
  M->new_field ("thumbnail_width_");
  M->pack_long (var->thumbnail_height_);
  M->new_field ("thumbnail_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultDocument *TdStackFetcherInputInlineQueryResultDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultDocument ();
  res->ID = CODE_InputInlineQueryResultDocument;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("document_url_");
  res->document_url_ = M->get_string ();
  M->pop ();
  M->get_field ("mime_type_");
  res->mime_type_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_width_");
  res->thumbnail_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("thumbnail_height_");
  res->thumbnail_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultGame *TdCreateObjectInputInlineQueryResultGame (char *id_, char *game_short_name_, struct TdReplyMarkup *reply_markup_) {
  auto var = new struct TdInputInlineQueryResultGame ();
  var->ID = CODE_InputInlineQueryResultGame;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->game_short_name_ = (game_short_name_) ? td::str_dup (td::Slice (game_short_name_)) : nullptr;
  var->reply_markup_ = reply_markup_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultGame> TdConvertToInternal (struct TdInputInlineQueryResultGame *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->game_short_name_) ? var->game_short_name_: "";
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v200;
  v200 = TdConvertToInternal (var->reply_markup_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultGame>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInputInlineQueryResultGame *TdConvertFromInternal (const td::td_api::inputInlineQueryResultGame &from) {
  auto res = new TdInputInlineQueryResultGame ();
  res->ID = CODE_InputInlineQueryResultGame;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->game_short_name_ = (from.game_short_name_.length ()) ? td::str_dup (from.game_short_name_) : nullptr;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultGame (struct TdInputInlineQueryResultGame *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultGame *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultGame (struct TdInputInlineQueryResultGame *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultGame *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->game_short_name_);
  TdDestroyObject (var->reply_markup_);
  delete var;
}
void TdStackStorerInputInlineQueryResultGame (struct TdInputInlineQueryResultGame *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultGame *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultGame");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->game_short_name_);
  M->new_field ("game_short_name_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
}
struct TdInputInlineQueryResultGame *TdStackFetcherInputInlineQueryResultGame (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultGame ();
  res->ID = CODE_InputInlineQueryResultGame;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("game_short_name_");
  res->game_short_name_ = M->get_string ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultLocation *TdCreateObjectInputInlineQueryResultLocation (char *id_, struct TdLocation *location_, int live_period_, char *title_, char *thumbnail_url_, int thumbnail_width_, int thumbnail_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultLocation ();
  var->ID = CODE_InputInlineQueryResultLocation;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->location_ = location_;
  var->live_period_ = live_period_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->thumbnail_width_ = thumbnail_width_;
  var->thumbnail_height_ = thumbnail_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultLocation> TdConvertToInternal (struct TdInputInlineQueryResultLocation *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::location> v100;
  v100 = TdConvertToInternal (var->location_);
  std::int32_t v200;
  v200 = var->live_period_;
  std::string v300;
  v300 = (var->title_) ? var->title_: "";
  std::string v400;
  v400 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::int32_t v500;
  v500 = var->thumbnail_width_;
  std::int32_t v600;
  v600 = var->thumbnail_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v700;
  v700 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v800;
  v800 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultLocation>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdInputInlineQueryResultLocation *TdConvertFromInternal (const td::td_api::inputInlineQueryResultLocation &from) {
  auto res = new TdInputInlineQueryResultLocation ();
  res->ID = CODE_InputInlineQueryResultLocation;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.location_) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.location_));
  }
  res->live_period_ = from.live_period_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->thumbnail_width_ = from.thumbnail_width_;
  res->thumbnail_height_ = from.thumbnail_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultLocation (struct TdInputInlineQueryResultLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultLocation (struct TdInputInlineQueryResultLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->location_);
  free (var->title_);
  free (var->thumbnail_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultLocation (struct TdInputInlineQueryResultLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultLocation");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->location_, M);
  M->new_field ("location_");
  M->pack_long (var->live_period_);
  M->new_field ("live_period_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_long (var->thumbnail_width_);
  M->new_field ("thumbnail_width_");
  M->pack_long (var->thumbnail_height_);
  M->new_field ("thumbnail_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultLocation *TdStackFetcherInputInlineQueryResultLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultLocation ();
  res->ID = CODE_InputInlineQueryResultLocation;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("location_");
  if (M->is_nil ()) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("live_period_");
  res->live_period_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_width_");
  res->thumbnail_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("thumbnail_height_");
  res->thumbnail_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultPhoto *TdCreateObjectInputInlineQueryResultPhoto (char *id_, char *title_, char *description_, char *thumbnail_url_, char *photo_url_, int photo_width_, int photo_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultPhoto ();
  var->ID = CODE_InputInlineQueryResultPhoto;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->photo_url_ = (photo_url_) ? td::str_dup (td::Slice (photo_url_)) : nullptr;
  var->photo_width_ = photo_width_;
  var->photo_height_ = photo_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultPhoto> TdConvertToInternal (struct TdInputInlineQueryResultPhoto *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->description_) ? var->description_: "";
  std::string v300;
  v300 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::string v400;
  v400 = (var->photo_url_) ? var->photo_url_: "";
  std::int32_t v500;
  v500 = var->photo_width_;
  std::int32_t v600;
  v600 = var->photo_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v700;
  v700 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v800;
  v800 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultPhoto>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdInputInlineQueryResultPhoto *TdConvertFromInternal (const td::td_api::inputInlineQueryResultPhoto &from) {
  auto res = new TdInputInlineQueryResultPhoto ();
  res->ID = CODE_InputInlineQueryResultPhoto;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->photo_url_ = (from.photo_url_.length ()) ? td::str_dup (from.photo_url_) : nullptr;
  res->photo_width_ = from.photo_width_;
  res->photo_height_ = from.photo_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultPhoto (struct TdInputInlineQueryResultPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultPhoto (struct TdInputInlineQueryResultPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  free (var->description_);
  free (var->thumbnail_url_);
  free (var->photo_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultPhoto (struct TdInputInlineQueryResultPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultPhoto");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_string (var->photo_url_);
  M->new_field ("photo_url_");
  M->pack_long (var->photo_width_);
  M->new_field ("photo_width_");
  M->pack_long (var->photo_height_);
  M->new_field ("photo_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultPhoto *TdStackFetcherInputInlineQueryResultPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultPhoto ();
  res->ID = CODE_InputInlineQueryResultPhoto;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_url_");
  res->photo_url_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_width_");
  res->photo_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("photo_height_");
  res->photo_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultSticker *TdCreateObjectInputInlineQueryResultSticker (char *id_, char *thumbnail_url_, char *sticker_url_, int sticker_width_, int sticker_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultSticker ();
  var->ID = CODE_InputInlineQueryResultSticker;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->sticker_url_ = (sticker_url_) ? td::str_dup (td::Slice (sticker_url_)) : nullptr;
  var->sticker_width_ = sticker_width_;
  var->sticker_height_ = sticker_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultSticker> TdConvertToInternal (struct TdInputInlineQueryResultSticker *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::string v200;
  v200 = (var->sticker_url_) ? var->sticker_url_: "";
  std::int32_t v300;
  v300 = var->sticker_width_;
  std::int32_t v400;
  v400 = var->sticker_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v500;
  v500 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v600;
  v600 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultSticker>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdInputInlineQueryResultSticker *TdConvertFromInternal (const td::td_api::inputInlineQueryResultSticker &from) {
  auto res = new TdInputInlineQueryResultSticker ();
  res->ID = CODE_InputInlineQueryResultSticker;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->sticker_url_ = (from.sticker_url_.length ()) ? td::str_dup (from.sticker_url_) : nullptr;
  res->sticker_width_ = from.sticker_width_;
  res->sticker_height_ = from.sticker_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultSticker (struct TdInputInlineQueryResultSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultSticker (struct TdInputInlineQueryResultSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->thumbnail_url_);
  free (var->sticker_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultSticker (struct TdInputInlineQueryResultSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultSticker");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_string (var->sticker_url_);
  M->new_field ("sticker_url_");
  M->pack_long (var->sticker_width_);
  M->new_field ("sticker_width_");
  M->pack_long (var->sticker_height_);
  M->new_field ("sticker_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultSticker *TdStackFetcherInputInlineQueryResultSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultSticker ();
  res->ID = CODE_InputInlineQueryResultSticker;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("sticker_url_");
  res->sticker_url_ = M->get_string ();
  M->pop ();
  M->get_field ("sticker_width_");
  res->sticker_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sticker_height_");
  res->sticker_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultVenue *TdCreateObjectInputInlineQueryResultVenue (char *id_, struct TdVenue *venue_, char *thumbnail_url_, int thumbnail_width_, int thumbnail_height_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultVenue ();
  var->ID = CODE_InputInlineQueryResultVenue;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->venue_ = venue_;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->thumbnail_width_ = thumbnail_width_;
  var->thumbnail_height_ = thumbnail_height_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultVenue> TdConvertToInternal (struct TdInputInlineQueryResultVenue *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  td::td_api::object_ptr<td::td_api::venue> v100;
  v100 = TdConvertToInternal (var->venue_);
  std::string v200;
  v200 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::int32_t v300;
  v300 = var->thumbnail_width_;
  std::int32_t v400;
  v400 = var->thumbnail_height_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v500;
  v500 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v600;
  v600 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultVenue>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdInputInlineQueryResultVenue *TdConvertFromInternal (const td::td_api::inputInlineQueryResultVenue &from) {
  auto res = new TdInputInlineQueryResultVenue ();
  res->ID = CODE_InputInlineQueryResultVenue;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  if (!from.venue_) {
    res->venue_ = nullptr;
  } else {
    res->venue_ = TdConvertFromInternal (static_cast<const td::td_api::venue &>(*from.venue_));
  }
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->thumbnail_width_ = from.thumbnail_width_;
  res->thumbnail_height_ = from.thumbnail_height_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultVenue (struct TdInputInlineQueryResultVenue *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultVenue *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultVenue (struct TdInputInlineQueryResultVenue *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultVenue *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  TdDestroyObject (var->venue_);
  free (var->thumbnail_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultVenue (struct TdInputInlineQueryResultVenue *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultVenue *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultVenue");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->venue_, M);
  M->new_field ("venue_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_long (var->thumbnail_width_);
  M->new_field ("thumbnail_width_");
  M->pack_long (var->thumbnail_height_);
  M->new_field ("thumbnail_height_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultVenue *TdStackFetcherInputInlineQueryResultVenue (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultVenue ();
  res->ID = CODE_InputInlineQueryResultVenue;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("venue_");
  if (M->is_nil ()) {
    res->venue_ = nullptr;
  } else {
    res->venue_ = TdStackFetcherVenue (M);
  }
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_width_");
  res->thumbnail_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("thumbnail_height_");
  res->thumbnail_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultVideo *TdCreateObjectInputInlineQueryResultVideo (char *id_, char *title_, char *description_, char *thumbnail_url_, char *video_url_, char *mime_type_, int video_width_, int video_height_, int video_duration_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultVideo ();
  var->ID = CODE_InputInlineQueryResultVideo;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->thumbnail_url_ = (thumbnail_url_) ? td::str_dup (td::Slice (thumbnail_url_)) : nullptr;
  var->video_url_ = (video_url_) ? td::str_dup (td::Slice (video_url_)) : nullptr;
  var->mime_type_ = (mime_type_) ? td::str_dup (td::Slice (mime_type_)) : nullptr;
  var->video_width_ = video_width_;
  var->video_height_ = video_height_;
  var->video_duration_ = video_duration_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultVideo> TdConvertToInternal (struct TdInputInlineQueryResultVideo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->description_) ? var->description_: "";
  std::string v300;
  v300 = (var->thumbnail_url_) ? var->thumbnail_url_: "";
  std::string v400;
  v400 = (var->video_url_) ? var->video_url_: "";
  std::string v500;
  v500 = (var->mime_type_) ? var->mime_type_: "";
  std::int32_t v600;
  v600 = var->video_width_;
  std::int32_t v700;
  v700 = var->video_height_;
  std::int32_t v800;
  v800 = var->video_duration_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v900;
  v900 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v1000;
  v1000 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultVideo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000));
}
struct TdInputInlineQueryResultVideo *TdConvertFromInternal (const td::td_api::inputInlineQueryResultVideo &from) {
  auto res = new TdInputInlineQueryResultVideo ();
  res->ID = CODE_InputInlineQueryResultVideo;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  res->thumbnail_url_ = (from.thumbnail_url_.length ()) ? td::str_dup (from.thumbnail_url_) : nullptr;
  res->video_url_ = (from.video_url_.length ()) ? td::str_dup (from.video_url_) : nullptr;
  res->mime_type_ = (from.mime_type_.length ()) ? td::str_dup (from.mime_type_) : nullptr;
  res->video_width_ = from.video_width_;
  res->video_height_ = from.video_height_;
  res->video_duration_ = from.video_duration_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultVideo (struct TdInputInlineQueryResultVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultVideo (struct TdInputInlineQueryResultVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  free (var->description_);
  free (var->thumbnail_url_);
  free (var->video_url_);
  free (var->mime_type_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultVideo (struct TdInputInlineQueryResultVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultVideo");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  M->pack_string (var->thumbnail_url_);
  M->new_field ("thumbnail_url_");
  M->pack_string (var->video_url_);
  M->new_field ("video_url_");
  M->pack_string (var->mime_type_);
  M->new_field ("mime_type_");
  M->pack_long (var->video_width_);
  M->new_field ("video_width_");
  M->pack_long (var->video_height_);
  M->new_field ("video_height_");
  M->pack_long (var->video_duration_);
  M->new_field ("video_duration_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultVideo *TdStackFetcherInputInlineQueryResultVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultVideo ();
  res->ID = CODE_InputInlineQueryResultVideo;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("thumbnail_url_");
  res->thumbnail_url_ = M->get_string ();
  M->pop ();
  M->get_field ("video_url_");
  res->video_url_ = M->get_string ();
  M->pop ();
  M->get_field ("mime_type_");
  res->mime_type_ = M->get_string ();
  M->pop ();
  M->get_field ("video_width_");
  res->video_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("video_height_");
  res->video_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("video_duration_");
  res->video_duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdInputInlineQueryResultVoiceNote *TdCreateObjectInputInlineQueryResultVoiceNote (char *id_, char *title_, char *voice_note_url_, int voice_note_duration_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdInputInlineQueryResultVoiceNote ();
  var->ID = CODE_InputInlineQueryResultVoiceNote;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->voice_note_url_ = (voice_note_url_) ? td::str_dup (td::Slice (voice_note_url_)) : nullptr;
  var->voice_note_duration_ = voice_note_duration_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputInlineQueryResultVoiceNote> TdConvertToInternal (struct TdInputInlineQueryResultVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->voice_note_url_) ? var->voice_note_url_: "";
  std::int32_t v300;
  v300 = var->voice_note_duration_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v400;
  v400 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v500;
  v500 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::inputInlineQueryResultVoiceNote>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdInputInlineQueryResultVoiceNote *TdConvertFromInternal (const td::td_api::inputInlineQueryResultVoiceNote &from) {
  auto res = new TdInputInlineQueryResultVoiceNote ();
  res->ID = CODE_InputInlineQueryResultVoiceNote;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->voice_note_url_ = (from.voice_note_url_.length ()) ? td::str_dup (from.voice_note_url_) : nullptr;
  res->voice_note_duration_ = from.voice_note_duration_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeInputInlineQueryResultVoiceNote (struct TdInputInlineQueryResultVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputInlineQueryResultVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputInlineQueryResultVoiceNote (struct TdInputInlineQueryResultVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputInlineQueryResultVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  free (var->voice_note_url_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerInputInlineQueryResultVoiceNote (struct TdInputInlineQueryResultVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputInlineQueryResultVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputInlineQueryResultVoiceNote");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->voice_note_url_);
  M->new_field ("voice_note_url_");
  M->pack_long (var->voice_note_duration_);
  M->new_field ("voice_note_duration_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdInputInlineQueryResultVoiceNote *TdStackFetcherInputInlineQueryResultVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdInputInlineQueryResultVoiceNote ();
  res->ID = CODE_InputInlineQueryResultVoiceNote;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("voice_note_url_");
  res->voice_note_url_ = M->get_string ();
  M->pop ();
  M->get_field ("voice_note_duration_");
  res->voice_note_duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::InputMessageContent> TdConvertToInternal (struct TdInputMessageContent *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputMessageText: return TdConvertToInternal ((struct TdInputMessageText *)var);
    case CODE_InputMessageAnimation: return TdConvertToInternal ((struct TdInputMessageAnimation *)var);
    case CODE_InputMessageAudio: return TdConvertToInternal ((struct TdInputMessageAudio *)var);
    case CODE_InputMessageDocument: return TdConvertToInternal ((struct TdInputMessageDocument *)var);
    case CODE_InputMessagePhoto: return TdConvertToInternal ((struct TdInputMessagePhoto *)var);
    case CODE_InputMessageSticker: return TdConvertToInternal ((struct TdInputMessageSticker *)var);
    case CODE_InputMessageVideo: return TdConvertToInternal ((struct TdInputMessageVideo *)var);
    case CODE_InputMessageVideoNote: return TdConvertToInternal ((struct TdInputMessageVideoNote *)var);
    case CODE_InputMessageVoiceNote: return TdConvertToInternal ((struct TdInputMessageVoiceNote *)var);
    case CODE_InputMessageLocation: return TdConvertToInternal ((struct TdInputMessageLocation *)var);
    case CODE_InputMessageVenue: return TdConvertToInternal ((struct TdInputMessageVenue *)var);
    case CODE_InputMessageContact: return TdConvertToInternal ((struct TdInputMessageContact *)var);
    case CODE_InputMessageGame: return TdConvertToInternal ((struct TdInputMessageGame *)var);
    case CODE_InputMessageInvoice: return TdConvertToInternal ((struct TdInputMessageInvoice *)var);
    case CODE_InputMessageForwarded: return TdConvertToInternal ((struct TdInputMessageForwarded *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdInputMessageContent *TdConvertFromInternal (const td::td_api::InputMessageContent &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_InputMessageText: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageText &>(from));
    case CODE_InputMessageAnimation: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageAnimation &>(from));
    case CODE_InputMessageAudio: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageAudio &>(from));
    case CODE_InputMessageDocument: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageDocument &>(from));
    case CODE_InputMessagePhoto: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessagePhoto &>(from));
    case CODE_InputMessageSticker: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageSticker &>(from));
    case CODE_InputMessageVideo: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageVideo &>(from));
    case CODE_InputMessageVideoNote: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageVideoNote &>(from));
    case CODE_InputMessageVoiceNote: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageVoiceNote &>(from));
    case CODE_InputMessageLocation: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageLocation &>(from));
    case CODE_InputMessageVenue: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageVenue &>(from));
    case CODE_InputMessageContact: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageContact &>(from));
    case CODE_InputMessageGame: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageGame &>(from));
    case CODE_InputMessageInvoice: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageInvoice &>(from));
    case CODE_InputMessageForwarded: return (struct TdInputMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::inputMessageForwarded &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeInputMessageContent (struct TdInputMessageContent *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageContent *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageContent (struct TdInputMessageContent *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageContent *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputMessageText: return TdDestroyObject ((struct TdInputMessageText *)var);
    case CODE_InputMessageAnimation: return TdDestroyObject ((struct TdInputMessageAnimation *)var);
    case CODE_InputMessageAudio: return TdDestroyObject ((struct TdInputMessageAudio *)var);
    case CODE_InputMessageDocument: return TdDestroyObject ((struct TdInputMessageDocument *)var);
    case CODE_InputMessagePhoto: return TdDestroyObject ((struct TdInputMessagePhoto *)var);
    case CODE_InputMessageSticker: return TdDestroyObject ((struct TdInputMessageSticker *)var);
    case CODE_InputMessageVideo: return TdDestroyObject ((struct TdInputMessageVideo *)var);
    case CODE_InputMessageVideoNote: return TdDestroyObject ((struct TdInputMessageVideoNote *)var);
    case CODE_InputMessageVoiceNote: return TdDestroyObject ((struct TdInputMessageVoiceNote *)var);
    case CODE_InputMessageLocation: return TdDestroyObject ((struct TdInputMessageLocation *)var);
    case CODE_InputMessageVenue: return TdDestroyObject ((struct TdInputMessageVenue *)var);
    case CODE_InputMessageContact: return TdDestroyObject ((struct TdInputMessageContact *)var);
    case CODE_InputMessageGame: return TdDestroyObject ((struct TdInputMessageGame *)var);
    case CODE_InputMessageInvoice: return TdDestroyObject ((struct TdInputMessageInvoice *)var);
    case CODE_InputMessageForwarded: return TdDestroyObject ((struct TdInputMessageForwarded *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerInputMessageContent (struct TdInputMessageContent *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageContent *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputMessageText: return TdStackStorer ((struct TdInputMessageText *)var, M);
    case CODE_InputMessageAnimation: return TdStackStorer ((struct TdInputMessageAnimation *)var, M);
    case CODE_InputMessageAudio: return TdStackStorer ((struct TdInputMessageAudio *)var, M);
    case CODE_InputMessageDocument: return TdStackStorer ((struct TdInputMessageDocument *)var, M);
    case CODE_InputMessagePhoto: return TdStackStorer ((struct TdInputMessagePhoto *)var, M);
    case CODE_InputMessageSticker: return TdStackStorer ((struct TdInputMessageSticker *)var, M);
    case CODE_InputMessageVideo: return TdStackStorer ((struct TdInputMessageVideo *)var, M);
    case CODE_InputMessageVideoNote: return TdStackStorer ((struct TdInputMessageVideoNote *)var, M);
    case CODE_InputMessageVoiceNote: return TdStackStorer ((struct TdInputMessageVoiceNote *)var, M);
    case CODE_InputMessageLocation: return TdStackStorer ((struct TdInputMessageLocation *)var, M);
    case CODE_InputMessageVenue: return TdStackStorer ((struct TdInputMessageVenue *)var, M);
    case CODE_InputMessageContact: return TdStackStorer ((struct TdInputMessageContact *)var, M);
    case CODE_InputMessageGame: return TdStackStorer ((struct TdInputMessageGame *)var, M);
    case CODE_InputMessageInvoice: return TdStackStorer ((struct TdInputMessageInvoice *)var, M);
    case CODE_InputMessageForwarded: return TdStackStorer ((struct TdInputMessageForwarded *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdInputMessageContent *TdStackFetcherInputMessageContent (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "InputMessageText") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageText (M);
  }
  if (constructor == "InputMessageAnimation") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageAnimation (M);
  }
  if (constructor == "InputMessageAudio") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageAudio (M);
  }
  if (constructor == "InputMessageDocument") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageDocument (M);
  }
  if (constructor == "InputMessagePhoto") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessagePhoto (M);
  }
  if (constructor == "InputMessageSticker") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageSticker (M);
  }
  if (constructor == "InputMessageVideo") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageVideo (M);
  }
  if (constructor == "InputMessageVideoNote") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageVideoNote (M);
  }
  if (constructor == "InputMessageVoiceNote") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageVoiceNote (M);
  }
  if (constructor == "InputMessageLocation") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageLocation (M);
  }
  if (constructor == "InputMessageVenue") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageVenue (M);
  }
  if (constructor == "InputMessageContact") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageContact (M);
  }
  if (constructor == "InputMessageGame") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageGame (M);
  }
  if (constructor == "InputMessageInvoice") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageInvoice (M);
  }
  if (constructor == "InputMessageForwarded") {
    return (struct TdInputMessageContent *)TdStackFetcherInputMessageForwarded (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdInputMessageText *TdCreateObjectInputMessageText (struct TdFormattedText *text_, int disable_web_page_preview_, int clear_draft_) {
  auto var = new struct TdInputMessageText ();
  var->ID = CODE_InputMessageText;
  var->refcnt = 1;
  var->text_ = text_;
  var->disable_web_page_preview_ = disable_web_page_preview_;
  var->clear_draft_ = clear_draft_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageText> TdConvertToInternal (struct TdInputMessageText *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::formattedText> v0;
  v0 = TdConvertToInternal (var->text_);
  bool v100;
  v100 = var->disable_web_page_preview_ != 0;
  bool v200;
  v200 = var->clear_draft_ != 0;
  return td::td_api::make_object<td::td_api::inputMessageText>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInputMessageText *TdConvertFromInternal (const td::td_api::inputMessageText &from) {
  auto res = new TdInputMessageText ();
  res->ID = CODE_InputMessageText;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.text_));
  }
  res->disable_web_page_preview_ = from.disable_web_page_preview_;
  res->clear_draft_ = from.clear_draft_;
  return res;
}
char *TdSerializeInputMessageText (struct TdInputMessageText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageText (struct TdInputMessageText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageText *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerInputMessageText (struct TdInputMessageText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageText *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageText");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  M->pack_bool (var->disable_web_page_preview_);
  M->new_field ("disable_web_page_preview_");
  M->pack_bool (var->clear_draft_);
  M->new_field ("clear_draft_");
}
struct TdInputMessageText *TdStackFetcherInputMessageText (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageText ();
  res->ID = CODE_InputMessageText;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("disable_web_page_preview_");
  res->disable_web_page_preview_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("clear_draft_");
  res->clear_draft_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputMessageAnimation *TdCreateObjectInputMessageAnimation (struct TdInputFile *animation_, struct TdInputThumbnail *thumbnail_, int duration_, int width_, int height_, struct TdFormattedText *caption_) {
  auto var = new struct TdInputMessageAnimation ();
  var->ID = CODE_InputMessageAnimation;
  var->refcnt = 1;
  var->animation_ = animation_;
  var->thumbnail_ = thumbnail_;
  var->duration_ = duration_;
  var->width_ = width_;
  var->height_ = height_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageAnimation> TdConvertToInternal (struct TdInputMessageAnimation *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->animation_);
  td::td_api::object_ptr<td::td_api::inputThumbnail> v100;
  v100 = TdConvertToInternal (var->thumbnail_);
  std::int32_t v200;
  v200 = var->duration_;
  std::int32_t v300;
  v300 = var->width_;
  std::int32_t v400;
  v400 = var->height_;
  td::td_api::object_ptr<td::td_api::formattedText> v500;
  v500 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::inputMessageAnimation>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdInputMessageAnimation *TdConvertFromInternal (const td::td_api::inputMessageAnimation &from) {
  auto res = new TdInputMessageAnimation ();
  res->ID = CODE_InputMessageAnimation;
  res->refcnt = 1;
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.animation_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::inputThumbnail &>(*from.thumbnail_));
  }
  res->duration_ = from.duration_;
  res->width_ = from.width_;
  res->height_ = from.height_;
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  return res;
}
char *TdSerializeInputMessageAnimation (struct TdInputMessageAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageAnimation (struct TdInputMessageAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->animation_);
  TdDestroyObject (var->thumbnail_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerInputMessageAnimation (struct TdInputMessageAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageAnimation");
  M->new_field ("ID");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdInputMessageAnimation *TdStackFetcherInputMessageAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageAnimation ();
  res->ID = CODE_InputMessageAnimation;
  res->refcnt = 1;
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherInputThumbnail (M);
  }
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdInputMessageAudio *TdCreateObjectInputMessageAudio (struct TdInputFile *audio_, struct TdInputThumbnail *album_cover_thumbnail_, int duration_, char *title_, char *performer_, struct TdFormattedText *caption_) {
  auto var = new struct TdInputMessageAudio ();
  var->ID = CODE_InputMessageAudio;
  var->refcnt = 1;
  var->audio_ = audio_;
  var->album_cover_thumbnail_ = album_cover_thumbnail_;
  var->duration_ = duration_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->performer_ = (performer_) ? td::str_dup (td::Slice (performer_)) : nullptr;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageAudio> TdConvertToInternal (struct TdInputMessageAudio *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->audio_);
  td::td_api::object_ptr<td::td_api::inputThumbnail> v100;
  v100 = TdConvertToInternal (var->album_cover_thumbnail_);
  std::int32_t v200;
  v200 = var->duration_;
  std::string v300;
  v300 = (var->title_) ? var->title_: "";
  std::string v400;
  v400 = (var->performer_) ? var->performer_: "";
  td::td_api::object_ptr<td::td_api::formattedText> v500;
  v500 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::inputMessageAudio>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdInputMessageAudio *TdConvertFromInternal (const td::td_api::inputMessageAudio &from) {
  auto res = new TdInputMessageAudio ();
  res->ID = CODE_InputMessageAudio;
  res->refcnt = 1;
  if (!from.audio_) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.audio_));
  }
  if (!from.album_cover_thumbnail_) {
    res->album_cover_thumbnail_ = nullptr;
  } else {
    res->album_cover_thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::inputThumbnail &>(*from.album_cover_thumbnail_));
  }
  res->duration_ = from.duration_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->performer_ = (from.performer_.length ()) ? td::str_dup (from.performer_) : nullptr;
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  return res;
}
char *TdSerializeInputMessageAudio (struct TdInputMessageAudio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageAudio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageAudio (struct TdInputMessageAudio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageAudio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->audio_);
  TdDestroyObject (var->album_cover_thumbnail_);
  free (var->title_);
  free (var->performer_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerInputMessageAudio (struct TdInputMessageAudio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageAudio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageAudio");
  M->new_field ("ID");
  TdStackStorer (var->audio_, M);
  M->new_field ("audio_");
  TdStackStorer (var->album_cover_thumbnail_, M);
  M->new_field ("album_cover_thumbnail_");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->performer_);
  M->new_field ("performer_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdInputMessageAudio *TdStackFetcherInputMessageAudio (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageAudio ();
  res->ID = CODE_InputMessageAudio;
  res->refcnt = 1;
  M->get_field ("audio_");
  if (M->is_nil ()) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("album_cover_thumbnail_");
  if (M->is_nil ()) {
    res->album_cover_thumbnail_ = nullptr;
  } else {
    res->album_cover_thumbnail_ = TdStackFetcherInputThumbnail (M);
  }
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("performer_");
  res->performer_ = M->get_string ();
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdInputMessageDocument *TdCreateObjectInputMessageDocument (struct TdInputFile *document_, struct TdInputThumbnail *thumbnail_, struct TdFormattedText *caption_) {
  auto var = new struct TdInputMessageDocument ();
  var->ID = CODE_InputMessageDocument;
  var->refcnt = 1;
  var->document_ = document_;
  var->thumbnail_ = thumbnail_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageDocument> TdConvertToInternal (struct TdInputMessageDocument *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->document_);
  td::td_api::object_ptr<td::td_api::inputThumbnail> v100;
  v100 = TdConvertToInternal (var->thumbnail_);
  td::td_api::object_ptr<td::td_api::formattedText> v200;
  v200 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::inputMessageDocument>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInputMessageDocument *TdConvertFromInternal (const td::td_api::inputMessageDocument &from) {
  auto res = new TdInputMessageDocument ();
  res->ID = CODE_InputMessageDocument;
  res->refcnt = 1;
  if (!from.document_) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.document_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::inputThumbnail &>(*from.thumbnail_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  return res;
}
char *TdSerializeInputMessageDocument (struct TdInputMessageDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageDocument (struct TdInputMessageDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->document_);
  TdDestroyObject (var->thumbnail_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerInputMessageDocument (struct TdInputMessageDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageDocument");
  M->new_field ("ID");
  TdStackStorer (var->document_, M);
  M->new_field ("document_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdInputMessageDocument *TdStackFetcherInputMessageDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageDocument ();
  res->ID = CODE_InputMessageDocument;
  res->refcnt = 1;
  M->get_field ("document_");
  if (M->is_nil ()) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherInputThumbnail (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdInputMessagePhoto *TdCreateObjectInputMessagePhoto (struct TdInputFile *photo_, struct TdInputThumbnail *thumbnail_, struct TdVectorInt *added_sticker_file_ids_, int width_, int height_, struct TdFormattedText *caption_, int ttl_) {
  auto var = new struct TdInputMessagePhoto ();
  var->ID = CODE_InputMessagePhoto;
  var->refcnt = 1;
  var->photo_ = photo_;
  var->thumbnail_ = thumbnail_;
  var->added_sticker_file_ids_ = added_sticker_file_ids_;
  var->width_ = width_;
  var->height_ = height_;
  var->caption_ = caption_;
  var->ttl_ = ttl_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessagePhoto> TdConvertToInternal (struct TdInputMessagePhoto *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->photo_);
  td::td_api::object_ptr<td::td_api::inputThumbnail> v100;
  v100 = TdConvertToInternal (var->thumbnail_);
  std::vector<std::int32_t> v200;
  for (int i200 = 0; i200 < var->added_sticker_file_ids_->len; i200++) {
    std::int32_t v201;
    v201 = var->added_sticker_file_ids_->data[i200];
    v200.push_back (std::move (v201));
  }
  std::int32_t v300;
  v300 = var->width_;
  std::int32_t v400;
  v400 = var->height_;
  td::td_api::object_ptr<td::td_api::formattedText> v500;
  v500 = TdConvertToInternal (var->caption_);
  std::int32_t v600;
  v600 = var->ttl_;
  return td::td_api::make_object<td::td_api::inputMessagePhoto>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdInputMessagePhoto *TdConvertFromInternal (const td::td_api::inputMessagePhoto &from) {
  auto res = new TdInputMessagePhoto ();
  res->ID = CODE_InputMessagePhoto;
  res->refcnt = 1;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.photo_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::inputThumbnail &>(*from.thumbnail_));
  }
  res->added_sticker_file_ids_ = new TdVectorInt ();
  res->added_sticker_file_ids_->len = (int)from.added_sticker_file_ids_.size ();
  res->added_sticker_file_ids_->data = new int  [res->added_sticker_file_ids_->len];
  for (int i200 = 0; i200 < res->added_sticker_file_ids_->len; i200++) {
    res->added_sticker_file_ids_->data[i200] = from.added_sticker_file_ids_[i200];
  }
  res->width_ = from.width_;
  res->height_ = from.height_;
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  res->ttl_ = from.ttl_;
  return res;
}
char *TdSerializeInputMessagePhoto (struct TdInputMessagePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessagePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessagePhoto (struct TdInputMessagePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessagePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->photo_);
  TdDestroyObject (var->thumbnail_);
  for (int i200 = 0; i200 < var->added_sticker_file_ids_->len; i200++) {
  }
  delete[] var->added_sticker_file_ids_->data;
  delete var->added_sticker_file_ids_;
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerInputMessagePhoto (struct TdInputMessagePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessagePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessagePhoto");
  M->new_field ("ID");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  M->new_array ();
  for (int i200 = 0; i200 < var->added_sticker_file_ids_->len; i200++) {
    M->pack_long (var->added_sticker_file_ids_->data[i200]);
    M->new_arr_field (i200);
  }
  M->new_field ("added_sticker_file_ids_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_long (var->ttl_);
  M->new_field ("ttl_");
}
struct TdInputMessagePhoto *TdStackFetcherInputMessagePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessagePhoto ();
  res->ID = CODE_InputMessagePhoto;
  res->refcnt = 1;
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherInputThumbnail (M);
  }
  M->pop ();
  M->get_field ("added_sticker_file_ids_");
  res->added_sticker_file_ids_ = new TdVectorInt ();
  res->added_sticker_file_ids_->len = M->get_arr_size ();
  res->added_sticker_file_ids_->data = new int  [res->added_sticker_file_ids_->len];
  for (int i200 = 0; i200 < res->added_sticker_file_ids_->len; i200++) {
    M->get_arr_field (i200);
    res->added_sticker_file_ids_->data[i200] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("ttl_");
  res->ttl_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputMessageSticker *TdCreateObjectInputMessageSticker (struct TdInputFile *sticker_, struct TdInputThumbnail *thumbnail_, int width_, int height_) {
  auto var = new struct TdInputMessageSticker ();
  var->ID = CODE_InputMessageSticker;
  var->refcnt = 1;
  var->sticker_ = sticker_;
  var->thumbnail_ = thumbnail_;
  var->width_ = width_;
  var->height_ = height_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageSticker> TdConvertToInternal (struct TdInputMessageSticker *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->sticker_);
  td::td_api::object_ptr<td::td_api::inputThumbnail> v100;
  v100 = TdConvertToInternal (var->thumbnail_);
  std::int32_t v200;
  v200 = var->width_;
  std::int32_t v300;
  v300 = var->height_;
  return td::td_api::make_object<td::td_api::inputMessageSticker>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdInputMessageSticker *TdConvertFromInternal (const td::td_api::inputMessageSticker &from) {
  auto res = new TdInputMessageSticker ();
  res->ID = CODE_InputMessageSticker;
  res->refcnt = 1;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.sticker_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::inputThumbnail &>(*from.thumbnail_));
  }
  res->width_ = from.width_;
  res->height_ = from.height_;
  return res;
}
char *TdSerializeInputMessageSticker (struct TdInputMessageSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageSticker (struct TdInputMessageSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  TdDestroyObject (var->thumbnail_);
  delete var;
}
void TdStackStorerInputMessageSticker (struct TdInputMessageSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageSticker");
  M->new_field ("ID");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
}
struct TdInputMessageSticker *TdStackFetcherInputMessageSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageSticker ();
  res->ID = CODE_InputMessageSticker;
  res->refcnt = 1;
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherInputThumbnail (M);
  }
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputMessageVideo *TdCreateObjectInputMessageVideo (struct TdInputFile *video_, struct TdInputThumbnail *thumbnail_, struct TdVectorInt *added_sticker_file_ids_, int duration_, int width_, int height_, int supports_streaming_, struct TdFormattedText *caption_, int ttl_) {
  auto var = new struct TdInputMessageVideo ();
  var->ID = CODE_InputMessageVideo;
  var->refcnt = 1;
  var->video_ = video_;
  var->thumbnail_ = thumbnail_;
  var->added_sticker_file_ids_ = added_sticker_file_ids_;
  var->duration_ = duration_;
  var->width_ = width_;
  var->height_ = height_;
  var->supports_streaming_ = supports_streaming_;
  var->caption_ = caption_;
  var->ttl_ = ttl_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageVideo> TdConvertToInternal (struct TdInputMessageVideo *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->video_);
  td::td_api::object_ptr<td::td_api::inputThumbnail> v100;
  v100 = TdConvertToInternal (var->thumbnail_);
  std::vector<std::int32_t> v200;
  for (int i200 = 0; i200 < var->added_sticker_file_ids_->len; i200++) {
    std::int32_t v201;
    v201 = var->added_sticker_file_ids_->data[i200];
    v200.push_back (std::move (v201));
  }
  std::int32_t v300;
  v300 = var->duration_;
  std::int32_t v400;
  v400 = var->width_;
  std::int32_t v500;
  v500 = var->height_;
  bool v600;
  v600 = var->supports_streaming_ != 0;
  td::td_api::object_ptr<td::td_api::formattedText> v700;
  v700 = TdConvertToInternal (var->caption_);
  std::int32_t v800;
  v800 = var->ttl_;
  return td::td_api::make_object<td::td_api::inputMessageVideo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdInputMessageVideo *TdConvertFromInternal (const td::td_api::inputMessageVideo &from) {
  auto res = new TdInputMessageVideo ();
  res->ID = CODE_InputMessageVideo;
  res->refcnt = 1;
  if (!from.video_) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.video_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::inputThumbnail &>(*from.thumbnail_));
  }
  res->added_sticker_file_ids_ = new TdVectorInt ();
  res->added_sticker_file_ids_->len = (int)from.added_sticker_file_ids_.size ();
  res->added_sticker_file_ids_->data = new int  [res->added_sticker_file_ids_->len];
  for (int i200 = 0; i200 < res->added_sticker_file_ids_->len; i200++) {
    res->added_sticker_file_ids_->data[i200] = from.added_sticker_file_ids_[i200];
  }
  res->duration_ = from.duration_;
  res->width_ = from.width_;
  res->height_ = from.height_;
  res->supports_streaming_ = from.supports_streaming_;
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  res->ttl_ = from.ttl_;
  return res;
}
char *TdSerializeInputMessageVideo (struct TdInputMessageVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageVideo (struct TdInputMessageVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->video_);
  TdDestroyObject (var->thumbnail_);
  for (int i200 = 0; i200 < var->added_sticker_file_ids_->len; i200++) {
  }
  delete[] var->added_sticker_file_ids_->data;
  delete var->added_sticker_file_ids_;
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerInputMessageVideo (struct TdInputMessageVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageVideo");
  M->new_field ("ID");
  TdStackStorer (var->video_, M);
  M->new_field ("video_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  M->new_array ();
  for (int i200 = 0; i200 < var->added_sticker_file_ids_->len; i200++) {
    M->pack_long (var->added_sticker_file_ids_->data[i200]);
    M->new_arr_field (i200);
  }
  M->new_field ("added_sticker_file_ids_");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
  M->pack_bool (var->supports_streaming_);
  M->new_field ("supports_streaming_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_long (var->ttl_);
  M->new_field ("ttl_");
}
struct TdInputMessageVideo *TdStackFetcherInputMessageVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageVideo ();
  res->ID = CODE_InputMessageVideo;
  res->refcnt = 1;
  M->get_field ("video_");
  if (M->is_nil ()) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherInputThumbnail (M);
  }
  M->pop ();
  M->get_field ("added_sticker_file_ids_");
  res->added_sticker_file_ids_ = new TdVectorInt ();
  res->added_sticker_file_ids_->len = M->get_arr_size ();
  res->added_sticker_file_ids_->data = new int  [res->added_sticker_file_ids_->len];
  for (int i200 = 0; i200 < res->added_sticker_file_ids_->len; i200++) {
    M->get_arr_field (i200);
    res->added_sticker_file_ids_->data[i200] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("supports_streaming_");
  res->supports_streaming_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("ttl_");
  res->ttl_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputMessageVideoNote *TdCreateObjectInputMessageVideoNote (struct TdInputFile *video_note_, struct TdInputThumbnail *thumbnail_, int duration_, int length_) {
  auto var = new struct TdInputMessageVideoNote ();
  var->ID = CODE_InputMessageVideoNote;
  var->refcnt = 1;
  var->video_note_ = video_note_;
  var->thumbnail_ = thumbnail_;
  var->duration_ = duration_;
  var->length_ = length_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageVideoNote> TdConvertToInternal (struct TdInputMessageVideoNote *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->video_note_);
  td::td_api::object_ptr<td::td_api::inputThumbnail> v100;
  v100 = TdConvertToInternal (var->thumbnail_);
  std::int32_t v200;
  v200 = var->duration_;
  std::int32_t v300;
  v300 = var->length_;
  return td::td_api::make_object<td::td_api::inputMessageVideoNote>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdInputMessageVideoNote *TdConvertFromInternal (const td::td_api::inputMessageVideoNote &from) {
  auto res = new TdInputMessageVideoNote ();
  res->ID = CODE_InputMessageVideoNote;
  res->refcnt = 1;
  if (!from.video_note_) {
    res->video_note_ = nullptr;
  } else {
    res->video_note_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.video_note_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::inputThumbnail &>(*from.thumbnail_));
  }
  res->duration_ = from.duration_;
  res->length_ = from.length_;
  return res;
}
char *TdSerializeInputMessageVideoNote (struct TdInputMessageVideoNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageVideoNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageVideoNote (struct TdInputMessageVideoNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageVideoNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->video_note_);
  TdDestroyObject (var->thumbnail_);
  delete var;
}
void TdStackStorerInputMessageVideoNote (struct TdInputMessageVideoNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageVideoNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageVideoNote");
  M->new_field ("ID");
  TdStackStorer (var->video_note_, M);
  M->new_field ("video_note_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_long (var->length_);
  M->new_field ("length_");
}
struct TdInputMessageVideoNote *TdStackFetcherInputMessageVideoNote (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageVideoNote ();
  res->ID = CODE_InputMessageVideoNote;
  res->refcnt = 1;
  M->get_field ("video_note_");
  if (M->is_nil ()) {
    res->video_note_ = nullptr;
  } else {
    res->video_note_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherInputThumbnail (M);
  }
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("length_");
  res->length_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputMessageVoiceNote *TdCreateObjectInputMessageVoiceNote (struct TdInputFile *voice_note_, int duration_, struct TdBytes waveform_, struct TdFormattedText *caption_) {
  auto var = new struct TdInputMessageVoiceNote ();
  var->ID = CODE_InputMessageVoiceNote;
  var->refcnt = 1;
  var->voice_note_ = voice_note_;
  var->duration_ = duration_;
  var->waveform_ = waveform_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageVoiceNote> TdConvertToInternal (struct TdInputMessageVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->voice_note_);
  std::int32_t v100;
  v100 = var->duration_;
  std::string v200;
  v200 = std::string ((char *)var->waveform_.data, var->waveform_.len);
  td::td_api::object_ptr<td::td_api::formattedText> v300;
  v300 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::inputMessageVoiceNote>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdInputMessageVoiceNote *TdConvertFromInternal (const td::td_api::inputMessageVoiceNote &from) {
  auto res = new TdInputMessageVoiceNote ();
  res->ID = CODE_InputMessageVoiceNote;
  res->refcnt = 1;
  if (!from.voice_note_) {
    res->voice_note_ = nullptr;
  } else {
    res->voice_note_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.voice_note_));
  }
  res->duration_ = from.duration_;
  res->waveform_.len = (int)from.waveform_.length ();
  if (res->waveform_.len) {
    res->waveform_.data = new unsigned char[res->waveform_.len];
    memcpy (res->waveform_.data, from.waveform_.c_str (), res->waveform_.len);
  } else {
    res->waveform_.data = nullptr;
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  return res;
}
char *TdSerializeInputMessageVoiceNote (struct TdInputMessageVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageVoiceNote (struct TdInputMessageVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->voice_note_);
  delete[]var->waveform_.data;
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerInputMessageVoiceNote (struct TdInputMessageVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageVoiceNote");
  M->new_field ("ID");
  TdStackStorer (var->voice_note_, M);
  M->new_field ("voice_note_");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_bytes (var->waveform_.data, var->waveform_.len);
  M->new_field ("waveform_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdInputMessageVoiceNote *TdStackFetcherInputMessageVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageVoiceNote ();
  res->ID = CODE_InputMessageVoiceNote;
  res->refcnt = 1;
  M->get_field ("voice_note_");
  if (M->is_nil ()) {
    res->voice_note_ = nullptr;
  } else {
    res->voice_note_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("waveform_");
  res->waveform_.data = M->get_bytes (&res->waveform_.len);
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdInputMessageLocation *TdCreateObjectInputMessageLocation (struct TdLocation *location_, int live_period_) {
  auto var = new struct TdInputMessageLocation ();
  var->ID = CODE_InputMessageLocation;
  var->refcnt = 1;
  var->location_ = location_;
  var->live_period_ = live_period_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageLocation> TdConvertToInternal (struct TdInputMessageLocation *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::location> v0;
  v0 = TdConvertToInternal (var->location_);
  std::int32_t v100;
  v100 = var->live_period_;
  return td::td_api::make_object<td::td_api::inputMessageLocation>(std::move (v0), std::move (v100));
}
struct TdInputMessageLocation *TdConvertFromInternal (const td::td_api::inputMessageLocation &from) {
  auto res = new TdInputMessageLocation ();
  res->ID = CODE_InputMessageLocation;
  res->refcnt = 1;
  if (!from.location_) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.location_));
  }
  res->live_period_ = from.live_period_;
  return res;
}
char *TdSerializeInputMessageLocation (struct TdInputMessageLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageLocation (struct TdInputMessageLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->location_);
  delete var;
}
void TdStackStorerInputMessageLocation (struct TdInputMessageLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageLocation");
  M->new_field ("ID");
  TdStackStorer (var->location_, M);
  M->new_field ("location_");
  M->pack_long (var->live_period_);
  M->new_field ("live_period_");
}
struct TdInputMessageLocation *TdStackFetcherInputMessageLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageLocation ();
  res->ID = CODE_InputMessageLocation;
  res->refcnt = 1;
  M->get_field ("location_");
  if (M->is_nil ()) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("live_period_");
  res->live_period_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInputMessageVenue *TdCreateObjectInputMessageVenue (struct TdVenue *venue_) {
  auto var = new struct TdInputMessageVenue ();
  var->ID = CODE_InputMessageVenue;
  var->refcnt = 1;
  var->venue_ = venue_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageVenue> TdConvertToInternal (struct TdInputMessageVenue *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::venue> v0;
  v0 = TdConvertToInternal (var->venue_);
  return td::td_api::make_object<td::td_api::inputMessageVenue>(std::move (v0));
}
struct TdInputMessageVenue *TdConvertFromInternal (const td::td_api::inputMessageVenue &from) {
  auto res = new TdInputMessageVenue ();
  res->ID = CODE_InputMessageVenue;
  res->refcnt = 1;
  if (!from.venue_) {
    res->venue_ = nullptr;
  } else {
    res->venue_ = TdConvertFromInternal (static_cast<const td::td_api::venue &>(*from.venue_));
  }
  return res;
}
char *TdSerializeInputMessageVenue (struct TdInputMessageVenue *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageVenue *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageVenue (struct TdInputMessageVenue *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageVenue *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->venue_);
  delete var;
}
void TdStackStorerInputMessageVenue (struct TdInputMessageVenue *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageVenue *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageVenue");
  M->new_field ("ID");
  TdStackStorer (var->venue_, M);
  M->new_field ("venue_");
}
struct TdInputMessageVenue *TdStackFetcherInputMessageVenue (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageVenue ();
  res->ID = CODE_InputMessageVenue;
  res->refcnt = 1;
  M->get_field ("venue_");
  if (M->is_nil ()) {
    res->venue_ = nullptr;
  } else {
    res->venue_ = TdStackFetcherVenue (M);
  }
  M->pop ();
  return res;
}
struct TdInputMessageContact *TdCreateObjectInputMessageContact (struct TdContact *contact_) {
  auto var = new struct TdInputMessageContact ();
  var->ID = CODE_InputMessageContact;
  var->refcnt = 1;
  var->contact_ = contact_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageContact> TdConvertToInternal (struct TdInputMessageContact *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::contact> v0;
  v0 = TdConvertToInternal (var->contact_);
  return td::td_api::make_object<td::td_api::inputMessageContact>(std::move (v0));
}
struct TdInputMessageContact *TdConvertFromInternal (const td::td_api::inputMessageContact &from) {
  auto res = new TdInputMessageContact ();
  res->ID = CODE_InputMessageContact;
  res->refcnt = 1;
  if (!from.contact_) {
    res->contact_ = nullptr;
  } else {
    res->contact_ = TdConvertFromInternal (static_cast<const td::td_api::contact &>(*from.contact_));
  }
  return res;
}
char *TdSerializeInputMessageContact (struct TdInputMessageContact *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageContact *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageContact (struct TdInputMessageContact *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageContact *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->contact_);
  delete var;
}
void TdStackStorerInputMessageContact (struct TdInputMessageContact *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageContact *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageContact");
  M->new_field ("ID");
  TdStackStorer (var->contact_, M);
  M->new_field ("contact_");
}
struct TdInputMessageContact *TdStackFetcherInputMessageContact (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageContact ();
  res->ID = CODE_InputMessageContact;
  res->refcnt = 1;
  M->get_field ("contact_");
  if (M->is_nil ()) {
    res->contact_ = nullptr;
  } else {
    res->contact_ = TdStackFetcherContact (M);
  }
  M->pop ();
  return res;
}
struct TdInputMessageGame *TdCreateObjectInputMessageGame (int bot_user_id_, char *game_short_name_) {
  auto var = new struct TdInputMessageGame ();
  var->ID = CODE_InputMessageGame;
  var->refcnt = 1;
  var->bot_user_id_ = bot_user_id_;
  var->game_short_name_ = (game_short_name_) ? td::str_dup (td::Slice (game_short_name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageGame> TdConvertToInternal (struct TdInputMessageGame *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->bot_user_id_;
  std::string v100;
  v100 = (var->game_short_name_) ? var->game_short_name_: "";
  return td::td_api::make_object<td::td_api::inputMessageGame>(std::move (v0), std::move (v100));
}
struct TdInputMessageGame *TdConvertFromInternal (const td::td_api::inputMessageGame &from) {
  auto res = new TdInputMessageGame ();
  res->ID = CODE_InputMessageGame;
  res->refcnt = 1;
  res->bot_user_id_ = from.bot_user_id_;
  res->game_short_name_ = (from.game_short_name_.length ()) ? td::str_dup (from.game_short_name_) : nullptr;
  return res;
}
char *TdSerializeInputMessageGame (struct TdInputMessageGame *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageGame *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageGame (struct TdInputMessageGame *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageGame *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->game_short_name_);
  delete var;
}
void TdStackStorerInputMessageGame (struct TdInputMessageGame *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageGame *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageGame");
  M->new_field ("ID");
  M->pack_long (var->bot_user_id_);
  M->new_field ("bot_user_id_");
  M->pack_string (var->game_short_name_);
  M->new_field ("game_short_name_");
}
struct TdInputMessageGame *TdStackFetcherInputMessageGame (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageGame ();
  res->ID = CODE_InputMessageGame;
  res->refcnt = 1;
  M->get_field ("bot_user_id_");
  res->bot_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("game_short_name_");
  res->game_short_name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInputMessageInvoice *TdCreateObjectInputMessageInvoice (struct TdInvoice *invoice_, char *title_, char *description_, char *photo_url_, int photo_size_, int photo_width_, int photo_height_, struct TdBytes payload_, char *provider_token_, char *provider_data_, char *start_parameter_) {
  auto var = new struct TdInputMessageInvoice ();
  var->ID = CODE_InputMessageInvoice;
  var->refcnt = 1;
  var->invoice_ = invoice_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->photo_url_ = (photo_url_) ? td::str_dup (td::Slice (photo_url_)) : nullptr;
  var->photo_size_ = photo_size_;
  var->photo_width_ = photo_width_;
  var->photo_height_ = photo_height_;
  var->payload_ = payload_;
  var->provider_token_ = (provider_token_) ? td::str_dup (td::Slice (provider_token_)) : nullptr;
  var->provider_data_ = (provider_data_) ? td::str_dup (td::Slice (provider_data_)) : nullptr;
  var->start_parameter_ = (start_parameter_) ? td::str_dup (td::Slice (start_parameter_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageInvoice> TdConvertToInternal (struct TdInputMessageInvoice *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::invoice> v0;
  v0 = TdConvertToInternal (var->invoice_);
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->description_) ? var->description_: "";
  std::string v300;
  v300 = (var->photo_url_) ? var->photo_url_: "";
  std::int32_t v400;
  v400 = var->photo_size_;
  std::int32_t v500;
  v500 = var->photo_width_;
  std::int32_t v600;
  v600 = var->photo_height_;
  std::string v700;
  v700 = std::string ((char *)var->payload_.data, var->payload_.len);
  std::string v800;
  v800 = (var->provider_token_) ? var->provider_token_: "";
  std::string v900;
  v900 = (var->provider_data_) ? var->provider_data_: "";
  std::string v1000;
  v1000 = (var->start_parameter_) ? var->start_parameter_: "";
  return td::td_api::make_object<td::td_api::inputMessageInvoice>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000));
}
struct TdInputMessageInvoice *TdConvertFromInternal (const td::td_api::inputMessageInvoice &from) {
  auto res = new TdInputMessageInvoice ();
  res->ID = CODE_InputMessageInvoice;
  res->refcnt = 1;
  if (!from.invoice_) {
    res->invoice_ = nullptr;
  } else {
    res->invoice_ = TdConvertFromInternal (static_cast<const td::td_api::invoice &>(*from.invoice_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  res->photo_url_ = (from.photo_url_.length ()) ? td::str_dup (from.photo_url_) : nullptr;
  res->photo_size_ = from.photo_size_;
  res->photo_width_ = from.photo_width_;
  res->photo_height_ = from.photo_height_;
  res->payload_.len = (int)from.payload_.length ();
  if (res->payload_.len) {
    res->payload_.data = new unsigned char[res->payload_.len];
    memcpy (res->payload_.data, from.payload_.c_str (), res->payload_.len);
  } else {
    res->payload_.data = nullptr;
  }
  res->provider_token_ = (from.provider_token_.length ()) ? td::str_dup (from.provider_token_) : nullptr;
  res->provider_data_ = (from.provider_data_.length ()) ? td::str_dup (from.provider_data_) : nullptr;
  res->start_parameter_ = (from.start_parameter_.length ()) ? td::str_dup (from.start_parameter_) : nullptr;
  return res;
}
char *TdSerializeInputMessageInvoice (struct TdInputMessageInvoice *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageInvoice *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageInvoice (struct TdInputMessageInvoice *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageInvoice *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->invoice_);
  free (var->title_);
  free (var->description_);
  free (var->photo_url_);
  delete[]var->payload_.data;
  free (var->provider_token_);
  free (var->provider_data_);
  free (var->start_parameter_);
  delete var;
}
void TdStackStorerInputMessageInvoice (struct TdInputMessageInvoice *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageInvoice *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageInvoice");
  M->new_field ("ID");
  TdStackStorer (var->invoice_, M);
  M->new_field ("invoice_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  M->pack_string (var->photo_url_);
  M->new_field ("photo_url_");
  M->pack_long (var->photo_size_);
  M->new_field ("photo_size_");
  M->pack_long (var->photo_width_);
  M->new_field ("photo_width_");
  M->pack_long (var->photo_height_);
  M->new_field ("photo_height_");
  M->pack_bytes (var->payload_.data, var->payload_.len);
  M->new_field ("payload_");
  M->pack_string (var->provider_token_);
  M->new_field ("provider_token_");
  M->pack_string (var->provider_data_);
  M->new_field ("provider_data_");
  M->pack_string (var->start_parameter_);
  M->new_field ("start_parameter_");
}
struct TdInputMessageInvoice *TdStackFetcherInputMessageInvoice (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageInvoice ();
  res->ID = CODE_InputMessageInvoice;
  res->refcnt = 1;
  M->get_field ("invoice_");
  if (M->is_nil ()) {
    res->invoice_ = nullptr;
  } else {
    res->invoice_ = TdStackFetcherInvoice (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_url_");
  res->photo_url_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_size_");
  res->photo_size_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("photo_width_");
  res->photo_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("photo_height_");
  res->photo_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("payload_");
  res->payload_.data = M->get_bytes (&res->payload_.len);
  M->pop ();
  M->get_field ("provider_token_");
  res->provider_token_ = M->get_string ();
  M->pop ();
  M->get_field ("provider_data_");
  res->provider_data_ = M->get_string ();
  M->pop ();
  M->get_field ("start_parameter_");
  res->start_parameter_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInputMessageForwarded *TdCreateObjectInputMessageForwarded (long long from_chat_id_, long long message_id_, int in_game_share_) {
  auto var = new struct TdInputMessageForwarded ();
  var->ID = CODE_InputMessageForwarded;
  var->refcnt = 1;
  var->from_chat_id_ = from_chat_id_;
  var->message_id_ = message_id_;
  var->in_game_share_ = in_game_share_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputMessageForwarded> TdConvertToInternal (struct TdInputMessageForwarded *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->from_chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  bool v200;
  v200 = var->in_game_share_ != 0;
  return td::td_api::make_object<td::td_api::inputMessageForwarded>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInputMessageForwarded *TdConvertFromInternal (const td::td_api::inputMessageForwarded &from) {
  auto res = new TdInputMessageForwarded ();
  res->ID = CODE_InputMessageForwarded;
  res->refcnt = 1;
  res->from_chat_id_ = from.from_chat_id_;
  res->message_id_ = from.message_id_;
  res->in_game_share_ = from.in_game_share_;
  return res;
}
char *TdSerializeInputMessageForwarded (struct TdInputMessageForwarded *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputMessageForwarded *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputMessageForwarded (struct TdInputMessageForwarded *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputMessageForwarded *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerInputMessageForwarded (struct TdInputMessageForwarded *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputMessageForwarded *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputMessageForwarded");
  M->new_field ("ID");
  M->pack_long (var->from_chat_id_);
  M->new_field ("from_chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_bool (var->in_game_share_);
  M->new_field ("in_game_share_");
}
struct TdInputMessageForwarded *TdStackFetcherInputMessageForwarded (struct TdStackFetcherMethods *M) {
  auto res = new TdInputMessageForwarded ();
  res->ID = CODE_InputMessageForwarded;
  res->refcnt = 1;
  M->get_field ("from_chat_id_");
  res->from_chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("in_game_share_");
  res->in_game_share_ = (int)M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::InputPassportElement> TdConvertToInternal (struct TdInputPassportElement *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputPassportElementPersonalDetails: return TdConvertToInternal ((struct TdInputPassportElementPersonalDetails *)var);
    case CODE_InputPassportElementPassport: return TdConvertToInternal ((struct TdInputPassportElementPassport *)var);
    case CODE_InputPassportElementDriverLicense: return TdConvertToInternal ((struct TdInputPassportElementDriverLicense *)var);
    case CODE_InputPassportElementIdentityCard: return TdConvertToInternal ((struct TdInputPassportElementIdentityCard *)var);
    case CODE_InputPassportElementInternalPassport: return TdConvertToInternal ((struct TdInputPassportElementInternalPassport *)var);
    case CODE_InputPassportElementAddress: return TdConvertToInternal ((struct TdInputPassportElementAddress *)var);
    case CODE_InputPassportElementUtilityBill: return TdConvertToInternal ((struct TdInputPassportElementUtilityBill *)var);
    case CODE_InputPassportElementBankStatement: return TdConvertToInternal ((struct TdInputPassportElementBankStatement *)var);
    case CODE_InputPassportElementRentalAgreement: return TdConvertToInternal ((struct TdInputPassportElementRentalAgreement *)var);
    case CODE_InputPassportElementPassportRegistration: return TdConvertToInternal ((struct TdInputPassportElementPassportRegistration *)var);
    case CODE_InputPassportElementTemporaryRegistration: return TdConvertToInternal ((struct TdInputPassportElementTemporaryRegistration *)var);
    case CODE_InputPassportElementPhoneNumber: return TdConvertToInternal ((struct TdInputPassportElementPhoneNumber *)var);
    case CODE_InputPassportElementEmailAddress: return TdConvertToInternal ((struct TdInputPassportElementEmailAddress *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdInputPassportElement *TdConvertFromInternal (const td::td_api::InputPassportElement &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_InputPassportElementPersonalDetails: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementPersonalDetails &>(from));
    case CODE_InputPassportElementPassport: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementPassport &>(from));
    case CODE_InputPassportElementDriverLicense: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementDriverLicense &>(from));
    case CODE_InputPassportElementIdentityCard: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementIdentityCard &>(from));
    case CODE_InputPassportElementInternalPassport: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementInternalPassport &>(from));
    case CODE_InputPassportElementAddress: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementAddress &>(from));
    case CODE_InputPassportElementUtilityBill: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementUtilityBill &>(from));
    case CODE_InputPassportElementBankStatement: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementBankStatement &>(from));
    case CODE_InputPassportElementRentalAgreement: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementRentalAgreement &>(from));
    case CODE_InputPassportElementPassportRegistration: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementPassportRegistration &>(from));
    case CODE_InputPassportElementTemporaryRegistration: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementTemporaryRegistration &>(from));
    case CODE_InputPassportElementPhoneNumber: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementPhoneNumber &>(from));
    case CODE_InputPassportElementEmailAddress: return (struct TdInputPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementEmailAddress &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeInputPassportElement (struct TdInputPassportElement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElement (struct TdInputPassportElement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElement *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputPassportElementPersonalDetails: return TdDestroyObject ((struct TdInputPassportElementPersonalDetails *)var);
    case CODE_InputPassportElementPassport: return TdDestroyObject ((struct TdInputPassportElementPassport *)var);
    case CODE_InputPassportElementDriverLicense: return TdDestroyObject ((struct TdInputPassportElementDriverLicense *)var);
    case CODE_InputPassportElementIdentityCard: return TdDestroyObject ((struct TdInputPassportElementIdentityCard *)var);
    case CODE_InputPassportElementInternalPassport: return TdDestroyObject ((struct TdInputPassportElementInternalPassport *)var);
    case CODE_InputPassportElementAddress: return TdDestroyObject ((struct TdInputPassportElementAddress *)var);
    case CODE_InputPassportElementUtilityBill: return TdDestroyObject ((struct TdInputPassportElementUtilityBill *)var);
    case CODE_InputPassportElementBankStatement: return TdDestroyObject ((struct TdInputPassportElementBankStatement *)var);
    case CODE_InputPassportElementRentalAgreement: return TdDestroyObject ((struct TdInputPassportElementRentalAgreement *)var);
    case CODE_InputPassportElementPassportRegistration: return TdDestroyObject ((struct TdInputPassportElementPassportRegistration *)var);
    case CODE_InputPassportElementTemporaryRegistration: return TdDestroyObject ((struct TdInputPassportElementTemporaryRegistration *)var);
    case CODE_InputPassportElementPhoneNumber: return TdDestroyObject ((struct TdInputPassportElementPhoneNumber *)var);
    case CODE_InputPassportElementEmailAddress: return TdDestroyObject ((struct TdInputPassportElementEmailAddress *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerInputPassportElement (struct TdInputPassportElement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElement *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputPassportElementPersonalDetails: return TdStackStorer ((struct TdInputPassportElementPersonalDetails *)var, M);
    case CODE_InputPassportElementPassport: return TdStackStorer ((struct TdInputPassportElementPassport *)var, M);
    case CODE_InputPassportElementDriverLicense: return TdStackStorer ((struct TdInputPassportElementDriverLicense *)var, M);
    case CODE_InputPassportElementIdentityCard: return TdStackStorer ((struct TdInputPassportElementIdentityCard *)var, M);
    case CODE_InputPassportElementInternalPassport: return TdStackStorer ((struct TdInputPassportElementInternalPassport *)var, M);
    case CODE_InputPassportElementAddress: return TdStackStorer ((struct TdInputPassportElementAddress *)var, M);
    case CODE_InputPassportElementUtilityBill: return TdStackStorer ((struct TdInputPassportElementUtilityBill *)var, M);
    case CODE_InputPassportElementBankStatement: return TdStackStorer ((struct TdInputPassportElementBankStatement *)var, M);
    case CODE_InputPassportElementRentalAgreement: return TdStackStorer ((struct TdInputPassportElementRentalAgreement *)var, M);
    case CODE_InputPassportElementPassportRegistration: return TdStackStorer ((struct TdInputPassportElementPassportRegistration *)var, M);
    case CODE_InputPassportElementTemporaryRegistration: return TdStackStorer ((struct TdInputPassportElementTemporaryRegistration *)var, M);
    case CODE_InputPassportElementPhoneNumber: return TdStackStorer ((struct TdInputPassportElementPhoneNumber *)var, M);
    case CODE_InputPassportElementEmailAddress: return TdStackStorer ((struct TdInputPassportElementEmailAddress *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdInputPassportElement *TdStackFetcherInputPassportElement (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "InputPassportElementPersonalDetails") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementPersonalDetails (M);
  }
  if (constructor == "InputPassportElementPassport") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementPassport (M);
  }
  if (constructor == "InputPassportElementDriverLicense") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementDriverLicense (M);
  }
  if (constructor == "InputPassportElementIdentityCard") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementIdentityCard (M);
  }
  if (constructor == "InputPassportElementInternalPassport") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementInternalPassport (M);
  }
  if (constructor == "InputPassportElementAddress") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementAddress (M);
  }
  if (constructor == "InputPassportElementUtilityBill") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementUtilityBill (M);
  }
  if (constructor == "InputPassportElementBankStatement") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementBankStatement (M);
  }
  if (constructor == "InputPassportElementRentalAgreement") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementRentalAgreement (M);
  }
  if (constructor == "InputPassportElementPassportRegistration") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementPassportRegistration (M);
  }
  if (constructor == "InputPassportElementTemporaryRegistration") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementTemporaryRegistration (M);
  }
  if (constructor == "InputPassportElementPhoneNumber") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementPhoneNumber (M);
  }
  if (constructor == "InputPassportElementEmailAddress") {
    return (struct TdInputPassportElement *)TdStackFetcherInputPassportElementEmailAddress (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdInputPassportElementPersonalDetails *TdCreateObjectInputPassportElementPersonalDetails (struct TdPersonalDetails *personal_details_) {
  auto var = new struct TdInputPassportElementPersonalDetails ();
  var->ID = CODE_InputPassportElementPersonalDetails;
  var->refcnt = 1;
  var->personal_details_ = personal_details_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementPersonalDetails> TdConvertToInternal (struct TdInputPassportElementPersonalDetails *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::personalDetails> v0;
  v0 = TdConvertToInternal (var->personal_details_);
  return td::td_api::make_object<td::td_api::inputPassportElementPersonalDetails>(std::move (v0));
}
struct TdInputPassportElementPersonalDetails *TdConvertFromInternal (const td::td_api::inputPassportElementPersonalDetails &from) {
  auto res = new TdInputPassportElementPersonalDetails ();
  res->ID = CODE_InputPassportElementPersonalDetails;
  res->refcnt = 1;
  if (!from.personal_details_) {
    res->personal_details_ = nullptr;
  } else {
    res->personal_details_ = TdConvertFromInternal (static_cast<const td::td_api::personalDetails &>(*from.personal_details_));
  }
  return res;
}
char *TdSerializeInputPassportElementPersonalDetails (struct TdInputPassportElementPersonalDetails *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementPersonalDetails *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementPersonalDetails (struct TdInputPassportElementPersonalDetails *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementPersonalDetails *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->personal_details_);
  delete var;
}
void TdStackStorerInputPassportElementPersonalDetails (struct TdInputPassportElementPersonalDetails *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementPersonalDetails *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementPersonalDetails");
  M->new_field ("ID");
  TdStackStorer (var->personal_details_, M);
  M->new_field ("personal_details_");
}
struct TdInputPassportElementPersonalDetails *TdStackFetcherInputPassportElementPersonalDetails (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementPersonalDetails ();
  res->ID = CODE_InputPassportElementPersonalDetails;
  res->refcnt = 1;
  M->get_field ("personal_details_");
  if (M->is_nil ()) {
    res->personal_details_ = nullptr;
  } else {
    res->personal_details_ = TdStackFetcherPersonalDetails (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementPassport *TdCreateObjectInputPassportElementPassport (struct TdInputIdentityDocument *passport_) {
  auto var = new struct TdInputPassportElementPassport ();
  var->ID = CODE_InputPassportElementPassport;
  var->refcnt = 1;
  var->passport_ = passport_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementPassport> TdConvertToInternal (struct TdInputPassportElementPassport *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputIdentityDocument> v0;
  v0 = TdConvertToInternal (var->passport_);
  return td::td_api::make_object<td::td_api::inputPassportElementPassport>(std::move (v0));
}
struct TdInputPassportElementPassport *TdConvertFromInternal (const td::td_api::inputPassportElementPassport &from) {
  auto res = new TdInputPassportElementPassport ();
  res->ID = CODE_InputPassportElementPassport;
  res->refcnt = 1;
  if (!from.passport_) {
    res->passport_ = nullptr;
  } else {
    res->passport_ = TdConvertFromInternal (static_cast<const td::td_api::inputIdentityDocument &>(*from.passport_));
  }
  return res;
}
char *TdSerializeInputPassportElementPassport (struct TdInputPassportElementPassport *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementPassport *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementPassport (struct TdInputPassportElementPassport *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementPassport *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->passport_);
  delete var;
}
void TdStackStorerInputPassportElementPassport (struct TdInputPassportElementPassport *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementPassport *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementPassport");
  M->new_field ("ID");
  TdStackStorer (var->passport_, M);
  M->new_field ("passport_");
}
struct TdInputPassportElementPassport *TdStackFetcherInputPassportElementPassport (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementPassport ();
  res->ID = CODE_InputPassportElementPassport;
  res->refcnt = 1;
  M->get_field ("passport_");
  if (M->is_nil ()) {
    res->passport_ = nullptr;
  } else {
    res->passport_ = TdStackFetcherInputIdentityDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementDriverLicense *TdCreateObjectInputPassportElementDriverLicense (struct TdInputIdentityDocument *driver_license_) {
  auto var = new struct TdInputPassportElementDriverLicense ();
  var->ID = CODE_InputPassportElementDriverLicense;
  var->refcnt = 1;
  var->driver_license_ = driver_license_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementDriverLicense> TdConvertToInternal (struct TdInputPassportElementDriverLicense *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputIdentityDocument> v0;
  v0 = TdConvertToInternal (var->driver_license_);
  return td::td_api::make_object<td::td_api::inputPassportElementDriverLicense>(std::move (v0));
}
struct TdInputPassportElementDriverLicense *TdConvertFromInternal (const td::td_api::inputPassportElementDriverLicense &from) {
  auto res = new TdInputPassportElementDriverLicense ();
  res->ID = CODE_InputPassportElementDriverLicense;
  res->refcnt = 1;
  if (!from.driver_license_) {
    res->driver_license_ = nullptr;
  } else {
    res->driver_license_ = TdConvertFromInternal (static_cast<const td::td_api::inputIdentityDocument &>(*from.driver_license_));
  }
  return res;
}
char *TdSerializeInputPassportElementDriverLicense (struct TdInputPassportElementDriverLicense *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementDriverLicense *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementDriverLicense (struct TdInputPassportElementDriverLicense *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementDriverLicense *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->driver_license_);
  delete var;
}
void TdStackStorerInputPassportElementDriverLicense (struct TdInputPassportElementDriverLicense *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementDriverLicense *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementDriverLicense");
  M->new_field ("ID");
  TdStackStorer (var->driver_license_, M);
  M->new_field ("driver_license_");
}
struct TdInputPassportElementDriverLicense *TdStackFetcherInputPassportElementDriverLicense (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementDriverLicense ();
  res->ID = CODE_InputPassportElementDriverLicense;
  res->refcnt = 1;
  M->get_field ("driver_license_");
  if (M->is_nil ()) {
    res->driver_license_ = nullptr;
  } else {
    res->driver_license_ = TdStackFetcherInputIdentityDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementIdentityCard *TdCreateObjectInputPassportElementIdentityCard (struct TdInputIdentityDocument *identity_card_) {
  auto var = new struct TdInputPassportElementIdentityCard ();
  var->ID = CODE_InputPassportElementIdentityCard;
  var->refcnt = 1;
  var->identity_card_ = identity_card_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementIdentityCard> TdConvertToInternal (struct TdInputPassportElementIdentityCard *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputIdentityDocument> v0;
  v0 = TdConvertToInternal (var->identity_card_);
  return td::td_api::make_object<td::td_api::inputPassportElementIdentityCard>(std::move (v0));
}
struct TdInputPassportElementIdentityCard *TdConvertFromInternal (const td::td_api::inputPassportElementIdentityCard &from) {
  auto res = new TdInputPassportElementIdentityCard ();
  res->ID = CODE_InputPassportElementIdentityCard;
  res->refcnt = 1;
  if (!from.identity_card_) {
    res->identity_card_ = nullptr;
  } else {
    res->identity_card_ = TdConvertFromInternal (static_cast<const td::td_api::inputIdentityDocument &>(*from.identity_card_));
  }
  return res;
}
char *TdSerializeInputPassportElementIdentityCard (struct TdInputPassportElementIdentityCard *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementIdentityCard *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementIdentityCard (struct TdInputPassportElementIdentityCard *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementIdentityCard *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->identity_card_);
  delete var;
}
void TdStackStorerInputPassportElementIdentityCard (struct TdInputPassportElementIdentityCard *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementIdentityCard *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementIdentityCard");
  M->new_field ("ID");
  TdStackStorer (var->identity_card_, M);
  M->new_field ("identity_card_");
}
struct TdInputPassportElementIdentityCard *TdStackFetcherInputPassportElementIdentityCard (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementIdentityCard ();
  res->ID = CODE_InputPassportElementIdentityCard;
  res->refcnt = 1;
  M->get_field ("identity_card_");
  if (M->is_nil ()) {
    res->identity_card_ = nullptr;
  } else {
    res->identity_card_ = TdStackFetcherInputIdentityDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementInternalPassport *TdCreateObjectInputPassportElementInternalPassport (struct TdInputIdentityDocument *internal_passport_) {
  auto var = new struct TdInputPassportElementInternalPassport ();
  var->ID = CODE_InputPassportElementInternalPassport;
  var->refcnt = 1;
  var->internal_passport_ = internal_passport_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementInternalPassport> TdConvertToInternal (struct TdInputPassportElementInternalPassport *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputIdentityDocument> v0;
  v0 = TdConvertToInternal (var->internal_passport_);
  return td::td_api::make_object<td::td_api::inputPassportElementInternalPassport>(std::move (v0));
}
struct TdInputPassportElementInternalPassport *TdConvertFromInternal (const td::td_api::inputPassportElementInternalPassport &from) {
  auto res = new TdInputPassportElementInternalPassport ();
  res->ID = CODE_InputPassportElementInternalPassport;
  res->refcnt = 1;
  if (!from.internal_passport_) {
    res->internal_passport_ = nullptr;
  } else {
    res->internal_passport_ = TdConvertFromInternal (static_cast<const td::td_api::inputIdentityDocument &>(*from.internal_passport_));
  }
  return res;
}
char *TdSerializeInputPassportElementInternalPassport (struct TdInputPassportElementInternalPassport *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementInternalPassport *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementInternalPassport (struct TdInputPassportElementInternalPassport *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementInternalPassport *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->internal_passport_);
  delete var;
}
void TdStackStorerInputPassportElementInternalPassport (struct TdInputPassportElementInternalPassport *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementInternalPassport *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementInternalPassport");
  M->new_field ("ID");
  TdStackStorer (var->internal_passport_, M);
  M->new_field ("internal_passport_");
}
struct TdInputPassportElementInternalPassport *TdStackFetcherInputPassportElementInternalPassport (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementInternalPassport ();
  res->ID = CODE_InputPassportElementInternalPassport;
  res->refcnt = 1;
  M->get_field ("internal_passport_");
  if (M->is_nil ()) {
    res->internal_passport_ = nullptr;
  } else {
    res->internal_passport_ = TdStackFetcherInputIdentityDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementAddress *TdCreateObjectInputPassportElementAddress (struct TdAddress *address_) {
  auto var = new struct TdInputPassportElementAddress ();
  var->ID = CODE_InputPassportElementAddress;
  var->refcnt = 1;
  var->address_ = address_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementAddress> TdConvertToInternal (struct TdInputPassportElementAddress *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::address> v0;
  v0 = TdConvertToInternal (var->address_);
  return td::td_api::make_object<td::td_api::inputPassportElementAddress>(std::move (v0));
}
struct TdInputPassportElementAddress *TdConvertFromInternal (const td::td_api::inputPassportElementAddress &from) {
  auto res = new TdInputPassportElementAddress ();
  res->ID = CODE_InputPassportElementAddress;
  res->refcnt = 1;
  if (!from.address_) {
    res->address_ = nullptr;
  } else {
    res->address_ = TdConvertFromInternal (static_cast<const td::td_api::address &>(*from.address_));
  }
  return res;
}
char *TdSerializeInputPassportElementAddress (struct TdInputPassportElementAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementAddress (struct TdInputPassportElementAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->address_);
  delete var;
}
void TdStackStorerInputPassportElementAddress (struct TdInputPassportElementAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementAddress");
  M->new_field ("ID");
  TdStackStorer (var->address_, M);
  M->new_field ("address_");
}
struct TdInputPassportElementAddress *TdStackFetcherInputPassportElementAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementAddress ();
  res->ID = CODE_InputPassportElementAddress;
  res->refcnt = 1;
  M->get_field ("address_");
  if (M->is_nil ()) {
    res->address_ = nullptr;
  } else {
    res->address_ = TdStackFetcherAddress (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementUtilityBill *TdCreateObjectInputPassportElementUtilityBill (struct TdInputPersonalDocument *utility_bill_) {
  auto var = new struct TdInputPassportElementUtilityBill ();
  var->ID = CODE_InputPassportElementUtilityBill;
  var->refcnt = 1;
  var->utility_bill_ = utility_bill_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementUtilityBill> TdConvertToInternal (struct TdInputPassportElementUtilityBill *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputPersonalDocument> v0;
  v0 = TdConvertToInternal (var->utility_bill_);
  return td::td_api::make_object<td::td_api::inputPassportElementUtilityBill>(std::move (v0));
}
struct TdInputPassportElementUtilityBill *TdConvertFromInternal (const td::td_api::inputPassportElementUtilityBill &from) {
  auto res = new TdInputPassportElementUtilityBill ();
  res->ID = CODE_InputPassportElementUtilityBill;
  res->refcnt = 1;
  if (!from.utility_bill_) {
    res->utility_bill_ = nullptr;
  } else {
    res->utility_bill_ = TdConvertFromInternal (static_cast<const td::td_api::inputPersonalDocument &>(*from.utility_bill_));
  }
  return res;
}
char *TdSerializeInputPassportElementUtilityBill (struct TdInputPassportElementUtilityBill *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementUtilityBill *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementUtilityBill (struct TdInputPassportElementUtilityBill *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementUtilityBill *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->utility_bill_);
  delete var;
}
void TdStackStorerInputPassportElementUtilityBill (struct TdInputPassportElementUtilityBill *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementUtilityBill *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementUtilityBill");
  M->new_field ("ID");
  TdStackStorer (var->utility_bill_, M);
  M->new_field ("utility_bill_");
}
struct TdInputPassportElementUtilityBill *TdStackFetcherInputPassportElementUtilityBill (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementUtilityBill ();
  res->ID = CODE_InputPassportElementUtilityBill;
  res->refcnt = 1;
  M->get_field ("utility_bill_");
  if (M->is_nil ()) {
    res->utility_bill_ = nullptr;
  } else {
    res->utility_bill_ = TdStackFetcherInputPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementBankStatement *TdCreateObjectInputPassportElementBankStatement (struct TdInputPersonalDocument *bank_statement_) {
  auto var = new struct TdInputPassportElementBankStatement ();
  var->ID = CODE_InputPassportElementBankStatement;
  var->refcnt = 1;
  var->bank_statement_ = bank_statement_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementBankStatement> TdConvertToInternal (struct TdInputPassportElementBankStatement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputPersonalDocument> v0;
  v0 = TdConvertToInternal (var->bank_statement_);
  return td::td_api::make_object<td::td_api::inputPassportElementBankStatement>(std::move (v0));
}
struct TdInputPassportElementBankStatement *TdConvertFromInternal (const td::td_api::inputPassportElementBankStatement &from) {
  auto res = new TdInputPassportElementBankStatement ();
  res->ID = CODE_InputPassportElementBankStatement;
  res->refcnt = 1;
  if (!from.bank_statement_) {
    res->bank_statement_ = nullptr;
  } else {
    res->bank_statement_ = TdConvertFromInternal (static_cast<const td::td_api::inputPersonalDocument &>(*from.bank_statement_));
  }
  return res;
}
char *TdSerializeInputPassportElementBankStatement (struct TdInputPassportElementBankStatement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementBankStatement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementBankStatement (struct TdInputPassportElementBankStatement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementBankStatement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->bank_statement_);
  delete var;
}
void TdStackStorerInputPassportElementBankStatement (struct TdInputPassportElementBankStatement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementBankStatement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementBankStatement");
  M->new_field ("ID");
  TdStackStorer (var->bank_statement_, M);
  M->new_field ("bank_statement_");
}
struct TdInputPassportElementBankStatement *TdStackFetcherInputPassportElementBankStatement (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementBankStatement ();
  res->ID = CODE_InputPassportElementBankStatement;
  res->refcnt = 1;
  M->get_field ("bank_statement_");
  if (M->is_nil ()) {
    res->bank_statement_ = nullptr;
  } else {
    res->bank_statement_ = TdStackFetcherInputPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementRentalAgreement *TdCreateObjectInputPassportElementRentalAgreement (struct TdInputPersonalDocument *rental_agreement_) {
  auto var = new struct TdInputPassportElementRentalAgreement ();
  var->ID = CODE_InputPassportElementRentalAgreement;
  var->refcnt = 1;
  var->rental_agreement_ = rental_agreement_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementRentalAgreement> TdConvertToInternal (struct TdInputPassportElementRentalAgreement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputPersonalDocument> v0;
  v0 = TdConvertToInternal (var->rental_agreement_);
  return td::td_api::make_object<td::td_api::inputPassportElementRentalAgreement>(std::move (v0));
}
struct TdInputPassportElementRentalAgreement *TdConvertFromInternal (const td::td_api::inputPassportElementRentalAgreement &from) {
  auto res = new TdInputPassportElementRentalAgreement ();
  res->ID = CODE_InputPassportElementRentalAgreement;
  res->refcnt = 1;
  if (!from.rental_agreement_) {
    res->rental_agreement_ = nullptr;
  } else {
    res->rental_agreement_ = TdConvertFromInternal (static_cast<const td::td_api::inputPersonalDocument &>(*from.rental_agreement_));
  }
  return res;
}
char *TdSerializeInputPassportElementRentalAgreement (struct TdInputPassportElementRentalAgreement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementRentalAgreement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementRentalAgreement (struct TdInputPassportElementRentalAgreement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementRentalAgreement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->rental_agreement_);
  delete var;
}
void TdStackStorerInputPassportElementRentalAgreement (struct TdInputPassportElementRentalAgreement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementRentalAgreement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementRentalAgreement");
  M->new_field ("ID");
  TdStackStorer (var->rental_agreement_, M);
  M->new_field ("rental_agreement_");
}
struct TdInputPassportElementRentalAgreement *TdStackFetcherInputPassportElementRentalAgreement (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementRentalAgreement ();
  res->ID = CODE_InputPassportElementRentalAgreement;
  res->refcnt = 1;
  M->get_field ("rental_agreement_");
  if (M->is_nil ()) {
    res->rental_agreement_ = nullptr;
  } else {
    res->rental_agreement_ = TdStackFetcherInputPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementPassportRegistration *TdCreateObjectInputPassportElementPassportRegistration (struct TdInputPersonalDocument *passport_registration_) {
  auto var = new struct TdInputPassportElementPassportRegistration ();
  var->ID = CODE_InputPassportElementPassportRegistration;
  var->refcnt = 1;
  var->passport_registration_ = passport_registration_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementPassportRegistration> TdConvertToInternal (struct TdInputPassportElementPassportRegistration *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputPersonalDocument> v0;
  v0 = TdConvertToInternal (var->passport_registration_);
  return td::td_api::make_object<td::td_api::inputPassportElementPassportRegistration>(std::move (v0));
}
struct TdInputPassportElementPassportRegistration *TdConvertFromInternal (const td::td_api::inputPassportElementPassportRegistration &from) {
  auto res = new TdInputPassportElementPassportRegistration ();
  res->ID = CODE_InputPassportElementPassportRegistration;
  res->refcnt = 1;
  if (!from.passport_registration_) {
    res->passport_registration_ = nullptr;
  } else {
    res->passport_registration_ = TdConvertFromInternal (static_cast<const td::td_api::inputPersonalDocument &>(*from.passport_registration_));
  }
  return res;
}
char *TdSerializeInputPassportElementPassportRegistration (struct TdInputPassportElementPassportRegistration *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementPassportRegistration *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementPassportRegistration (struct TdInputPassportElementPassportRegistration *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementPassportRegistration *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->passport_registration_);
  delete var;
}
void TdStackStorerInputPassportElementPassportRegistration (struct TdInputPassportElementPassportRegistration *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementPassportRegistration *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementPassportRegistration");
  M->new_field ("ID");
  TdStackStorer (var->passport_registration_, M);
  M->new_field ("passport_registration_");
}
struct TdInputPassportElementPassportRegistration *TdStackFetcherInputPassportElementPassportRegistration (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementPassportRegistration ();
  res->ID = CODE_InputPassportElementPassportRegistration;
  res->refcnt = 1;
  M->get_field ("passport_registration_");
  if (M->is_nil ()) {
    res->passport_registration_ = nullptr;
  } else {
    res->passport_registration_ = TdStackFetcherInputPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementTemporaryRegistration *TdCreateObjectInputPassportElementTemporaryRegistration (struct TdInputPersonalDocument *temporary_registration_) {
  auto var = new struct TdInputPassportElementTemporaryRegistration ();
  var->ID = CODE_InputPassportElementTemporaryRegistration;
  var->refcnt = 1;
  var->temporary_registration_ = temporary_registration_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementTemporaryRegistration> TdConvertToInternal (struct TdInputPassportElementTemporaryRegistration *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::inputPersonalDocument> v0;
  v0 = TdConvertToInternal (var->temporary_registration_);
  return td::td_api::make_object<td::td_api::inputPassportElementTemporaryRegistration>(std::move (v0));
}
struct TdInputPassportElementTemporaryRegistration *TdConvertFromInternal (const td::td_api::inputPassportElementTemporaryRegistration &from) {
  auto res = new TdInputPassportElementTemporaryRegistration ();
  res->ID = CODE_InputPassportElementTemporaryRegistration;
  res->refcnt = 1;
  if (!from.temporary_registration_) {
    res->temporary_registration_ = nullptr;
  } else {
    res->temporary_registration_ = TdConvertFromInternal (static_cast<const td::td_api::inputPersonalDocument &>(*from.temporary_registration_));
  }
  return res;
}
char *TdSerializeInputPassportElementTemporaryRegistration (struct TdInputPassportElementTemporaryRegistration *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementTemporaryRegistration *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementTemporaryRegistration (struct TdInputPassportElementTemporaryRegistration *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementTemporaryRegistration *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->temporary_registration_);
  delete var;
}
void TdStackStorerInputPassportElementTemporaryRegistration (struct TdInputPassportElementTemporaryRegistration *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementTemporaryRegistration *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementTemporaryRegistration");
  M->new_field ("ID");
  TdStackStorer (var->temporary_registration_, M);
  M->new_field ("temporary_registration_");
}
struct TdInputPassportElementTemporaryRegistration *TdStackFetcherInputPassportElementTemporaryRegistration (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementTemporaryRegistration ();
  res->ID = CODE_InputPassportElementTemporaryRegistration;
  res->refcnt = 1;
  M->get_field ("temporary_registration_");
  if (M->is_nil ()) {
    res->temporary_registration_ = nullptr;
  } else {
    res->temporary_registration_ = TdStackFetcherInputPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementPhoneNumber *TdCreateObjectInputPassportElementPhoneNumber (char *phone_number_) {
  auto var = new struct TdInputPassportElementPhoneNumber ();
  var->ID = CODE_InputPassportElementPhoneNumber;
  var->refcnt = 1;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementPhoneNumber> TdConvertToInternal (struct TdInputPassportElementPhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->phone_number_) ? var->phone_number_: "";
  return td::td_api::make_object<td::td_api::inputPassportElementPhoneNumber>(std::move (v0));
}
struct TdInputPassportElementPhoneNumber *TdConvertFromInternal (const td::td_api::inputPassportElementPhoneNumber &from) {
  auto res = new TdInputPassportElementPhoneNumber ();
  res->ID = CODE_InputPassportElementPhoneNumber;
  res->refcnt = 1;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  return res;
}
char *TdSerializeInputPassportElementPhoneNumber (struct TdInputPassportElementPhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementPhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementPhoneNumber (struct TdInputPassportElementPhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementPhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->phone_number_);
  delete var;
}
void TdStackStorerInputPassportElementPhoneNumber (struct TdInputPassportElementPhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementPhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementPhoneNumber");
  M->new_field ("ID");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
}
struct TdInputPassportElementPhoneNumber *TdStackFetcherInputPassportElementPhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementPhoneNumber ();
  res->ID = CODE_InputPassportElementPhoneNumber;
  res->refcnt = 1;
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInputPassportElementEmailAddress *TdCreateObjectInputPassportElementEmailAddress (char *email_address_) {
  auto var = new struct TdInputPassportElementEmailAddress ();
  var->ID = CODE_InputPassportElementEmailAddress;
  var->refcnt = 1;
  var->email_address_ = (email_address_) ? td::str_dup (td::Slice (email_address_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementEmailAddress> TdConvertToInternal (struct TdInputPassportElementEmailAddress *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->email_address_) ? var->email_address_: "";
  return td::td_api::make_object<td::td_api::inputPassportElementEmailAddress>(std::move (v0));
}
struct TdInputPassportElementEmailAddress *TdConvertFromInternal (const td::td_api::inputPassportElementEmailAddress &from) {
  auto res = new TdInputPassportElementEmailAddress ();
  res->ID = CODE_InputPassportElementEmailAddress;
  res->refcnt = 1;
  res->email_address_ = (from.email_address_.length ()) ? td::str_dup (from.email_address_) : nullptr;
  return res;
}
char *TdSerializeInputPassportElementEmailAddress (struct TdInputPassportElementEmailAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementEmailAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementEmailAddress (struct TdInputPassportElementEmailAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementEmailAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->email_address_);
  delete var;
}
void TdStackStorerInputPassportElementEmailAddress (struct TdInputPassportElementEmailAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementEmailAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementEmailAddress");
  M->new_field ("ID");
  M->pack_string (var->email_address_);
  M->new_field ("email_address_");
}
struct TdInputPassportElementEmailAddress *TdStackFetcherInputPassportElementEmailAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementEmailAddress ();
  res->ID = CODE_InputPassportElementEmailAddress;
  res->refcnt = 1;
  M->get_field ("email_address_");
  res->email_address_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdInputPassportElementError *TdCreateObjectInputPassportElementError (struct TdPassportElementType *type_, char *message_, struct TdInputPassportElementErrorSource *source_) {
  auto var = new struct TdInputPassportElementError ();
  var->ID = CODE_InputPassportElementError;
  var->refcnt = 1;
  var->type_ = type_;
  var->message_ = (message_) ? td::str_dup (td::Slice (message_)) : nullptr;
  var->source_ = source_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementError> TdConvertToInternal (struct TdInputPassportElementError *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::PassportElementType> v0;
  v0 = TdConvertToInternal (var->type_);
  std::string v100;
  v100 = (var->message_) ? var->message_: "";
  td::td_api::object_ptr<td::td_api::InputPassportElementErrorSource> v200;
  v200 = TdConvertToInternal (var->source_);
  return td::td_api::make_object<td::td_api::inputPassportElementError>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInputPassportElementError *TdConvertFromInternal (const td::td_api::inputPassportElementError &from) {
  auto res = new TdInputPassportElementError ();
  res->ID = CODE_InputPassportElementError;
  res->refcnt = 1;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::PassportElementType &>(*from.type_));
  }
  res->message_ = (from.message_.length ()) ? td::str_dup (from.message_) : nullptr;
  if (!from.source_) {
    res->source_ = nullptr;
  } else {
    res->source_ = TdConvertFromInternal (static_cast<const td::td_api::InputPassportElementErrorSource &>(*from.source_));
  }
  return res;
}
char *TdSerializeInputPassportElementError (struct TdInputPassportElementError *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementError *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementError (struct TdInputPassportElementError *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementError *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  free (var->message_);
  TdDestroyObject (var->source_);
  delete var;
}
void TdStackStorerInputPassportElementError (struct TdInputPassportElementError *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementError *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementError");
  M->new_field ("ID");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  M->pack_string (var->message_);
  M->new_field ("message_");
  TdStackStorer (var->source_, M);
  M->new_field ("source_");
}
struct TdInputPassportElementError *TdStackFetcherInputPassportElementError (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementError ();
  res->ID = CODE_InputPassportElementError;
  res->refcnt = 1;
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherPassportElementType (M);
  }
  M->pop ();
  M->get_field ("message_");
  res->message_ = M->get_string ();
  M->pop ();
  M->get_field ("source_");
  if (M->is_nil ()) {
    res->source_ = nullptr;
  } else {
    res->source_ = TdStackFetcherInputPassportElementErrorSource (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::InputPassportElementErrorSource> TdConvertToInternal (struct TdInputPassportElementErrorSource *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputPassportElementErrorSourceUnspecified: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceUnspecified *)var);
    case CODE_InputPassportElementErrorSourceDataField: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceDataField *)var);
    case CODE_InputPassportElementErrorSourceFrontSide: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceFrontSide *)var);
    case CODE_InputPassportElementErrorSourceReverseSide: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceReverseSide *)var);
    case CODE_InputPassportElementErrorSourceSelfie: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceSelfie *)var);
    case CODE_InputPassportElementErrorSourceTranslationFile: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceTranslationFile *)var);
    case CODE_InputPassportElementErrorSourceTranslationFiles: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceTranslationFiles *)var);
    case CODE_InputPassportElementErrorSourceFile: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceFile *)var);
    case CODE_InputPassportElementErrorSourceFiles: return TdConvertToInternal ((struct TdInputPassportElementErrorSourceFiles *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdInputPassportElementErrorSource *TdConvertFromInternal (const td::td_api::InputPassportElementErrorSource &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_InputPassportElementErrorSourceUnspecified: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceUnspecified &>(from));
    case CODE_InputPassportElementErrorSourceDataField: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceDataField &>(from));
    case CODE_InputPassportElementErrorSourceFrontSide: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceFrontSide &>(from));
    case CODE_InputPassportElementErrorSourceReverseSide: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceReverseSide &>(from));
    case CODE_InputPassportElementErrorSourceSelfie: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceSelfie &>(from));
    case CODE_InputPassportElementErrorSourceTranslationFile: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceTranslationFile &>(from));
    case CODE_InputPassportElementErrorSourceTranslationFiles: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceTranslationFiles &>(from));
    case CODE_InputPassportElementErrorSourceFile: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceFile &>(from));
    case CODE_InputPassportElementErrorSourceFiles: return (struct TdInputPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::inputPassportElementErrorSourceFiles &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeInputPassportElementErrorSource (struct TdInputPassportElementErrorSource *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSource *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSource (struct TdInputPassportElementErrorSource *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSource *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputPassportElementErrorSourceUnspecified: return TdDestroyObject ((struct TdInputPassportElementErrorSourceUnspecified *)var);
    case CODE_InputPassportElementErrorSourceDataField: return TdDestroyObject ((struct TdInputPassportElementErrorSourceDataField *)var);
    case CODE_InputPassportElementErrorSourceFrontSide: return TdDestroyObject ((struct TdInputPassportElementErrorSourceFrontSide *)var);
    case CODE_InputPassportElementErrorSourceReverseSide: return TdDestroyObject ((struct TdInputPassportElementErrorSourceReverseSide *)var);
    case CODE_InputPassportElementErrorSourceSelfie: return TdDestroyObject ((struct TdInputPassportElementErrorSourceSelfie *)var);
    case CODE_InputPassportElementErrorSourceTranslationFile: return TdDestroyObject ((struct TdInputPassportElementErrorSourceTranslationFile *)var);
    case CODE_InputPassportElementErrorSourceTranslationFiles: return TdDestroyObject ((struct TdInputPassportElementErrorSourceTranslationFiles *)var);
    case CODE_InputPassportElementErrorSourceFile: return TdDestroyObject ((struct TdInputPassportElementErrorSourceFile *)var);
    case CODE_InputPassportElementErrorSourceFiles: return TdDestroyObject ((struct TdInputPassportElementErrorSourceFiles *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerInputPassportElementErrorSource (struct TdInputPassportElementErrorSource *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSource *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_InputPassportElementErrorSourceUnspecified: return TdStackStorer ((struct TdInputPassportElementErrorSourceUnspecified *)var, M);
    case CODE_InputPassportElementErrorSourceDataField: return TdStackStorer ((struct TdInputPassportElementErrorSourceDataField *)var, M);
    case CODE_InputPassportElementErrorSourceFrontSide: return TdStackStorer ((struct TdInputPassportElementErrorSourceFrontSide *)var, M);
    case CODE_InputPassportElementErrorSourceReverseSide: return TdStackStorer ((struct TdInputPassportElementErrorSourceReverseSide *)var, M);
    case CODE_InputPassportElementErrorSourceSelfie: return TdStackStorer ((struct TdInputPassportElementErrorSourceSelfie *)var, M);
    case CODE_InputPassportElementErrorSourceTranslationFile: return TdStackStorer ((struct TdInputPassportElementErrorSourceTranslationFile *)var, M);
    case CODE_InputPassportElementErrorSourceTranslationFiles: return TdStackStorer ((struct TdInputPassportElementErrorSourceTranslationFiles *)var, M);
    case CODE_InputPassportElementErrorSourceFile: return TdStackStorer ((struct TdInputPassportElementErrorSourceFile *)var, M);
    case CODE_InputPassportElementErrorSourceFiles: return TdStackStorer ((struct TdInputPassportElementErrorSourceFiles *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdInputPassportElementErrorSource *TdStackFetcherInputPassportElementErrorSource (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "InputPassportElementErrorSourceUnspecified") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceUnspecified (M);
  }
  if (constructor == "InputPassportElementErrorSourceDataField") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceDataField (M);
  }
  if (constructor == "InputPassportElementErrorSourceFrontSide") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceFrontSide (M);
  }
  if (constructor == "InputPassportElementErrorSourceReverseSide") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceReverseSide (M);
  }
  if (constructor == "InputPassportElementErrorSourceSelfie") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceSelfie (M);
  }
  if (constructor == "InputPassportElementErrorSourceTranslationFile") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceTranslationFile (M);
  }
  if (constructor == "InputPassportElementErrorSourceTranslationFiles") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceTranslationFiles (M);
  }
  if (constructor == "InputPassportElementErrorSourceFile") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceFile (M);
  }
  if (constructor == "InputPassportElementErrorSourceFiles") {
    return (struct TdInputPassportElementErrorSource *)TdStackFetcherInputPassportElementErrorSourceFiles (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdInputPassportElementErrorSourceUnspecified *TdCreateObjectInputPassportElementErrorSourceUnspecified (struct TdBytes element_hash_) {
  auto var = new struct TdInputPassportElementErrorSourceUnspecified ();
  var->ID = CODE_InputPassportElementErrorSourceUnspecified;
  var->refcnt = 1;
  var->element_hash_ = element_hash_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceUnspecified> TdConvertToInternal (struct TdInputPassportElementErrorSourceUnspecified *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->element_hash_.data, var->element_hash_.len);
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceUnspecified>(std::move (v0));
}
struct TdInputPassportElementErrorSourceUnspecified *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceUnspecified &from) {
  auto res = new TdInputPassportElementErrorSourceUnspecified ();
  res->ID = CODE_InputPassportElementErrorSourceUnspecified;
  res->refcnt = 1;
  res->element_hash_.len = (int)from.element_hash_.length ();
  if (res->element_hash_.len) {
    res->element_hash_.data = new unsigned char[res->element_hash_.len];
    memcpy (res->element_hash_.data, from.element_hash_.c_str (), res->element_hash_.len);
  } else {
    res->element_hash_.data = nullptr;
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceUnspecified (struct TdInputPassportElementErrorSourceUnspecified *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceUnspecified *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceUnspecified (struct TdInputPassportElementErrorSourceUnspecified *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceUnspecified *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->element_hash_.data;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceUnspecified (struct TdInputPassportElementErrorSourceUnspecified *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceUnspecified *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceUnspecified");
  M->new_field ("ID");
  M->pack_bytes (var->element_hash_.data, var->element_hash_.len);
  M->new_field ("element_hash_");
}
struct TdInputPassportElementErrorSourceUnspecified *TdStackFetcherInputPassportElementErrorSourceUnspecified (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceUnspecified ();
  res->ID = CODE_InputPassportElementErrorSourceUnspecified;
  res->refcnt = 1;
  M->get_field ("element_hash_");
  res->element_hash_.data = M->get_bytes (&res->element_hash_.len);
  M->pop ();
  return res;
}
struct TdInputPassportElementErrorSourceDataField *TdCreateObjectInputPassportElementErrorSourceDataField (char *field_name_, struct TdBytes data_hash_) {
  auto var = new struct TdInputPassportElementErrorSourceDataField ();
  var->ID = CODE_InputPassportElementErrorSourceDataField;
  var->refcnt = 1;
  var->field_name_ = (field_name_) ? td::str_dup (td::Slice (field_name_)) : nullptr;
  var->data_hash_ = data_hash_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceDataField> TdConvertToInternal (struct TdInputPassportElementErrorSourceDataField *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->field_name_) ? var->field_name_: "";
  std::string v100;
  v100 = std::string ((char *)var->data_hash_.data, var->data_hash_.len);
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceDataField>(std::move (v0), std::move (v100));
}
struct TdInputPassportElementErrorSourceDataField *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceDataField &from) {
  auto res = new TdInputPassportElementErrorSourceDataField ();
  res->ID = CODE_InputPassportElementErrorSourceDataField;
  res->refcnt = 1;
  res->field_name_ = (from.field_name_.length ()) ? td::str_dup (from.field_name_) : nullptr;
  res->data_hash_.len = (int)from.data_hash_.length ();
  if (res->data_hash_.len) {
    res->data_hash_.data = new unsigned char[res->data_hash_.len];
    memcpy (res->data_hash_.data, from.data_hash_.c_str (), res->data_hash_.len);
  } else {
    res->data_hash_.data = nullptr;
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceDataField (struct TdInputPassportElementErrorSourceDataField *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceDataField *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceDataField (struct TdInputPassportElementErrorSourceDataField *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceDataField *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->field_name_);
  delete[]var->data_hash_.data;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceDataField (struct TdInputPassportElementErrorSourceDataField *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceDataField *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceDataField");
  M->new_field ("ID");
  M->pack_string (var->field_name_);
  M->new_field ("field_name_");
  M->pack_bytes (var->data_hash_.data, var->data_hash_.len);
  M->new_field ("data_hash_");
}
struct TdInputPassportElementErrorSourceDataField *TdStackFetcherInputPassportElementErrorSourceDataField (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceDataField ();
  res->ID = CODE_InputPassportElementErrorSourceDataField;
  res->refcnt = 1;
  M->get_field ("field_name_");
  res->field_name_ = M->get_string ();
  M->pop ();
  M->get_field ("data_hash_");
  res->data_hash_.data = M->get_bytes (&res->data_hash_.len);
  M->pop ();
  return res;
}
struct TdInputPassportElementErrorSourceFrontSide *TdCreateObjectInputPassportElementErrorSourceFrontSide (struct TdBytes file_hash_) {
  auto var = new struct TdInputPassportElementErrorSourceFrontSide ();
  var->ID = CODE_InputPassportElementErrorSourceFrontSide;
  var->refcnt = 1;
  var->file_hash_ = file_hash_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceFrontSide> TdConvertToInternal (struct TdInputPassportElementErrorSourceFrontSide *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->file_hash_.data, var->file_hash_.len);
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceFrontSide>(std::move (v0));
}
struct TdInputPassportElementErrorSourceFrontSide *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceFrontSide &from) {
  auto res = new TdInputPassportElementErrorSourceFrontSide ();
  res->ID = CODE_InputPassportElementErrorSourceFrontSide;
  res->refcnt = 1;
  res->file_hash_.len = (int)from.file_hash_.length ();
  if (res->file_hash_.len) {
    res->file_hash_.data = new unsigned char[res->file_hash_.len];
    memcpy (res->file_hash_.data, from.file_hash_.c_str (), res->file_hash_.len);
  } else {
    res->file_hash_.data = nullptr;
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceFrontSide (struct TdInputPassportElementErrorSourceFrontSide *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceFrontSide *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceFrontSide (struct TdInputPassportElementErrorSourceFrontSide *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceFrontSide *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->file_hash_.data;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceFrontSide (struct TdInputPassportElementErrorSourceFrontSide *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceFrontSide *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceFrontSide");
  M->new_field ("ID");
  M->pack_bytes (var->file_hash_.data, var->file_hash_.len);
  M->new_field ("file_hash_");
}
struct TdInputPassportElementErrorSourceFrontSide *TdStackFetcherInputPassportElementErrorSourceFrontSide (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceFrontSide ();
  res->ID = CODE_InputPassportElementErrorSourceFrontSide;
  res->refcnt = 1;
  M->get_field ("file_hash_");
  res->file_hash_.data = M->get_bytes (&res->file_hash_.len);
  M->pop ();
  return res;
}
struct TdInputPassportElementErrorSourceReverseSide *TdCreateObjectInputPassportElementErrorSourceReverseSide (struct TdBytes file_hash_) {
  auto var = new struct TdInputPassportElementErrorSourceReverseSide ();
  var->ID = CODE_InputPassportElementErrorSourceReverseSide;
  var->refcnt = 1;
  var->file_hash_ = file_hash_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceReverseSide> TdConvertToInternal (struct TdInputPassportElementErrorSourceReverseSide *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->file_hash_.data, var->file_hash_.len);
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceReverseSide>(std::move (v0));
}
struct TdInputPassportElementErrorSourceReverseSide *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceReverseSide &from) {
  auto res = new TdInputPassportElementErrorSourceReverseSide ();
  res->ID = CODE_InputPassportElementErrorSourceReverseSide;
  res->refcnt = 1;
  res->file_hash_.len = (int)from.file_hash_.length ();
  if (res->file_hash_.len) {
    res->file_hash_.data = new unsigned char[res->file_hash_.len];
    memcpy (res->file_hash_.data, from.file_hash_.c_str (), res->file_hash_.len);
  } else {
    res->file_hash_.data = nullptr;
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceReverseSide (struct TdInputPassportElementErrorSourceReverseSide *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceReverseSide *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceReverseSide (struct TdInputPassportElementErrorSourceReverseSide *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceReverseSide *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->file_hash_.data;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceReverseSide (struct TdInputPassportElementErrorSourceReverseSide *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceReverseSide *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceReverseSide");
  M->new_field ("ID");
  M->pack_bytes (var->file_hash_.data, var->file_hash_.len);
  M->new_field ("file_hash_");
}
struct TdInputPassportElementErrorSourceReverseSide *TdStackFetcherInputPassportElementErrorSourceReverseSide (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceReverseSide ();
  res->ID = CODE_InputPassportElementErrorSourceReverseSide;
  res->refcnt = 1;
  M->get_field ("file_hash_");
  res->file_hash_.data = M->get_bytes (&res->file_hash_.len);
  M->pop ();
  return res;
}
struct TdInputPassportElementErrorSourceSelfie *TdCreateObjectInputPassportElementErrorSourceSelfie (struct TdBytes file_hash_) {
  auto var = new struct TdInputPassportElementErrorSourceSelfie ();
  var->ID = CODE_InputPassportElementErrorSourceSelfie;
  var->refcnt = 1;
  var->file_hash_ = file_hash_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceSelfie> TdConvertToInternal (struct TdInputPassportElementErrorSourceSelfie *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->file_hash_.data, var->file_hash_.len);
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceSelfie>(std::move (v0));
}
struct TdInputPassportElementErrorSourceSelfie *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceSelfie &from) {
  auto res = new TdInputPassportElementErrorSourceSelfie ();
  res->ID = CODE_InputPassportElementErrorSourceSelfie;
  res->refcnt = 1;
  res->file_hash_.len = (int)from.file_hash_.length ();
  if (res->file_hash_.len) {
    res->file_hash_.data = new unsigned char[res->file_hash_.len];
    memcpy (res->file_hash_.data, from.file_hash_.c_str (), res->file_hash_.len);
  } else {
    res->file_hash_.data = nullptr;
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceSelfie (struct TdInputPassportElementErrorSourceSelfie *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceSelfie *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceSelfie (struct TdInputPassportElementErrorSourceSelfie *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceSelfie *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->file_hash_.data;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceSelfie (struct TdInputPassportElementErrorSourceSelfie *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceSelfie *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceSelfie");
  M->new_field ("ID");
  M->pack_bytes (var->file_hash_.data, var->file_hash_.len);
  M->new_field ("file_hash_");
}
struct TdInputPassportElementErrorSourceSelfie *TdStackFetcherInputPassportElementErrorSourceSelfie (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceSelfie ();
  res->ID = CODE_InputPassportElementErrorSourceSelfie;
  res->refcnt = 1;
  M->get_field ("file_hash_");
  res->file_hash_.data = M->get_bytes (&res->file_hash_.len);
  M->pop ();
  return res;
}
struct TdInputPassportElementErrorSourceTranslationFile *TdCreateObjectInputPassportElementErrorSourceTranslationFile (struct TdBytes file_hash_) {
  auto var = new struct TdInputPassportElementErrorSourceTranslationFile ();
  var->ID = CODE_InputPassportElementErrorSourceTranslationFile;
  var->refcnt = 1;
  var->file_hash_ = file_hash_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceTranslationFile> TdConvertToInternal (struct TdInputPassportElementErrorSourceTranslationFile *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->file_hash_.data, var->file_hash_.len);
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceTranslationFile>(std::move (v0));
}
struct TdInputPassportElementErrorSourceTranslationFile *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceTranslationFile &from) {
  auto res = new TdInputPassportElementErrorSourceTranslationFile ();
  res->ID = CODE_InputPassportElementErrorSourceTranslationFile;
  res->refcnt = 1;
  res->file_hash_.len = (int)from.file_hash_.length ();
  if (res->file_hash_.len) {
    res->file_hash_.data = new unsigned char[res->file_hash_.len];
    memcpy (res->file_hash_.data, from.file_hash_.c_str (), res->file_hash_.len);
  } else {
    res->file_hash_.data = nullptr;
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceTranslationFile (struct TdInputPassportElementErrorSourceTranslationFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceTranslationFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceTranslationFile (struct TdInputPassportElementErrorSourceTranslationFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceTranslationFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->file_hash_.data;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceTranslationFile (struct TdInputPassportElementErrorSourceTranslationFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceTranslationFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceTranslationFile");
  M->new_field ("ID");
  M->pack_bytes (var->file_hash_.data, var->file_hash_.len);
  M->new_field ("file_hash_");
}
struct TdInputPassportElementErrorSourceTranslationFile *TdStackFetcherInputPassportElementErrorSourceTranslationFile (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceTranslationFile ();
  res->ID = CODE_InputPassportElementErrorSourceTranslationFile;
  res->refcnt = 1;
  M->get_field ("file_hash_");
  res->file_hash_.data = M->get_bytes (&res->file_hash_.len);
  M->pop ();
  return res;
}
struct TdInputPassportElementErrorSourceTranslationFiles *TdCreateObjectInputPassportElementErrorSourceTranslationFiles (struct TdVectorBytes *file_hashes_) {
  auto var = new struct TdInputPassportElementErrorSourceTranslationFiles ();
  var->ID = CODE_InputPassportElementErrorSourceTranslationFiles;
  var->refcnt = 1;
  var->file_hashes_ = file_hashes_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceTranslationFiles> TdConvertToInternal (struct TdInputPassportElementErrorSourceTranslationFiles *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::string> v0;
  for (int i0 = 0; i0 < var->file_hashes_->len; i0++) {
    std::string v1;
    v1 = std::string ((char *)var->file_hashes_->data[i0].data, var->file_hashes_->data[i0].len);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceTranslationFiles>(std::move (v0));
}
struct TdInputPassportElementErrorSourceTranslationFiles *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceTranslationFiles &from) {
  auto res = new TdInputPassportElementErrorSourceTranslationFiles ();
  res->ID = CODE_InputPassportElementErrorSourceTranslationFiles;
  res->refcnt = 1;
  res->file_hashes_ = new TdVectorBytes ();
  res->file_hashes_->len = (int)from.file_hashes_.size ();
  res->file_hashes_->data = new struct TdBytes  [res->file_hashes_->len];
  for (int i0 = 0; i0 < res->file_hashes_->len; i0++) {
    res->file_hashes_->data[i0].len = (int)from.file_hashes_[i0].length ();
    if (res->file_hashes_->data[i0].len) {
      res->file_hashes_->data[i0].data = new unsigned char[res->file_hashes_->data[i0].len];
      memcpy (res->file_hashes_->data[i0].data, from.file_hashes_[i0].c_str (), res->file_hashes_->data[i0].len);
    } else {
      res->file_hashes_->data[i0].data = nullptr;
    }
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceTranslationFiles (struct TdInputPassportElementErrorSourceTranslationFiles *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceTranslationFiles *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceTranslationFiles (struct TdInputPassportElementErrorSourceTranslationFiles *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceTranslationFiles *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->file_hashes_->len; i0++) {
    delete[]var->file_hashes_->data[i0].data;
  }
  delete[] var->file_hashes_->data;
  delete var->file_hashes_;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceTranslationFiles (struct TdInputPassportElementErrorSourceTranslationFiles *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceTranslationFiles *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceTranslationFiles");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->file_hashes_->len; i0++) {
    M->pack_bytes (var->file_hashes_->data[i0].data, var->file_hashes_->data[i0].len);
    M->new_arr_field (i0);
  }
  M->new_field ("file_hashes_");
}
struct TdInputPassportElementErrorSourceTranslationFiles *TdStackFetcherInputPassportElementErrorSourceTranslationFiles (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceTranslationFiles ();
  res->ID = CODE_InputPassportElementErrorSourceTranslationFiles;
  res->refcnt = 1;
  M->get_field ("file_hashes_");
  res->file_hashes_ = new TdVectorBytes ();
  res->file_hashes_->len = M->get_arr_size ();
  res->file_hashes_->data = new struct TdBytes  [res->file_hashes_->len];
  for (int i0 = 0; i0 < res->file_hashes_->len; i0++) {
    M->get_arr_field (i0);
    res->file_hashes_->data[i0].data = M->get_bytes (&res->file_hashes_->data[i0].len);
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdInputPassportElementErrorSourceFile *TdCreateObjectInputPassportElementErrorSourceFile (struct TdBytes file_hash_) {
  auto var = new struct TdInputPassportElementErrorSourceFile ();
  var->ID = CODE_InputPassportElementErrorSourceFile;
  var->refcnt = 1;
  var->file_hash_ = file_hash_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceFile> TdConvertToInternal (struct TdInputPassportElementErrorSourceFile *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->file_hash_.data, var->file_hash_.len);
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceFile>(std::move (v0));
}
struct TdInputPassportElementErrorSourceFile *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceFile &from) {
  auto res = new TdInputPassportElementErrorSourceFile ();
  res->ID = CODE_InputPassportElementErrorSourceFile;
  res->refcnt = 1;
  res->file_hash_.len = (int)from.file_hash_.length ();
  if (res->file_hash_.len) {
    res->file_hash_.data = new unsigned char[res->file_hash_.len];
    memcpy (res->file_hash_.data, from.file_hash_.c_str (), res->file_hash_.len);
  } else {
    res->file_hash_.data = nullptr;
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceFile (struct TdInputPassportElementErrorSourceFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceFile (struct TdInputPassportElementErrorSourceFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->file_hash_.data;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceFile (struct TdInputPassportElementErrorSourceFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceFile");
  M->new_field ("ID");
  M->pack_bytes (var->file_hash_.data, var->file_hash_.len);
  M->new_field ("file_hash_");
}
struct TdInputPassportElementErrorSourceFile *TdStackFetcherInputPassportElementErrorSourceFile (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceFile ();
  res->ID = CODE_InputPassportElementErrorSourceFile;
  res->refcnt = 1;
  M->get_field ("file_hash_");
  res->file_hash_.data = M->get_bytes (&res->file_hash_.len);
  M->pop ();
  return res;
}
struct TdInputPassportElementErrorSourceFiles *TdCreateObjectInputPassportElementErrorSourceFiles (struct TdVectorBytes *file_hashes_) {
  auto var = new struct TdInputPassportElementErrorSourceFiles ();
  var->ID = CODE_InputPassportElementErrorSourceFiles;
  var->refcnt = 1;
  var->file_hashes_ = file_hashes_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPassportElementErrorSourceFiles> TdConvertToInternal (struct TdInputPassportElementErrorSourceFiles *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::string> v0;
  for (int i0 = 0; i0 < var->file_hashes_->len; i0++) {
    std::string v1;
    v1 = std::string ((char *)var->file_hashes_->data[i0].data, var->file_hashes_->data[i0].len);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::inputPassportElementErrorSourceFiles>(std::move (v0));
}
struct TdInputPassportElementErrorSourceFiles *TdConvertFromInternal (const td::td_api::inputPassportElementErrorSourceFiles &from) {
  auto res = new TdInputPassportElementErrorSourceFiles ();
  res->ID = CODE_InputPassportElementErrorSourceFiles;
  res->refcnt = 1;
  res->file_hashes_ = new TdVectorBytes ();
  res->file_hashes_->len = (int)from.file_hashes_.size ();
  res->file_hashes_->data = new struct TdBytes  [res->file_hashes_->len];
  for (int i0 = 0; i0 < res->file_hashes_->len; i0++) {
    res->file_hashes_->data[i0].len = (int)from.file_hashes_[i0].length ();
    if (res->file_hashes_->data[i0].len) {
      res->file_hashes_->data[i0].data = new unsigned char[res->file_hashes_->data[i0].len];
      memcpy (res->file_hashes_->data[i0].data, from.file_hashes_[i0].c_str (), res->file_hashes_->data[i0].len);
    } else {
      res->file_hashes_->data[i0].data = nullptr;
    }
  }
  return res;
}
char *TdSerializeInputPassportElementErrorSourceFiles (struct TdInputPassportElementErrorSourceFiles *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPassportElementErrorSourceFiles *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPassportElementErrorSourceFiles (struct TdInputPassportElementErrorSourceFiles *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPassportElementErrorSourceFiles *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->file_hashes_->len; i0++) {
    delete[]var->file_hashes_->data[i0].data;
  }
  delete[] var->file_hashes_->data;
  delete var->file_hashes_;
  delete var;
}
void TdStackStorerInputPassportElementErrorSourceFiles (struct TdInputPassportElementErrorSourceFiles *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPassportElementErrorSourceFiles *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPassportElementErrorSourceFiles");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->file_hashes_->len; i0++) {
    M->pack_bytes (var->file_hashes_->data[i0].data, var->file_hashes_->data[i0].len);
    M->new_arr_field (i0);
  }
  M->new_field ("file_hashes_");
}
struct TdInputPassportElementErrorSourceFiles *TdStackFetcherInputPassportElementErrorSourceFiles (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPassportElementErrorSourceFiles ();
  res->ID = CODE_InputPassportElementErrorSourceFiles;
  res->refcnt = 1;
  M->get_field ("file_hashes_");
  res->file_hashes_ = new TdVectorBytes ();
  res->file_hashes_->len = M->get_arr_size ();
  res->file_hashes_->data = new struct TdBytes  [res->file_hashes_->len];
  for (int i0 = 0; i0 < res->file_hashes_->len; i0++) {
    M->get_arr_field (i0);
    res->file_hashes_->data[i0].data = M->get_bytes (&res->file_hashes_->data[i0].len);
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdInputPersonalDocument *TdCreateObjectInputPersonalDocument (struct TdVectorInputFile *files_, struct TdVectorInputFile *translation_) {
  auto var = new struct TdInputPersonalDocument ();
  var->ID = CODE_InputPersonalDocument;
  var->refcnt = 1;
  var->files_ = files_;
  var->translation_ = translation_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputPersonalDocument> TdConvertToInternal (struct TdInputPersonalDocument *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::InputFile>> v0;
  for (int i0 = 0; i0 < var->files_->len; i0++) {
    td::td_api::object_ptr<td::td_api::InputFile> v1;
    v1 = TdConvertToInternal (var->files_->data[i0]);
    v0.push_back (std::move (v1));
  }
  std::vector<td::td_api::object_ptr<td::td_api::InputFile>> v100;
  for (int i100 = 0; i100 < var->translation_->len; i100++) {
    td::td_api::object_ptr<td::td_api::InputFile> v101;
    v101 = TdConvertToInternal (var->translation_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::inputPersonalDocument>(std::move (v0), std::move (v100));
}
struct TdInputPersonalDocument *TdConvertFromInternal (const td::td_api::inputPersonalDocument &from) {
  auto res = new TdInputPersonalDocument ();
  res->ID = CODE_InputPersonalDocument;
  res->refcnt = 1;
  res->files_ = new TdVectorInputFile ();
  res->files_->len = (int)from.files_.size ();
  res->files_->data = new struct TdInputFile * [res->files_->len];
  for (int i0 = 0; i0 < res->files_->len; i0++) {
    if (!from.files_[i0]) {
      res->files_->data[i0] = nullptr;
    } else {
      res->files_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.files_[i0]));
    }
  }
  res->translation_ = new TdVectorInputFile ();
  res->translation_->len = (int)from.translation_.size ();
  res->translation_->data = new struct TdInputFile * [res->translation_->len];
  for (int i100 = 0; i100 < res->translation_->len; i100++) {
    if (!from.translation_[i100]) {
      res->translation_->data[i100] = nullptr;
    } else {
      res->translation_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.translation_[i100]));
    }
  }
  return res;
}
char *TdSerializeInputPersonalDocument (struct TdInputPersonalDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputPersonalDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputPersonalDocument (struct TdInputPersonalDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputPersonalDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->files_->len; i0++) {
    TdDestroyObject (var->files_->data[i0]);
  }
  delete[] var->files_->data;
  delete var->files_;
  for (int i100 = 0; i100 < var->translation_->len; i100++) {
    TdDestroyObject (var->translation_->data[i100]);
  }
  delete[] var->translation_->data;
  delete var->translation_;
  delete var;
}
void TdStackStorerInputPersonalDocument (struct TdInputPersonalDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputPersonalDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputPersonalDocument");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->files_->len; i0++) {
    TdStackStorer (var->files_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("files_");
  M->new_array ();
  for (int i100 = 0; i100 < var->translation_->len; i100++) {
    TdStackStorer (var->translation_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("translation_");
}
struct TdInputPersonalDocument *TdStackFetcherInputPersonalDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdInputPersonalDocument ();
  res->ID = CODE_InputPersonalDocument;
  res->refcnt = 1;
  M->get_field ("files_");
  res->files_ = new TdVectorInputFile ();
  res->files_->len = M->get_arr_size ();
  res->files_->data = new struct TdInputFile * [res->files_->len];
  for (int i0 = 0; i0 < res->files_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->files_->data[i0] = nullptr;
    } else {
      res->files_->data[i0] = TdStackFetcherInputFile (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("translation_");
  res->translation_ = new TdVectorInputFile ();
  res->translation_->len = M->get_arr_size ();
  res->translation_->data = new struct TdInputFile * [res->translation_->len];
  for (int i100 = 0; i100 < res->translation_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->translation_->data[i100] = nullptr;
    } else {
      res->translation_->data[i100] = TdStackFetcherInputFile (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdInputSticker *TdCreateObjectInputSticker (struct TdInputFile *png_sticker_, char *emojis_, struct TdMaskPosition *mask_position_) {
  auto var = new struct TdInputSticker ();
  var->ID = CODE_InputSticker;
  var->refcnt = 1;
  var->png_sticker_ = png_sticker_;
  var->emojis_ = (emojis_) ? td::str_dup (td::Slice (emojis_)) : nullptr;
  var->mask_position_ = mask_position_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputSticker> TdConvertToInternal (struct TdInputSticker *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->png_sticker_);
  std::string v100;
  v100 = (var->emojis_) ? var->emojis_: "";
  td::td_api::object_ptr<td::td_api::maskPosition> v200;
  v200 = TdConvertToInternal (var->mask_position_);
  return td::td_api::make_object<td::td_api::inputSticker>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInputSticker *TdConvertFromInternal (const td::td_api::inputSticker &from) {
  auto res = new TdInputSticker ();
  res->ID = CODE_InputSticker;
  res->refcnt = 1;
  if (!from.png_sticker_) {
    res->png_sticker_ = nullptr;
  } else {
    res->png_sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.png_sticker_));
  }
  res->emojis_ = (from.emojis_.length ()) ? td::str_dup (from.emojis_) : nullptr;
  if (!from.mask_position_) {
    res->mask_position_ = nullptr;
  } else {
    res->mask_position_ = TdConvertFromInternal (static_cast<const td::td_api::maskPosition &>(*from.mask_position_));
  }
  return res;
}
char *TdSerializeInputSticker (struct TdInputSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputSticker (struct TdInputSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->png_sticker_);
  free (var->emojis_);
  TdDestroyObject (var->mask_position_);
  delete var;
}
void TdStackStorerInputSticker (struct TdInputSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputSticker");
  M->new_field ("ID");
  TdStackStorer (var->png_sticker_, M);
  M->new_field ("png_sticker_");
  M->pack_string (var->emojis_);
  M->new_field ("emojis_");
  TdStackStorer (var->mask_position_, M);
  M->new_field ("mask_position_");
}
struct TdInputSticker *TdStackFetcherInputSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdInputSticker ();
  res->ID = CODE_InputSticker;
  res->refcnt = 1;
  M->get_field ("png_sticker_");
  if (M->is_nil ()) {
    res->png_sticker_ = nullptr;
  } else {
    res->png_sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("emojis_");
  res->emojis_ = M->get_string ();
  M->pop ();
  M->get_field ("mask_position_");
  if (M->is_nil ()) {
    res->mask_position_ = nullptr;
  } else {
    res->mask_position_ = TdStackFetcherMaskPosition (M);
  }
  M->pop ();
  return res;
}
struct TdInputThumbnail *TdCreateObjectInputThumbnail (struct TdInputFile *thumbnail_, int width_, int height_) {
  auto var = new struct TdInputThumbnail ();
  var->ID = CODE_InputThumbnail;
  var->refcnt = 1;
  var->thumbnail_ = thumbnail_;
  var->width_ = width_;
  var->height_ = height_;
  return var;
}
td::td_api::object_ptr<td::td_api::inputThumbnail> TdConvertToInternal (struct TdInputThumbnail *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->thumbnail_);
  std::int32_t v100;
  v100 = var->width_;
  std::int32_t v200;
  v200 = var->height_;
  return td::td_api::make_object<td::td_api::inputThumbnail>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdInputThumbnail *TdConvertFromInternal (const td::td_api::inputThumbnail &from) {
  auto res = new TdInputThumbnail ();
  res->ID = CODE_InputThumbnail;
  res->refcnt = 1;
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.thumbnail_));
  }
  res->width_ = from.width_;
  res->height_ = from.height_;
  return res;
}
char *TdSerializeInputThumbnail (struct TdInputThumbnail *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInputThumbnail *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInputThumbnail (struct TdInputThumbnail *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInputThumbnail *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->thumbnail_);
  delete var;
}
void TdStackStorerInputThumbnail (struct TdInputThumbnail *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInputThumbnail *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("InputThumbnail");
  M->new_field ("ID");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
}
struct TdInputThumbnail *TdStackFetcherInputThumbnail (struct TdStackFetcherMethods *M) {
  auto res = new TdInputThumbnail ();
  res->ID = CODE_InputThumbnail;
  res->refcnt = 1;
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdInvoice *TdCreateObjectInvoice (char *currency_, struct TdVectorLabeledPricePart *price_parts_, int is_test_, int need_name_, int need_phone_number_, int need_email_address_, int need_shipping_address_, int send_phone_number_to_provider_, int send_email_address_to_provider_, int is_flexible_) {
  auto var = new struct TdInvoice ();
  var->ID = CODE_Invoice;
  var->refcnt = 1;
  var->currency_ = (currency_) ? td::str_dup (td::Slice (currency_)) : nullptr;
  var->price_parts_ = price_parts_;
  var->is_test_ = is_test_;
  var->need_name_ = need_name_;
  var->need_phone_number_ = need_phone_number_;
  var->need_email_address_ = need_email_address_;
  var->need_shipping_address_ = need_shipping_address_;
  var->send_phone_number_to_provider_ = send_phone_number_to_provider_;
  var->send_email_address_to_provider_ = send_email_address_to_provider_;
  var->is_flexible_ = is_flexible_;
  return var;
}
td::td_api::object_ptr<td::td_api::invoice> TdConvertToInternal (struct TdInvoice *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->currency_) ? var->currency_: "";
  std::vector<td::td_api::object_ptr<td::td_api::labeledPricePart>> v100;
  for (int i100 = 0; i100 < var->price_parts_->len; i100++) {
    td::td_api::object_ptr<td::td_api::labeledPricePart> v101;
    v101 = TdConvertToInternal (var->price_parts_->data[i100]);
    v100.push_back (std::move (v101));
  }
  bool v200;
  v200 = var->is_test_ != 0;
  bool v300;
  v300 = var->need_name_ != 0;
  bool v400;
  v400 = var->need_phone_number_ != 0;
  bool v500;
  v500 = var->need_email_address_ != 0;
  bool v600;
  v600 = var->need_shipping_address_ != 0;
  bool v700;
  v700 = var->send_phone_number_to_provider_ != 0;
  bool v800;
  v800 = var->send_email_address_to_provider_ != 0;
  bool v900;
  v900 = var->is_flexible_ != 0;
  return td::td_api::make_object<td::td_api::invoice>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900));
}
struct TdInvoice *TdConvertFromInternal (const td::td_api::invoice &from) {
  auto res = new TdInvoice ();
  res->ID = CODE_Invoice;
  res->refcnt = 1;
  res->currency_ = (from.currency_.length ()) ? td::str_dup (from.currency_) : nullptr;
  res->price_parts_ = new TdVectorLabeledPricePart ();
  res->price_parts_->len = (int)from.price_parts_.size ();
  res->price_parts_->data = new struct TdLabeledPricePart * [res->price_parts_->len];
  for (int i100 = 0; i100 < res->price_parts_->len; i100++) {
    if (!from.price_parts_[i100]) {
      res->price_parts_->data[i100] = nullptr;
    } else {
      res->price_parts_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::labeledPricePart &>(*from.price_parts_[i100]));
    }
  }
  res->is_test_ = from.is_test_;
  res->need_name_ = from.need_name_;
  res->need_phone_number_ = from.need_phone_number_;
  res->need_email_address_ = from.need_email_address_;
  res->need_shipping_address_ = from.need_shipping_address_;
  res->send_phone_number_to_provider_ = from.send_phone_number_to_provider_;
  res->send_email_address_to_provider_ = from.send_email_address_to_provider_;
  res->is_flexible_ = from.is_flexible_;
  return res;
}
char *TdSerializeInvoice (struct TdInvoice *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdInvoice *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectInvoice (struct TdInvoice *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdInvoice *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->currency_);
  for (int i100 = 0; i100 < var->price_parts_->len; i100++) {
    TdDestroyObject (var->price_parts_->data[i100]);
  }
  delete[] var->price_parts_->data;
  delete var->price_parts_;
  delete var;
}
void TdStackStorerInvoice (struct TdInvoice *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdInvoice *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Invoice");
  M->new_field ("ID");
  M->pack_string (var->currency_);
  M->new_field ("currency_");
  M->new_array ();
  for (int i100 = 0; i100 < var->price_parts_->len; i100++) {
    TdStackStorer (var->price_parts_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("price_parts_");
  M->pack_bool (var->is_test_);
  M->new_field ("is_test_");
  M->pack_bool (var->need_name_);
  M->new_field ("need_name_");
  M->pack_bool (var->need_phone_number_);
  M->new_field ("need_phone_number_");
  M->pack_bool (var->need_email_address_);
  M->new_field ("need_email_address_");
  M->pack_bool (var->need_shipping_address_);
  M->new_field ("need_shipping_address_");
  M->pack_bool (var->send_phone_number_to_provider_);
  M->new_field ("send_phone_number_to_provider_");
  M->pack_bool (var->send_email_address_to_provider_);
  M->new_field ("send_email_address_to_provider_");
  M->pack_bool (var->is_flexible_);
  M->new_field ("is_flexible_");
}
struct TdInvoice *TdStackFetcherInvoice (struct TdStackFetcherMethods *M) {
  auto res = new TdInvoice ();
  res->ID = CODE_Invoice;
  res->refcnt = 1;
  M->get_field ("currency_");
  res->currency_ = M->get_string ();
  M->pop ();
  M->get_field ("price_parts_");
  res->price_parts_ = new TdVectorLabeledPricePart ();
  res->price_parts_->len = M->get_arr_size ();
  res->price_parts_->data = new struct TdLabeledPricePart * [res->price_parts_->len];
  for (int i100 = 0; i100 < res->price_parts_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->price_parts_->data[i100] = nullptr;
    } else {
      res->price_parts_->data[i100] = TdStackFetcherLabeledPricePart (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("is_test_");
  res->is_test_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_name_");
  res->need_name_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_phone_number_");
  res->need_phone_number_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_email_address_");
  res->need_email_address_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_shipping_address_");
  res->need_shipping_address_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("send_phone_number_to_provider_");
  res->send_phone_number_to_provider_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("send_email_address_to_provider_");
  res->send_email_address_to_provider_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_flexible_");
  res->is_flexible_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdKeyboardButton *TdCreateObjectKeyboardButton (char *text_, struct TdKeyboardButtonType *type_) {
  auto var = new struct TdKeyboardButton ();
  var->ID = CODE_KeyboardButton;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::keyboardButton> TdConvertToInternal (struct TdKeyboardButton *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  td::td_api::object_ptr<td::td_api::KeyboardButtonType> v100;
  v100 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::keyboardButton>(std::move (v0), std::move (v100));
}
struct TdKeyboardButton *TdConvertFromInternal (const td::td_api::keyboardButton &from) {
  auto res = new TdKeyboardButton ();
  res->ID = CODE_KeyboardButton;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::KeyboardButtonType &>(*from.type_));
  }
  return res;
}
char *TdSerializeKeyboardButton (struct TdKeyboardButton *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdKeyboardButton *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectKeyboardButton (struct TdKeyboardButton *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdKeyboardButton *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerKeyboardButton (struct TdKeyboardButton *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdKeyboardButton *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("KeyboardButton");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdKeyboardButton *TdStackFetcherKeyboardButton (struct TdStackFetcherMethods *M) {
  auto res = new TdKeyboardButton ();
  res->ID = CODE_KeyboardButton;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherKeyboardButtonType (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::KeyboardButtonType> TdConvertToInternal (struct TdKeyboardButtonType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_KeyboardButtonTypeText: return TdConvertToInternal ((struct TdKeyboardButtonTypeText *)var);
    case CODE_KeyboardButtonTypeRequestPhoneNumber: return TdConvertToInternal ((struct TdKeyboardButtonTypeRequestPhoneNumber *)var);
    case CODE_KeyboardButtonTypeRequestLocation: return TdConvertToInternal ((struct TdKeyboardButtonTypeRequestLocation *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdKeyboardButtonType *TdConvertFromInternal (const td::td_api::KeyboardButtonType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_KeyboardButtonTypeText: return (struct TdKeyboardButtonType *)TdConvertFromInternal(static_cast<const td::td_api::keyboardButtonTypeText &>(from));
    case CODE_KeyboardButtonTypeRequestPhoneNumber: return (struct TdKeyboardButtonType *)TdConvertFromInternal(static_cast<const td::td_api::keyboardButtonTypeRequestPhoneNumber &>(from));
    case CODE_KeyboardButtonTypeRequestLocation: return (struct TdKeyboardButtonType *)TdConvertFromInternal(static_cast<const td::td_api::keyboardButtonTypeRequestLocation &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeKeyboardButtonType (struct TdKeyboardButtonType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdKeyboardButtonType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectKeyboardButtonType (struct TdKeyboardButtonType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdKeyboardButtonType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_KeyboardButtonTypeText: return TdDestroyObject ((struct TdKeyboardButtonTypeText *)var);
    case CODE_KeyboardButtonTypeRequestPhoneNumber: return TdDestroyObject ((struct TdKeyboardButtonTypeRequestPhoneNumber *)var);
    case CODE_KeyboardButtonTypeRequestLocation: return TdDestroyObject ((struct TdKeyboardButtonTypeRequestLocation *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerKeyboardButtonType (struct TdKeyboardButtonType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdKeyboardButtonType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_KeyboardButtonTypeText: return TdStackStorer ((struct TdKeyboardButtonTypeText *)var, M);
    case CODE_KeyboardButtonTypeRequestPhoneNumber: return TdStackStorer ((struct TdKeyboardButtonTypeRequestPhoneNumber *)var, M);
    case CODE_KeyboardButtonTypeRequestLocation: return TdStackStorer ((struct TdKeyboardButtonTypeRequestLocation *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdKeyboardButtonType *TdStackFetcherKeyboardButtonType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "KeyboardButtonTypeText") {
    return (struct TdKeyboardButtonType *)TdStackFetcherKeyboardButtonTypeText (M);
  }
  if (constructor == "KeyboardButtonTypeRequestPhoneNumber") {
    return (struct TdKeyboardButtonType *)TdStackFetcherKeyboardButtonTypeRequestPhoneNumber (M);
  }
  if (constructor == "KeyboardButtonTypeRequestLocation") {
    return (struct TdKeyboardButtonType *)TdStackFetcherKeyboardButtonTypeRequestLocation (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdKeyboardButtonTypeText *TdCreateObjectKeyboardButtonTypeText (void) {
  auto var = new struct TdKeyboardButtonTypeText ();
  var->ID = CODE_KeyboardButtonTypeText;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::keyboardButtonTypeText> TdConvertToInternal (struct TdKeyboardButtonTypeText *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::keyboardButtonTypeText>();
}
struct TdKeyboardButtonTypeText *TdConvertFromInternal (const td::td_api::keyboardButtonTypeText &from) {
  auto res = new TdKeyboardButtonTypeText ();
  res->ID = CODE_KeyboardButtonTypeText;
  res->refcnt = 1;
  return res;
}
char *TdSerializeKeyboardButtonTypeText (struct TdKeyboardButtonTypeText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdKeyboardButtonTypeText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectKeyboardButtonTypeText (struct TdKeyboardButtonTypeText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdKeyboardButtonTypeText *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerKeyboardButtonTypeText (struct TdKeyboardButtonTypeText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdKeyboardButtonTypeText *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("KeyboardButtonTypeText");
  M->new_field ("ID");
}
struct TdKeyboardButtonTypeText *TdStackFetcherKeyboardButtonTypeText (struct TdStackFetcherMethods *M) {
  auto res = new TdKeyboardButtonTypeText ();
  res->ID = CODE_KeyboardButtonTypeText;
  res->refcnt = 1;
  return res;
}
struct TdKeyboardButtonTypeRequestPhoneNumber *TdCreateObjectKeyboardButtonTypeRequestPhoneNumber (void) {
  auto var = new struct TdKeyboardButtonTypeRequestPhoneNumber ();
  var->ID = CODE_KeyboardButtonTypeRequestPhoneNumber;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::keyboardButtonTypeRequestPhoneNumber> TdConvertToInternal (struct TdKeyboardButtonTypeRequestPhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::keyboardButtonTypeRequestPhoneNumber>();
}
struct TdKeyboardButtonTypeRequestPhoneNumber *TdConvertFromInternal (const td::td_api::keyboardButtonTypeRequestPhoneNumber &from) {
  auto res = new TdKeyboardButtonTypeRequestPhoneNumber ();
  res->ID = CODE_KeyboardButtonTypeRequestPhoneNumber;
  res->refcnt = 1;
  return res;
}
char *TdSerializeKeyboardButtonTypeRequestPhoneNumber (struct TdKeyboardButtonTypeRequestPhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdKeyboardButtonTypeRequestPhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectKeyboardButtonTypeRequestPhoneNumber (struct TdKeyboardButtonTypeRequestPhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdKeyboardButtonTypeRequestPhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerKeyboardButtonTypeRequestPhoneNumber (struct TdKeyboardButtonTypeRequestPhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdKeyboardButtonTypeRequestPhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("KeyboardButtonTypeRequestPhoneNumber");
  M->new_field ("ID");
}
struct TdKeyboardButtonTypeRequestPhoneNumber *TdStackFetcherKeyboardButtonTypeRequestPhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdKeyboardButtonTypeRequestPhoneNumber ();
  res->ID = CODE_KeyboardButtonTypeRequestPhoneNumber;
  res->refcnt = 1;
  return res;
}
struct TdKeyboardButtonTypeRequestLocation *TdCreateObjectKeyboardButtonTypeRequestLocation (void) {
  auto var = new struct TdKeyboardButtonTypeRequestLocation ();
  var->ID = CODE_KeyboardButtonTypeRequestLocation;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::keyboardButtonTypeRequestLocation> TdConvertToInternal (struct TdKeyboardButtonTypeRequestLocation *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::keyboardButtonTypeRequestLocation>();
}
struct TdKeyboardButtonTypeRequestLocation *TdConvertFromInternal (const td::td_api::keyboardButtonTypeRequestLocation &from) {
  auto res = new TdKeyboardButtonTypeRequestLocation ();
  res->ID = CODE_KeyboardButtonTypeRequestLocation;
  res->refcnt = 1;
  return res;
}
char *TdSerializeKeyboardButtonTypeRequestLocation (struct TdKeyboardButtonTypeRequestLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdKeyboardButtonTypeRequestLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectKeyboardButtonTypeRequestLocation (struct TdKeyboardButtonTypeRequestLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdKeyboardButtonTypeRequestLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerKeyboardButtonTypeRequestLocation (struct TdKeyboardButtonTypeRequestLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdKeyboardButtonTypeRequestLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("KeyboardButtonTypeRequestLocation");
  M->new_field ("ID");
}
struct TdKeyboardButtonTypeRequestLocation *TdStackFetcherKeyboardButtonTypeRequestLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdKeyboardButtonTypeRequestLocation ();
  res->ID = CODE_KeyboardButtonTypeRequestLocation;
  res->refcnt = 1;
  return res;
}
struct TdLabeledPricePart *TdCreateObjectLabeledPricePart (char *label_, long long amount_) {
  auto var = new struct TdLabeledPricePart ();
  var->ID = CODE_LabeledPricePart;
  var->refcnt = 1;
  var->label_ = (label_) ? td::str_dup (td::Slice (label_)) : nullptr;
  var->amount_ = amount_;
  return var;
}
td::td_api::object_ptr<td::td_api::labeledPricePart> TdConvertToInternal (struct TdLabeledPricePart *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->label_) ? var->label_: "";
  std::int64_t v100;
  v100 = var->amount_;
  return td::td_api::make_object<td::td_api::labeledPricePart>(std::move (v0), std::move (v100));
}
struct TdLabeledPricePart *TdConvertFromInternal (const td::td_api::labeledPricePart &from) {
  auto res = new TdLabeledPricePart ();
  res->ID = CODE_LabeledPricePart;
  res->refcnt = 1;
  res->label_ = (from.label_.length ()) ? td::str_dup (from.label_) : nullptr;
  res->amount_ = from.amount_;
  return res;
}
char *TdSerializeLabeledPricePart (struct TdLabeledPricePart *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLabeledPricePart *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLabeledPricePart (struct TdLabeledPricePart *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLabeledPricePart *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->label_);
  delete var;
}
void TdStackStorerLabeledPricePart (struct TdLabeledPricePart *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLabeledPricePart *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LabeledPricePart");
  M->new_field ("ID");
  M->pack_string (var->label_);
  M->new_field ("label_");
  M->pack_long (var->amount_);
  M->new_field ("amount_");
}
struct TdLabeledPricePart *TdStackFetcherLabeledPricePart (struct TdStackFetcherMethods *M) {
  auto res = new TdLabeledPricePart ();
  res->ID = CODE_LabeledPricePart;
  res->refcnt = 1;
  M->get_field ("label_");
  res->label_ = M->get_string ();
  M->pop ();
  M->get_field ("amount_");
  res->amount_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdLanguagePackInfo *TdCreateObjectLanguagePackInfo (char *id_, char *name_, char *native_name_, int local_string_count_) {
  auto var = new struct TdLanguagePackInfo ();
  var->ID = CODE_LanguagePackInfo;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  var->native_name_ = (native_name_) ? td::str_dup (td::Slice (native_name_)) : nullptr;
  var->local_string_count_ = local_string_count_;
  return var;
}
td::td_api::object_ptr<td::td_api::languagePackInfo> TdConvertToInternal (struct TdLanguagePackInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->name_) ? var->name_: "";
  std::string v200;
  v200 = (var->native_name_) ? var->native_name_: "";
  std::int32_t v300;
  v300 = var->local_string_count_;
  return td::td_api::make_object<td::td_api::languagePackInfo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdLanguagePackInfo *TdConvertFromInternal (const td::td_api::languagePackInfo &from) {
  auto res = new TdLanguagePackInfo ();
  res->ID = CODE_LanguagePackInfo;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  res->native_name_ = (from.native_name_.length ()) ? td::str_dup (from.native_name_) : nullptr;
  res->local_string_count_ = from.local_string_count_;
  return res;
}
char *TdSerializeLanguagePackInfo (struct TdLanguagePackInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLanguagePackInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLanguagePackInfo (struct TdLanguagePackInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLanguagePackInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->name_);
  free (var->native_name_);
  delete var;
}
void TdStackStorerLanguagePackInfo (struct TdLanguagePackInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLanguagePackInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LanguagePackInfo");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->name_);
  M->new_field ("name_");
  M->pack_string (var->native_name_);
  M->new_field ("native_name_");
  M->pack_long (var->local_string_count_);
  M->new_field ("local_string_count_");
}
struct TdLanguagePackInfo *TdStackFetcherLanguagePackInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdLanguagePackInfo ();
  res->ID = CODE_LanguagePackInfo;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  M->get_field ("native_name_");
  res->native_name_ = M->get_string ();
  M->pop ();
  M->get_field ("local_string_count_");
  res->local_string_count_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdLanguagePackString *TdCreateObjectLanguagePackString (char *key_, struct TdLanguagePackStringValue *value_) {
  auto var = new struct TdLanguagePackString ();
  var->ID = CODE_LanguagePackString;
  var->refcnt = 1;
  var->key_ = (key_) ? td::str_dup (td::Slice (key_)) : nullptr;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::languagePackString> TdConvertToInternal (struct TdLanguagePackString *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->key_) ? var->key_: "";
  td::td_api::object_ptr<td::td_api::LanguagePackStringValue> v100;
  v100 = TdConvertToInternal (var->value_);
  return td::td_api::make_object<td::td_api::languagePackString>(std::move (v0), std::move (v100));
}
struct TdLanguagePackString *TdConvertFromInternal (const td::td_api::languagePackString &from) {
  auto res = new TdLanguagePackString ();
  res->ID = CODE_LanguagePackString;
  res->refcnt = 1;
  res->key_ = (from.key_.length ()) ? td::str_dup (from.key_) : nullptr;
  if (!from.value_) {
    res->value_ = nullptr;
  } else {
    res->value_ = TdConvertFromInternal (static_cast<const td::td_api::LanguagePackStringValue &>(*from.value_));
  }
  return res;
}
char *TdSerializeLanguagePackString (struct TdLanguagePackString *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLanguagePackString *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLanguagePackString (struct TdLanguagePackString *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLanguagePackString *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->key_);
  TdDestroyObject (var->value_);
  delete var;
}
void TdStackStorerLanguagePackString (struct TdLanguagePackString *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLanguagePackString *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LanguagePackString");
  M->new_field ("ID");
  M->pack_string (var->key_);
  M->new_field ("key_");
  TdStackStorer (var->value_, M);
  M->new_field ("value_");
}
struct TdLanguagePackString *TdStackFetcherLanguagePackString (struct TdStackFetcherMethods *M) {
  auto res = new TdLanguagePackString ();
  res->ID = CODE_LanguagePackString;
  res->refcnt = 1;
  M->get_field ("key_");
  res->key_ = M->get_string ();
  M->pop ();
  M->get_field ("value_");
  if (M->is_nil ()) {
    res->value_ = nullptr;
  } else {
    res->value_ = TdStackFetcherLanguagePackStringValue (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::LanguagePackStringValue> TdConvertToInternal (struct TdLanguagePackStringValue *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_LanguagePackStringValueOrdinary: return TdConvertToInternal ((struct TdLanguagePackStringValueOrdinary *)var);
    case CODE_LanguagePackStringValuePluralized: return TdConvertToInternal ((struct TdLanguagePackStringValuePluralized *)var);
    case CODE_LanguagePackStringValueDeleted: return TdConvertToInternal ((struct TdLanguagePackStringValueDeleted *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdLanguagePackStringValue *TdConvertFromInternal (const td::td_api::LanguagePackStringValue &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_LanguagePackStringValueOrdinary: return (struct TdLanguagePackStringValue *)TdConvertFromInternal(static_cast<const td::td_api::languagePackStringValueOrdinary &>(from));
    case CODE_LanguagePackStringValuePluralized: return (struct TdLanguagePackStringValue *)TdConvertFromInternal(static_cast<const td::td_api::languagePackStringValuePluralized &>(from));
    case CODE_LanguagePackStringValueDeleted: return (struct TdLanguagePackStringValue *)TdConvertFromInternal(static_cast<const td::td_api::languagePackStringValueDeleted &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeLanguagePackStringValue (struct TdLanguagePackStringValue *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLanguagePackStringValue *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLanguagePackStringValue (struct TdLanguagePackStringValue *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLanguagePackStringValue *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_LanguagePackStringValueOrdinary: return TdDestroyObject ((struct TdLanguagePackStringValueOrdinary *)var);
    case CODE_LanguagePackStringValuePluralized: return TdDestroyObject ((struct TdLanguagePackStringValuePluralized *)var);
    case CODE_LanguagePackStringValueDeleted: return TdDestroyObject ((struct TdLanguagePackStringValueDeleted *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerLanguagePackStringValue (struct TdLanguagePackStringValue *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLanguagePackStringValue *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_LanguagePackStringValueOrdinary: return TdStackStorer ((struct TdLanguagePackStringValueOrdinary *)var, M);
    case CODE_LanguagePackStringValuePluralized: return TdStackStorer ((struct TdLanguagePackStringValuePluralized *)var, M);
    case CODE_LanguagePackStringValueDeleted: return TdStackStorer ((struct TdLanguagePackStringValueDeleted *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdLanguagePackStringValue *TdStackFetcherLanguagePackStringValue (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "LanguagePackStringValueOrdinary") {
    return (struct TdLanguagePackStringValue *)TdStackFetcherLanguagePackStringValueOrdinary (M);
  }
  if (constructor == "LanguagePackStringValuePluralized") {
    return (struct TdLanguagePackStringValue *)TdStackFetcherLanguagePackStringValuePluralized (M);
  }
  if (constructor == "LanguagePackStringValueDeleted") {
    return (struct TdLanguagePackStringValue *)TdStackFetcherLanguagePackStringValueDeleted (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdLanguagePackStringValueOrdinary *TdCreateObjectLanguagePackStringValueOrdinary (char *value_) {
  auto var = new struct TdLanguagePackStringValueOrdinary ();
  var->ID = CODE_LanguagePackStringValueOrdinary;
  var->refcnt = 1;
  var->value_ = (value_) ? td::str_dup (td::Slice (value_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::languagePackStringValueOrdinary> TdConvertToInternal (struct TdLanguagePackStringValueOrdinary *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->value_) ? var->value_: "";
  return td::td_api::make_object<td::td_api::languagePackStringValueOrdinary>(std::move (v0));
}
struct TdLanguagePackStringValueOrdinary *TdConvertFromInternal (const td::td_api::languagePackStringValueOrdinary &from) {
  auto res = new TdLanguagePackStringValueOrdinary ();
  res->ID = CODE_LanguagePackStringValueOrdinary;
  res->refcnt = 1;
  res->value_ = (from.value_.length ()) ? td::str_dup (from.value_) : nullptr;
  return res;
}
char *TdSerializeLanguagePackStringValueOrdinary (struct TdLanguagePackStringValueOrdinary *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLanguagePackStringValueOrdinary *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLanguagePackStringValueOrdinary (struct TdLanguagePackStringValueOrdinary *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLanguagePackStringValueOrdinary *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->value_);
  delete var;
}
void TdStackStorerLanguagePackStringValueOrdinary (struct TdLanguagePackStringValueOrdinary *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLanguagePackStringValueOrdinary *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LanguagePackStringValueOrdinary");
  M->new_field ("ID");
  M->pack_string (var->value_);
  M->new_field ("value_");
}
struct TdLanguagePackStringValueOrdinary *TdStackFetcherLanguagePackStringValueOrdinary (struct TdStackFetcherMethods *M) {
  auto res = new TdLanguagePackStringValueOrdinary ();
  res->ID = CODE_LanguagePackStringValueOrdinary;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdLanguagePackStringValuePluralized *TdCreateObjectLanguagePackStringValuePluralized (char *zero_value_, char *one_value_, char *two_value_, char *few_value_, char *many_value_, char *other_value_) {
  auto var = new struct TdLanguagePackStringValuePluralized ();
  var->ID = CODE_LanguagePackStringValuePluralized;
  var->refcnt = 1;
  var->zero_value_ = (zero_value_) ? td::str_dup (td::Slice (zero_value_)) : nullptr;
  var->one_value_ = (one_value_) ? td::str_dup (td::Slice (one_value_)) : nullptr;
  var->two_value_ = (two_value_) ? td::str_dup (td::Slice (two_value_)) : nullptr;
  var->few_value_ = (few_value_) ? td::str_dup (td::Slice (few_value_)) : nullptr;
  var->many_value_ = (many_value_) ? td::str_dup (td::Slice (many_value_)) : nullptr;
  var->other_value_ = (other_value_) ? td::str_dup (td::Slice (other_value_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::languagePackStringValuePluralized> TdConvertToInternal (struct TdLanguagePackStringValuePluralized *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->zero_value_) ? var->zero_value_: "";
  std::string v100;
  v100 = (var->one_value_) ? var->one_value_: "";
  std::string v200;
  v200 = (var->two_value_) ? var->two_value_: "";
  std::string v300;
  v300 = (var->few_value_) ? var->few_value_: "";
  std::string v400;
  v400 = (var->many_value_) ? var->many_value_: "";
  std::string v500;
  v500 = (var->other_value_) ? var->other_value_: "";
  return td::td_api::make_object<td::td_api::languagePackStringValuePluralized>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdLanguagePackStringValuePluralized *TdConvertFromInternal (const td::td_api::languagePackStringValuePluralized &from) {
  auto res = new TdLanguagePackStringValuePluralized ();
  res->ID = CODE_LanguagePackStringValuePluralized;
  res->refcnt = 1;
  res->zero_value_ = (from.zero_value_.length ()) ? td::str_dup (from.zero_value_) : nullptr;
  res->one_value_ = (from.one_value_.length ()) ? td::str_dup (from.one_value_) : nullptr;
  res->two_value_ = (from.two_value_.length ()) ? td::str_dup (from.two_value_) : nullptr;
  res->few_value_ = (from.few_value_.length ()) ? td::str_dup (from.few_value_) : nullptr;
  res->many_value_ = (from.many_value_.length ()) ? td::str_dup (from.many_value_) : nullptr;
  res->other_value_ = (from.other_value_.length ()) ? td::str_dup (from.other_value_) : nullptr;
  return res;
}
char *TdSerializeLanguagePackStringValuePluralized (struct TdLanguagePackStringValuePluralized *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLanguagePackStringValuePluralized *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLanguagePackStringValuePluralized (struct TdLanguagePackStringValuePluralized *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLanguagePackStringValuePluralized *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->zero_value_);
  free (var->one_value_);
  free (var->two_value_);
  free (var->few_value_);
  free (var->many_value_);
  free (var->other_value_);
  delete var;
}
void TdStackStorerLanguagePackStringValuePluralized (struct TdLanguagePackStringValuePluralized *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLanguagePackStringValuePluralized *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LanguagePackStringValuePluralized");
  M->new_field ("ID");
  M->pack_string (var->zero_value_);
  M->new_field ("zero_value_");
  M->pack_string (var->one_value_);
  M->new_field ("one_value_");
  M->pack_string (var->two_value_);
  M->new_field ("two_value_");
  M->pack_string (var->few_value_);
  M->new_field ("few_value_");
  M->pack_string (var->many_value_);
  M->new_field ("many_value_");
  M->pack_string (var->other_value_);
  M->new_field ("other_value_");
}
struct TdLanguagePackStringValuePluralized *TdStackFetcherLanguagePackStringValuePluralized (struct TdStackFetcherMethods *M) {
  auto res = new TdLanguagePackStringValuePluralized ();
  res->ID = CODE_LanguagePackStringValuePluralized;
  res->refcnt = 1;
  M->get_field ("zero_value_");
  res->zero_value_ = M->get_string ();
  M->pop ();
  M->get_field ("one_value_");
  res->one_value_ = M->get_string ();
  M->pop ();
  M->get_field ("two_value_");
  res->two_value_ = M->get_string ();
  M->pop ();
  M->get_field ("few_value_");
  res->few_value_ = M->get_string ();
  M->pop ();
  M->get_field ("many_value_");
  res->many_value_ = M->get_string ();
  M->pop ();
  M->get_field ("other_value_");
  res->other_value_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdLanguagePackStringValueDeleted *TdCreateObjectLanguagePackStringValueDeleted (void) {
  auto var = new struct TdLanguagePackStringValueDeleted ();
  var->ID = CODE_LanguagePackStringValueDeleted;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::languagePackStringValueDeleted> TdConvertToInternal (struct TdLanguagePackStringValueDeleted *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::languagePackStringValueDeleted>();
}
struct TdLanguagePackStringValueDeleted *TdConvertFromInternal (const td::td_api::languagePackStringValueDeleted &from) {
  auto res = new TdLanguagePackStringValueDeleted ();
  res->ID = CODE_LanguagePackStringValueDeleted;
  res->refcnt = 1;
  return res;
}
char *TdSerializeLanguagePackStringValueDeleted (struct TdLanguagePackStringValueDeleted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLanguagePackStringValueDeleted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLanguagePackStringValueDeleted (struct TdLanguagePackStringValueDeleted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLanguagePackStringValueDeleted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerLanguagePackStringValueDeleted (struct TdLanguagePackStringValueDeleted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLanguagePackStringValueDeleted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LanguagePackStringValueDeleted");
  M->new_field ("ID");
}
struct TdLanguagePackStringValueDeleted *TdStackFetcherLanguagePackStringValueDeleted (struct TdStackFetcherMethods *M) {
  auto res = new TdLanguagePackStringValueDeleted ();
  res->ID = CODE_LanguagePackStringValueDeleted;
  res->refcnt = 1;
  return res;
}
struct TdLanguagePackStrings *TdCreateObjectLanguagePackStrings (struct TdVectorLanguagePackString *strings_) {
  auto var = new struct TdLanguagePackStrings ();
  var->ID = CODE_LanguagePackStrings;
  var->refcnt = 1;
  var->strings_ = strings_;
  return var;
}
td::td_api::object_ptr<td::td_api::languagePackStrings> TdConvertToInternal (struct TdLanguagePackStrings *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::languagePackString>> v0;
  for (int i0 = 0; i0 < var->strings_->len; i0++) {
    td::td_api::object_ptr<td::td_api::languagePackString> v1;
    v1 = TdConvertToInternal (var->strings_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::languagePackStrings>(std::move (v0));
}
struct TdLanguagePackStrings *TdConvertFromInternal (const td::td_api::languagePackStrings &from) {
  auto res = new TdLanguagePackStrings ();
  res->ID = CODE_LanguagePackStrings;
  res->refcnt = 1;
  res->strings_ = new TdVectorLanguagePackString ();
  res->strings_->len = (int)from.strings_.size ();
  res->strings_->data = new struct TdLanguagePackString * [res->strings_->len];
  for (int i0 = 0; i0 < res->strings_->len; i0++) {
    if (!from.strings_[i0]) {
      res->strings_->data[i0] = nullptr;
    } else {
      res->strings_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::languagePackString &>(*from.strings_[i0]));
    }
  }
  return res;
}
char *TdSerializeLanguagePackStrings (struct TdLanguagePackStrings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLanguagePackStrings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLanguagePackStrings (struct TdLanguagePackStrings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLanguagePackStrings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->strings_->len; i0++) {
    TdDestroyObject (var->strings_->data[i0]);
  }
  delete[] var->strings_->data;
  delete var->strings_;
  delete var;
}
void TdStackStorerLanguagePackStrings (struct TdLanguagePackStrings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLanguagePackStrings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LanguagePackStrings");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->strings_->len; i0++) {
    TdStackStorer (var->strings_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("strings_");
}
struct TdLanguagePackStrings *TdStackFetcherLanguagePackStrings (struct TdStackFetcherMethods *M) {
  auto res = new TdLanguagePackStrings ();
  res->ID = CODE_LanguagePackStrings;
  res->refcnt = 1;
  M->get_field ("strings_");
  res->strings_ = new TdVectorLanguagePackString ();
  res->strings_->len = M->get_arr_size ();
  res->strings_->data = new struct TdLanguagePackString * [res->strings_->len];
  for (int i0 = 0; i0 < res->strings_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->strings_->data[i0] = nullptr;
    } else {
      res->strings_->data[i0] = TdStackFetcherLanguagePackString (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::LinkState> TdConvertToInternal (struct TdLinkState *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_LinkStateNone: return TdConvertToInternal ((struct TdLinkStateNone *)var);
    case CODE_LinkStateKnowsPhoneNumber: return TdConvertToInternal ((struct TdLinkStateKnowsPhoneNumber *)var);
    case CODE_LinkStateIsContact: return TdConvertToInternal ((struct TdLinkStateIsContact *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdLinkState *TdConvertFromInternal (const td::td_api::LinkState &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_LinkStateNone: return (struct TdLinkState *)TdConvertFromInternal(static_cast<const td::td_api::linkStateNone &>(from));
    case CODE_LinkStateKnowsPhoneNumber: return (struct TdLinkState *)TdConvertFromInternal(static_cast<const td::td_api::linkStateKnowsPhoneNumber &>(from));
    case CODE_LinkStateIsContact: return (struct TdLinkState *)TdConvertFromInternal(static_cast<const td::td_api::linkStateIsContact &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeLinkState (struct TdLinkState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLinkState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLinkState (struct TdLinkState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLinkState *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_LinkStateNone: return TdDestroyObject ((struct TdLinkStateNone *)var);
    case CODE_LinkStateKnowsPhoneNumber: return TdDestroyObject ((struct TdLinkStateKnowsPhoneNumber *)var);
    case CODE_LinkStateIsContact: return TdDestroyObject ((struct TdLinkStateIsContact *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerLinkState (struct TdLinkState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLinkState *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_LinkStateNone: return TdStackStorer ((struct TdLinkStateNone *)var, M);
    case CODE_LinkStateKnowsPhoneNumber: return TdStackStorer ((struct TdLinkStateKnowsPhoneNumber *)var, M);
    case CODE_LinkStateIsContact: return TdStackStorer ((struct TdLinkStateIsContact *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdLinkState *TdStackFetcherLinkState (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "LinkStateNone") {
    return (struct TdLinkState *)TdStackFetcherLinkStateNone (M);
  }
  if (constructor == "LinkStateKnowsPhoneNumber") {
    return (struct TdLinkState *)TdStackFetcherLinkStateKnowsPhoneNumber (M);
  }
  if (constructor == "LinkStateIsContact") {
    return (struct TdLinkState *)TdStackFetcherLinkStateIsContact (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdLinkStateNone *TdCreateObjectLinkStateNone (void) {
  auto var = new struct TdLinkStateNone ();
  var->ID = CODE_LinkStateNone;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::linkStateNone> TdConvertToInternal (struct TdLinkStateNone *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::linkStateNone>();
}
struct TdLinkStateNone *TdConvertFromInternal (const td::td_api::linkStateNone &from) {
  auto res = new TdLinkStateNone ();
  res->ID = CODE_LinkStateNone;
  res->refcnt = 1;
  return res;
}
char *TdSerializeLinkStateNone (struct TdLinkStateNone *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLinkStateNone *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLinkStateNone (struct TdLinkStateNone *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLinkStateNone *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerLinkStateNone (struct TdLinkStateNone *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLinkStateNone *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LinkStateNone");
  M->new_field ("ID");
}
struct TdLinkStateNone *TdStackFetcherLinkStateNone (struct TdStackFetcherMethods *M) {
  auto res = new TdLinkStateNone ();
  res->ID = CODE_LinkStateNone;
  res->refcnt = 1;
  return res;
}
struct TdLinkStateKnowsPhoneNumber *TdCreateObjectLinkStateKnowsPhoneNumber (void) {
  auto var = new struct TdLinkStateKnowsPhoneNumber ();
  var->ID = CODE_LinkStateKnowsPhoneNumber;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::linkStateKnowsPhoneNumber> TdConvertToInternal (struct TdLinkStateKnowsPhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::linkStateKnowsPhoneNumber>();
}
struct TdLinkStateKnowsPhoneNumber *TdConvertFromInternal (const td::td_api::linkStateKnowsPhoneNumber &from) {
  auto res = new TdLinkStateKnowsPhoneNumber ();
  res->ID = CODE_LinkStateKnowsPhoneNumber;
  res->refcnt = 1;
  return res;
}
char *TdSerializeLinkStateKnowsPhoneNumber (struct TdLinkStateKnowsPhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLinkStateKnowsPhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLinkStateKnowsPhoneNumber (struct TdLinkStateKnowsPhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLinkStateKnowsPhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerLinkStateKnowsPhoneNumber (struct TdLinkStateKnowsPhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLinkStateKnowsPhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LinkStateKnowsPhoneNumber");
  M->new_field ("ID");
}
struct TdLinkStateKnowsPhoneNumber *TdStackFetcherLinkStateKnowsPhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdLinkStateKnowsPhoneNumber ();
  res->ID = CODE_LinkStateKnowsPhoneNumber;
  res->refcnt = 1;
  return res;
}
struct TdLinkStateIsContact *TdCreateObjectLinkStateIsContact (void) {
  auto var = new struct TdLinkStateIsContact ();
  var->ID = CODE_LinkStateIsContact;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::linkStateIsContact> TdConvertToInternal (struct TdLinkStateIsContact *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::linkStateIsContact>();
}
struct TdLinkStateIsContact *TdConvertFromInternal (const td::td_api::linkStateIsContact &from) {
  auto res = new TdLinkStateIsContact ();
  res->ID = CODE_LinkStateIsContact;
  res->refcnt = 1;
  return res;
}
char *TdSerializeLinkStateIsContact (struct TdLinkStateIsContact *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLinkStateIsContact *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLinkStateIsContact (struct TdLinkStateIsContact *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLinkStateIsContact *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerLinkStateIsContact (struct TdLinkStateIsContact *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLinkStateIsContact *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LinkStateIsContact");
  M->new_field ("ID");
}
struct TdLinkStateIsContact *TdStackFetcherLinkStateIsContact (struct TdStackFetcherMethods *M) {
  auto res = new TdLinkStateIsContact ();
  res->ID = CODE_LinkStateIsContact;
  res->refcnt = 1;
  return res;
}
struct TdLocalFile *TdCreateObjectLocalFile (char *path_, int can_be_downloaded_, int can_be_deleted_, int is_downloading_active_, int is_downloading_completed_, int downloaded_prefix_size_, int downloaded_size_) {
  auto var = new struct TdLocalFile ();
  var->ID = CODE_LocalFile;
  var->refcnt = 1;
  var->path_ = (path_) ? td::str_dup (td::Slice (path_)) : nullptr;
  var->can_be_downloaded_ = can_be_downloaded_;
  var->can_be_deleted_ = can_be_deleted_;
  var->is_downloading_active_ = is_downloading_active_;
  var->is_downloading_completed_ = is_downloading_completed_;
  var->downloaded_prefix_size_ = downloaded_prefix_size_;
  var->downloaded_size_ = downloaded_size_;
  return var;
}
td::td_api::object_ptr<td::td_api::localFile> TdConvertToInternal (struct TdLocalFile *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->path_) ? var->path_: "";
  bool v100;
  v100 = var->can_be_downloaded_ != 0;
  bool v200;
  v200 = var->can_be_deleted_ != 0;
  bool v300;
  v300 = var->is_downloading_active_ != 0;
  bool v400;
  v400 = var->is_downloading_completed_ != 0;
  std::int32_t v500;
  v500 = var->downloaded_prefix_size_;
  std::int32_t v600;
  v600 = var->downloaded_size_;
  return td::td_api::make_object<td::td_api::localFile>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdLocalFile *TdConvertFromInternal (const td::td_api::localFile &from) {
  auto res = new TdLocalFile ();
  res->ID = CODE_LocalFile;
  res->refcnt = 1;
  res->path_ = (from.path_.length ()) ? td::str_dup (from.path_) : nullptr;
  res->can_be_downloaded_ = from.can_be_downloaded_;
  res->can_be_deleted_ = from.can_be_deleted_;
  res->is_downloading_active_ = from.is_downloading_active_;
  res->is_downloading_completed_ = from.is_downloading_completed_;
  res->downloaded_prefix_size_ = from.downloaded_prefix_size_;
  res->downloaded_size_ = from.downloaded_size_;
  return res;
}
char *TdSerializeLocalFile (struct TdLocalFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLocalFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLocalFile (struct TdLocalFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLocalFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->path_);
  delete var;
}
void TdStackStorerLocalFile (struct TdLocalFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLocalFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LocalFile");
  M->new_field ("ID");
  M->pack_string (var->path_);
  M->new_field ("path_");
  M->pack_bool (var->can_be_downloaded_);
  M->new_field ("can_be_downloaded_");
  M->pack_bool (var->can_be_deleted_);
  M->new_field ("can_be_deleted_");
  M->pack_bool (var->is_downloading_active_);
  M->new_field ("is_downloading_active_");
  M->pack_bool (var->is_downloading_completed_);
  M->new_field ("is_downloading_completed_");
  M->pack_long (var->downloaded_prefix_size_);
  M->new_field ("downloaded_prefix_size_");
  M->pack_long (var->downloaded_size_);
  M->new_field ("downloaded_size_");
}
struct TdLocalFile *TdStackFetcherLocalFile (struct TdStackFetcherMethods *M) {
  auto res = new TdLocalFile ();
  res->ID = CODE_LocalFile;
  res->refcnt = 1;
  M->get_field ("path_");
  res->path_ = M->get_string ();
  M->pop ();
  M->get_field ("can_be_downloaded_");
  res->can_be_downloaded_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_be_deleted_");
  res->can_be_deleted_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_downloading_active_");
  res->is_downloading_active_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_downloading_completed_");
  res->is_downloading_completed_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("downloaded_prefix_size_");
  res->downloaded_prefix_size_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("downloaded_size_");
  res->downloaded_size_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdLocalizationTargetInfo *TdCreateObjectLocalizationTargetInfo (struct TdVectorLanguagePackInfo *language_packs_) {
  auto var = new struct TdLocalizationTargetInfo ();
  var->ID = CODE_LocalizationTargetInfo;
  var->refcnt = 1;
  var->language_packs_ = language_packs_;
  return var;
}
td::td_api::object_ptr<td::td_api::localizationTargetInfo> TdConvertToInternal (struct TdLocalizationTargetInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::languagePackInfo>> v0;
  for (int i0 = 0; i0 < var->language_packs_->len; i0++) {
    td::td_api::object_ptr<td::td_api::languagePackInfo> v1;
    v1 = TdConvertToInternal (var->language_packs_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::localizationTargetInfo>(std::move (v0));
}
struct TdLocalizationTargetInfo *TdConvertFromInternal (const td::td_api::localizationTargetInfo &from) {
  auto res = new TdLocalizationTargetInfo ();
  res->ID = CODE_LocalizationTargetInfo;
  res->refcnt = 1;
  res->language_packs_ = new TdVectorLanguagePackInfo ();
  res->language_packs_->len = (int)from.language_packs_.size ();
  res->language_packs_->data = new struct TdLanguagePackInfo * [res->language_packs_->len];
  for (int i0 = 0; i0 < res->language_packs_->len; i0++) {
    if (!from.language_packs_[i0]) {
      res->language_packs_->data[i0] = nullptr;
    } else {
      res->language_packs_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::languagePackInfo &>(*from.language_packs_[i0]));
    }
  }
  return res;
}
char *TdSerializeLocalizationTargetInfo (struct TdLocalizationTargetInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLocalizationTargetInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLocalizationTargetInfo (struct TdLocalizationTargetInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLocalizationTargetInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->language_packs_->len; i0++) {
    TdDestroyObject (var->language_packs_->data[i0]);
  }
  delete[] var->language_packs_->data;
  delete var->language_packs_;
  delete var;
}
void TdStackStorerLocalizationTargetInfo (struct TdLocalizationTargetInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLocalizationTargetInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LocalizationTargetInfo");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->language_packs_->len; i0++) {
    TdStackStorer (var->language_packs_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("language_packs_");
}
struct TdLocalizationTargetInfo *TdStackFetcherLocalizationTargetInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdLocalizationTargetInfo ();
  res->ID = CODE_LocalizationTargetInfo;
  res->refcnt = 1;
  M->get_field ("language_packs_");
  res->language_packs_ = new TdVectorLanguagePackInfo ();
  res->language_packs_->len = M->get_arr_size ();
  res->language_packs_->data = new struct TdLanguagePackInfo * [res->language_packs_->len];
  for (int i0 = 0; i0 < res->language_packs_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->language_packs_->data[i0] = nullptr;
    } else {
      res->language_packs_->data[i0] = TdStackFetcherLanguagePackInfo (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdLocation *TdCreateObjectLocation (double latitude_, double longitude_) {
  auto var = new struct TdLocation ();
  var->ID = CODE_Location;
  var->refcnt = 1;
  var->latitude_ = latitude_;
  var->longitude_ = longitude_;
  return var;
}
td::td_api::object_ptr<td::td_api::location> TdConvertToInternal (struct TdLocation *var) {
  if (!var) {
    return nullptr;
  }
  double v0;
  v0 = var->latitude_;
  double v100;
  v100 = var->longitude_;
  return td::td_api::make_object<td::td_api::location>(std::move (v0), std::move (v100));
}
struct TdLocation *TdConvertFromInternal (const td::td_api::location &from) {
  auto res = new TdLocation ();
  res->ID = CODE_Location;
  res->refcnt = 1;
  res->latitude_ = from.latitude_;
  res->longitude_ = from.longitude_;
  return res;
}
char *TdSerializeLocation (struct TdLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLocation (struct TdLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerLocation (struct TdLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Location");
  M->new_field ("ID");
  M->pack_double (var->latitude_);
  M->new_field ("latitude_");
  M->pack_double (var->longitude_);
  M->new_field ("longitude_");
}
struct TdLocation *TdStackFetcherLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdLocation ();
  res->ID = CODE_Location;
  res->refcnt = 1;
  M->get_field ("latitude_");
  res->latitude_ = M->get_double ();
  M->pop ();
  M->get_field ("longitude_");
  res->longitude_ = M->get_double ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::MaskPoint> TdConvertToInternal (struct TdMaskPoint *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MaskPointForehead: return TdConvertToInternal ((struct TdMaskPointForehead *)var);
    case CODE_MaskPointEyes: return TdConvertToInternal ((struct TdMaskPointEyes *)var);
    case CODE_MaskPointMouth: return TdConvertToInternal ((struct TdMaskPointMouth *)var);
    case CODE_MaskPointChin: return TdConvertToInternal ((struct TdMaskPointChin *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdMaskPoint *TdConvertFromInternal (const td::td_api::MaskPoint &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_MaskPointForehead: return (struct TdMaskPoint *)TdConvertFromInternal(static_cast<const td::td_api::maskPointForehead &>(from));
    case CODE_MaskPointEyes: return (struct TdMaskPoint *)TdConvertFromInternal(static_cast<const td::td_api::maskPointEyes &>(from));
    case CODE_MaskPointMouth: return (struct TdMaskPoint *)TdConvertFromInternal(static_cast<const td::td_api::maskPointMouth &>(from));
    case CODE_MaskPointChin: return (struct TdMaskPoint *)TdConvertFromInternal(static_cast<const td::td_api::maskPointChin &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeMaskPoint (struct TdMaskPoint *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMaskPoint *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMaskPoint (struct TdMaskPoint *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMaskPoint *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MaskPointForehead: return TdDestroyObject ((struct TdMaskPointForehead *)var);
    case CODE_MaskPointEyes: return TdDestroyObject ((struct TdMaskPointEyes *)var);
    case CODE_MaskPointMouth: return TdDestroyObject ((struct TdMaskPointMouth *)var);
    case CODE_MaskPointChin: return TdDestroyObject ((struct TdMaskPointChin *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerMaskPoint (struct TdMaskPoint *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMaskPoint *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MaskPointForehead: return TdStackStorer ((struct TdMaskPointForehead *)var, M);
    case CODE_MaskPointEyes: return TdStackStorer ((struct TdMaskPointEyes *)var, M);
    case CODE_MaskPointMouth: return TdStackStorer ((struct TdMaskPointMouth *)var, M);
    case CODE_MaskPointChin: return TdStackStorer ((struct TdMaskPointChin *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdMaskPoint *TdStackFetcherMaskPoint (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "MaskPointForehead") {
    return (struct TdMaskPoint *)TdStackFetcherMaskPointForehead (M);
  }
  if (constructor == "MaskPointEyes") {
    return (struct TdMaskPoint *)TdStackFetcherMaskPointEyes (M);
  }
  if (constructor == "MaskPointMouth") {
    return (struct TdMaskPoint *)TdStackFetcherMaskPointMouth (M);
  }
  if (constructor == "MaskPointChin") {
    return (struct TdMaskPoint *)TdStackFetcherMaskPointChin (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdMaskPointForehead *TdCreateObjectMaskPointForehead (void) {
  auto var = new struct TdMaskPointForehead ();
  var->ID = CODE_MaskPointForehead;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::maskPointForehead> TdConvertToInternal (struct TdMaskPointForehead *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::maskPointForehead>();
}
struct TdMaskPointForehead *TdConvertFromInternal (const td::td_api::maskPointForehead &from) {
  auto res = new TdMaskPointForehead ();
  res->ID = CODE_MaskPointForehead;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMaskPointForehead (struct TdMaskPointForehead *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMaskPointForehead *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMaskPointForehead (struct TdMaskPointForehead *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMaskPointForehead *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMaskPointForehead (struct TdMaskPointForehead *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMaskPointForehead *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MaskPointForehead");
  M->new_field ("ID");
}
struct TdMaskPointForehead *TdStackFetcherMaskPointForehead (struct TdStackFetcherMethods *M) {
  auto res = new TdMaskPointForehead ();
  res->ID = CODE_MaskPointForehead;
  res->refcnt = 1;
  return res;
}
struct TdMaskPointEyes *TdCreateObjectMaskPointEyes (void) {
  auto var = new struct TdMaskPointEyes ();
  var->ID = CODE_MaskPointEyes;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::maskPointEyes> TdConvertToInternal (struct TdMaskPointEyes *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::maskPointEyes>();
}
struct TdMaskPointEyes *TdConvertFromInternal (const td::td_api::maskPointEyes &from) {
  auto res = new TdMaskPointEyes ();
  res->ID = CODE_MaskPointEyes;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMaskPointEyes (struct TdMaskPointEyes *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMaskPointEyes *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMaskPointEyes (struct TdMaskPointEyes *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMaskPointEyes *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMaskPointEyes (struct TdMaskPointEyes *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMaskPointEyes *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MaskPointEyes");
  M->new_field ("ID");
}
struct TdMaskPointEyes *TdStackFetcherMaskPointEyes (struct TdStackFetcherMethods *M) {
  auto res = new TdMaskPointEyes ();
  res->ID = CODE_MaskPointEyes;
  res->refcnt = 1;
  return res;
}
struct TdMaskPointMouth *TdCreateObjectMaskPointMouth (void) {
  auto var = new struct TdMaskPointMouth ();
  var->ID = CODE_MaskPointMouth;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::maskPointMouth> TdConvertToInternal (struct TdMaskPointMouth *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::maskPointMouth>();
}
struct TdMaskPointMouth *TdConvertFromInternal (const td::td_api::maskPointMouth &from) {
  auto res = new TdMaskPointMouth ();
  res->ID = CODE_MaskPointMouth;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMaskPointMouth (struct TdMaskPointMouth *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMaskPointMouth *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMaskPointMouth (struct TdMaskPointMouth *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMaskPointMouth *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMaskPointMouth (struct TdMaskPointMouth *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMaskPointMouth *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MaskPointMouth");
  M->new_field ("ID");
}
struct TdMaskPointMouth *TdStackFetcherMaskPointMouth (struct TdStackFetcherMethods *M) {
  auto res = new TdMaskPointMouth ();
  res->ID = CODE_MaskPointMouth;
  res->refcnt = 1;
  return res;
}
struct TdMaskPointChin *TdCreateObjectMaskPointChin (void) {
  auto var = new struct TdMaskPointChin ();
  var->ID = CODE_MaskPointChin;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::maskPointChin> TdConvertToInternal (struct TdMaskPointChin *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::maskPointChin>();
}
struct TdMaskPointChin *TdConvertFromInternal (const td::td_api::maskPointChin &from) {
  auto res = new TdMaskPointChin ();
  res->ID = CODE_MaskPointChin;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMaskPointChin (struct TdMaskPointChin *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMaskPointChin *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMaskPointChin (struct TdMaskPointChin *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMaskPointChin *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMaskPointChin (struct TdMaskPointChin *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMaskPointChin *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MaskPointChin");
  M->new_field ("ID");
}
struct TdMaskPointChin *TdStackFetcherMaskPointChin (struct TdStackFetcherMethods *M) {
  auto res = new TdMaskPointChin ();
  res->ID = CODE_MaskPointChin;
  res->refcnt = 1;
  return res;
}
struct TdMaskPosition *TdCreateObjectMaskPosition (struct TdMaskPoint *point_, double x_shift_, double y_shift_, double scale_) {
  auto var = new struct TdMaskPosition ();
  var->ID = CODE_MaskPosition;
  var->refcnt = 1;
  var->point_ = point_;
  var->x_shift_ = x_shift_;
  var->y_shift_ = y_shift_;
  var->scale_ = scale_;
  return var;
}
td::td_api::object_ptr<td::td_api::maskPosition> TdConvertToInternal (struct TdMaskPosition *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::MaskPoint> v0;
  v0 = TdConvertToInternal (var->point_);
  double v100;
  v100 = var->x_shift_;
  double v200;
  v200 = var->y_shift_;
  double v300;
  v300 = var->scale_;
  return td::td_api::make_object<td::td_api::maskPosition>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdMaskPosition *TdConvertFromInternal (const td::td_api::maskPosition &from) {
  auto res = new TdMaskPosition ();
  res->ID = CODE_MaskPosition;
  res->refcnt = 1;
  if (!from.point_) {
    res->point_ = nullptr;
  } else {
    res->point_ = TdConvertFromInternal (static_cast<const td::td_api::MaskPoint &>(*from.point_));
  }
  res->x_shift_ = from.x_shift_;
  res->y_shift_ = from.y_shift_;
  res->scale_ = from.scale_;
  return res;
}
char *TdSerializeMaskPosition (struct TdMaskPosition *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMaskPosition *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMaskPosition (struct TdMaskPosition *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMaskPosition *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->point_);
  delete var;
}
void TdStackStorerMaskPosition (struct TdMaskPosition *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMaskPosition *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MaskPosition");
  M->new_field ("ID");
  TdStackStorer (var->point_, M);
  M->new_field ("point_");
  M->pack_double (var->x_shift_);
  M->new_field ("x_shift_");
  M->pack_double (var->y_shift_);
  M->new_field ("y_shift_");
  M->pack_double (var->scale_);
  M->new_field ("scale_");
}
struct TdMaskPosition *TdStackFetcherMaskPosition (struct TdStackFetcherMethods *M) {
  auto res = new TdMaskPosition ();
  res->ID = CODE_MaskPosition;
  res->refcnt = 1;
  M->get_field ("point_");
  if (M->is_nil ()) {
    res->point_ = nullptr;
  } else {
    res->point_ = TdStackFetcherMaskPoint (M);
  }
  M->pop ();
  M->get_field ("x_shift_");
  res->x_shift_ = M->get_double ();
  M->pop ();
  M->get_field ("y_shift_");
  res->y_shift_ = M->get_double ();
  M->pop ();
  M->get_field ("scale_");
  res->scale_ = M->get_double ();
  M->pop ();
  return res;
}
struct TdMessage *TdCreateObjectMessage (long long id_, int sender_user_id_, long long chat_id_, struct TdMessageSendingState *sending_state_, int is_outgoing_, int can_be_edited_, int can_be_forwarded_, int can_be_deleted_only_for_self_, int can_be_deleted_for_all_users_, int is_channel_post_, int contains_unread_mention_, int date_, int edit_date_, struct TdMessageForwardInfo *forward_info_, long long reply_to_message_id_, int ttl_, double ttl_expires_in_, int via_bot_user_id_, char *author_signature_, int views_, long long media_album_id_, struct TdMessageContent *content_, struct TdReplyMarkup *reply_markup_) {
  auto var = new struct TdMessage ();
  var->ID = CODE_Message;
  var->refcnt = 1;
  var->id_ = id_;
  var->sender_user_id_ = sender_user_id_;
  var->chat_id_ = chat_id_;
  var->sending_state_ = sending_state_;
  var->is_outgoing_ = is_outgoing_;
  var->can_be_edited_ = can_be_edited_;
  var->can_be_forwarded_ = can_be_forwarded_;
  var->can_be_deleted_only_for_self_ = can_be_deleted_only_for_self_;
  var->can_be_deleted_for_all_users_ = can_be_deleted_for_all_users_;
  var->is_channel_post_ = is_channel_post_;
  var->contains_unread_mention_ = contains_unread_mention_;
  var->date_ = date_;
  var->edit_date_ = edit_date_;
  var->forward_info_ = forward_info_;
  var->reply_to_message_id_ = reply_to_message_id_;
  var->ttl_ = ttl_;
  var->ttl_expires_in_ = ttl_expires_in_;
  var->via_bot_user_id_ = via_bot_user_id_;
  var->author_signature_ = (author_signature_) ? td::str_dup (td::Slice (author_signature_)) : nullptr;
  var->views_ = views_;
  var->media_album_id_ = media_album_id_;
  var->content_ = content_;
  var->reply_markup_ = reply_markup_;
  return var;
}
td::td_api::object_ptr<td::td_api::message> TdConvertToInternal (struct TdMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->sender_user_id_;
  std::int64_t v200;
  v200 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::MessageSendingState> v300;
  v300 = TdConvertToInternal (var->sending_state_);
  bool v400;
  v400 = var->is_outgoing_ != 0;
  bool v500;
  v500 = var->can_be_edited_ != 0;
  bool v600;
  v600 = var->can_be_forwarded_ != 0;
  bool v700;
  v700 = var->can_be_deleted_only_for_self_ != 0;
  bool v800;
  v800 = var->can_be_deleted_for_all_users_ != 0;
  bool v900;
  v900 = var->is_channel_post_ != 0;
  bool v1000;
  v1000 = var->contains_unread_mention_ != 0;
  std::int32_t v1100;
  v1100 = var->date_;
  std::int32_t v1200;
  v1200 = var->edit_date_;
  td::td_api::object_ptr<td::td_api::MessageForwardInfo> v1300;
  v1300 = TdConvertToInternal (var->forward_info_);
  std::int64_t v1400;
  v1400 = var->reply_to_message_id_;
  std::int32_t v1500;
  v1500 = var->ttl_;
  double v1600;
  v1600 = var->ttl_expires_in_;
  std::int32_t v1700;
  v1700 = var->via_bot_user_id_;
  std::string v1800;
  v1800 = (var->author_signature_) ? var->author_signature_: "";
  std::int32_t v1900;
  v1900 = var->views_;
  std::int64_t v2000;
  v2000 = var->media_album_id_;
  td::td_api::object_ptr<td::td_api::MessageContent> v2100;
  v2100 = TdConvertToInternal (var->content_);
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v2200;
  v2200 = TdConvertToInternal (var->reply_markup_);
  return td::td_api::make_object<td::td_api::message>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000), std::move (v1100), std::move (v1200), std::move (v1300), std::move (v1400), std::move (v1500), std::move (v1600), std::move (v1700), std::move (v1800), std::move (v1900), std::move (v2000), std::move (v2100), std::move (v2200));
}
struct TdMessage *TdConvertFromInternal (const td::td_api::message &from) {
  auto res = new TdMessage ();
  res->ID = CODE_Message;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->sender_user_id_ = from.sender_user_id_;
  res->chat_id_ = from.chat_id_;
  if (!from.sending_state_) {
    res->sending_state_ = nullptr;
  } else {
    res->sending_state_ = TdConvertFromInternal (static_cast<const td::td_api::MessageSendingState &>(*from.sending_state_));
  }
  res->is_outgoing_ = from.is_outgoing_;
  res->can_be_edited_ = from.can_be_edited_;
  res->can_be_forwarded_ = from.can_be_forwarded_;
  res->can_be_deleted_only_for_self_ = from.can_be_deleted_only_for_self_;
  res->can_be_deleted_for_all_users_ = from.can_be_deleted_for_all_users_;
  res->is_channel_post_ = from.is_channel_post_;
  res->contains_unread_mention_ = from.contains_unread_mention_;
  res->date_ = from.date_;
  res->edit_date_ = from.edit_date_;
  if (!from.forward_info_) {
    res->forward_info_ = nullptr;
  } else {
    res->forward_info_ = TdConvertFromInternal (static_cast<const td::td_api::MessageForwardInfo &>(*from.forward_info_));
  }
  res->reply_to_message_id_ = from.reply_to_message_id_;
  res->ttl_ = from.ttl_;
  res->ttl_expires_in_ = from.ttl_expires_in_;
  res->via_bot_user_id_ = from.via_bot_user_id_;
  res->author_signature_ = (from.author_signature_.length ()) ? td::str_dup (from.author_signature_) : nullptr;
  res->views_ = from.views_;
  res->media_album_id_ = from.media_album_id_;
  if (!from.content_) {
    res->content_ = nullptr;
  } else {
    res->content_ = TdConvertFromInternal (static_cast<const td::td_api::MessageContent &>(*from.content_));
  }
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  return res;
}
char *TdSerializeMessage (struct TdMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessage (struct TdMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sending_state_);
  TdDestroyObject (var->forward_info_);
  free (var->author_signature_);
  TdDestroyObject (var->content_);
  TdDestroyObject (var->reply_markup_);
  delete var;
}
void TdStackStorerMessage (struct TdMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Message");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->sending_state_, M);
  M->new_field ("sending_state_");
  M->pack_bool (var->is_outgoing_);
  M->new_field ("is_outgoing_");
  M->pack_bool (var->can_be_edited_);
  M->new_field ("can_be_edited_");
  M->pack_bool (var->can_be_forwarded_);
  M->new_field ("can_be_forwarded_");
  M->pack_bool (var->can_be_deleted_only_for_self_);
  M->new_field ("can_be_deleted_only_for_self_");
  M->pack_bool (var->can_be_deleted_for_all_users_);
  M->new_field ("can_be_deleted_for_all_users_");
  M->pack_bool (var->is_channel_post_);
  M->new_field ("is_channel_post_");
  M->pack_bool (var->contains_unread_mention_);
  M->new_field ("contains_unread_mention_");
  M->pack_long (var->date_);
  M->new_field ("date_");
  M->pack_long (var->edit_date_);
  M->new_field ("edit_date_");
  TdStackStorer (var->forward_info_, M);
  M->new_field ("forward_info_");
  M->pack_long (var->reply_to_message_id_);
  M->new_field ("reply_to_message_id_");
  M->pack_long (var->ttl_);
  M->new_field ("ttl_");
  M->pack_double (var->ttl_expires_in_);
  M->new_field ("ttl_expires_in_");
  M->pack_long (var->via_bot_user_id_);
  M->new_field ("via_bot_user_id_");
  M->pack_string (var->author_signature_);
  M->new_field ("author_signature_");
  M->pack_long (var->views_);
  M->new_field ("views_");
  M->pack_long (var->media_album_id_);
  M->new_field ("media_album_id_");
  TdStackStorer (var->content_, M);
  M->new_field ("content_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
}
struct TdMessage *TdStackFetcherMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdMessage ();
  res->ID = CODE_Message;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("sending_state_");
  if (M->is_nil ()) {
    res->sending_state_ = nullptr;
  } else {
    res->sending_state_ = TdStackFetcherMessageSendingState (M);
  }
  M->pop ();
  M->get_field ("is_outgoing_");
  res->is_outgoing_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_be_edited_");
  res->can_be_edited_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_be_forwarded_");
  res->can_be_forwarded_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_be_deleted_only_for_self_");
  res->can_be_deleted_only_for_self_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_be_deleted_for_all_users_");
  res->can_be_deleted_for_all_users_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_channel_post_");
  res->is_channel_post_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("contains_unread_mention_");
  res->contains_unread_mention_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("edit_date_");
  res->edit_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("forward_info_");
  if (M->is_nil ()) {
    res->forward_info_ = nullptr;
  } else {
    res->forward_info_ = TdStackFetcherMessageForwardInfo (M);
  }
  M->pop ();
  M->get_field ("reply_to_message_id_");
  res->reply_to_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("ttl_");
  res->ttl_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("ttl_expires_in_");
  res->ttl_expires_in_ = M->get_double ();
  M->pop ();
  M->get_field ("via_bot_user_id_");
  res->via_bot_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("author_signature_");
  res->author_signature_ = M->get_string ();
  M->pop ();
  M->get_field ("views_");
  res->views_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("media_album_id_");
  res->media_album_id_ = M->get_long ();
  M->pop ();
  M->get_field ("content_");
  if (M->is_nil ()) {
    res->content_ = nullptr;
  } else {
    res->content_ = TdStackFetcherMessageContent (M);
  }
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::MessageContent> TdConvertToInternal (struct TdMessageContent *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageText: return TdConvertToInternal ((struct TdMessageText *)var);
    case CODE_MessageAnimation: return TdConvertToInternal ((struct TdMessageAnimation *)var);
    case CODE_MessageAudio: return TdConvertToInternal ((struct TdMessageAudio *)var);
    case CODE_MessageDocument: return TdConvertToInternal ((struct TdMessageDocument *)var);
    case CODE_MessagePhoto: return TdConvertToInternal ((struct TdMessagePhoto *)var);
    case CODE_MessageExpiredPhoto: return TdConvertToInternal ((struct TdMessageExpiredPhoto *)var);
    case CODE_MessageSticker: return TdConvertToInternal ((struct TdMessageSticker *)var);
    case CODE_MessageVideo: return TdConvertToInternal ((struct TdMessageVideo *)var);
    case CODE_MessageExpiredVideo: return TdConvertToInternal ((struct TdMessageExpiredVideo *)var);
    case CODE_MessageVideoNote: return TdConvertToInternal ((struct TdMessageVideoNote *)var);
    case CODE_MessageVoiceNote: return TdConvertToInternal ((struct TdMessageVoiceNote *)var);
    case CODE_MessageLocation: return TdConvertToInternal ((struct TdMessageLocation *)var);
    case CODE_MessageVenue: return TdConvertToInternal ((struct TdMessageVenue *)var);
    case CODE_MessageContact: return TdConvertToInternal ((struct TdMessageContact *)var);
    case CODE_MessageGame: return TdConvertToInternal ((struct TdMessageGame *)var);
    case CODE_MessageInvoice: return TdConvertToInternal ((struct TdMessageInvoice *)var);
    case CODE_MessageCall: return TdConvertToInternal ((struct TdMessageCall *)var);
    case CODE_MessageBasicGroupChatCreate: return TdConvertToInternal ((struct TdMessageBasicGroupChatCreate *)var);
    case CODE_MessageSupergroupChatCreate: return TdConvertToInternal ((struct TdMessageSupergroupChatCreate *)var);
    case CODE_MessageChatChangeTitle: return TdConvertToInternal ((struct TdMessageChatChangeTitle *)var);
    case CODE_MessageChatChangePhoto: return TdConvertToInternal ((struct TdMessageChatChangePhoto *)var);
    case CODE_MessageChatDeletePhoto: return TdConvertToInternal ((struct TdMessageChatDeletePhoto *)var);
    case CODE_MessageChatAddMembers: return TdConvertToInternal ((struct TdMessageChatAddMembers *)var);
    case CODE_MessageChatJoinByLink: return TdConvertToInternal ((struct TdMessageChatJoinByLink *)var);
    case CODE_MessageChatDeleteMember: return TdConvertToInternal ((struct TdMessageChatDeleteMember *)var);
    case CODE_MessageChatUpgradeTo: return TdConvertToInternal ((struct TdMessageChatUpgradeTo *)var);
    case CODE_MessageChatUpgradeFrom: return TdConvertToInternal ((struct TdMessageChatUpgradeFrom *)var);
    case CODE_MessagePinMessage: return TdConvertToInternal ((struct TdMessagePinMessage *)var);
    case CODE_MessageScreenshotTaken: return TdConvertToInternal ((struct TdMessageScreenshotTaken *)var);
    case CODE_MessageChatSetTtl: return TdConvertToInternal ((struct TdMessageChatSetTtl *)var);
    case CODE_MessageCustomServiceAction: return TdConvertToInternal ((struct TdMessageCustomServiceAction *)var);
    case CODE_MessageGameScore: return TdConvertToInternal ((struct TdMessageGameScore *)var);
    case CODE_MessagePaymentSuccessful: return TdConvertToInternal ((struct TdMessagePaymentSuccessful *)var);
    case CODE_MessagePaymentSuccessfulBot: return TdConvertToInternal ((struct TdMessagePaymentSuccessfulBot *)var);
    case CODE_MessageContactRegistered: return TdConvertToInternal ((struct TdMessageContactRegistered *)var);
    case CODE_MessageWebsiteConnected: return TdConvertToInternal ((struct TdMessageWebsiteConnected *)var);
    case CODE_MessagePassportDataSent: return TdConvertToInternal ((struct TdMessagePassportDataSent *)var);
    case CODE_MessagePassportDataReceived: return TdConvertToInternal ((struct TdMessagePassportDataReceived *)var);
    case CODE_MessageUnsupported: return TdConvertToInternal ((struct TdMessageUnsupported *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdMessageContent *TdConvertFromInternal (const td::td_api::MessageContent &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_MessageText: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageText &>(from));
    case CODE_MessageAnimation: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageAnimation &>(from));
    case CODE_MessageAudio: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageAudio &>(from));
    case CODE_MessageDocument: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageDocument &>(from));
    case CODE_MessagePhoto: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messagePhoto &>(from));
    case CODE_MessageExpiredPhoto: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageExpiredPhoto &>(from));
    case CODE_MessageSticker: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageSticker &>(from));
    case CODE_MessageVideo: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageVideo &>(from));
    case CODE_MessageExpiredVideo: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageExpiredVideo &>(from));
    case CODE_MessageVideoNote: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageVideoNote &>(from));
    case CODE_MessageVoiceNote: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageVoiceNote &>(from));
    case CODE_MessageLocation: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageLocation &>(from));
    case CODE_MessageVenue: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageVenue &>(from));
    case CODE_MessageContact: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageContact &>(from));
    case CODE_MessageGame: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageGame &>(from));
    case CODE_MessageInvoice: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageInvoice &>(from));
    case CODE_MessageCall: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageCall &>(from));
    case CODE_MessageBasicGroupChatCreate: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageBasicGroupChatCreate &>(from));
    case CODE_MessageSupergroupChatCreate: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageSupergroupChatCreate &>(from));
    case CODE_MessageChatChangeTitle: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatChangeTitle &>(from));
    case CODE_MessageChatChangePhoto: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatChangePhoto &>(from));
    case CODE_MessageChatDeletePhoto: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatDeletePhoto &>(from));
    case CODE_MessageChatAddMembers: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatAddMembers &>(from));
    case CODE_MessageChatJoinByLink: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatJoinByLink &>(from));
    case CODE_MessageChatDeleteMember: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatDeleteMember &>(from));
    case CODE_MessageChatUpgradeTo: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatUpgradeTo &>(from));
    case CODE_MessageChatUpgradeFrom: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatUpgradeFrom &>(from));
    case CODE_MessagePinMessage: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messagePinMessage &>(from));
    case CODE_MessageScreenshotTaken: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageScreenshotTaken &>(from));
    case CODE_MessageChatSetTtl: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageChatSetTtl &>(from));
    case CODE_MessageCustomServiceAction: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageCustomServiceAction &>(from));
    case CODE_MessageGameScore: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageGameScore &>(from));
    case CODE_MessagePaymentSuccessful: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messagePaymentSuccessful &>(from));
    case CODE_MessagePaymentSuccessfulBot: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messagePaymentSuccessfulBot &>(from));
    case CODE_MessageContactRegistered: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageContactRegistered &>(from));
    case CODE_MessageWebsiteConnected: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageWebsiteConnected &>(from));
    case CODE_MessagePassportDataSent: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messagePassportDataSent &>(from));
    case CODE_MessagePassportDataReceived: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messagePassportDataReceived &>(from));
    case CODE_MessageUnsupported: return (struct TdMessageContent *)TdConvertFromInternal(static_cast<const td::td_api::messageUnsupported &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeMessageContent (struct TdMessageContent *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageContent *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageContent (struct TdMessageContent *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageContent *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageText: return TdDestroyObject ((struct TdMessageText *)var);
    case CODE_MessageAnimation: return TdDestroyObject ((struct TdMessageAnimation *)var);
    case CODE_MessageAudio: return TdDestroyObject ((struct TdMessageAudio *)var);
    case CODE_MessageDocument: return TdDestroyObject ((struct TdMessageDocument *)var);
    case CODE_MessagePhoto: return TdDestroyObject ((struct TdMessagePhoto *)var);
    case CODE_MessageExpiredPhoto: return TdDestroyObject ((struct TdMessageExpiredPhoto *)var);
    case CODE_MessageSticker: return TdDestroyObject ((struct TdMessageSticker *)var);
    case CODE_MessageVideo: return TdDestroyObject ((struct TdMessageVideo *)var);
    case CODE_MessageExpiredVideo: return TdDestroyObject ((struct TdMessageExpiredVideo *)var);
    case CODE_MessageVideoNote: return TdDestroyObject ((struct TdMessageVideoNote *)var);
    case CODE_MessageVoiceNote: return TdDestroyObject ((struct TdMessageVoiceNote *)var);
    case CODE_MessageLocation: return TdDestroyObject ((struct TdMessageLocation *)var);
    case CODE_MessageVenue: return TdDestroyObject ((struct TdMessageVenue *)var);
    case CODE_MessageContact: return TdDestroyObject ((struct TdMessageContact *)var);
    case CODE_MessageGame: return TdDestroyObject ((struct TdMessageGame *)var);
    case CODE_MessageInvoice: return TdDestroyObject ((struct TdMessageInvoice *)var);
    case CODE_MessageCall: return TdDestroyObject ((struct TdMessageCall *)var);
    case CODE_MessageBasicGroupChatCreate: return TdDestroyObject ((struct TdMessageBasicGroupChatCreate *)var);
    case CODE_MessageSupergroupChatCreate: return TdDestroyObject ((struct TdMessageSupergroupChatCreate *)var);
    case CODE_MessageChatChangeTitle: return TdDestroyObject ((struct TdMessageChatChangeTitle *)var);
    case CODE_MessageChatChangePhoto: return TdDestroyObject ((struct TdMessageChatChangePhoto *)var);
    case CODE_MessageChatDeletePhoto: return TdDestroyObject ((struct TdMessageChatDeletePhoto *)var);
    case CODE_MessageChatAddMembers: return TdDestroyObject ((struct TdMessageChatAddMembers *)var);
    case CODE_MessageChatJoinByLink: return TdDestroyObject ((struct TdMessageChatJoinByLink *)var);
    case CODE_MessageChatDeleteMember: return TdDestroyObject ((struct TdMessageChatDeleteMember *)var);
    case CODE_MessageChatUpgradeTo: return TdDestroyObject ((struct TdMessageChatUpgradeTo *)var);
    case CODE_MessageChatUpgradeFrom: return TdDestroyObject ((struct TdMessageChatUpgradeFrom *)var);
    case CODE_MessagePinMessage: return TdDestroyObject ((struct TdMessagePinMessage *)var);
    case CODE_MessageScreenshotTaken: return TdDestroyObject ((struct TdMessageScreenshotTaken *)var);
    case CODE_MessageChatSetTtl: return TdDestroyObject ((struct TdMessageChatSetTtl *)var);
    case CODE_MessageCustomServiceAction: return TdDestroyObject ((struct TdMessageCustomServiceAction *)var);
    case CODE_MessageGameScore: return TdDestroyObject ((struct TdMessageGameScore *)var);
    case CODE_MessagePaymentSuccessful: return TdDestroyObject ((struct TdMessagePaymentSuccessful *)var);
    case CODE_MessagePaymentSuccessfulBot: return TdDestroyObject ((struct TdMessagePaymentSuccessfulBot *)var);
    case CODE_MessageContactRegistered: return TdDestroyObject ((struct TdMessageContactRegistered *)var);
    case CODE_MessageWebsiteConnected: return TdDestroyObject ((struct TdMessageWebsiteConnected *)var);
    case CODE_MessagePassportDataSent: return TdDestroyObject ((struct TdMessagePassportDataSent *)var);
    case CODE_MessagePassportDataReceived: return TdDestroyObject ((struct TdMessagePassportDataReceived *)var);
    case CODE_MessageUnsupported: return TdDestroyObject ((struct TdMessageUnsupported *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerMessageContent (struct TdMessageContent *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageContent *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageText: return TdStackStorer ((struct TdMessageText *)var, M);
    case CODE_MessageAnimation: return TdStackStorer ((struct TdMessageAnimation *)var, M);
    case CODE_MessageAudio: return TdStackStorer ((struct TdMessageAudio *)var, M);
    case CODE_MessageDocument: return TdStackStorer ((struct TdMessageDocument *)var, M);
    case CODE_MessagePhoto: return TdStackStorer ((struct TdMessagePhoto *)var, M);
    case CODE_MessageExpiredPhoto: return TdStackStorer ((struct TdMessageExpiredPhoto *)var, M);
    case CODE_MessageSticker: return TdStackStorer ((struct TdMessageSticker *)var, M);
    case CODE_MessageVideo: return TdStackStorer ((struct TdMessageVideo *)var, M);
    case CODE_MessageExpiredVideo: return TdStackStorer ((struct TdMessageExpiredVideo *)var, M);
    case CODE_MessageVideoNote: return TdStackStorer ((struct TdMessageVideoNote *)var, M);
    case CODE_MessageVoiceNote: return TdStackStorer ((struct TdMessageVoiceNote *)var, M);
    case CODE_MessageLocation: return TdStackStorer ((struct TdMessageLocation *)var, M);
    case CODE_MessageVenue: return TdStackStorer ((struct TdMessageVenue *)var, M);
    case CODE_MessageContact: return TdStackStorer ((struct TdMessageContact *)var, M);
    case CODE_MessageGame: return TdStackStorer ((struct TdMessageGame *)var, M);
    case CODE_MessageInvoice: return TdStackStorer ((struct TdMessageInvoice *)var, M);
    case CODE_MessageCall: return TdStackStorer ((struct TdMessageCall *)var, M);
    case CODE_MessageBasicGroupChatCreate: return TdStackStorer ((struct TdMessageBasicGroupChatCreate *)var, M);
    case CODE_MessageSupergroupChatCreate: return TdStackStorer ((struct TdMessageSupergroupChatCreate *)var, M);
    case CODE_MessageChatChangeTitle: return TdStackStorer ((struct TdMessageChatChangeTitle *)var, M);
    case CODE_MessageChatChangePhoto: return TdStackStorer ((struct TdMessageChatChangePhoto *)var, M);
    case CODE_MessageChatDeletePhoto: return TdStackStorer ((struct TdMessageChatDeletePhoto *)var, M);
    case CODE_MessageChatAddMembers: return TdStackStorer ((struct TdMessageChatAddMembers *)var, M);
    case CODE_MessageChatJoinByLink: return TdStackStorer ((struct TdMessageChatJoinByLink *)var, M);
    case CODE_MessageChatDeleteMember: return TdStackStorer ((struct TdMessageChatDeleteMember *)var, M);
    case CODE_MessageChatUpgradeTo: return TdStackStorer ((struct TdMessageChatUpgradeTo *)var, M);
    case CODE_MessageChatUpgradeFrom: return TdStackStorer ((struct TdMessageChatUpgradeFrom *)var, M);
    case CODE_MessagePinMessage: return TdStackStorer ((struct TdMessagePinMessage *)var, M);
    case CODE_MessageScreenshotTaken: return TdStackStorer ((struct TdMessageScreenshotTaken *)var, M);
    case CODE_MessageChatSetTtl: return TdStackStorer ((struct TdMessageChatSetTtl *)var, M);
    case CODE_MessageCustomServiceAction: return TdStackStorer ((struct TdMessageCustomServiceAction *)var, M);
    case CODE_MessageGameScore: return TdStackStorer ((struct TdMessageGameScore *)var, M);
    case CODE_MessagePaymentSuccessful: return TdStackStorer ((struct TdMessagePaymentSuccessful *)var, M);
    case CODE_MessagePaymentSuccessfulBot: return TdStackStorer ((struct TdMessagePaymentSuccessfulBot *)var, M);
    case CODE_MessageContactRegistered: return TdStackStorer ((struct TdMessageContactRegistered *)var, M);
    case CODE_MessageWebsiteConnected: return TdStackStorer ((struct TdMessageWebsiteConnected *)var, M);
    case CODE_MessagePassportDataSent: return TdStackStorer ((struct TdMessagePassportDataSent *)var, M);
    case CODE_MessagePassportDataReceived: return TdStackStorer ((struct TdMessagePassportDataReceived *)var, M);
    case CODE_MessageUnsupported: return TdStackStorer ((struct TdMessageUnsupported *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdMessageContent *TdStackFetcherMessageContent (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "MessageText") {
    return (struct TdMessageContent *)TdStackFetcherMessageText (M);
  }
  if (constructor == "MessageAnimation") {
    return (struct TdMessageContent *)TdStackFetcherMessageAnimation (M);
  }
  if (constructor == "MessageAudio") {
    return (struct TdMessageContent *)TdStackFetcherMessageAudio (M);
  }
  if (constructor == "MessageDocument") {
    return (struct TdMessageContent *)TdStackFetcherMessageDocument (M);
  }
  if (constructor == "MessagePhoto") {
    return (struct TdMessageContent *)TdStackFetcherMessagePhoto (M);
  }
  if (constructor == "MessageExpiredPhoto") {
    return (struct TdMessageContent *)TdStackFetcherMessageExpiredPhoto (M);
  }
  if (constructor == "MessageSticker") {
    return (struct TdMessageContent *)TdStackFetcherMessageSticker (M);
  }
  if (constructor == "MessageVideo") {
    return (struct TdMessageContent *)TdStackFetcherMessageVideo (M);
  }
  if (constructor == "MessageExpiredVideo") {
    return (struct TdMessageContent *)TdStackFetcherMessageExpiredVideo (M);
  }
  if (constructor == "MessageVideoNote") {
    return (struct TdMessageContent *)TdStackFetcherMessageVideoNote (M);
  }
  if (constructor == "MessageVoiceNote") {
    return (struct TdMessageContent *)TdStackFetcherMessageVoiceNote (M);
  }
  if (constructor == "MessageLocation") {
    return (struct TdMessageContent *)TdStackFetcherMessageLocation (M);
  }
  if (constructor == "MessageVenue") {
    return (struct TdMessageContent *)TdStackFetcherMessageVenue (M);
  }
  if (constructor == "MessageContact") {
    return (struct TdMessageContent *)TdStackFetcherMessageContact (M);
  }
  if (constructor == "MessageGame") {
    return (struct TdMessageContent *)TdStackFetcherMessageGame (M);
  }
  if (constructor == "MessageInvoice") {
    return (struct TdMessageContent *)TdStackFetcherMessageInvoice (M);
  }
  if (constructor == "MessageCall") {
    return (struct TdMessageContent *)TdStackFetcherMessageCall (M);
  }
  if (constructor == "MessageBasicGroupChatCreate") {
    return (struct TdMessageContent *)TdStackFetcherMessageBasicGroupChatCreate (M);
  }
  if (constructor == "MessageSupergroupChatCreate") {
    return (struct TdMessageContent *)TdStackFetcherMessageSupergroupChatCreate (M);
  }
  if (constructor == "MessageChatChangeTitle") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatChangeTitle (M);
  }
  if (constructor == "MessageChatChangePhoto") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatChangePhoto (M);
  }
  if (constructor == "MessageChatDeletePhoto") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatDeletePhoto (M);
  }
  if (constructor == "MessageChatAddMembers") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatAddMembers (M);
  }
  if (constructor == "MessageChatJoinByLink") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatJoinByLink (M);
  }
  if (constructor == "MessageChatDeleteMember") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatDeleteMember (M);
  }
  if (constructor == "MessageChatUpgradeTo") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatUpgradeTo (M);
  }
  if (constructor == "MessageChatUpgradeFrom") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatUpgradeFrom (M);
  }
  if (constructor == "MessagePinMessage") {
    return (struct TdMessageContent *)TdStackFetcherMessagePinMessage (M);
  }
  if (constructor == "MessageScreenshotTaken") {
    return (struct TdMessageContent *)TdStackFetcherMessageScreenshotTaken (M);
  }
  if (constructor == "MessageChatSetTtl") {
    return (struct TdMessageContent *)TdStackFetcherMessageChatSetTtl (M);
  }
  if (constructor == "MessageCustomServiceAction") {
    return (struct TdMessageContent *)TdStackFetcherMessageCustomServiceAction (M);
  }
  if (constructor == "MessageGameScore") {
    return (struct TdMessageContent *)TdStackFetcherMessageGameScore (M);
  }
  if (constructor == "MessagePaymentSuccessful") {
    return (struct TdMessageContent *)TdStackFetcherMessagePaymentSuccessful (M);
  }
  if (constructor == "MessagePaymentSuccessfulBot") {
    return (struct TdMessageContent *)TdStackFetcherMessagePaymentSuccessfulBot (M);
  }
  if (constructor == "MessageContactRegistered") {
    return (struct TdMessageContent *)TdStackFetcherMessageContactRegistered (M);
  }
  if (constructor == "MessageWebsiteConnected") {
    return (struct TdMessageContent *)TdStackFetcherMessageWebsiteConnected (M);
  }
  if (constructor == "MessagePassportDataSent") {
    return (struct TdMessageContent *)TdStackFetcherMessagePassportDataSent (M);
  }
  if (constructor == "MessagePassportDataReceived") {
    return (struct TdMessageContent *)TdStackFetcherMessagePassportDataReceived (M);
  }
  if (constructor == "MessageUnsupported") {
    return (struct TdMessageContent *)TdStackFetcherMessageUnsupported (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdMessageText *TdCreateObjectMessageText (struct TdFormattedText *text_, struct TdWebPage *web_page_) {
  auto var = new struct TdMessageText ();
  var->ID = CODE_MessageText;
  var->refcnt = 1;
  var->text_ = text_;
  var->web_page_ = web_page_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageText> TdConvertToInternal (struct TdMessageText *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::formattedText> v0;
  v0 = TdConvertToInternal (var->text_);
  td::td_api::object_ptr<td::td_api::webPage> v100;
  v100 = TdConvertToInternal (var->web_page_);
  return td::td_api::make_object<td::td_api::messageText>(std::move (v0), std::move (v100));
}
struct TdMessageText *TdConvertFromInternal (const td::td_api::messageText &from) {
  auto res = new TdMessageText ();
  res->ID = CODE_MessageText;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.text_));
  }
  if (!from.web_page_) {
    res->web_page_ = nullptr;
  } else {
    res->web_page_ = TdConvertFromInternal (static_cast<const td::td_api::webPage &>(*from.web_page_));
  }
  return res;
}
char *TdSerializeMessageText (struct TdMessageText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageText (struct TdMessageText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageText *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  TdDestroyObject (var->web_page_);
  delete var;
}
void TdStackStorerMessageText (struct TdMessageText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageText *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageText");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  TdStackStorer (var->web_page_, M);
  M->new_field ("web_page_");
}
struct TdMessageText *TdStackFetcherMessageText (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageText ();
  res->ID = CODE_MessageText;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("web_page_");
  if (M->is_nil ()) {
    res->web_page_ = nullptr;
  } else {
    res->web_page_ = TdStackFetcherWebPage (M);
  }
  M->pop ();
  return res;
}
struct TdMessageAnimation *TdCreateObjectMessageAnimation (struct TdAnimation *animation_, struct TdFormattedText *caption_, int is_secret_) {
  auto var = new struct TdMessageAnimation ();
  var->ID = CODE_MessageAnimation;
  var->refcnt = 1;
  var->animation_ = animation_;
  var->caption_ = caption_;
  var->is_secret_ = is_secret_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageAnimation> TdConvertToInternal (struct TdMessageAnimation *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::animation> v0;
  v0 = TdConvertToInternal (var->animation_);
  td::td_api::object_ptr<td::td_api::formattedText> v100;
  v100 = TdConvertToInternal (var->caption_);
  bool v200;
  v200 = var->is_secret_ != 0;
  return td::td_api::make_object<td::td_api::messageAnimation>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdMessageAnimation *TdConvertFromInternal (const td::td_api::messageAnimation &from) {
  auto res = new TdMessageAnimation ();
  res->ID = CODE_MessageAnimation;
  res->refcnt = 1;
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::animation &>(*from.animation_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  res->is_secret_ = from.is_secret_;
  return res;
}
char *TdSerializeMessageAnimation (struct TdMessageAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageAnimation (struct TdMessageAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->animation_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerMessageAnimation (struct TdMessageAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageAnimation");
  M->new_field ("ID");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_bool (var->is_secret_);
  M->new_field ("is_secret_");
}
struct TdMessageAnimation *TdStackFetcherMessageAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageAnimation ();
  res->ID = CODE_MessageAnimation;
  res->refcnt = 1;
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherAnimation (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("is_secret_");
  res->is_secret_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageAudio *TdCreateObjectMessageAudio (struct TdAudio *audio_, struct TdFormattedText *caption_) {
  auto var = new struct TdMessageAudio ();
  var->ID = CODE_MessageAudio;
  var->refcnt = 1;
  var->audio_ = audio_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageAudio> TdConvertToInternal (struct TdMessageAudio *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::audio> v0;
  v0 = TdConvertToInternal (var->audio_);
  td::td_api::object_ptr<td::td_api::formattedText> v100;
  v100 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::messageAudio>(std::move (v0), std::move (v100));
}
struct TdMessageAudio *TdConvertFromInternal (const td::td_api::messageAudio &from) {
  auto res = new TdMessageAudio ();
  res->ID = CODE_MessageAudio;
  res->refcnt = 1;
  if (!from.audio_) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdConvertFromInternal (static_cast<const td::td_api::audio &>(*from.audio_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  return res;
}
char *TdSerializeMessageAudio (struct TdMessageAudio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageAudio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageAudio (struct TdMessageAudio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageAudio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->audio_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerMessageAudio (struct TdMessageAudio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageAudio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageAudio");
  M->new_field ("ID");
  TdStackStorer (var->audio_, M);
  M->new_field ("audio_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdMessageAudio *TdStackFetcherMessageAudio (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageAudio ();
  res->ID = CODE_MessageAudio;
  res->refcnt = 1;
  M->get_field ("audio_");
  if (M->is_nil ()) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdStackFetcherAudio (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdMessageDocument *TdCreateObjectMessageDocument (struct TdDocument *document_, struct TdFormattedText *caption_) {
  auto var = new struct TdMessageDocument ();
  var->ID = CODE_MessageDocument;
  var->refcnt = 1;
  var->document_ = document_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageDocument> TdConvertToInternal (struct TdMessageDocument *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::document> v0;
  v0 = TdConvertToInternal (var->document_);
  td::td_api::object_ptr<td::td_api::formattedText> v100;
  v100 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::messageDocument>(std::move (v0), std::move (v100));
}
struct TdMessageDocument *TdConvertFromInternal (const td::td_api::messageDocument &from) {
  auto res = new TdMessageDocument ();
  res->ID = CODE_MessageDocument;
  res->refcnt = 1;
  if (!from.document_) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdConvertFromInternal (static_cast<const td::td_api::document &>(*from.document_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  return res;
}
char *TdSerializeMessageDocument (struct TdMessageDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageDocument (struct TdMessageDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->document_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerMessageDocument (struct TdMessageDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageDocument");
  M->new_field ("ID");
  TdStackStorer (var->document_, M);
  M->new_field ("document_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdMessageDocument *TdStackFetcherMessageDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageDocument ();
  res->ID = CODE_MessageDocument;
  res->refcnt = 1;
  M->get_field ("document_");
  if (M->is_nil ()) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdStackFetcherDocument (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdMessagePhoto *TdCreateObjectMessagePhoto (struct TdPhoto *photo_, struct TdFormattedText *caption_, int is_secret_) {
  auto var = new struct TdMessagePhoto ();
  var->ID = CODE_MessagePhoto;
  var->refcnt = 1;
  var->photo_ = photo_;
  var->caption_ = caption_;
  var->is_secret_ = is_secret_;
  return var;
}
td::td_api::object_ptr<td::td_api::messagePhoto> TdConvertToInternal (struct TdMessagePhoto *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::photo> v0;
  v0 = TdConvertToInternal (var->photo_);
  td::td_api::object_ptr<td::td_api::formattedText> v100;
  v100 = TdConvertToInternal (var->caption_);
  bool v200;
  v200 = var->is_secret_ != 0;
  return td::td_api::make_object<td::td_api::messagePhoto>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdMessagePhoto *TdConvertFromInternal (const td::td_api::messagePhoto &from) {
  auto res = new TdMessagePhoto ();
  res->ID = CODE_MessagePhoto;
  res->refcnt = 1;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.photo_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  res->is_secret_ = from.is_secret_;
  return res;
}
char *TdSerializeMessagePhoto (struct TdMessagePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessagePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessagePhoto (struct TdMessagePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessagePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->photo_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerMessagePhoto (struct TdMessagePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessagePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessagePhoto");
  M->new_field ("ID");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_bool (var->is_secret_);
  M->new_field ("is_secret_");
}
struct TdMessagePhoto *TdStackFetcherMessagePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdMessagePhoto ();
  res->ID = CODE_MessagePhoto;
  res->refcnt = 1;
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("is_secret_");
  res->is_secret_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageExpiredPhoto *TdCreateObjectMessageExpiredPhoto (void) {
  auto var = new struct TdMessageExpiredPhoto ();
  var->ID = CODE_MessageExpiredPhoto;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageExpiredPhoto> TdConvertToInternal (struct TdMessageExpiredPhoto *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageExpiredPhoto>();
}
struct TdMessageExpiredPhoto *TdConvertFromInternal (const td::td_api::messageExpiredPhoto &from) {
  auto res = new TdMessageExpiredPhoto ();
  res->ID = CODE_MessageExpiredPhoto;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageExpiredPhoto (struct TdMessageExpiredPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageExpiredPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageExpiredPhoto (struct TdMessageExpiredPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageExpiredPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageExpiredPhoto (struct TdMessageExpiredPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageExpiredPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageExpiredPhoto");
  M->new_field ("ID");
}
struct TdMessageExpiredPhoto *TdStackFetcherMessageExpiredPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageExpiredPhoto ();
  res->ID = CODE_MessageExpiredPhoto;
  res->refcnt = 1;
  return res;
}
struct TdMessageSticker *TdCreateObjectMessageSticker (struct TdSticker *sticker_) {
  auto var = new struct TdMessageSticker ();
  var->ID = CODE_MessageSticker;
  var->refcnt = 1;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageSticker> TdConvertToInternal (struct TdMessageSticker *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::sticker> v0;
  v0 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::messageSticker>(std::move (v0));
}
struct TdMessageSticker *TdConvertFromInternal (const td::td_api::messageSticker &from) {
  auto res = new TdMessageSticker ();
  res->ID = CODE_MessageSticker;
  res->refcnt = 1;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::sticker &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeMessageSticker (struct TdMessageSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageSticker (struct TdMessageSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerMessageSticker (struct TdMessageSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageSticker");
  M->new_field ("ID");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdMessageSticker *TdStackFetcherMessageSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageSticker ();
  res->ID = CODE_MessageSticker;
  res->refcnt = 1;
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherSticker (M);
  }
  M->pop ();
  return res;
}
struct TdMessageVideo *TdCreateObjectMessageVideo (struct TdVideo *video_, struct TdFormattedText *caption_, int is_secret_) {
  auto var = new struct TdMessageVideo ();
  var->ID = CODE_MessageVideo;
  var->refcnt = 1;
  var->video_ = video_;
  var->caption_ = caption_;
  var->is_secret_ = is_secret_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageVideo> TdConvertToInternal (struct TdMessageVideo *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::video> v0;
  v0 = TdConvertToInternal (var->video_);
  td::td_api::object_ptr<td::td_api::formattedText> v100;
  v100 = TdConvertToInternal (var->caption_);
  bool v200;
  v200 = var->is_secret_ != 0;
  return td::td_api::make_object<td::td_api::messageVideo>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdMessageVideo *TdConvertFromInternal (const td::td_api::messageVideo &from) {
  auto res = new TdMessageVideo ();
  res->ID = CODE_MessageVideo;
  res->refcnt = 1;
  if (!from.video_) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdConvertFromInternal (static_cast<const td::td_api::video &>(*from.video_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  res->is_secret_ = from.is_secret_;
  return res;
}
char *TdSerializeMessageVideo (struct TdMessageVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageVideo (struct TdMessageVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->video_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerMessageVideo (struct TdMessageVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageVideo");
  M->new_field ("ID");
  TdStackStorer (var->video_, M);
  M->new_field ("video_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_bool (var->is_secret_);
  M->new_field ("is_secret_");
}
struct TdMessageVideo *TdStackFetcherMessageVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageVideo ();
  res->ID = CODE_MessageVideo;
  res->refcnt = 1;
  M->get_field ("video_");
  if (M->is_nil ()) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdStackFetcherVideo (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("is_secret_");
  res->is_secret_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageExpiredVideo *TdCreateObjectMessageExpiredVideo (void) {
  auto var = new struct TdMessageExpiredVideo ();
  var->ID = CODE_MessageExpiredVideo;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageExpiredVideo> TdConvertToInternal (struct TdMessageExpiredVideo *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageExpiredVideo>();
}
struct TdMessageExpiredVideo *TdConvertFromInternal (const td::td_api::messageExpiredVideo &from) {
  auto res = new TdMessageExpiredVideo ();
  res->ID = CODE_MessageExpiredVideo;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageExpiredVideo (struct TdMessageExpiredVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageExpiredVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageExpiredVideo (struct TdMessageExpiredVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageExpiredVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageExpiredVideo (struct TdMessageExpiredVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageExpiredVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageExpiredVideo");
  M->new_field ("ID");
}
struct TdMessageExpiredVideo *TdStackFetcherMessageExpiredVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageExpiredVideo ();
  res->ID = CODE_MessageExpiredVideo;
  res->refcnt = 1;
  return res;
}
struct TdMessageVideoNote *TdCreateObjectMessageVideoNote (struct TdVideoNote *video_note_, int is_viewed_, int is_secret_) {
  auto var = new struct TdMessageVideoNote ();
  var->ID = CODE_MessageVideoNote;
  var->refcnt = 1;
  var->video_note_ = video_note_;
  var->is_viewed_ = is_viewed_;
  var->is_secret_ = is_secret_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageVideoNote> TdConvertToInternal (struct TdMessageVideoNote *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::videoNote> v0;
  v0 = TdConvertToInternal (var->video_note_);
  bool v100;
  v100 = var->is_viewed_ != 0;
  bool v200;
  v200 = var->is_secret_ != 0;
  return td::td_api::make_object<td::td_api::messageVideoNote>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdMessageVideoNote *TdConvertFromInternal (const td::td_api::messageVideoNote &from) {
  auto res = new TdMessageVideoNote ();
  res->ID = CODE_MessageVideoNote;
  res->refcnt = 1;
  if (!from.video_note_) {
    res->video_note_ = nullptr;
  } else {
    res->video_note_ = TdConvertFromInternal (static_cast<const td::td_api::videoNote &>(*from.video_note_));
  }
  res->is_viewed_ = from.is_viewed_;
  res->is_secret_ = from.is_secret_;
  return res;
}
char *TdSerializeMessageVideoNote (struct TdMessageVideoNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageVideoNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageVideoNote (struct TdMessageVideoNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageVideoNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->video_note_);
  delete var;
}
void TdStackStorerMessageVideoNote (struct TdMessageVideoNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageVideoNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageVideoNote");
  M->new_field ("ID");
  TdStackStorer (var->video_note_, M);
  M->new_field ("video_note_");
  M->pack_bool (var->is_viewed_);
  M->new_field ("is_viewed_");
  M->pack_bool (var->is_secret_);
  M->new_field ("is_secret_");
}
struct TdMessageVideoNote *TdStackFetcherMessageVideoNote (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageVideoNote ();
  res->ID = CODE_MessageVideoNote;
  res->refcnt = 1;
  M->get_field ("video_note_");
  if (M->is_nil ()) {
    res->video_note_ = nullptr;
  } else {
    res->video_note_ = TdStackFetcherVideoNote (M);
  }
  M->pop ();
  M->get_field ("is_viewed_");
  res->is_viewed_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_secret_");
  res->is_secret_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageVoiceNote *TdCreateObjectMessageVoiceNote (struct TdVoiceNote *voice_note_, struct TdFormattedText *caption_, int is_listened_) {
  auto var = new struct TdMessageVoiceNote ();
  var->ID = CODE_MessageVoiceNote;
  var->refcnt = 1;
  var->voice_note_ = voice_note_;
  var->caption_ = caption_;
  var->is_listened_ = is_listened_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageVoiceNote> TdConvertToInternal (struct TdMessageVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::voiceNote> v0;
  v0 = TdConvertToInternal (var->voice_note_);
  td::td_api::object_ptr<td::td_api::formattedText> v100;
  v100 = TdConvertToInternal (var->caption_);
  bool v200;
  v200 = var->is_listened_ != 0;
  return td::td_api::make_object<td::td_api::messageVoiceNote>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdMessageVoiceNote *TdConvertFromInternal (const td::td_api::messageVoiceNote &from) {
  auto res = new TdMessageVoiceNote ();
  res->ID = CODE_MessageVoiceNote;
  res->refcnt = 1;
  if (!from.voice_note_) {
    res->voice_note_ = nullptr;
  } else {
    res->voice_note_ = TdConvertFromInternal (static_cast<const td::td_api::voiceNote &>(*from.voice_note_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  res->is_listened_ = from.is_listened_;
  return res;
}
char *TdSerializeMessageVoiceNote (struct TdMessageVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageVoiceNote (struct TdMessageVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->voice_note_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerMessageVoiceNote (struct TdMessageVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageVoiceNote");
  M->new_field ("ID");
  TdStackStorer (var->voice_note_, M);
  M->new_field ("voice_note_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_bool (var->is_listened_);
  M->new_field ("is_listened_");
}
struct TdMessageVoiceNote *TdStackFetcherMessageVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageVoiceNote ();
  res->ID = CODE_MessageVoiceNote;
  res->refcnt = 1;
  M->get_field ("voice_note_");
  if (M->is_nil ()) {
    res->voice_note_ = nullptr;
  } else {
    res->voice_note_ = TdStackFetcherVoiceNote (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("is_listened_");
  res->is_listened_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageLocation *TdCreateObjectMessageLocation (struct TdLocation *location_, int live_period_, int expires_in_) {
  auto var = new struct TdMessageLocation ();
  var->ID = CODE_MessageLocation;
  var->refcnt = 1;
  var->location_ = location_;
  var->live_period_ = live_period_;
  var->expires_in_ = expires_in_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageLocation> TdConvertToInternal (struct TdMessageLocation *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::location> v0;
  v0 = TdConvertToInternal (var->location_);
  std::int32_t v100;
  v100 = var->live_period_;
  std::int32_t v200;
  v200 = var->expires_in_;
  return td::td_api::make_object<td::td_api::messageLocation>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdMessageLocation *TdConvertFromInternal (const td::td_api::messageLocation &from) {
  auto res = new TdMessageLocation ();
  res->ID = CODE_MessageLocation;
  res->refcnt = 1;
  if (!from.location_) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.location_));
  }
  res->live_period_ = from.live_period_;
  res->expires_in_ = from.expires_in_;
  return res;
}
char *TdSerializeMessageLocation (struct TdMessageLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageLocation (struct TdMessageLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->location_);
  delete var;
}
void TdStackStorerMessageLocation (struct TdMessageLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageLocation");
  M->new_field ("ID");
  TdStackStorer (var->location_, M);
  M->new_field ("location_");
  M->pack_long (var->live_period_);
  M->new_field ("live_period_");
  M->pack_long (var->expires_in_);
  M->new_field ("expires_in_");
}
struct TdMessageLocation *TdStackFetcherMessageLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageLocation ();
  res->ID = CODE_MessageLocation;
  res->refcnt = 1;
  M->get_field ("location_");
  if (M->is_nil ()) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("live_period_");
  res->live_period_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("expires_in_");
  res->expires_in_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageVenue *TdCreateObjectMessageVenue (struct TdVenue *venue_) {
  auto var = new struct TdMessageVenue ();
  var->ID = CODE_MessageVenue;
  var->refcnt = 1;
  var->venue_ = venue_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageVenue> TdConvertToInternal (struct TdMessageVenue *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::venue> v0;
  v0 = TdConvertToInternal (var->venue_);
  return td::td_api::make_object<td::td_api::messageVenue>(std::move (v0));
}
struct TdMessageVenue *TdConvertFromInternal (const td::td_api::messageVenue &from) {
  auto res = new TdMessageVenue ();
  res->ID = CODE_MessageVenue;
  res->refcnt = 1;
  if (!from.venue_) {
    res->venue_ = nullptr;
  } else {
    res->venue_ = TdConvertFromInternal (static_cast<const td::td_api::venue &>(*from.venue_));
  }
  return res;
}
char *TdSerializeMessageVenue (struct TdMessageVenue *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageVenue *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageVenue (struct TdMessageVenue *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageVenue *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->venue_);
  delete var;
}
void TdStackStorerMessageVenue (struct TdMessageVenue *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageVenue *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageVenue");
  M->new_field ("ID");
  TdStackStorer (var->venue_, M);
  M->new_field ("venue_");
}
struct TdMessageVenue *TdStackFetcherMessageVenue (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageVenue ();
  res->ID = CODE_MessageVenue;
  res->refcnt = 1;
  M->get_field ("venue_");
  if (M->is_nil ()) {
    res->venue_ = nullptr;
  } else {
    res->venue_ = TdStackFetcherVenue (M);
  }
  M->pop ();
  return res;
}
struct TdMessageContact *TdCreateObjectMessageContact (struct TdContact *contact_) {
  auto var = new struct TdMessageContact ();
  var->ID = CODE_MessageContact;
  var->refcnt = 1;
  var->contact_ = contact_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageContact> TdConvertToInternal (struct TdMessageContact *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::contact> v0;
  v0 = TdConvertToInternal (var->contact_);
  return td::td_api::make_object<td::td_api::messageContact>(std::move (v0));
}
struct TdMessageContact *TdConvertFromInternal (const td::td_api::messageContact &from) {
  auto res = new TdMessageContact ();
  res->ID = CODE_MessageContact;
  res->refcnt = 1;
  if (!from.contact_) {
    res->contact_ = nullptr;
  } else {
    res->contact_ = TdConvertFromInternal (static_cast<const td::td_api::contact &>(*from.contact_));
  }
  return res;
}
char *TdSerializeMessageContact (struct TdMessageContact *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageContact *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageContact (struct TdMessageContact *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageContact *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->contact_);
  delete var;
}
void TdStackStorerMessageContact (struct TdMessageContact *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageContact *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageContact");
  M->new_field ("ID");
  TdStackStorer (var->contact_, M);
  M->new_field ("contact_");
}
struct TdMessageContact *TdStackFetcherMessageContact (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageContact ();
  res->ID = CODE_MessageContact;
  res->refcnt = 1;
  M->get_field ("contact_");
  if (M->is_nil ()) {
    res->contact_ = nullptr;
  } else {
    res->contact_ = TdStackFetcherContact (M);
  }
  M->pop ();
  return res;
}
struct TdMessageGame *TdCreateObjectMessageGame (struct TdGame *game_) {
  auto var = new struct TdMessageGame ();
  var->ID = CODE_MessageGame;
  var->refcnt = 1;
  var->game_ = game_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageGame> TdConvertToInternal (struct TdMessageGame *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::game> v0;
  v0 = TdConvertToInternal (var->game_);
  return td::td_api::make_object<td::td_api::messageGame>(std::move (v0));
}
struct TdMessageGame *TdConvertFromInternal (const td::td_api::messageGame &from) {
  auto res = new TdMessageGame ();
  res->ID = CODE_MessageGame;
  res->refcnt = 1;
  if (!from.game_) {
    res->game_ = nullptr;
  } else {
    res->game_ = TdConvertFromInternal (static_cast<const td::td_api::game &>(*from.game_));
  }
  return res;
}
char *TdSerializeMessageGame (struct TdMessageGame *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageGame *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageGame (struct TdMessageGame *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageGame *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->game_);
  delete var;
}
void TdStackStorerMessageGame (struct TdMessageGame *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageGame *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageGame");
  M->new_field ("ID");
  TdStackStorer (var->game_, M);
  M->new_field ("game_");
}
struct TdMessageGame *TdStackFetcherMessageGame (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageGame ();
  res->ID = CODE_MessageGame;
  res->refcnt = 1;
  M->get_field ("game_");
  if (M->is_nil ()) {
    res->game_ = nullptr;
  } else {
    res->game_ = TdStackFetcherGame (M);
  }
  M->pop ();
  return res;
}
struct TdMessageInvoice *TdCreateObjectMessageInvoice (char *title_, char *description_, struct TdPhoto *photo_, char *currency_, long long total_amount_, char *start_parameter_, int is_test_, int need_shipping_address_, long long receipt_message_id_) {
  auto var = new struct TdMessageInvoice ();
  var->ID = CODE_MessageInvoice;
  var->refcnt = 1;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->photo_ = photo_;
  var->currency_ = (currency_) ? td::str_dup (td::Slice (currency_)) : nullptr;
  var->total_amount_ = total_amount_;
  var->start_parameter_ = (start_parameter_) ? td::str_dup (td::Slice (start_parameter_)) : nullptr;
  var->is_test_ = is_test_;
  var->need_shipping_address_ = need_shipping_address_;
  var->receipt_message_id_ = receipt_message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageInvoice> TdConvertToInternal (struct TdMessageInvoice *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->title_) ? var->title_: "";
  std::string v100;
  v100 = (var->description_) ? var->description_: "";
  td::td_api::object_ptr<td::td_api::photo> v200;
  v200 = TdConvertToInternal (var->photo_);
  std::string v300;
  v300 = (var->currency_) ? var->currency_: "";
  std::int64_t v400;
  v400 = var->total_amount_;
  std::string v500;
  v500 = (var->start_parameter_) ? var->start_parameter_: "";
  bool v600;
  v600 = var->is_test_ != 0;
  bool v700;
  v700 = var->need_shipping_address_ != 0;
  std::int64_t v800;
  v800 = var->receipt_message_id_;
  return td::td_api::make_object<td::td_api::messageInvoice>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdMessageInvoice *TdConvertFromInternal (const td::td_api::messageInvoice &from) {
  auto res = new TdMessageInvoice ();
  res->ID = CODE_MessageInvoice;
  res->refcnt = 1;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.photo_));
  }
  res->currency_ = (from.currency_.length ()) ? td::str_dup (from.currency_) : nullptr;
  res->total_amount_ = from.total_amount_;
  res->start_parameter_ = (from.start_parameter_.length ()) ? td::str_dup (from.start_parameter_) : nullptr;
  res->is_test_ = from.is_test_;
  res->need_shipping_address_ = from.need_shipping_address_;
  res->receipt_message_id_ = from.receipt_message_id_;
  return res;
}
char *TdSerializeMessageInvoice (struct TdMessageInvoice *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageInvoice *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageInvoice (struct TdMessageInvoice *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageInvoice *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  free (var->description_);
  TdDestroyObject (var->photo_);
  free (var->currency_);
  free (var->start_parameter_);
  delete var;
}
void TdStackStorerMessageInvoice (struct TdMessageInvoice *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageInvoice *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageInvoice");
  M->new_field ("ID");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  M->pack_string (var->currency_);
  M->new_field ("currency_");
  M->pack_long (var->total_amount_);
  M->new_field ("total_amount_");
  M->pack_string (var->start_parameter_);
  M->new_field ("start_parameter_");
  M->pack_bool (var->is_test_);
  M->new_field ("is_test_");
  M->pack_bool (var->need_shipping_address_);
  M->new_field ("need_shipping_address_");
  M->pack_long (var->receipt_message_id_);
  M->new_field ("receipt_message_id_");
}
struct TdMessageInvoice *TdStackFetcherMessageInvoice (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageInvoice ();
  res->ID = CODE_MessageInvoice;
  res->refcnt = 1;
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  M->get_field ("currency_");
  res->currency_ = M->get_string ();
  M->pop ();
  M->get_field ("total_amount_");
  res->total_amount_ = M->get_long ();
  M->pop ();
  M->get_field ("start_parameter_");
  res->start_parameter_ = M->get_string ();
  M->pop ();
  M->get_field ("is_test_");
  res->is_test_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_shipping_address_");
  res->need_shipping_address_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("receipt_message_id_");
  res->receipt_message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageCall *TdCreateObjectMessageCall (struct TdCallDiscardReason *discard_reason_, int duration_) {
  auto var = new struct TdMessageCall ();
  var->ID = CODE_MessageCall;
  var->refcnt = 1;
  var->discard_reason_ = discard_reason_;
  var->duration_ = duration_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageCall> TdConvertToInternal (struct TdMessageCall *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::CallDiscardReason> v0;
  v0 = TdConvertToInternal (var->discard_reason_);
  std::int32_t v100;
  v100 = var->duration_;
  return td::td_api::make_object<td::td_api::messageCall>(std::move (v0), std::move (v100));
}
struct TdMessageCall *TdConvertFromInternal (const td::td_api::messageCall &from) {
  auto res = new TdMessageCall ();
  res->ID = CODE_MessageCall;
  res->refcnt = 1;
  if (!from.discard_reason_) {
    res->discard_reason_ = nullptr;
  } else {
    res->discard_reason_ = TdConvertFromInternal (static_cast<const td::td_api::CallDiscardReason &>(*from.discard_reason_));
  }
  res->duration_ = from.duration_;
  return res;
}
char *TdSerializeMessageCall (struct TdMessageCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageCall (struct TdMessageCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->discard_reason_);
  delete var;
}
void TdStackStorerMessageCall (struct TdMessageCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageCall");
  M->new_field ("ID");
  TdStackStorer (var->discard_reason_, M);
  M->new_field ("discard_reason_");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
}
struct TdMessageCall *TdStackFetcherMessageCall (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageCall ();
  res->ID = CODE_MessageCall;
  res->refcnt = 1;
  M->get_field ("discard_reason_");
  if (M->is_nil ()) {
    res->discard_reason_ = nullptr;
  } else {
    res->discard_reason_ = TdStackFetcherCallDiscardReason (M);
  }
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageBasicGroupChatCreate *TdCreateObjectMessageBasicGroupChatCreate (char *title_, struct TdVectorInt *member_user_ids_) {
  auto var = new struct TdMessageBasicGroupChatCreate ();
  var->ID = CODE_MessageBasicGroupChatCreate;
  var->refcnt = 1;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->member_user_ids_ = member_user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageBasicGroupChatCreate> TdConvertToInternal (struct TdMessageBasicGroupChatCreate *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->title_) ? var->title_: "";
  std::vector<std::int32_t> v100;
  for (int i100 = 0; i100 < var->member_user_ids_->len; i100++) {
    std::int32_t v101;
    v101 = var->member_user_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::messageBasicGroupChatCreate>(std::move (v0), std::move (v100));
}
struct TdMessageBasicGroupChatCreate *TdConvertFromInternal (const td::td_api::messageBasicGroupChatCreate &from) {
  auto res = new TdMessageBasicGroupChatCreate ();
  res->ID = CODE_MessageBasicGroupChatCreate;
  res->refcnt = 1;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->member_user_ids_ = new TdVectorInt ();
  res->member_user_ids_->len = (int)from.member_user_ids_.size ();
  res->member_user_ids_->data = new int  [res->member_user_ids_->len];
  for (int i100 = 0; i100 < res->member_user_ids_->len; i100++) {
    res->member_user_ids_->data[i100] = from.member_user_ids_[i100];
  }
  return res;
}
char *TdSerializeMessageBasicGroupChatCreate (struct TdMessageBasicGroupChatCreate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageBasicGroupChatCreate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageBasicGroupChatCreate (struct TdMessageBasicGroupChatCreate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageBasicGroupChatCreate *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  for (int i100 = 0; i100 < var->member_user_ids_->len; i100++) {
  }
  delete[] var->member_user_ids_->data;
  delete var->member_user_ids_;
  delete var;
}
void TdStackStorerMessageBasicGroupChatCreate (struct TdMessageBasicGroupChatCreate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageBasicGroupChatCreate *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageBasicGroupChatCreate");
  M->new_field ("ID");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->new_array ();
  for (int i100 = 0; i100 < var->member_user_ids_->len; i100++) {
    M->pack_long (var->member_user_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("member_user_ids_");
}
struct TdMessageBasicGroupChatCreate *TdStackFetcherMessageBasicGroupChatCreate (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageBasicGroupChatCreate ();
  res->ID = CODE_MessageBasicGroupChatCreate;
  res->refcnt = 1;
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("member_user_ids_");
  res->member_user_ids_ = new TdVectorInt ();
  res->member_user_ids_->len = M->get_arr_size ();
  res->member_user_ids_->data = new int  [res->member_user_ids_->len];
  for (int i100 = 0; i100 < res->member_user_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->member_user_ids_->data[i100] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdMessageSupergroupChatCreate *TdCreateObjectMessageSupergroupChatCreate (char *title_) {
  auto var = new struct TdMessageSupergroupChatCreate ();
  var->ID = CODE_MessageSupergroupChatCreate;
  var->refcnt = 1;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::messageSupergroupChatCreate> TdConvertToInternal (struct TdMessageSupergroupChatCreate *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->title_) ? var->title_: "";
  return td::td_api::make_object<td::td_api::messageSupergroupChatCreate>(std::move (v0));
}
struct TdMessageSupergroupChatCreate *TdConvertFromInternal (const td::td_api::messageSupergroupChatCreate &from) {
  auto res = new TdMessageSupergroupChatCreate ();
  res->ID = CODE_MessageSupergroupChatCreate;
  res->refcnt = 1;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  return res;
}
char *TdSerializeMessageSupergroupChatCreate (struct TdMessageSupergroupChatCreate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageSupergroupChatCreate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageSupergroupChatCreate (struct TdMessageSupergroupChatCreate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageSupergroupChatCreate *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  delete var;
}
void TdStackStorerMessageSupergroupChatCreate (struct TdMessageSupergroupChatCreate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageSupergroupChatCreate *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageSupergroupChatCreate");
  M->new_field ("ID");
  M->pack_string (var->title_);
  M->new_field ("title_");
}
struct TdMessageSupergroupChatCreate *TdStackFetcherMessageSupergroupChatCreate (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageSupergroupChatCreate ();
  res->ID = CODE_MessageSupergroupChatCreate;
  res->refcnt = 1;
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdMessageChatChangeTitle *TdCreateObjectMessageChatChangeTitle (char *title_) {
  auto var = new struct TdMessageChatChangeTitle ();
  var->ID = CODE_MessageChatChangeTitle;
  var->refcnt = 1;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatChangeTitle> TdConvertToInternal (struct TdMessageChatChangeTitle *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->title_) ? var->title_: "";
  return td::td_api::make_object<td::td_api::messageChatChangeTitle>(std::move (v0));
}
struct TdMessageChatChangeTitle *TdConvertFromInternal (const td::td_api::messageChatChangeTitle &from) {
  auto res = new TdMessageChatChangeTitle ();
  res->ID = CODE_MessageChatChangeTitle;
  res->refcnt = 1;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  return res;
}
char *TdSerializeMessageChatChangeTitle (struct TdMessageChatChangeTitle *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatChangeTitle *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatChangeTitle (struct TdMessageChatChangeTitle *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatChangeTitle *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  delete var;
}
void TdStackStorerMessageChatChangeTitle (struct TdMessageChatChangeTitle *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatChangeTitle *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatChangeTitle");
  M->new_field ("ID");
  M->pack_string (var->title_);
  M->new_field ("title_");
}
struct TdMessageChatChangeTitle *TdStackFetcherMessageChatChangeTitle (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatChangeTitle ();
  res->ID = CODE_MessageChatChangeTitle;
  res->refcnt = 1;
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdMessageChatChangePhoto *TdCreateObjectMessageChatChangePhoto (struct TdPhoto *photo_) {
  auto var = new struct TdMessageChatChangePhoto ();
  var->ID = CODE_MessageChatChangePhoto;
  var->refcnt = 1;
  var->photo_ = photo_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatChangePhoto> TdConvertToInternal (struct TdMessageChatChangePhoto *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::photo> v0;
  v0 = TdConvertToInternal (var->photo_);
  return td::td_api::make_object<td::td_api::messageChatChangePhoto>(std::move (v0));
}
struct TdMessageChatChangePhoto *TdConvertFromInternal (const td::td_api::messageChatChangePhoto &from) {
  auto res = new TdMessageChatChangePhoto ();
  res->ID = CODE_MessageChatChangePhoto;
  res->refcnt = 1;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.photo_));
  }
  return res;
}
char *TdSerializeMessageChatChangePhoto (struct TdMessageChatChangePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatChangePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatChangePhoto (struct TdMessageChatChangePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatChangePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->photo_);
  delete var;
}
void TdStackStorerMessageChatChangePhoto (struct TdMessageChatChangePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatChangePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatChangePhoto");
  M->new_field ("ID");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
}
struct TdMessageChatChangePhoto *TdStackFetcherMessageChatChangePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatChangePhoto ();
  res->ID = CODE_MessageChatChangePhoto;
  res->refcnt = 1;
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  return res;
}
struct TdMessageChatDeletePhoto *TdCreateObjectMessageChatDeletePhoto (void) {
  auto var = new struct TdMessageChatDeletePhoto ();
  var->ID = CODE_MessageChatDeletePhoto;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatDeletePhoto> TdConvertToInternal (struct TdMessageChatDeletePhoto *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageChatDeletePhoto>();
}
struct TdMessageChatDeletePhoto *TdConvertFromInternal (const td::td_api::messageChatDeletePhoto &from) {
  auto res = new TdMessageChatDeletePhoto ();
  res->ID = CODE_MessageChatDeletePhoto;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageChatDeletePhoto (struct TdMessageChatDeletePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatDeletePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatDeletePhoto (struct TdMessageChatDeletePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatDeletePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageChatDeletePhoto (struct TdMessageChatDeletePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatDeletePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatDeletePhoto");
  M->new_field ("ID");
}
struct TdMessageChatDeletePhoto *TdStackFetcherMessageChatDeletePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatDeletePhoto ();
  res->ID = CODE_MessageChatDeletePhoto;
  res->refcnt = 1;
  return res;
}
struct TdMessageChatAddMembers *TdCreateObjectMessageChatAddMembers (struct TdVectorInt *member_user_ids_) {
  auto var = new struct TdMessageChatAddMembers ();
  var->ID = CODE_MessageChatAddMembers;
  var->refcnt = 1;
  var->member_user_ids_ = member_user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatAddMembers> TdConvertToInternal (struct TdMessageChatAddMembers *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->member_user_ids_->len; i0++) {
    std::int32_t v1;
    v1 = var->member_user_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::messageChatAddMembers>(std::move (v0));
}
struct TdMessageChatAddMembers *TdConvertFromInternal (const td::td_api::messageChatAddMembers &from) {
  auto res = new TdMessageChatAddMembers ();
  res->ID = CODE_MessageChatAddMembers;
  res->refcnt = 1;
  res->member_user_ids_ = new TdVectorInt ();
  res->member_user_ids_->len = (int)from.member_user_ids_.size ();
  res->member_user_ids_->data = new int  [res->member_user_ids_->len];
  for (int i0 = 0; i0 < res->member_user_ids_->len; i0++) {
    res->member_user_ids_->data[i0] = from.member_user_ids_[i0];
  }
  return res;
}
char *TdSerializeMessageChatAddMembers (struct TdMessageChatAddMembers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatAddMembers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatAddMembers (struct TdMessageChatAddMembers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatAddMembers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->member_user_ids_->len; i0++) {
  }
  delete[] var->member_user_ids_->data;
  delete var->member_user_ids_;
  delete var;
}
void TdStackStorerMessageChatAddMembers (struct TdMessageChatAddMembers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatAddMembers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatAddMembers");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->member_user_ids_->len; i0++) {
    M->pack_long (var->member_user_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("member_user_ids_");
}
struct TdMessageChatAddMembers *TdStackFetcherMessageChatAddMembers (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatAddMembers ();
  res->ID = CODE_MessageChatAddMembers;
  res->refcnt = 1;
  M->get_field ("member_user_ids_");
  res->member_user_ids_ = new TdVectorInt ();
  res->member_user_ids_->len = M->get_arr_size ();
  res->member_user_ids_->data = new int  [res->member_user_ids_->len];
  for (int i0 = 0; i0 < res->member_user_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->member_user_ids_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdMessageChatJoinByLink *TdCreateObjectMessageChatJoinByLink (void) {
  auto var = new struct TdMessageChatJoinByLink ();
  var->ID = CODE_MessageChatJoinByLink;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatJoinByLink> TdConvertToInternal (struct TdMessageChatJoinByLink *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageChatJoinByLink>();
}
struct TdMessageChatJoinByLink *TdConvertFromInternal (const td::td_api::messageChatJoinByLink &from) {
  auto res = new TdMessageChatJoinByLink ();
  res->ID = CODE_MessageChatJoinByLink;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageChatJoinByLink (struct TdMessageChatJoinByLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatJoinByLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatJoinByLink (struct TdMessageChatJoinByLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatJoinByLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageChatJoinByLink (struct TdMessageChatJoinByLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatJoinByLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatJoinByLink");
  M->new_field ("ID");
}
struct TdMessageChatJoinByLink *TdStackFetcherMessageChatJoinByLink (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatJoinByLink ();
  res->ID = CODE_MessageChatJoinByLink;
  res->refcnt = 1;
  return res;
}
struct TdMessageChatDeleteMember *TdCreateObjectMessageChatDeleteMember (int user_id_) {
  auto var = new struct TdMessageChatDeleteMember ();
  var->ID = CODE_MessageChatDeleteMember;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatDeleteMember> TdConvertToInternal (struct TdMessageChatDeleteMember *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::messageChatDeleteMember>(std::move (v0));
}
struct TdMessageChatDeleteMember *TdConvertFromInternal (const td::td_api::messageChatDeleteMember &from) {
  auto res = new TdMessageChatDeleteMember ();
  res->ID = CODE_MessageChatDeleteMember;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeMessageChatDeleteMember (struct TdMessageChatDeleteMember *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatDeleteMember *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatDeleteMember (struct TdMessageChatDeleteMember *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatDeleteMember *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageChatDeleteMember (struct TdMessageChatDeleteMember *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatDeleteMember *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatDeleteMember");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdMessageChatDeleteMember *TdStackFetcherMessageChatDeleteMember (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatDeleteMember ();
  res->ID = CODE_MessageChatDeleteMember;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageChatUpgradeTo *TdCreateObjectMessageChatUpgradeTo (int supergroup_id_) {
  auto var = new struct TdMessageChatUpgradeTo ();
  var->ID = CODE_MessageChatUpgradeTo;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatUpgradeTo> TdConvertToInternal (struct TdMessageChatUpgradeTo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  return td::td_api::make_object<td::td_api::messageChatUpgradeTo>(std::move (v0));
}
struct TdMessageChatUpgradeTo *TdConvertFromInternal (const td::td_api::messageChatUpgradeTo &from) {
  auto res = new TdMessageChatUpgradeTo ();
  res->ID = CODE_MessageChatUpgradeTo;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  return res;
}
char *TdSerializeMessageChatUpgradeTo (struct TdMessageChatUpgradeTo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatUpgradeTo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatUpgradeTo (struct TdMessageChatUpgradeTo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatUpgradeTo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageChatUpgradeTo (struct TdMessageChatUpgradeTo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatUpgradeTo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatUpgradeTo");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
}
struct TdMessageChatUpgradeTo *TdStackFetcherMessageChatUpgradeTo (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatUpgradeTo ();
  res->ID = CODE_MessageChatUpgradeTo;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageChatUpgradeFrom *TdCreateObjectMessageChatUpgradeFrom (char *title_, int basic_group_id_) {
  auto var = new struct TdMessageChatUpgradeFrom ();
  var->ID = CODE_MessageChatUpgradeFrom;
  var->refcnt = 1;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->basic_group_id_ = basic_group_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatUpgradeFrom> TdConvertToInternal (struct TdMessageChatUpgradeFrom *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->title_) ? var->title_: "";
  std::int32_t v100;
  v100 = var->basic_group_id_;
  return td::td_api::make_object<td::td_api::messageChatUpgradeFrom>(std::move (v0), std::move (v100));
}
struct TdMessageChatUpgradeFrom *TdConvertFromInternal (const td::td_api::messageChatUpgradeFrom &from) {
  auto res = new TdMessageChatUpgradeFrom ();
  res->ID = CODE_MessageChatUpgradeFrom;
  res->refcnt = 1;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->basic_group_id_ = from.basic_group_id_;
  return res;
}
char *TdSerializeMessageChatUpgradeFrom (struct TdMessageChatUpgradeFrom *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatUpgradeFrom *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatUpgradeFrom (struct TdMessageChatUpgradeFrom *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatUpgradeFrom *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  delete var;
}
void TdStackStorerMessageChatUpgradeFrom (struct TdMessageChatUpgradeFrom *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatUpgradeFrom *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatUpgradeFrom");
  M->new_field ("ID");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_long (var->basic_group_id_);
  M->new_field ("basic_group_id_");
}
struct TdMessageChatUpgradeFrom *TdStackFetcherMessageChatUpgradeFrom (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatUpgradeFrom ();
  res->ID = CODE_MessageChatUpgradeFrom;
  res->refcnt = 1;
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("basic_group_id_");
  res->basic_group_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessagePinMessage *TdCreateObjectMessagePinMessage (long long message_id_) {
  auto var = new struct TdMessagePinMessage ();
  var->ID = CODE_MessagePinMessage;
  var->refcnt = 1;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::messagePinMessage> TdConvertToInternal (struct TdMessagePinMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->message_id_;
  return td::td_api::make_object<td::td_api::messagePinMessage>(std::move (v0));
}
struct TdMessagePinMessage *TdConvertFromInternal (const td::td_api::messagePinMessage &from) {
  auto res = new TdMessagePinMessage ();
  res->ID = CODE_MessagePinMessage;
  res->refcnt = 1;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeMessagePinMessage (struct TdMessagePinMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessagePinMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessagePinMessage (struct TdMessagePinMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessagePinMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessagePinMessage (struct TdMessagePinMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessagePinMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessagePinMessage");
  M->new_field ("ID");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdMessagePinMessage *TdStackFetcherMessagePinMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdMessagePinMessage ();
  res->ID = CODE_MessagePinMessage;
  res->refcnt = 1;
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageScreenshotTaken *TdCreateObjectMessageScreenshotTaken (void) {
  auto var = new struct TdMessageScreenshotTaken ();
  var->ID = CODE_MessageScreenshotTaken;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageScreenshotTaken> TdConvertToInternal (struct TdMessageScreenshotTaken *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageScreenshotTaken>();
}
struct TdMessageScreenshotTaken *TdConvertFromInternal (const td::td_api::messageScreenshotTaken &from) {
  auto res = new TdMessageScreenshotTaken ();
  res->ID = CODE_MessageScreenshotTaken;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageScreenshotTaken (struct TdMessageScreenshotTaken *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageScreenshotTaken *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageScreenshotTaken (struct TdMessageScreenshotTaken *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageScreenshotTaken *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageScreenshotTaken (struct TdMessageScreenshotTaken *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageScreenshotTaken *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageScreenshotTaken");
  M->new_field ("ID");
}
struct TdMessageScreenshotTaken *TdStackFetcherMessageScreenshotTaken (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageScreenshotTaken ();
  res->ID = CODE_MessageScreenshotTaken;
  res->refcnt = 1;
  return res;
}
struct TdMessageChatSetTtl *TdCreateObjectMessageChatSetTtl (int ttl_) {
  auto var = new struct TdMessageChatSetTtl ();
  var->ID = CODE_MessageChatSetTtl;
  var->refcnt = 1;
  var->ttl_ = ttl_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageChatSetTtl> TdConvertToInternal (struct TdMessageChatSetTtl *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->ttl_;
  return td::td_api::make_object<td::td_api::messageChatSetTtl>(std::move (v0));
}
struct TdMessageChatSetTtl *TdConvertFromInternal (const td::td_api::messageChatSetTtl &from) {
  auto res = new TdMessageChatSetTtl ();
  res->ID = CODE_MessageChatSetTtl;
  res->refcnt = 1;
  res->ttl_ = from.ttl_;
  return res;
}
char *TdSerializeMessageChatSetTtl (struct TdMessageChatSetTtl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageChatSetTtl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageChatSetTtl (struct TdMessageChatSetTtl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageChatSetTtl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageChatSetTtl (struct TdMessageChatSetTtl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageChatSetTtl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageChatSetTtl");
  M->new_field ("ID");
  M->pack_long (var->ttl_);
  M->new_field ("ttl_");
}
struct TdMessageChatSetTtl *TdStackFetcherMessageChatSetTtl (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageChatSetTtl ();
  res->ID = CODE_MessageChatSetTtl;
  res->refcnt = 1;
  M->get_field ("ttl_");
  res->ttl_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageCustomServiceAction *TdCreateObjectMessageCustomServiceAction (char *text_) {
  auto var = new struct TdMessageCustomServiceAction ();
  var->ID = CODE_MessageCustomServiceAction;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::messageCustomServiceAction> TdConvertToInternal (struct TdMessageCustomServiceAction *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  return td::td_api::make_object<td::td_api::messageCustomServiceAction>(std::move (v0));
}
struct TdMessageCustomServiceAction *TdConvertFromInternal (const td::td_api::messageCustomServiceAction &from) {
  auto res = new TdMessageCustomServiceAction ();
  res->ID = CODE_MessageCustomServiceAction;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  return res;
}
char *TdSerializeMessageCustomServiceAction (struct TdMessageCustomServiceAction *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageCustomServiceAction *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageCustomServiceAction (struct TdMessageCustomServiceAction *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageCustomServiceAction *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  delete var;
}
void TdStackStorerMessageCustomServiceAction (struct TdMessageCustomServiceAction *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageCustomServiceAction *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageCustomServiceAction");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
}
struct TdMessageCustomServiceAction *TdStackFetcherMessageCustomServiceAction (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageCustomServiceAction ();
  res->ID = CODE_MessageCustomServiceAction;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdMessageGameScore *TdCreateObjectMessageGameScore (long long game_message_id_, long long game_id_, int score_) {
  auto var = new struct TdMessageGameScore ();
  var->ID = CODE_MessageGameScore;
  var->refcnt = 1;
  var->game_message_id_ = game_message_id_;
  var->game_id_ = game_id_;
  var->score_ = score_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageGameScore> TdConvertToInternal (struct TdMessageGameScore *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->game_message_id_;
  std::int64_t v100;
  v100 = var->game_id_;
  std::int32_t v200;
  v200 = var->score_;
  return td::td_api::make_object<td::td_api::messageGameScore>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdMessageGameScore *TdConvertFromInternal (const td::td_api::messageGameScore &from) {
  auto res = new TdMessageGameScore ();
  res->ID = CODE_MessageGameScore;
  res->refcnt = 1;
  res->game_message_id_ = from.game_message_id_;
  res->game_id_ = from.game_id_;
  res->score_ = from.score_;
  return res;
}
char *TdSerializeMessageGameScore (struct TdMessageGameScore *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageGameScore *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageGameScore (struct TdMessageGameScore *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageGameScore *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageGameScore (struct TdMessageGameScore *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageGameScore *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageGameScore");
  M->new_field ("ID");
  M->pack_long (var->game_message_id_);
  M->new_field ("game_message_id_");
  M->pack_long (var->game_id_);
  M->new_field ("game_id_");
  M->pack_long (var->score_);
  M->new_field ("score_");
}
struct TdMessageGameScore *TdStackFetcherMessageGameScore (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageGameScore ();
  res->ID = CODE_MessageGameScore;
  res->refcnt = 1;
  M->get_field ("game_message_id_");
  res->game_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("game_id_");
  res->game_id_ = M->get_long ();
  M->pop ();
  M->get_field ("score_");
  res->score_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdMessagePaymentSuccessful *TdCreateObjectMessagePaymentSuccessful (long long invoice_message_id_, char *currency_, long long total_amount_) {
  auto var = new struct TdMessagePaymentSuccessful ();
  var->ID = CODE_MessagePaymentSuccessful;
  var->refcnt = 1;
  var->invoice_message_id_ = invoice_message_id_;
  var->currency_ = (currency_) ? td::str_dup (td::Slice (currency_)) : nullptr;
  var->total_amount_ = total_amount_;
  return var;
}
td::td_api::object_ptr<td::td_api::messagePaymentSuccessful> TdConvertToInternal (struct TdMessagePaymentSuccessful *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->invoice_message_id_;
  std::string v100;
  v100 = (var->currency_) ? var->currency_: "";
  std::int64_t v200;
  v200 = var->total_amount_;
  return td::td_api::make_object<td::td_api::messagePaymentSuccessful>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdMessagePaymentSuccessful *TdConvertFromInternal (const td::td_api::messagePaymentSuccessful &from) {
  auto res = new TdMessagePaymentSuccessful ();
  res->ID = CODE_MessagePaymentSuccessful;
  res->refcnt = 1;
  res->invoice_message_id_ = from.invoice_message_id_;
  res->currency_ = (from.currency_.length ()) ? td::str_dup (from.currency_) : nullptr;
  res->total_amount_ = from.total_amount_;
  return res;
}
char *TdSerializeMessagePaymentSuccessful (struct TdMessagePaymentSuccessful *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessagePaymentSuccessful *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessagePaymentSuccessful (struct TdMessagePaymentSuccessful *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessagePaymentSuccessful *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->currency_);
  delete var;
}
void TdStackStorerMessagePaymentSuccessful (struct TdMessagePaymentSuccessful *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessagePaymentSuccessful *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessagePaymentSuccessful");
  M->new_field ("ID");
  M->pack_long (var->invoice_message_id_);
  M->new_field ("invoice_message_id_");
  M->pack_string (var->currency_);
  M->new_field ("currency_");
  M->pack_long (var->total_amount_);
  M->new_field ("total_amount_");
}
struct TdMessagePaymentSuccessful *TdStackFetcherMessagePaymentSuccessful (struct TdStackFetcherMethods *M) {
  auto res = new TdMessagePaymentSuccessful ();
  res->ID = CODE_MessagePaymentSuccessful;
  res->refcnt = 1;
  M->get_field ("invoice_message_id_");
  res->invoice_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("currency_");
  res->currency_ = M->get_string ();
  M->pop ();
  M->get_field ("total_amount_");
  res->total_amount_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdMessagePaymentSuccessfulBot *TdCreateObjectMessagePaymentSuccessfulBot (long long invoice_message_id_, char *currency_, long long total_amount_, struct TdBytes invoice_payload_, char *shipping_option_id_, struct TdOrderInfo *order_info_, char *telegram_payment_charge_id_, char *provider_payment_charge_id_) {
  auto var = new struct TdMessagePaymentSuccessfulBot ();
  var->ID = CODE_MessagePaymentSuccessfulBot;
  var->refcnt = 1;
  var->invoice_message_id_ = invoice_message_id_;
  var->currency_ = (currency_) ? td::str_dup (td::Slice (currency_)) : nullptr;
  var->total_amount_ = total_amount_;
  var->invoice_payload_ = invoice_payload_;
  var->shipping_option_id_ = (shipping_option_id_) ? td::str_dup (td::Slice (shipping_option_id_)) : nullptr;
  var->order_info_ = order_info_;
  var->telegram_payment_charge_id_ = (telegram_payment_charge_id_) ? td::str_dup (td::Slice (telegram_payment_charge_id_)) : nullptr;
  var->provider_payment_charge_id_ = (provider_payment_charge_id_) ? td::str_dup (td::Slice (provider_payment_charge_id_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::messagePaymentSuccessfulBot> TdConvertToInternal (struct TdMessagePaymentSuccessfulBot *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->invoice_message_id_;
  std::string v100;
  v100 = (var->currency_) ? var->currency_: "";
  std::int64_t v200;
  v200 = var->total_amount_;
  std::string v300;
  v300 = std::string ((char *)var->invoice_payload_.data, var->invoice_payload_.len);
  std::string v400;
  v400 = (var->shipping_option_id_) ? var->shipping_option_id_: "";
  td::td_api::object_ptr<td::td_api::orderInfo> v500;
  v500 = TdConvertToInternal (var->order_info_);
  std::string v600;
  v600 = (var->telegram_payment_charge_id_) ? var->telegram_payment_charge_id_: "";
  std::string v700;
  v700 = (var->provider_payment_charge_id_) ? var->provider_payment_charge_id_: "";
  return td::td_api::make_object<td::td_api::messagePaymentSuccessfulBot>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700));
}
struct TdMessagePaymentSuccessfulBot *TdConvertFromInternal (const td::td_api::messagePaymentSuccessfulBot &from) {
  auto res = new TdMessagePaymentSuccessfulBot ();
  res->ID = CODE_MessagePaymentSuccessfulBot;
  res->refcnt = 1;
  res->invoice_message_id_ = from.invoice_message_id_;
  res->currency_ = (from.currency_.length ()) ? td::str_dup (from.currency_) : nullptr;
  res->total_amount_ = from.total_amount_;
  res->invoice_payload_.len = (int)from.invoice_payload_.length ();
  if (res->invoice_payload_.len) {
    res->invoice_payload_.data = new unsigned char[res->invoice_payload_.len];
    memcpy (res->invoice_payload_.data, from.invoice_payload_.c_str (), res->invoice_payload_.len);
  } else {
    res->invoice_payload_.data = nullptr;
  }
  res->shipping_option_id_ = (from.shipping_option_id_.length ()) ? td::str_dup (from.shipping_option_id_) : nullptr;
  if (!from.order_info_) {
    res->order_info_ = nullptr;
  } else {
    res->order_info_ = TdConvertFromInternal (static_cast<const td::td_api::orderInfo &>(*from.order_info_));
  }
  res->telegram_payment_charge_id_ = (from.telegram_payment_charge_id_.length ()) ? td::str_dup (from.telegram_payment_charge_id_) : nullptr;
  res->provider_payment_charge_id_ = (from.provider_payment_charge_id_.length ()) ? td::str_dup (from.provider_payment_charge_id_) : nullptr;
  return res;
}
char *TdSerializeMessagePaymentSuccessfulBot (struct TdMessagePaymentSuccessfulBot *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessagePaymentSuccessfulBot *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessagePaymentSuccessfulBot (struct TdMessagePaymentSuccessfulBot *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessagePaymentSuccessfulBot *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->currency_);
  delete[]var->invoice_payload_.data;
  free (var->shipping_option_id_);
  TdDestroyObject (var->order_info_);
  free (var->telegram_payment_charge_id_);
  free (var->provider_payment_charge_id_);
  delete var;
}
void TdStackStorerMessagePaymentSuccessfulBot (struct TdMessagePaymentSuccessfulBot *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessagePaymentSuccessfulBot *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessagePaymentSuccessfulBot");
  M->new_field ("ID");
  M->pack_long (var->invoice_message_id_);
  M->new_field ("invoice_message_id_");
  M->pack_string (var->currency_);
  M->new_field ("currency_");
  M->pack_long (var->total_amount_);
  M->new_field ("total_amount_");
  M->pack_bytes (var->invoice_payload_.data, var->invoice_payload_.len);
  M->new_field ("invoice_payload_");
  M->pack_string (var->shipping_option_id_);
  M->new_field ("shipping_option_id_");
  TdStackStorer (var->order_info_, M);
  M->new_field ("order_info_");
  M->pack_string (var->telegram_payment_charge_id_);
  M->new_field ("telegram_payment_charge_id_");
  M->pack_string (var->provider_payment_charge_id_);
  M->new_field ("provider_payment_charge_id_");
}
struct TdMessagePaymentSuccessfulBot *TdStackFetcherMessagePaymentSuccessfulBot (struct TdStackFetcherMethods *M) {
  auto res = new TdMessagePaymentSuccessfulBot ();
  res->ID = CODE_MessagePaymentSuccessfulBot;
  res->refcnt = 1;
  M->get_field ("invoice_message_id_");
  res->invoice_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("currency_");
  res->currency_ = M->get_string ();
  M->pop ();
  M->get_field ("total_amount_");
  res->total_amount_ = M->get_long ();
  M->pop ();
  M->get_field ("invoice_payload_");
  res->invoice_payload_.data = M->get_bytes (&res->invoice_payload_.len);
  M->pop ();
  M->get_field ("shipping_option_id_");
  res->shipping_option_id_ = M->get_string ();
  M->pop ();
  M->get_field ("order_info_");
  if (M->is_nil ()) {
    res->order_info_ = nullptr;
  } else {
    res->order_info_ = TdStackFetcherOrderInfo (M);
  }
  M->pop ();
  M->get_field ("telegram_payment_charge_id_");
  res->telegram_payment_charge_id_ = M->get_string ();
  M->pop ();
  M->get_field ("provider_payment_charge_id_");
  res->provider_payment_charge_id_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdMessageContactRegistered *TdCreateObjectMessageContactRegistered (void) {
  auto var = new struct TdMessageContactRegistered ();
  var->ID = CODE_MessageContactRegistered;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageContactRegistered> TdConvertToInternal (struct TdMessageContactRegistered *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageContactRegistered>();
}
struct TdMessageContactRegistered *TdConvertFromInternal (const td::td_api::messageContactRegistered &from) {
  auto res = new TdMessageContactRegistered ();
  res->ID = CODE_MessageContactRegistered;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageContactRegistered (struct TdMessageContactRegistered *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageContactRegistered *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageContactRegistered (struct TdMessageContactRegistered *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageContactRegistered *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageContactRegistered (struct TdMessageContactRegistered *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageContactRegistered *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageContactRegistered");
  M->new_field ("ID");
}
struct TdMessageContactRegistered *TdStackFetcherMessageContactRegistered (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageContactRegistered ();
  res->ID = CODE_MessageContactRegistered;
  res->refcnt = 1;
  return res;
}
struct TdMessageWebsiteConnected *TdCreateObjectMessageWebsiteConnected (char *domain_name_) {
  auto var = new struct TdMessageWebsiteConnected ();
  var->ID = CODE_MessageWebsiteConnected;
  var->refcnt = 1;
  var->domain_name_ = (domain_name_) ? td::str_dup (td::Slice (domain_name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::messageWebsiteConnected> TdConvertToInternal (struct TdMessageWebsiteConnected *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->domain_name_) ? var->domain_name_: "";
  return td::td_api::make_object<td::td_api::messageWebsiteConnected>(std::move (v0));
}
struct TdMessageWebsiteConnected *TdConvertFromInternal (const td::td_api::messageWebsiteConnected &from) {
  auto res = new TdMessageWebsiteConnected ();
  res->ID = CODE_MessageWebsiteConnected;
  res->refcnt = 1;
  res->domain_name_ = (from.domain_name_.length ()) ? td::str_dup (from.domain_name_) : nullptr;
  return res;
}
char *TdSerializeMessageWebsiteConnected (struct TdMessageWebsiteConnected *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageWebsiteConnected *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageWebsiteConnected (struct TdMessageWebsiteConnected *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageWebsiteConnected *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->domain_name_);
  delete var;
}
void TdStackStorerMessageWebsiteConnected (struct TdMessageWebsiteConnected *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageWebsiteConnected *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageWebsiteConnected");
  M->new_field ("ID");
  M->pack_string (var->domain_name_);
  M->new_field ("domain_name_");
}
struct TdMessageWebsiteConnected *TdStackFetcherMessageWebsiteConnected (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageWebsiteConnected ();
  res->ID = CODE_MessageWebsiteConnected;
  res->refcnt = 1;
  M->get_field ("domain_name_");
  res->domain_name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdMessagePassportDataSent *TdCreateObjectMessagePassportDataSent (struct TdVectorPassportElementType *types_) {
  auto var = new struct TdMessagePassportDataSent ();
  var->ID = CODE_MessagePassportDataSent;
  var->refcnt = 1;
  var->types_ = types_;
  return var;
}
td::td_api::object_ptr<td::td_api::messagePassportDataSent> TdConvertToInternal (struct TdMessagePassportDataSent *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::PassportElementType>> v0;
  for (int i0 = 0; i0 < var->types_->len; i0++) {
    td::td_api::object_ptr<td::td_api::PassportElementType> v1;
    v1 = TdConvertToInternal (var->types_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::messagePassportDataSent>(std::move (v0));
}
struct TdMessagePassportDataSent *TdConvertFromInternal (const td::td_api::messagePassportDataSent &from) {
  auto res = new TdMessagePassportDataSent ();
  res->ID = CODE_MessagePassportDataSent;
  res->refcnt = 1;
  res->types_ = new TdVectorPassportElementType ();
  res->types_->len = (int)from.types_.size ();
  res->types_->data = new struct TdPassportElementType * [res->types_->len];
  for (int i0 = 0; i0 < res->types_->len; i0++) {
    if (!from.types_[i0]) {
      res->types_->data[i0] = nullptr;
    } else {
      res->types_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::PassportElementType &>(*from.types_[i0]));
    }
  }
  return res;
}
char *TdSerializeMessagePassportDataSent (struct TdMessagePassportDataSent *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessagePassportDataSent *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessagePassportDataSent (struct TdMessagePassportDataSent *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessagePassportDataSent *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->types_->len; i0++) {
    TdDestroyObject (var->types_->data[i0]);
  }
  delete[] var->types_->data;
  delete var->types_;
  delete var;
}
void TdStackStorerMessagePassportDataSent (struct TdMessagePassportDataSent *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessagePassportDataSent *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessagePassportDataSent");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->types_->len; i0++) {
    TdStackStorer (var->types_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("types_");
}
struct TdMessagePassportDataSent *TdStackFetcherMessagePassportDataSent (struct TdStackFetcherMethods *M) {
  auto res = new TdMessagePassportDataSent ();
  res->ID = CODE_MessagePassportDataSent;
  res->refcnt = 1;
  M->get_field ("types_");
  res->types_ = new TdVectorPassportElementType ();
  res->types_->len = M->get_arr_size ();
  res->types_->data = new struct TdPassportElementType * [res->types_->len];
  for (int i0 = 0; i0 < res->types_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->types_->data[i0] = nullptr;
    } else {
      res->types_->data[i0] = TdStackFetcherPassportElementType (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdMessagePassportDataReceived *TdCreateObjectMessagePassportDataReceived (struct TdVectorEncryptedPassportElement *elements_, struct TdEncryptedCredentials *credentials_) {
  auto var = new struct TdMessagePassportDataReceived ();
  var->ID = CODE_MessagePassportDataReceived;
  var->refcnt = 1;
  var->elements_ = elements_;
  var->credentials_ = credentials_;
  return var;
}
td::td_api::object_ptr<td::td_api::messagePassportDataReceived> TdConvertToInternal (struct TdMessagePassportDataReceived *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::encryptedPassportElement>> v0;
  for (int i0 = 0; i0 < var->elements_->len; i0++) {
    td::td_api::object_ptr<td::td_api::encryptedPassportElement> v1;
    v1 = TdConvertToInternal (var->elements_->data[i0]);
    v0.push_back (std::move (v1));
  }
  td::td_api::object_ptr<td::td_api::encryptedCredentials> v100;
  v100 = TdConvertToInternal (var->credentials_);
  return td::td_api::make_object<td::td_api::messagePassportDataReceived>(std::move (v0), std::move (v100));
}
struct TdMessagePassportDataReceived *TdConvertFromInternal (const td::td_api::messagePassportDataReceived &from) {
  auto res = new TdMessagePassportDataReceived ();
  res->ID = CODE_MessagePassportDataReceived;
  res->refcnt = 1;
  res->elements_ = new TdVectorEncryptedPassportElement ();
  res->elements_->len = (int)from.elements_.size ();
  res->elements_->data = new struct TdEncryptedPassportElement * [res->elements_->len];
  for (int i0 = 0; i0 < res->elements_->len; i0++) {
    if (!from.elements_[i0]) {
      res->elements_->data[i0] = nullptr;
    } else {
      res->elements_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::encryptedPassportElement &>(*from.elements_[i0]));
    }
  }
  if (!from.credentials_) {
    res->credentials_ = nullptr;
  } else {
    res->credentials_ = TdConvertFromInternal (static_cast<const td::td_api::encryptedCredentials &>(*from.credentials_));
  }
  return res;
}
char *TdSerializeMessagePassportDataReceived (struct TdMessagePassportDataReceived *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessagePassportDataReceived *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessagePassportDataReceived (struct TdMessagePassportDataReceived *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessagePassportDataReceived *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->elements_->len; i0++) {
    TdDestroyObject (var->elements_->data[i0]);
  }
  delete[] var->elements_->data;
  delete var->elements_;
  TdDestroyObject (var->credentials_);
  delete var;
}
void TdStackStorerMessagePassportDataReceived (struct TdMessagePassportDataReceived *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessagePassportDataReceived *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessagePassportDataReceived");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->elements_->len; i0++) {
    TdStackStorer (var->elements_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("elements_");
  TdStackStorer (var->credentials_, M);
  M->new_field ("credentials_");
}
struct TdMessagePassportDataReceived *TdStackFetcherMessagePassportDataReceived (struct TdStackFetcherMethods *M) {
  auto res = new TdMessagePassportDataReceived ();
  res->ID = CODE_MessagePassportDataReceived;
  res->refcnt = 1;
  M->get_field ("elements_");
  res->elements_ = new TdVectorEncryptedPassportElement ();
  res->elements_->len = M->get_arr_size ();
  res->elements_->data = new struct TdEncryptedPassportElement * [res->elements_->len];
  for (int i0 = 0; i0 < res->elements_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->elements_->data[i0] = nullptr;
    } else {
      res->elements_->data[i0] = TdStackFetcherEncryptedPassportElement (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("credentials_");
  if (M->is_nil ()) {
    res->credentials_ = nullptr;
  } else {
    res->credentials_ = TdStackFetcherEncryptedCredentials (M);
  }
  M->pop ();
  return res;
}
struct TdMessageUnsupported *TdCreateObjectMessageUnsupported (void) {
  auto var = new struct TdMessageUnsupported ();
  var->ID = CODE_MessageUnsupported;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageUnsupported> TdConvertToInternal (struct TdMessageUnsupported *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageUnsupported>();
}
struct TdMessageUnsupported *TdConvertFromInternal (const td::td_api::messageUnsupported &from) {
  auto res = new TdMessageUnsupported ();
  res->ID = CODE_MessageUnsupported;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageUnsupported (struct TdMessageUnsupported *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageUnsupported *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageUnsupported (struct TdMessageUnsupported *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageUnsupported *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageUnsupported (struct TdMessageUnsupported *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageUnsupported *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageUnsupported");
  M->new_field ("ID");
}
struct TdMessageUnsupported *TdStackFetcherMessageUnsupported (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageUnsupported ();
  res->ID = CODE_MessageUnsupported;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::MessageForwardInfo> TdConvertToInternal (struct TdMessageForwardInfo *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageForwardedFromUser: return TdConvertToInternal ((struct TdMessageForwardedFromUser *)var);
    case CODE_MessageForwardedPost: return TdConvertToInternal ((struct TdMessageForwardedPost *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdMessageForwardInfo *TdConvertFromInternal (const td::td_api::MessageForwardInfo &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_MessageForwardedFromUser: return (struct TdMessageForwardInfo *)TdConvertFromInternal(static_cast<const td::td_api::messageForwardedFromUser &>(from));
    case CODE_MessageForwardedPost: return (struct TdMessageForwardInfo *)TdConvertFromInternal(static_cast<const td::td_api::messageForwardedPost &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeMessageForwardInfo (struct TdMessageForwardInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageForwardInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageForwardInfo (struct TdMessageForwardInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageForwardInfo *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageForwardedFromUser: return TdDestroyObject ((struct TdMessageForwardedFromUser *)var);
    case CODE_MessageForwardedPost: return TdDestroyObject ((struct TdMessageForwardedPost *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerMessageForwardInfo (struct TdMessageForwardInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageForwardInfo *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageForwardedFromUser: return TdStackStorer ((struct TdMessageForwardedFromUser *)var, M);
    case CODE_MessageForwardedPost: return TdStackStorer ((struct TdMessageForwardedPost *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdMessageForwardInfo *TdStackFetcherMessageForwardInfo (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "MessageForwardedFromUser") {
    return (struct TdMessageForwardInfo *)TdStackFetcherMessageForwardedFromUser (M);
  }
  if (constructor == "MessageForwardedPost") {
    return (struct TdMessageForwardInfo *)TdStackFetcherMessageForwardedPost (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdMessageForwardedFromUser *TdCreateObjectMessageForwardedFromUser (int sender_user_id_, int date_, long long forwarded_from_chat_id_, long long forwarded_from_message_id_) {
  auto var = new struct TdMessageForwardedFromUser ();
  var->ID = CODE_MessageForwardedFromUser;
  var->refcnt = 1;
  var->sender_user_id_ = sender_user_id_;
  var->date_ = date_;
  var->forwarded_from_chat_id_ = forwarded_from_chat_id_;
  var->forwarded_from_message_id_ = forwarded_from_message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageForwardedFromUser> TdConvertToInternal (struct TdMessageForwardedFromUser *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->sender_user_id_;
  std::int32_t v100;
  v100 = var->date_;
  std::int64_t v200;
  v200 = var->forwarded_from_chat_id_;
  std::int64_t v300;
  v300 = var->forwarded_from_message_id_;
  return td::td_api::make_object<td::td_api::messageForwardedFromUser>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdMessageForwardedFromUser *TdConvertFromInternal (const td::td_api::messageForwardedFromUser &from) {
  auto res = new TdMessageForwardedFromUser ();
  res->ID = CODE_MessageForwardedFromUser;
  res->refcnt = 1;
  res->sender_user_id_ = from.sender_user_id_;
  res->date_ = from.date_;
  res->forwarded_from_chat_id_ = from.forwarded_from_chat_id_;
  res->forwarded_from_message_id_ = from.forwarded_from_message_id_;
  return res;
}
char *TdSerializeMessageForwardedFromUser (struct TdMessageForwardedFromUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageForwardedFromUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageForwardedFromUser (struct TdMessageForwardedFromUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageForwardedFromUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageForwardedFromUser (struct TdMessageForwardedFromUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageForwardedFromUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageForwardedFromUser");
  M->new_field ("ID");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  M->pack_long (var->date_);
  M->new_field ("date_");
  M->pack_long (var->forwarded_from_chat_id_);
  M->new_field ("forwarded_from_chat_id_");
  M->pack_long (var->forwarded_from_message_id_);
  M->new_field ("forwarded_from_message_id_");
}
struct TdMessageForwardedFromUser *TdStackFetcherMessageForwardedFromUser (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageForwardedFromUser ();
  res->ID = CODE_MessageForwardedFromUser;
  res->refcnt = 1;
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("forwarded_from_chat_id_");
  res->forwarded_from_chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("forwarded_from_message_id_");
  res->forwarded_from_message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdMessageForwardedPost *TdCreateObjectMessageForwardedPost (long long chat_id_, char *author_signature_, int date_, long long message_id_, long long forwarded_from_chat_id_, long long forwarded_from_message_id_) {
  auto var = new struct TdMessageForwardedPost ();
  var->ID = CODE_MessageForwardedPost;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->author_signature_ = (author_signature_) ? td::str_dup (td::Slice (author_signature_)) : nullptr;
  var->date_ = date_;
  var->message_id_ = message_id_;
  var->forwarded_from_chat_id_ = forwarded_from_chat_id_;
  var->forwarded_from_message_id_ = forwarded_from_message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::messageForwardedPost> TdConvertToInternal (struct TdMessageForwardedPost *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->author_signature_) ? var->author_signature_: "";
  std::int32_t v200;
  v200 = var->date_;
  std::int64_t v300;
  v300 = var->message_id_;
  std::int64_t v400;
  v400 = var->forwarded_from_chat_id_;
  std::int64_t v500;
  v500 = var->forwarded_from_message_id_;
  return td::td_api::make_object<td::td_api::messageForwardedPost>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdMessageForwardedPost *TdConvertFromInternal (const td::td_api::messageForwardedPost &from) {
  auto res = new TdMessageForwardedPost ();
  res->ID = CODE_MessageForwardedPost;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->author_signature_ = (from.author_signature_.length ()) ? td::str_dup (from.author_signature_) : nullptr;
  res->date_ = from.date_;
  res->message_id_ = from.message_id_;
  res->forwarded_from_chat_id_ = from.forwarded_from_chat_id_;
  res->forwarded_from_message_id_ = from.forwarded_from_message_id_;
  return res;
}
char *TdSerializeMessageForwardedPost (struct TdMessageForwardedPost *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageForwardedPost *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageForwardedPost (struct TdMessageForwardedPost *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageForwardedPost *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->author_signature_);
  delete var;
}
void TdStackStorerMessageForwardedPost (struct TdMessageForwardedPost *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageForwardedPost *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageForwardedPost");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->author_signature_);
  M->new_field ("author_signature_");
  M->pack_long (var->date_);
  M->new_field ("date_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_long (var->forwarded_from_chat_id_);
  M->new_field ("forwarded_from_chat_id_");
  M->pack_long (var->forwarded_from_message_id_);
  M->new_field ("forwarded_from_message_id_");
}
struct TdMessageForwardedPost *TdStackFetcherMessageForwardedPost (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageForwardedPost ();
  res->ID = CODE_MessageForwardedPost;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("author_signature_");
  res->author_signature_ = M->get_string ();
  M->pop ();
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("forwarded_from_chat_id_");
  res->forwarded_from_chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("forwarded_from_message_id_");
  res->forwarded_from_message_id_ = M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::MessageSendingState> TdConvertToInternal (struct TdMessageSendingState *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageSendingStatePending: return TdConvertToInternal ((struct TdMessageSendingStatePending *)var);
    case CODE_MessageSendingStateFailed: return TdConvertToInternal ((struct TdMessageSendingStateFailed *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdMessageSendingState *TdConvertFromInternal (const td::td_api::MessageSendingState &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_MessageSendingStatePending: return (struct TdMessageSendingState *)TdConvertFromInternal(static_cast<const td::td_api::messageSendingStatePending &>(from));
    case CODE_MessageSendingStateFailed: return (struct TdMessageSendingState *)TdConvertFromInternal(static_cast<const td::td_api::messageSendingStateFailed &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeMessageSendingState (struct TdMessageSendingState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageSendingState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageSendingState (struct TdMessageSendingState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageSendingState *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageSendingStatePending: return TdDestroyObject ((struct TdMessageSendingStatePending *)var);
    case CODE_MessageSendingStateFailed: return TdDestroyObject ((struct TdMessageSendingStateFailed *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerMessageSendingState (struct TdMessageSendingState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageSendingState *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_MessageSendingStatePending: return TdStackStorer ((struct TdMessageSendingStatePending *)var, M);
    case CODE_MessageSendingStateFailed: return TdStackStorer ((struct TdMessageSendingStateFailed *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdMessageSendingState *TdStackFetcherMessageSendingState (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "MessageSendingStatePending") {
    return (struct TdMessageSendingState *)TdStackFetcherMessageSendingStatePending (M);
  }
  if (constructor == "MessageSendingStateFailed") {
    return (struct TdMessageSendingState *)TdStackFetcherMessageSendingStateFailed (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdMessageSendingStatePending *TdCreateObjectMessageSendingStatePending (void) {
  auto var = new struct TdMessageSendingStatePending ();
  var->ID = CODE_MessageSendingStatePending;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageSendingStatePending> TdConvertToInternal (struct TdMessageSendingStatePending *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageSendingStatePending>();
}
struct TdMessageSendingStatePending *TdConvertFromInternal (const td::td_api::messageSendingStatePending &from) {
  auto res = new TdMessageSendingStatePending ();
  res->ID = CODE_MessageSendingStatePending;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageSendingStatePending (struct TdMessageSendingStatePending *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageSendingStatePending *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageSendingStatePending (struct TdMessageSendingStatePending *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageSendingStatePending *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageSendingStatePending (struct TdMessageSendingStatePending *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageSendingStatePending *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageSendingStatePending");
  M->new_field ("ID");
}
struct TdMessageSendingStatePending *TdStackFetcherMessageSendingStatePending (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageSendingStatePending ();
  res->ID = CODE_MessageSendingStatePending;
  res->refcnt = 1;
  return res;
}
struct TdMessageSendingStateFailed *TdCreateObjectMessageSendingStateFailed (void) {
  auto var = new struct TdMessageSendingStateFailed ();
  var->ID = CODE_MessageSendingStateFailed;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::messageSendingStateFailed> TdConvertToInternal (struct TdMessageSendingStateFailed *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::messageSendingStateFailed>();
}
struct TdMessageSendingStateFailed *TdConvertFromInternal (const td::td_api::messageSendingStateFailed &from) {
  auto res = new TdMessageSendingStateFailed ();
  res->ID = CODE_MessageSendingStateFailed;
  res->refcnt = 1;
  return res;
}
char *TdSerializeMessageSendingStateFailed (struct TdMessageSendingStateFailed *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessageSendingStateFailed *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessageSendingStateFailed (struct TdMessageSendingStateFailed *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessageSendingStateFailed *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerMessageSendingStateFailed (struct TdMessageSendingStateFailed *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessageSendingStateFailed *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("MessageSendingStateFailed");
  M->new_field ("ID");
}
struct TdMessageSendingStateFailed *TdStackFetcherMessageSendingStateFailed (struct TdStackFetcherMethods *M) {
  auto res = new TdMessageSendingStateFailed ();
  res->ID = CODE_MessageSendingStateFailed;
  res->refcnt = 1;
  return res;
}
struct TdMessages *TdCreateObjectMessages (int total_count_, struct TdVectorMessage *messages_) {
  auto var = new struct TdMessages ();
  var->ID = CODE_Messages;
  var->refcnt = 1;
  var->total_count_ = total_count_;
  var->messages_ = messages_;
  return var;
}
td::td_api::object_ptr<td::td_api::messages> TdConvertToInternal (struct TdMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->total_count_;
  std::vector<td::td_api::object_ptr<td::td_api::message>> v100;
  for (int i100 = 0; i100 < var->messages_->len; i100++) {
    td::td_api::object_ptr<td::td_api::message> v101;
    v101 = TdConvertToInternal (var->messages_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::messages>(std::move (v0), std::move (v100));
}
struct TdMessages *TdConvertFromInternal (const td::td_api::messages &from) {
  auto res = new TdMessages ();
  res->ID = CODE_Messages;
  res->refcnt = 1;
  res->total_count_ = from.total_count_;
  res->messages_ = new TdVectorMessage ();
  res->messages_->len = (int)from.messages_.size ();
  res->messages_->data = new struct TdMessage * [res->messages_->len];
  for (int i100 = 0; i100 < res->messages_->len; i100++) {
    if (!from.messages_[i100]) {
      res->messages_->data[i100] = nullptr;
    } else {
      res->messages_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.messages_[i100]));
    }
  }
  return res;
}
char *TdSerializeMessages (struct TdMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectMessages (struct TdMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->messages_->len; i100++) {
    TdDestroyObject (var->messages_->data[i100]);
  }
  delete[] var->messages_->data;
  delete var->messages_;
  delete var;
}
void TdStackStorerMessages (struct TdMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Messages");
  M->new_field ("ID");
  M->pack_long (var->total_count_);
  M->new_field ("total_count_");
  M->new_array ();
  for (int i100 = 0; i100 < var->messages_->len; i100++) {
    TdStackStorer (var->messages_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("messages_");
}
struct TdMessages *TdStackFetcherMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdMessages ();
  res->ID = CODE_Messages;
  res->refcnt = 1;
  M->get_field ("total_count_");
  res->total_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("messages_");
  res->messages_ = new TdVectorMessage ();
  res->messages_->len = M->get_arr_size ();
  res->messages_->data = new struct TdMessage * [res->messages_->len];
  for (int i100 = 0; i100 < res->messages_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->messages_->data[i100] = nullptr;
    } else {
      res->messages_->data[i100] = TdStackFetcherMessage (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdNetworkStatistics *TdCreateObjectNetworkStatistics (int since_date_, struct TdVectorNetworkStatisticsEntry *entries_) {
  auto var = new struct TdNetworkStatistics ();
  var->ID = CODE_NetworkStatistics;
  var->refcnt = 1;
  var->since_date_ = since_date_;
  var->entries_ = entries_;
  return var;
}
td::td_api::object_ptr<td::td_api::networkStatistics> TdConvertToInternal (struct TdNetworkStatistics *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->since_date_;
  std::vector<td::td_api::object_ptr<td::td_api::NetworkStatisticsEntry>> v100;
  for (int i100 = 0; i100 < var->entries_->len; i100++) {
    td::td_api::object_ptr<td::td_api::NetworkStatisticsEntry> v101;
    v101 = TdConvertToInternal (var->entries_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::networkStatistics>(std::move (v0), std::move (v100));
}
struct TdNetworkStatistics *TdConvertFromInternal (const td::td_api::networkStatistics &from) {
  auto res = new TdNetworkStatistics ();
  res->ID = CODE_NetworkStatistics;
  res->refcnt = 1;
  res->since_date_ = from.since_date_;
  res->entries_ = new TdVectorNetworkStatisticsEntry ();
  res->entries_->len = (int)from.entries_.size ();
  res->entries_->data = new struct TdNetworkStatisticsEntry * [res->entries_->len];
  for (int i100 = 0; i100 < res->entries_->len; i100++) {
    if (!from.entries_[i100]) {
      res->entries_->data[i100] = nullptr;
    } else {
      res->entries_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::NetworkStatisticsEntry &>(*from.entries_[i100]));
    }
  }
  return res;
}
char *TdSerializeNetworkStatistics (struct TdNetworkStatistics *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkStatistics *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkStatistics (struct TdNetworkStatistics *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkStatistics *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->entries_->len; i100++) {
    TdDestroyObject (var->entries_->data[i100]);
  }
  delete[] var->entries_->data;
  delete var->entries_;
  delete var;
}
void TdStackStorerNetworkStatistics (struct TdNetworkStatistics *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkStatistics *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NetworkStatistics");
  M->new_field ("ID");
  M->pack_long (var->since_date_);
  M->new_field ("since_date_");
  M->new_array ();
  for (int i100 = 0; i100 < var->entries_->len; i100++) {
    TdStackStorer (var->entries_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("entries_");
}
struct TdNetworkStatistics *TdStackFetcherNetworkStatistics (struct TdStackFetcherMethods *M) {
  auto res = new TdNetworkStatistics ();
  res->ID = CODE_NetworkStatistics;
  res->refcnt = 1;
  M->get_field ("since_date_");
  res->since_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("entries_");
  res->entries_ = new TdVectorNetworkStatisticsEntry ();
  res->entries_->len = M->get_arr_size ();
  res->entries_->data = new struct TdNetworkStatisticsEntry * [res->entries_->len];
  for (int i100 = 0; i100 < res->entries_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->entries_->data[i100] = nullptr;
    } else {
      res->entries_->data[i100] = TdStackFetcherNetworkStatisticsEntry (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::NetworkStatisticsEntry> TdConvertToInternal (struct TdNetworkStatisticsEntry *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NetworkStatisticsEntryFile: return TdConvertToInternal ((struct TdNetworkStatisticsEntryFile *)var);
    case CODE_NetworkStatisticsEntryCall: return TdConvertToInternal ((struct TdNetworkStatisticsEntryCall *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdNetworkStatisticsEntry *TdConvertFromInternal (const td::td_api::NetworkStatisticsEntry &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_NetworkStatisticsEntryFile: return (struct TdNetworkStatisticsEntry *)TdConvertFromInternal(static_cast<const td::td_api::networkStatisticsEntryFile &>(from));
    case CODE_NetworkStatisticsEntryCall: return (struct TdNetworkStatisticsEntry *)TdConvertFromInternal(static_cast<const td::td_api::networkStatisticsEntryCall &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeNetworkStatisticsEntry (struct TdNetworkStatisticsEntry *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkStatisticsEntry *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkStatisticsEntry (struct TdNetworkStatisticsEntry *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkStatisticsEntry *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NetworkStatisticsEntryFile: return TdDestroyObject ((struct TdNetworkStatisticsEntryFile *)var);
    case CODE_NetworkStatisticsEntryCall: return TdDestroyObject ((struct TdNetworkStatisticsEntryCall *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerNetworkStatisticsEntry (struct TdNetworkStatisticsEntry *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkStatisticsEntry *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NetworkStatisticsEntryFile: return TdStackStorer ((struct TdNetworkStatisticsEntryFile *)var, M);
    case CODE_NetworkStatisticsEntryCall: return TdStackStorer ((struct TdNetworkStatisticsEntryCall *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdNetworkStatisticsEntry *TdStackFetcherNetworkStatisticsEntry (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "NetworkStatisticsEntryFile") {
    return (struct TdNetworkStatisticsEntry *)TdStackFetcherNetworkStatisticsEntryFile (M);
  }
  if (constructor == "NetworkStatisticsEntryCall") {
    return (struct TdNetworkStatisticsEntry *)TdStackFetcherNetworkStatisticsEntryCall (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdNetworkStatisticsEntryFile *TdCreateObjectNetworkStatisticsEntryFile (struct TdFileType *file_type_, struct TdNetworkType *network_type_, long long sent_bytes_, long long received_bytes_) {
  auto var = new struct TdNetworkStatisticsEntryFile ();
  var->ID = CODE_NetworkStatisticsEntryFile;
  var->refcnt = 1;
  var->file_type_ = file_type_;
  var->network_type_ = network_type_;
  var->sent_bytes_ = sent_bytes_;
  var->received_bytes_ = received_bytes_;
  return var;
}
td::td_api::object_ptr<td::td_api::networkStatisticsEntryFile> TdConvertToInternal (struct TdNetworkStatisticsEntryFile *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::FileType> v0;
  v0 = TdConvertToInternal (var->file_type_);
  td::td_api::object_ptr<td::td_api::NetworkType> v100;
  v100 = TdConvertToInternal (var->network_type_);
  std::int64_t v200;
  v200 = var->sent_bytes_;
  std::int64_t v300;
  v300 = var->received_bytes_;
  return td::td_api::make_object<td::td_api::networkStatisticsEntryFile>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdNetworkStatisticsEntryFile *TdConvertFromInternal (const td::td_api::networkStatisticsEntryFile &from) {
  auto res = new TdNetworkStatisticsEntryFile ();
  res->ID = CODE_NetworkStatisticsEntryFile;
  res->refcnt = 1;
  if (!from.file_type_) {
    res->file_type_ = nullptr;
  } else {
    res->file_type_ = TdConvertFromInternal (static_cast<const td::td_api::FileType &>(*from.file_type_));
  }
  if (!from.network_type_) {
    res->network_type_ = nullptr;
  } else {
    res->network_type_ = TdConvertFromInternal (static_cast<const td::td_api::NetworkType &>(*from.network_type_));
  }
  res->sent_bytes_ = from.sent_bytes_;
  res->received_bytes_ = from.received_bytes_;
  return res;
}
char *TdSerializeNetworkStatisticsEntryFile (struct TdNetworkStatisticsEntryFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkStatisticsEntryFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkStatisticsEntryFile (struct TdNetworkStatisticsEntryFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkStatisticsEntryFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->file_type_);
  TdDestroyObject (var->network_type_);
  delete var;
}
void TdStackStorerNetworkStatisticsEntryFile (struct TdNetworkStatisticsEntryFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkStatisticsEntryFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NetworkStatisticsEntryFile");
  M->new_field ("ID");
  TdStackStorer (var->file_type_, M);
  M->new_field ("file_type_");
  TdStackStorer (var->network_type_, M);
  M->new_field ("network_type_");
  M->pack_long (var->sent_bytes_);
  M->new_field ("sent_bytes_");
  M->pack_long (var->received_bytes_);
  M->new_field ("received_bytes_");
}
struct TdNetworkStatisticsEntryFile *TdStackFetcherNetworkStatisticsEntryFile (struct TdStackFetcherMethods *M) {
  auto res = new TdNetworkStatisticsEntryFile ();
  res->ID = CODE_NetworkStatisticsEntryFile;
  res->refcnt = 1;
  M->get_field ("file_type_");
  if (M->is_nil ()) {
    res->file_type_ = nullptr;
  } else {
    res->file_type_ = TdStackFetcherFileType (M);
  }
  M->pop ();
  M->get_field ("network_type_");
  if (M->is_nil ()) {
    res->network_type_ = nullptr;
  } else {
    res->network_type_ = TdStackFetcherNetworkType (M);
  }
  M->pop ();
  M->get_field ("sent_bytes_");
  res->sent_bytes_ = M->get_long ();
  M->pop ();
  M->get_field ("received_bytes_");
  res->received_bytes_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdNetworkStatisticsEntryCall *TdCreateObjectNetworkStatisticsEntryCall (struct TdNetworkType *network_type_, long long sent_bytes_, long long received_bytes_, double duration_) {
  auto var = new struct TdNetworkStatisticsEntryCall ();
  var->ID = CODE_NetworkStatisticsEntryCall;
  var->refcnt = 1;
  var->network_type_ = network_type_;
  var->sent_bytes_ = sent_bytes_;
  var->received_bytes_ = received_bytes_;
  var->duration_ = duration_;
  return var;
}
td::td_api::object_ptr<td::td_api::networkStatisticsEntryCall> TdConvertToInternal (struct TdNetworkStatisticsEntryCall *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::NetworkType> v0;
  v0 = TdConvertToInternal (var->network_type_);
  std::int64_t v100;
  v100 = var->sent_bytes_;
  std::int64_t v200;
  v200 = var->received_bytes_;
  double v300;
  v300 = var->duration_;
  return td::td_api::make_object<td::td_api::networkStatisticsEntryCall>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdNetworkStatisticsEntryCall *TdConvertFromInternal (const td::td_api::networkStatisticsEntryCall &from) {
  auto res = new TdNetworkStatisticsEntryCall ();
  res->ID = CODE_NetworkStatisticsEntryCall;
  res->refcnt = 1;
  if (!from.network_type_) {
    res->network_type_ = nullptr;
  } else {
    res->network_type_ = TdConvertFromInternal (static_cast<const td::td_api::NetworkType &>(*from.network_type_));
  }
  res->sent_bytes_ = from.sent_bytes_;
  res->received_bytes_ = from.received_bytes_;
  res->duration_ = from.duration_;
  return res;
}
char *TdSerializeNetworkStatisticsEntryCall (struct TdNetworkStatisticsEntryCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkStatisticsEntryCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkStatisticsEntryCall (struct TdNetworkStatisticsEntryCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkStatisticsEntryCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->network_type_);
  delete var;
}
void TdStackStorerNetworkStatisticsEntryCall (struct TdNetworkStatisticsEntryCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkStatisticsEntryCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NetworkStatisticsEntryCall");
  M->new_field ("ID");
  TdStackStorer (var->network_type_, M);
  M->new_field ("network_type_");
  M->pack_long (var->sent_bytes_);
  M->new_field ("sent_bytes_");
  M->pack_long (var->received_bytes_);
  M->new_field ("received_bytes_");
  M->pack_double (var->duration_);
  M->new_field ("duration_");
}
struct TdNetworkStatisticsEntryCall *TdStackFetcherNetworkStatisticsEntryCall (struct TdStackFetcherMethods *M) {
  auto res = new TdNetworkStatisticsEntryCall ();
  res->ID = CODE_NetworkStatisticsEntryCall;
  res->refcnt = 1;
  M->get_field ("network_type_");
  if (M->is_nil ()) {
    res->network_type_ = nullptr;
  } else {
    res->network_type_ = TdStackFetcherNetworkType (M);
  }
  M->pop ();
  M->get_field ("sent_bytes_");
  res->sent_bytes_ = M->get_long ();
  M->pop ();
  M->get_field ("received_bytes_");
  res->received_bytes_ = M->get_long ();
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = M->get_double ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::NetworkType> TdConvertToInternal (struct TdNetworkType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NetworkTypeNone: return TdConvertToInternal ((struct TdNetworkTypeNone *)var);
    case CODE_NetworkTypeMobile: return TdConvertToInternal ((struct TdNetworkTypeMobile *)var);
    case CODE_NetworkTypeMobileRoaming: return TdConvertToInternal ((struct TdNetworkTypeMobileRoaming *)var);
    case CODE_NetworkTypeWiFi: return TdConvertToInternal ((struct TdNetworkTypeWiFi *)var);
    case CODE_NetworkTypeOther: return TdConvertToInternal ((struct TdNetworkTypeOther *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdNetworkType *TdConvertFromInternal (const td::td_api::NetworkType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_NetworkTypeNone: return (struct TdNetworkType *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeNone &>(from));
    case CODE_NetworkTypeMobile: return (struct TdNetworkType *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeMobile &>(from));
    case CODE_NetworkTypeMobileRoaming: return (struct TdNetworkType *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeMobileRoaming &>(from));
    case CODE_NetworkTypeWiFi: return (struct TdNetworkType *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeWiFi &>(from));
    case CODE_NetworkTypeOther: return (struct TdNetworkType *)TdConvertFromInternal(static_cast<const td::td_api::networkTypeOther &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeNetworkType (struct TdNetworkType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkType (struct TdNetworkType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NetworkTypeNone: return TdDestroyObject ((struct TdNetworkTypeNone *)var);
    case CODE_NetworkTypeMobile: return TdDestroyObject ((struct TdNetworkTypeMobile *)var);
    case CODE_NetworkTypeMobileRoaming: return TdDestroyObject ((struct TdNetworkTypeMobileRoaming *)var);
    case CODE_NetworkTypeWiFi: return TdDestroyObject ((struct TdNetworkTypeWiFi *)var);
    case CODE_NetworkTypeOther: return TdDestroyObject ((struct TdNetworkTypeOther *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerNetworkType (struct TdNetworkType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NetworkTypeNone: return TdStackStorer ((struct TdNetworkTypeNone *)var, M);
    case CODE_NetworkTypeMobile: return TdStackStorer ((struct TdNetworkTypeMobile *)var, M);
    case CODE_NetworkTypeMobileRoaming: return TdStackStorer ((struct TdNetworkTypeMobileRoaming *)var, M);
    case CODE_NetworkTypeWiFi: return TdStackStorer ((struct TdNetworkTypeWiFi *)var, M);
    case CODE_NetworkTypeOther: return TdStackStorer ((struct TdNetworkTypeOther *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdNetworkType *TdStackFetcherNetworkType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "NetworkTypeNone") {
    return (struct TdNetworkType *)TdStackFetcherNetworkTypeNone (M);
  }
  if (constructor == "NetworkTypeMobile") {
    return (struct TdNetworkType *)TdStackFetcherNetworkTypeMobile (M);
  }
  if (constructor == "NetworkTypeMobileRoaming") {
    return (struct TdNetworkType *)TdStackFetcherNetworkTypeMobileRoaming (M);
  }
  if (constructor == "NetworkTypeWiFi") {
    return (struct TdNetworkType *)TdStackFetcherNetworkTypeWiFi (M);
  }
  if (constructor == "NetworkTypeOther") {
    return (struct TdNetworkType *)TdStackFetcherNetworkTypeOther (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdNetworkTypeNone *TdCreateObjectNetworkTypeNone (void) {
  auto var = new struct TdNetworkTypeNone ();
  var->ID = CODE_NetworkTypeNone;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::networkTypeNone> TdConvertToInternal (struct TdNetworkTypeNone *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::networkTypeNone>();
}
struct TdNetworkTypeNone *TdConvertFromInternal (const td::td_api::networkTypeNone &from) {
  auto res = new TdNetworkTypeNone ();
  res->ID = CODE_NetworkTypeNone;
  res->refcnt = 1;
  return res;
}
char *TdSerializeNetworkTypeNone (struct TdNetworkTypeNone *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkTypeNone *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkTypeNone (struct TdNetworkTypeNone *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkTypeNone *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerNetworkTypeNone (struct TdNetworkTypeNone *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkTypeNone *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NetworkTypeNone");
  M->new_field ("ID");
}
struct TdNetworkTypeNone *TdStackFetcherNetworkTypeNone (struct TdStackFetcherMethods *M) {
  auto res = new TdNetworkTypeNone ();
  res->ID = CODE_NetworkTypeNone;
  res->refcnt = 1;
  return res;
}
struct TdNetworkTypeMobile *TdCreateObjectNetworkTypeMobile (void) {
  auto var = new struct TdNetworkTypeMobile ();
  var->ID = CODE_NetworkTypeMobile;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::networkTypeMobile> TdConvertToInternal (struct TdNetworkTypeMobile *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::networkTypeMobile>();
}
struct TdNetworkTypeMobile *TdConvertFromInternal (const td::td_api::networkTypeMobile &from) {
  auto res = new TdNetworkTypeMobile ();
  res->ID = CODE_NetworkTypeMobile;
  res->refcnt = 1;
  return res;
}
char *TdSerializeNetworkTypeMobile (struct TdNetworkTypeMobile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkTypeMobile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkTypeMobile (struct TdNetworkTypeMobile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkTypeMobile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerNetworkTypeMobile (struct TdNetworkTypeMobile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkTypeMobile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NetworkTypeMobile");
  M->new_field ("ID");
}
struct TdNetworkTypeMobile *TdStackFetcherNetworkTypeMobile (struct TdStackFetcherMethods *M) {
  auto res = new TdNetworkTypeMobile ();
  res->ID = CODE_NetworkTypeMobile;
  res->refcnt = 1;
  return res;
}
struct TdNetworkTypeMobileRoaming *TdCreateObjectNetworkTypeMobileRoaming (void) {
  auto var = new struct TdNetworkTypeMobileRoaming ();
  var->ID = CODE_NetworkTypeMobileRoaming;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::networkTypeMobileRoaming> TdConvertToInternal (struct TdNetworkTypeMobileRoaming *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::networkTypeMobileRoaming>();
}
struct TdNetworkTypeMobileRoaming *TdConvertFromInternal (const td::td_api::networkTypeMobileRoaming &from) {
  auto res = new TdNetworkTypeMobileRoaming ();
  res->ID = CODE_NetworkTypeMobileRoaming;
  res->refcnt = 1;
  return res;
}
char *TdSerializeNetworkTypeMobileRoaming (struct TdNetworkTypeMobileRoaming *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkTypeMobileRoaming *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkTypeMobileRoaming (struct TdNetworkTypeMobileRoaming *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkTypeMobileRoaming *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerNetworkTypeMobileRoaming (struct TdNetworkTypeMobileRoaming *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkTypeMobileRoaming *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NetworkTypeMobileRoaming");
  M->new_field ("ID");
}
struct TdNetworkTypeMobileRoaming *TdStackFetcherNetworkTypeMobileRoaming (struct TdStackFetcherMethods *M) {
  auto res = new TdNetworkTypeMobileRoaming ();
  res->ID = CODE_NetworkTypeMobileRoaming;
  res->refcnt = 1;
  return res;
}
struct TdNetworkTypeWiFi *TdCreateObjectNetworkTypeWiFi (void) {
  auto var = new struct TdNetworkTypeWiFi ();
  var->ID = CODE_NetworkTypeWiFi;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::networkTypeWiFi> TdConvertToInternal (struct TdNetworkTypeWiFi *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::networkTypeWiFi>();
}
struct TdNetworkTypeWiFi *TdConvertFromInternal (const td::td_api::networkTypeWiFi &from) {
  auto res = new TdNetworkTypeWiFi ();
  res->ID = CODE_NetworkTypeWiFi;
  res->refcnt = 1;
  return res;
}
char *TdSerializeNetworkTypeWiFi (struct TdNetworkTypeWiFi *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkTypeWiFi *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkTypeWiFi (struct TdNetworkTypeWiFi *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkTypeWiFi *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerNetworkTypeWiFi (struct TdNetworkTypeWiFi *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkTypeWiFi *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NetworkTypeWiFi");
  M->new_field ("ID");
}
struct TdNetworkTypeWiFi *TdStackFetcherNetworkTypeWiFi (struct TdStackFetcherMethods *M) {
  auto res = new TdNetworkTypeWiFi ();
  res->ID = CODE_NetworkTypeWiFi;
  res->refcnt = 1;
  return res;
}
struct TdNetworkTypeOther *TdCreateObjectNetworkTypeOther (void) {
  auto var = new struct TdNetworkTypeOther ();
  var->ID = CODE_NetworkTypeOther;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::networkTypeOther> TdConvertToInternal (struct TdNetworkTypeOther *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::networkTypeOther>();
}
struct TdNetworkTypeOther *TdConvertFromInternal (const td::td_api::networkTypeOther &from) {
  auto res = new TdNetworkTypeOther ();
  res->ID = CODE_NetworkTypeOther;
  res->refcnt = 1;
  return res;
}
char *TdSerializeNetworkTypeOther (struct TdNetworkTypeOther *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNetworkTypeOther *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNetworkTypeOther (struct TdNetworkTypeOther *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNetworkTypeOther *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerNetworkTypeOther (struct TdNetworkTypeOther *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNetworkTypeOther *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NetworkTypeOther");
  M->new_field ("ID");
}
struct TdNetworkTypeOther *TdStackFetcherNetworkTypeOther (struct TdStackFetcherMethods *M) {
  auto res = new TdNetworkTypeOther ();
  res->ID = CODE_NetworkTypeOther;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::NotificationSettingsScope> TdConvertToInternal (struct TdNotificationSettingsScope *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NotificationSettingsScopePrivateChats: return TdConvertToInternal ((struct TdNotificationSettingsScopePrivateChats *)var);
    case CODE_NotificationSettingsScopeGroupChats: return TdConvertToInternal ((struct TdNotificationSettingsScopeGroupChats *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdNotificationSettingsScope *TdConvertFromInternal (const td::td_api::NotificationSettingsScope &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_NotificationSettingsScopePrivateChats: return (struct TdNotificationSettingsScope *)TdConvertFromInternal(static_cast<const td::td_api::notificationSettingsScopePrivateChats &>(from));
    case CODE_NotificationSettingsScopeGroupChats: return (struct TdNotificationSettingsScope *)TdConvertFromInternal(static_cast<const td::td_api::notificationSettingsScopeGroupChats &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeNotificationSettingsScope (struct TdNotificationSettingsScope *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNotificationSettingsScope *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNotificationSettingsScope (struct TdNotificationSettingsScope *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNotificationSettingsScope *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NotificationSettingsScopePrivateChats: return TdDestroyObject ((struct TdNotificationSettingsScopePrivateChats *)var);
    case CODE_NotificationSettingsScopeGroupChats: return TdDestroyObject ((struct TdNotificationSettingsScopeGroupChats *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerNotificationSettingsScope (struct TdNotificationSettingsScope *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNotificationSettingsScope *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_NotificationSettingsScopePrivateChats: return TdStackStorer ((struct TdNotificationSettingsScopePrivateChats *)var, M);
    case CODE_NotificationSettingsScopeGroupChats: return TdStackStorer ((struct TdNotificationSettingsScopeGroupChats *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdNotificationSettingsScope *TdStackFetcherNotificationSettingsScope (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "NotificationSettingsScopePrivateChats") {
    return (struct TdNotificationSettingsScope *)TdStackFetcherNotificationSettingsScopePrivateChats (M);
  }
  if (constructor == "NotificationSettingsScopeGroupChats") {
    return (struct TdNotificationSettingsScope *)TdStackFetcherNotificationSettingsScopeGroupChats (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdNotificationSettingsScopePrivateChats *TdCreateObjectNotificationSettingsScopePrivateChats (void) {
  auto var = new struct TdNotificationSettingsScopePrivateChats ();
  var->ID = CODE_NotificationSettingsScopePrivateChats;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::notificationSettingsScopePrivateChats> TdConvertToInternal (struct TdNotificationSettingsScopePrivateChats *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::notificationSettingsScopePrivateChats>();
}
struct TdNotificationSettingsScopePrivateChats *TdConvertFromInternal (const td::td_api::notificationSettingsScopePrivateChats &from) {
  auto res = new TdNotificationSettingsScopePrivateChats ();
  res->ID = CODE_NotificationSettingsScopePrivateChats;
  res->refcnt = 1;
  return res;
}
char *TdSerializeNotificationSettingsScopePrivateChats (struct TdNotificationSettingsScopePrivateChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNotificationSettingsScopePrivateChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNotificationSettingsScopePrivateChats (struct TdNotificationSettingsScopePrivateChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNotificationSettingsScopePrivateChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerNotificationSettingsScopePrivateChats (struct TdNotificationSettingsScopePrivateChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNotificationSettingsScopePrivateChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NotificationSettingsScopePrivateChats");
  M->new_field ("ID");
}
struct TdNotificationSettingsScopePrivateChats *TdStackFetcherNotificationSettingsScopePrivateChats (struct TdStackFetcherMethods *M) {
  auto res = new TdNotificationSettingsScopePrivateChats ();
  res->ID = CODE_NotificationSettingsScopePrivateChats;
  res->refcnt = 1;
  return res;
}
struct TdNotificationSettingsScopeGroupChats *TdCreateObjectNotificationSettingsScopeGroupChats (void) {
  auto var = new struct TdNotificationSettingsScopeGroupChats ();
  var->ID = CODE_NotificationSettingsScopeGroupChats;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::notificationSettingsScopeGroupChats> TdConvertToInternal (struct TdNotificationSettingsScopeGroupChats *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::notificationSettingsScopeGroupChats>();
}
struct TdNotificationSettingsScopeGroupChats *TdConvertFromInternal (const td::td_api::notificationSettingsScopeGroupChats &from) {
  auto res = new TdNotificationSettingsScopeGroupChats ();
  res->ID = CODE_NotificationSettingsScopeGroupChats;
  res->refcnt = 1;
  return res;
}
char *TdSerializeNotificationSettingsScopeGroupChats (struct TdNotificationSettingsScopeGroupChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdNotificationSettingsScopeGroupChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectNotificationSettingsScopeGroupChats (struct TdNotificationSettingsScopeGroupChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdNotificationSettingsScopeGroupChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerNotificationSettingsScopeGroupChats (struct TdNotificationSettingsScopeGroupChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdNotificationSettingsScopeGroupChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("NotificationSettingsScopeGroupChats");
  M->new_field ("ID");
}
struct TdNotificationSettingsScopeGroupChats *TdStackFetcherNotificationSettingsScopeGroupChats (struct TdStackFetcherMethods *M) {
  auto res = new TdNotificationSettingsScopeGroupChats ();
  res->ID = CODE_NotificationSettingsScopeGroupChats;
  res->refcnt = 1;
  return res;
}
struct TdOk *TdCreateObjectOk (void) {
  auto var = new struct TdOk ();
  var->ID = CODE_Ok;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::ok> TdConvertToInternal (struct TdOk *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::ok>();
}
struct TdOk *TdConvertFromInternal (const td::td_api::ok &from) {
  auto res = new TdOk ();
  res->ID = CODE_Ok;
  res->refcnt = 1;
  return res;
}
char *TdSerializeOk (struct TdOk *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOk *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOk (struct TdOk *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOk *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerOk (struct TdOk *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOk *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Ok");
  M->new_field ("ID");
}
struct TdOk *TdStackFetcherOk (struct TdStackFetcherMethods *M) {
  auto res = new TdOk ();
  res->ID = CODE_Ok;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::OptionValue> TdConvertToInternal (struct TdOptionValue *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_OptionValueBoolean: return TdConvertToInternal ((struct TdOptionValueBoolean *)var);
    case CODE_OptionValueEmpty: return TdConvertToInternal ((struct TdOptionValueEmpty *)var);
    case CODE_OptionValueInteger: return TdConvertToInternal ((struct TdOptionValueInteger *)var);
    case CODE_OptionValueString: return TdConvertToInternal ((struct TdOptionValueString *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdOptionValue *TdConvertFromInternal (const td::td_api::OptionValue &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_OptionValueBoolean: return (struct TdOptionValue *)TdConvertFromInternal(static_cast<const td::td_api::optionValueBoolean &>(from));
    case CODE_OptionValueEmpty: return (struct TdOptionValue *)TdConvertFromInternal(static_cast<const td::td_api::optionValueEmpty &>(from));
    case CODE_OptionValueInteger: return (struct TdOptionValue *)TdConvertFromInternal(static_cast<const td::td_api::optionValueInteger &>(from));
    case CODE_OptionValueString: return (struct TdOptionValue *)TdConvertFromInternal(static_cast<const td::td_api::optionValueString &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeOptionValue (struct TdOptionValue *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOptionValue *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOptionValue (struct TdOptionValue *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOptionValue *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_OptionValueBoolean: return TdDestroyObject ((struct TdOptionValueBoolean *)var);
    case CODE_OptionValueEmpty: return TdDestroyObject ((struct TdOptionValueEmpty *)var);
    case CODE_OptionValueInteger: return TdDestroyObject ((struct TdOptionValueInteger *)var);
    case CODE_OptionValueString: return TdDestroyObject ((struct TdOptionValueString *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerOptionValue (struct TdOptionValue *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOptionValue *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_OptionValueBoolean: return TdStackStorer ((struct TdOptionValueBoolean *)var, M);
    case CODE_OptionValueEmpty: return TdStackStorer ((struct TdOptionValueEmpty *)var, M);
    case CODE_OptionValueInteger: return TdStackStorer ((struct TdOptionValueInteger *)var, M);
    case CODE_OptionValueString: return TdStackStorer ((struct TdOptionValueString *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdOptionValue *TdStackFetcherOptionValue (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "OptionValueBoolean") {
    return (struct TdOptionValue *)TdStackFetcherOptionValueBoolean (M);
  }
  if (constructor == "OptionValueEmpty") {
    return (struct TdOptionValue *)TdStackFetcherOptionValueEmpty (M);
  }
  if (constructor == "OptionValueInteger") {
    return (struct TdOptionValue *)TdStackFetcherOptionValueInteger (M);
  }
  if (constructor == "OptionValueString") {
    return (struct TdOptionValue *)TdStackFetcherOptionValueString (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdOptionValueBoolean *TdCreateObjectOptionValueBoolean (int value_) {
  auto var = new struct TdOptionValueBoolean ();
  var->ID = CODE_OptionValueBoolean;
  var->refcnt = 1;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::optionValueBoolean> TdConvertToInternal (struct TdOptionValueBoolean *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->value_ != 0;
  return td::td_api::make_object<td::td_api::optionValueBoolean>(std::move (v0));
}
struct TdOptionValueBoolean *TdConvertFromInternal (const td::td_api::optionValueBoolean &from) {
  auto res = new TdOptionValueBoolean ();
  res->ID = CODE_OptionValueBoolean;
  res->refcnt = 1;
  res->value_ = from.value_;
  return res;
}
char *TdSerializeOptionValueBoolean (struct TdOptionValueBoolean *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOptionValueBoolean *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOptionValueBoolean (struct TdOptionValueBoolean *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOptionValueBoolean *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerOptionValueBoolean (struct TdOptionValueBoolean *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOptionValueBoolean *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("OptionValueBoolean");
  M->new_field ("ID");
  M->pack_bool (var->value_);
  M->new_field ("value_");
}
struct TdOptionValueBoolean *TdStackFetcherOptionValueBoolean (struct TdStackFetcherMethods *M) {
  auto res = new TdOptionValueBoolean ();
  res->ID = CODE_OptionValueBoolean;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdOptionValueEmpty *TdCreateObjectOptionValueEmpty (void) {
  auto var = new struct TdOptionValueEmpty ();
  var->ID = CODE_OptionValueEmpty;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::optionValueEmpty> TdConvertToInternal (struct TdOptionValueEmpty *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::optionValueEmpty>();
}
struct TdOptionValueEmpty *TdConvertFromInternal (const td::td_api::optionValueEmpty &from) {
  auto res = new TdOptionValueEmpty ();
  res->ID = CODE_OptionValueEmpty;
  res->refcnt = 1;
  return res;
}
char *TdSerializeOptionValueEmpty (struct TdOptionValueEmpty *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOptionValueEmpty *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOptionValueEmpty (struct TdOptionValueEmpty *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOptionValueEmpty *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerOptionValueEmpty (struct TdOptionValueEmpty *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOptionValueEmpty *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("OptionValueEmpty");
  M->new_field ("ID");
}
struct TdOptionValueEmpty *TdStackFetcherOptionValueEmpty (struct TdStackFetcherMethods *M) {
  auto res = new TdOptionValueEmpty ();
  res->ID = CODE_OptionValueEmpty;
  res->refcnt = 1;
  return res;
}
struct TdOptionValueInteger *TdCreateObjectOptionValueInteger (int value_) {
  auto var = new struct TdOptionValueInteger ();
  var->ID = CODE_OptionValueInteger;
  var->refcnt = 1;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::optionValueInteger> TdConvertToInternal (struct TdOptionValueInteger *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->value_;
  return td::td_api::make_object<td::td_api::optionValueInteger>(std::move (v0));
}
struct TdOptionValueInteger *TdConvertFromInternal (const td::td_api::optionValueInteger &from) {
  auto res = new TdOptionValueInteger ();
  res->ID = CODE_OptionValueInteger;
  res->refcnt = 1;
  res->value_ = from.value_;
  return res;
}
char *TdSerializeOptionValueInteger (struct TdOptionValueInteger *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOptionValueInteger *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOptionValueInteger (struct TdOptionValueInteger *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOptionValueInteger *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerOptionValueInteger (struct TdOptionValueInteger *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOptionValueInteger *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("OptionValueInteger");
  M->new_field ("ID");
  M->pack_long (var->value_);
  M->new_field ("value_");
}
struct TdOptionValueInteger *TdStackFetcherOptionValueInteger (struct TdStackFetcherMethods *M) {
  auto res = new TdOptionValueInteger ();
  res->ID = CODE_OptionValueInteger;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdOptionValueString *TdCreateObjectOptionValueString (char *value_) {
  auto var = new struct TdOptionValueString ();
  var->ID = CODE_OptionValueString;
  var->refcnt = 1;
  var->value_ = (value_) ? td::str_dup (td::Slice (value_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::optionValueString> TdConvertToInternal (struct TdOptionValueString *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->value_) ? var->value_: "";
  return td::td_api::make_object<td::td_api::optionValueString>(std::move (v0));
}
struct TdOptionValueString *TdConvertFromInternal (const td::td_api::optionValueString &from) {
  auto res = new TdOptionValueString ();
  res->ID = CODE_OptionValueString;
  res->refcnt = 1;
  res->value_ = (from.value_.length ()) ? td::str_dup (from.value_) : nullptr;
  return res;
}
char *TdSerializeOptionValueString (struct TdOptionValueString *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOptionValueString *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOptionValueString (struct TdOptionValueString *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOptionValueString *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->value_);
  delete var;
}
void TdStackStorerOptionValueString (struct TdOptionValueString *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOptionValueString *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("OptionValueString");
  M->new_field ("ID");
  M->pack_string (var->value_);
  M->new_field ("value_");
}
struct TdOptionValueString *TdStackFetcherOptionValueString (struct TdStackFetcherMethods *M) {
  auto res = new TdOptionValueString ();
  res->ID = CODE_OptionValueString;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdOrderInfo *TdCreateObjectOrderInfo (char *name_, char *phone_number_, char *email_address_, struct TdAddress *shipping_address_) {
  auto var = new struct TdOrderInfo ();
  var->ID = CODE_OrderInfo;
  var->refcnt = 1;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  var->email_address_ = (email_address_) ? td::str_dup (td::Slice (email_address_)) : nullptr;
  var->shipping_address_ = shipping_address_;
  return var;
}
td::td_api::object_ptr<td::td_api::orderInfo> TdConvertToInternal (struct TdOrderInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->name_) ? var->name_: "";
  std::string v100;
  v100 = (var->phone_number_) ? var->phone_number_: "";
  std::string v200;
  v200 = (var->email_address_) ? var->email_address_: "";
  td::td_api::object_ptr<td::td_api::address> v300;
  v300 = TdConvertToInternal (var->shipping_address_);
  return td::td_api::make_object<td::td_api::orderInfo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdOrderInfo *TdConvertFromInternal (const td::td_api::orderInfo &from) {
  auto res = new TdOrderInfo ();
  res->ID = CODE_OrderInfo;
  res->refcnt = 1;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  res->email_address_ = (from.email_address_.length ()) ? td::str_dup (from.email_address_) : nullptr;
  if (!from.shipping_address_) {
    res->shipping_address_ = nullptr;
  } else {
    res->shipping_address_ = TdConvertFromInternal (static_cast<const td::td_api::address &>(*from.shipping_address_));
  }
  return res;
}
char *TdSerializeOrderInfo (struct TdOrderInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOrderInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOrderInfo (struct TdOrderInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOrderInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->name_);
  free (var->phone_number_);
  free (var->email_address_);
  TdDestroyObject (var->shipping_address_);
  delete var;
}
void TdStackStorerOrderInfo (struct TdOrderInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOrderInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("OrderInfo");
  M->new_field ("ID");
  M->pack_string (var->name_);
  M->new_field ("name_");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
  M->pack_string (var->email_address_);
  M->new_field ("email_address_");
  TdStackStorer (var->shipping_address_, M);
  M->new_field ("shipping_address_");
}
struct TdOrderInfo *TdStackFetcherOrderInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdOrderInfo ();
  res->ID = CODE_OrderInfo;
  res->refcnt = 1;
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  M->get_field ("email_address_");
  res->email_address_ = M->get_string ();
  M->pop ();
  M->get_field ("shipping_address_");
  if (M->is_nil ()) {
    res->shipping_address_ = nullptr;
  } else {
    res->shipping_address_ = TdStackFetcherAddress (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::PageBlock> TdConvertToInternal (struct TdPageBlock *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PageBlockTitle: return TdConvertToInternal ((struct TdPageBlockTitle *)var);
    case CODE_PageBlockSubtitle: return TdConvertToInternal ((struct TdPageBlockSubtitle *)var);
    case CODE_PageBlockAuthorDate: return TdConvertToInternal ((struct TdPageBlockAuthorDate *)var);
    case CODE_PageBlockHeader: return TdConvertToInternal ((struct TdPageBlockHeader *)var);
    case CODE_PageBlockSubheader: return TdConvertToInternal ((struct TdPageBlockSubheader *)var);
    case CODE_PageBlockParagraph: return TdConvertToInternal ((struct TdPageBlockParagraph *)var);
    case CODE_PageBlockPreformatted: return TdConvertToInternal ((struct TdPageBlockPreformatted *)var);
    case CODE_PageBlockFooter: return TdConvertToInternal ((struct TdPageBlockFooter *)var);
    case CODE_PageBlockDivider: return TdConvertToInternal ((struct TdPageBlockDivider *)var);
    case CODE_PageBlockAnchor: return TdConvertToInternal ((struct TdPageBlockAnchor *)var);
    case CODE_PageBlockList: return TdConvertToInternal ((struct TdPageBlockList *)var);
    case CODE_PageBlockBlockQuote: return TdConvertToInternal ((struct TdPageBlockBlockQuote *)var);
    case CODE_PageBlockPullQuote: return TdConvertToInternal ((struct TdPageBlockPullQuote *)var);
    case CODE_PageBlockAnimation: return TdConvertToInternal ((struct TdPageBlockAnimation *)var);
    case CODE_PageBlockAudio: return TdConvertToInternal ((struct TdPageBlockAudio *)var);
    case CODE_PageBlockPhoto: return TdConvertToInternal ((struct TdPageBlockPhoto *)var);
    case CODE_PageBlockVideo: return TdConvertToInternal ((struct TdPageBlockVideo *)var);
    case CODE_PageBlockCover: return TdConvertToInternal ((struct TdPageBlockCover *)var);
    case CODE_PageBlockEmbedded: return TdConvertToInternal ((struct TdPageBlockEmbedded *)var);
    case CODE_PageBlockEmbeddedPost: return TdConvertToInternal ((struct TdPageBlockEmbeddedPost *)var);
    case CODE_PageBlockCollage: return TdConvertToInternal ((struct TdPageBlockCollage *)var);
    case CODE_PageBlockSlideshow: return TdConvertToInternal ((struct TdPageBlockSlideshow *)var);
    case CODE_PageBlockChatLink: return TdConvertToInternal ((struct TdPageBlockChatLink *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdPageBlock *TdConvertFromInternal (const td::td_api::PageBlock &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_PageBlockTitle: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockTitle &>(from));
    case CODE_PageBlockSubtitle: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockSubtitle &>(from));
    case CODE_PageBlockAuthorDate: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockAuthorDate &>(from));
    case CODE_PageBlockHeader: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockHeader &>(from));
    case CODE_PageBlockSubheader: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockSubheader &>(from));
    case CODE_PageBlockParagraph: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockParagraph &>(from));
    case CODE_PageBlockPreformatted: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockPreformatted &>(from));
    case CODE_PageBlockFooter: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockFooter &>(from));
    case CODE_PageBlockDivider: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockDivider &>(from));
    case CODE_PageBlockAnchor: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockAnchor &>(from));
    case CODE_PageBlockList: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockList &>(from));
    case CODE_PageBlockBlockQuote: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockBlockQuote &>(from));
    case CODE_PageBlockPullQuote: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockPullQuote &>(from));
    case CODE_PageBlockAnimation: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockAnimation &>(from));
    case CODE_PageBlockAudio: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockAudio &>(from));
    case CODE_PageBlockPhoto: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockPhoto &>(from));
    case CODE_PageBlockVideo: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockVideo &>(from));
    case CODE_PageBlockCover: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockCover &>(from));
    case CODE_PageBlockEmbedded: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockEmbedded &>(from));
    case CODE_PageBlockEmbeddedPost: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockEmbeddedPost &>(from));
    case CODE_PageBlockCollage: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockCollage &>(from));
    case CODE_PageBlockSlideshow: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockSlideshow &>(from));
    case CODE_PageBlockChatLink: return (struct TdPageBlock *)TdConvertFromInternal(static_cast<const td::td_api::pageBlockChatLink &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializePageBlock (struct TdPageBlock *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlock *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlock (struct TdPageBlock *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlock *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PageBlockTitle: return TdDestroyObject ((struct TdPageBlockTitle *)var);
    case CODE_PageBlockSubtitle: return TdDestroyObject ((struct TdPageBlockSubtitle *)var);
    case CODE_PageBlockAuthorDate: return TdDestroyObject ((struct TdPageBlockAuthorDate *)var);
    case CODE_PageBlockHeader: return TdDestroyObject ((struct TdPageBlockHeader *)var);
    case CODE_PageBlockSubheader: return TdDestroyObject ((struct TdPageBlockSubheader *)var);
    case CODE_PageBlockParagraph: return TdDestroyObject ((struct TdPageBlockParagraph *)var);
    case CODE_PageBlockPreformatted: return TdDestroyObject ((struct TdPageBlockPreformatted *)var);
    case CODE_PageBlockFooter: return TdDestroyObject ((struct TdPageBlockFooter *)var);
    case CODE_PageBlockDivider: return TdDestroyObject ((struct TdPageBlockDivider *)var);
    case CODE_PageBlockAnchor: return TdDestroyObject ((struct TdPageBlockAnchor *)var);
    case CODE_PageBlockList: return TdDestroyObject ((struct TdPageBlockList *)var);
    case CODE_PageBlockBlockQuote: return TdDestroyObject ((struct TdPageBlockBlockQuote *)var);
    case CODE_PageBlockPullQuote: return TdDestroyObject ((struct TdPageBlockPullQuote *)var);
    case CODE_PageBlockAnimation: return TdDestroyObject ((struct TdPageBlockAnimation *)var);
    case CODE_PageBlockAudio: return TdDestroyObject ((struct TdPageBlockAudio *)var);
    case CODE_PageBlockPhoto: return TdDestroyObject ((struct TdPageBlockPhoto *)var);
    case CODE_PageBlockVideo: return TdDestroyObject ((struct TdPageBlockVideo *)var);
    case CODE_PageBlockCover: return TdDestroyObject ((struct TdPageBlockCover *)var);
    case CODE_PageBlockEmbedded: return TdDestroyObject ((struct TdPageBlockEmbedded *)var);
    case CODE_PageBlockEmbeddedPost: return TdDestroyObject ((struct TdPageBlockEmbeddedPost *)var);
    case CODE_PageBlockCollage: return TdDestroyObject ((struct TdPageBlockCollage *)var);
    case CODE_PageBlockSlideshow: return TdDestroyObject ((struct TdPageBlockSlideshow *)var);
    case CODE_PageBlockChatLink: return TdDestroyObject ((struct TdPageBlockChatLink *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerPageBlock (struct TdPageBlock *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlock *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PageBlockTitle: return TdStackStorer ((struct TdPageBlockTitle *)var, M);
    case CODE_PageBlockSubtitle: return TdStackStorer ((struct TdPageBlockSubtitle *)var, M);
    case CODE_PageBlockAuthorDate: return TdStackStorer ((struct TdPageBlockAuthorDate *)var, M);
    case CODE_PageBlockHeader: return TdStackStorer ((struct TdPageBlockHeader *)var, M);
    case CODE_PageBlockSubheader: return TdStackStorer ((struct TdPageBlockSubheader *)var, M);
    case CODE_PageBlockParagraph: return TdStackStorer ((struct TdPageBlockParagraph *)var, M);
    case CODE_PageBlockPreformatted: return TdStackStorer ((struct TdPageBlockPreformatted *)var, M);
    case CODE_PageBlockFooter: return TdStackStorer ((struct TdPageBlockFooter *)var, M);
    case CODE_PageBlockDivider: return TdStackStorer ((struct TdPageBlockDivider *)var, M);
    case CODE_PageBlockAnchor: return TdStackStorer ((struct TdPageBlockAnchor *)var, M);
    case CODE_PageBlockList: return TdStackStorer ((struct TdPageBlockList *)var, M);
    case CODE_PageBlockBlockQuote: return TdStackStorer ((struct TdPageBlockBlockQuote *)var, M);
    case CODE_PageBlockPullQuote: return TdStackStorer ((struct TdPageBlockPullQuote *)var, M);
    case CODE_PageBlockAnimation: return TdStackStorer ((struct TdPageBlockAnimation *)var, M);
    case CODE_PageBlockAudio: return TdStackStorer ((struct TdPageBlockAudio *)var, M);
    case CODE_PageBlockPhoto: return TdStackStorer ((struct TdPageBlockPhoto *)var, M);
    case CODE_PageBlockVideo: return TdStackStorer ((struct TdPageBlockVideo *)var, M);
    case CODE_PageBlockCover: return TdStackStorer ((struct TdPageBlockCover *)var, M);
    case CODE_PageBlockEmbedded: return TdStackStorer ((struct TdPageBlockEmbedded *)var, M);
    case CODE_PageBlockEmbeddedPost: return TdStackStorer ((struct TdPageBlockEmbeddedPost *)var, M);
    case CODE_PageBlockCollage: return TdStackStorer ((struct TdPageBlockCollage *)var, M);
    case CODE_PageBlockSlideshow: return TdStackStorer ((struct TdPageBlockSlideshow *)var, M);
    case CODE_PageBlockChatLink: return TdStackStorer ((struct TdPageBlockChatLink *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdPageBlock *TdStackFetcherPageBlock (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "PageBlockTitle") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockTitle (M);
  }
  if (constructor == "PageBlockSubtitle") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockSubtitle (M);
  }
  if (constructor == "PageBlockAuthorDate") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockAuthorDate (M);
  }
  if (constructor == "PageBlockHeader") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockHeader (M);
  }
  if (constructor == "PageBlockSubheader") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockSubheader (M);
  }
  if (constructor == "PageBlockParagraph") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockParagraph (M);
  }
  if (constructor == "PageBlockPreformatted") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockPreformatted (M);
  }
  if (constructor == "PageBlockFooter") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockFooter (M);
  }
  if (constructor == "PageBlockDivider") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockDivider (M);
  }
  if (constructor == "PageBlockAnchor") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockAnchor (M);
  }
  if (constructor == "PageBlockList") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockList (M);
  }
  if (constructor == "PageBlockBlockQuote") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockBlockQuote (M);
  }
  if (constructor == "PageBlockPullQuote") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockPullQuote (M);
  }
  if (constructor == "PageBlockAnimation") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockAnimation (M);
  }
  if (constructor == "PageBlockAudio") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockAudio (M);
  }
  if (constructor == "PageBlockPhoto") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockPhoto (M);
  }
  if (constructor == "PageBlockVideo") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockVideo (M);
  }
  if (constructor == "PageBlockCover") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockCover (M);
  }
  if (constructor == "PageBlockEmbedded") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockEmbedded (M);
  }
  if (constructor == "PageBlockEmbeddedPost") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockEmbeddedPost (M);
  }
  if (constructor == "PageBlockCollage") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockCollage (M);
  }
  if (constructor == "PageBlockSlideshow") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockSlideshow (M);
  }
  if (constructor == "PageBlockChatLink") {
    return (struct TdPageBlock *)TdStackFetcherPageBlockChatLink (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdPageBlockTitle *TdCreateObjectPageBlockTitle (struct TdRichText *title_) {
  auto var = new struct TdPageBlockTitle ();
  var->ID = CODE_PageBlockTitle;
  var->refcnt = 1;
  var->title_ = title_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockTitle> TdConvertToInternal (struct TdPageBlockTitle *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->title_);
  return td::td_api::make_object<td::td_api::pageBlockTitle>(std::move (v0));
}
struct TdPageBlockTitle *TdConvertFromInternal (const td::td_api::pageBlockTitle &from) {
  auto res = new TdPageBlockTitle ();
  res->ID = CODE_PageBlockTitle;
  res->refcnt = 1;
  if (!from.title_) {
    res->title_ = nullptr;
  } else {
    res->title_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.title_));
  }
  return res;
}
char *TdSerializePageBlockTitle (struct TdPageBlockTitle *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockTitle *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockTitle (struct TdPageBlockTitle *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockTitle *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->title_);
  delete var;
}
void TdStackStorerPageBlockTitle (struct TdPageBlockTitle *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockTitle *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockTitle");
  M->new_field ("ID");
  TdStackStorer (var->title_, M);
  M->new_field ("title_");
}
struct TdPageBlockTitle *TdStackFetcherPageBlockTitle (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockTitle ();
  res->ID = CODE_PageBlockTitle;
  res->refcnt = 1;
  M->get_field ("title_");
  if (M->is_nil ()) {
    res->title_ = nullptr;
  } else {
    res->title_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockSubtitle *TdCreateObjectPageBlockSubtitle (struct TdRichText *subtitle_) {
  auto var = new struct TdPageBlockSubtitle ();
  var->ID = CODE_PageBlockSubtitle;
  var->refcnt = 1;
  var->subtitle_ = subtitle_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockSubtitle> TdConvertToInternal (struct TdPageBlockSubtitle *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->subtitle_);
  return td::td_api::make_object<td::td_api::pageBlockSubtitle>(std::move (v0));
}
struct TdPageBlockSubtitle *TdConvertFromInternal (const td::td_api::pageBlockSubtitle &from) {
  auto res = new TdPageBlockSubtitle ();
  res->ID = CODE_PageBlockSubtitle;
  res->refcnt = 1;
  if (!from.subtitle_) {
    res->subtitle_ = nullptr;
  } else {
    res->subtitle_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.subtitle_));
  }
  return res;
}
char *TdSerializePageBlockSubtitle (struct TdPageBlockSubtitle *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockSubtitle *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockSubtitle (struct TdPageBlockSubtitle *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockSubtitle *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->subtitle_);
  delete var;
}
void TdStackStorerPageBlockSubtitle (struct TdPageBlockSubtitle *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockSubtitle *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockSubtitle");
  M->new_field ("ID");
  TdStackStorer (var->subtitle_, M);
  M->new_field ("subtitle_");
}
struct TdPageBlockSubtitle *TdStackFetcherPageBlockSubtitle (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockSubtitle ();
  res->ID = CODE_PageBlockSubtitle;
  res->refcnt = 1;
  M->get_field ("subtitle_");
  if (M->is_nil ()) {
    res->subtitle_ = nullptr;
  } else {
    res->subtitle_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockAuthorDate *TdCreateObjectPageBlockAuthorDate (struct TdRichText *author_, int publish_date_) {
  auto var = new struct TdPageBlockAuthorDate ();
  var->ID = CODE_PageBlockAuthorDate;
  var->refcnt = 1;
  var->author_ = author_;
  var->publish_date_ = publish_date_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockAuthorDate> TdConvertToInternal (struct TdPageBlockAuthorDate *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->author_);
  std::int32_t v100;
  v100 = var->publish_date_;
  return td::td_api::make_object<td::td_api::pageBlockAuthorDate>(std::move (v0), std::move (v100));
}
struct TdPageBlockAuthorDate *TdConvertFromInternal (const td::td_api::pageBlockAuthorDate &from) {
  auto res = new TdPageBlockAuthorDate ();
  res->ID = CODE_PageBlockAuthorDate;
  res->refcnt = 1;
  if (!from.author_) {
    res->author_ = nullptr;
  } else {
    res->author_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.author_));
  }
  res->publish_date_ = from.publish_date_;
  return res;
}
char *TdSerializePageBlockAuthorDate (struct TdPageBlockAuthorDate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockAuthorDate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockAuthorDate (struct TdPageBlockAuthorDate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockAuthorDate *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->author_);
  delete var;
}
void TdStackStorerPageBlockAuthorDate (struct TdPageBlockAuthorDate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockAuthorDate *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockAuthorDate");
  M->new_field ("ID");
  TdStackStorer (var->author_, M);
  M->new_field ("author_");
  M->pack_long (var->publish_date_);
  M->new_field ("publish_date_");
}
struct TdPageBlockAuthorDate *TdStackFetcherPageBlockAuthorDate (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockAuthorDate ();
  res->ID = CODE_PageBlockAuthorDate;
  res->refcnt = 1;
  M->get_field ("author_");
  if (M->is_nil ()) {
    res->author_ = nullptr;
  } else {
    res->author_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("publish_date_");
  res->publish_date_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPageBlockHeader *TdCreateObjectPageBlockHeader (struct TdRichText *header_) {
  auto var = new struct TdPageBlockHeader ();
  var->ID = CODE_PageBlockHeader;
  var->refcnt = 1;
  var->header_ = header_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockHeader> TdConvertToInternal (struct TdPageBlockHeader *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->header_);
  return td::td_api::make_object<td::td_api::pageBlockHeader>(std::move (v0));
}
struct TdPageBlockHeader *TdConvertFromInternal (const td::td_api::pageBlockHeader &from) {
  auto res = new TdPageBlockHeader ();
  res->ID = CODE_PageBlockHeader;
  res->refcnt = 1;
  if (!from.header_) {
    res->header_ = nullptr;
  } else {
    res->header_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.header_));
  }
  return res;
}
char *TdSerializePageBlockHeader (struct TdPageBlockHeader *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockHeader *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockHeader (struct TdPageBlockHeader *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockHeader *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->header_);
  delete var;
}
void TdStackStorerPageBlockHeader (struct TdPageBlockHeader *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockHeader *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockHeader");
  M->new_field ("ID");
  TdStackStorer (var->header_, M);
  M->new_field ("header_");
}
struct TdPageBlockHeader *TdStackFetcherPageBlockHeader (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockHeader ();
  res->ID = CODE_PageBlockHeader;
  res->refcnt = 1;
  M->get_field ("header_");
  if (M->is_nil ()) {
    res->header_ = nullptr;
  } else {
    res->header_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockSubheader *TdCreateObjectPageBlockSubheader (struct TdRichText *subheader_) {
  auto var = new struct TdPageBlockSubheader ();
  var->ID = CODE_PageBlockSubheader;
  var->refcnt = 1;
  var->subheader_ = subheader_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockSubheader> TdConvertToInternal (struct TdPageBlockSubheader *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->subheader_);
  return td::td_api::make_object<td::td_api::pageBlockSubheader>(std::move (v0));
}
struct TdPageBlockSubheader *TdConvertFromInternal (const td::td_api::pageBlockSubheader &from) {
  auto res = new TdPageBlockSubheader ();
  res->ID = CODE_PageBlockSubheader;
  res->refcnt = 1;
  if (!from.subheader_) {
    res->subheader_ = nullptr;
  } else {
    res->subheader_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.subheader_));
  }
  return res;
}
char *TdSerializePageBlockSubheader (struct TdPageBlockSubheader *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockSubheader *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockSubheader (struct TdPageBlockSubheader *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockSubheader *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->subheader_);
  delete var;
}
void TdStackStorerPageBlockSubheader (struct TdPageBlockSubheader *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockSubheader *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockSubheader");
  M->new_field ("ID");
  TdStackStorer (var->subheader_, M);
  M->new_field ("subheader_");
}
struct TdPageBlockSubheader *TdStackFetcherPageBlockSubheader (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockSubheader ();
  res->ID = CODE_PageBlockSubheader;
  res->refcnt = 1;
  M->get_field ("subheader_");
  if (M->is_nil ()) {
    res->subheader_ = nullptr;
  } else {
    res->subheader_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockParagraph *TdCreateObjectPageBlockParagraph (struct TdRichText *text_) {
  auto var = new struct TdPageBlockParagraph ();
  var->ID = CODE_PageBlockParagraph;
  var->refcnt = 1;
  var->text_ = text_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockParagraph> TdConvertToInternal (struct TdPageBlockParagraph *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  return td::td_api::make_object<td::td_api::pageBlockParagraph>(std::move (v0));
}
struct TdPageBlockParagraph *TdConvertFromInternal (const td::td_api::pageBlockParagraph &from) {
  auto res = new TdPageBlockParagraph ();
  res->ID = CODE_PageBlockParagraph;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  return res;
}
char *TdSerializePageBlockParagraph (struct TdPageBlockParagraph *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockParagraph *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockParagraph (struct TdPageBlockParagraph *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockParagraph *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerPageBlockParagraph (struct TdPageBlockParagraph *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockParagraph *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockParagraph");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
}
struct TdPageBlockParagraph *TdStackFetcherPageBlockParagraph (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockParagraph ();
  res->ID = CODE_PageBlockParagraph;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockPreformatted *TdCreateObjectPageBlockPreformatted (struct TdRichText *text_, char *language_) {
  auto var = new struct TdPageBlockPreformatted ();
  var->ID = CODE_PageBlockPreformatted;
  var->refcnt = 1;
  var->text_ = text_;
  var->language_ = (language_) ? td::str_dup (td::Slice (language_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockPreformatted> TdConvertToInternal (struct TdPageBlockPreformatted *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  std::string v100;
  v100 = (var->language_) ? var->language_: "";
  return td::td_api::make_object<td::td_api::pageBlockPreformatted>(std::move (v0), std::move (v100));
}
struct TdPageBlockPreformatted *TdConvertFromInternal (const td::td_api::pageBlockPreformatted &from) {
  auto res = new TdPageBlockPreformatted ();
  res->ID = CODE_PageBlockPreformatted;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  res->language_ = (from.language_.length ()) ? td::str_dup (from.language_) : nullptr;
  return res;
}
char *TdSerializePageBlockPreformatted (struct TdPageBlockPreformatted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockPreformatted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockPreformatted (struct TdPageBlockPreformatted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockPreformatted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  free (var->language_);
  delete var;
}
void TdStackStorerPageBlockPreformatted (struct TdPageBlockPreformatted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockPreformatted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockPreformatted");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  M->pack_string (var->language_);
  M->new_field ("language_");
}
struct TdPageBlockPreformatted *TdStackFetcherPageBlockPreformatted (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockPreformatted ();
  res->ID = CODE_PageBlockPreformatted;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("language_");
  res->language_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPageBlockFooter *TdCreateObjectPageBlockFooter (struct TdRichText *footer_) {
  auto var = new struct TdPageBlockFooter ();
  var->ID = CODE_PageBlockFooter;
  var->refcnt = 1;
  var->footer_ = footer_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockFooter> TdConvertToInternal (struct TdPageBlockFooter *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->footer_);
  return td::td_api::make_object<td::td_api::pageBlockFooter>(std::move (v0));
}
struct TdPageBlockFooter *TdConvertFromInternal (const td::td_api::pageBlockFooter &from) {
  auto res = new TdPageBlockFooter ();
  res->ID = CODE_PageBlockFooter;
  res->refcnt = 1;
  if (!from.footer_) {
    res->footer_ = nullptr;
  } else {
    res->footer_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.footer_));
  }
  return res;
}
char *TdSerializePageBlockFooter (struct TdPageBlockFooter *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockFooter *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockFooter (struct TdPageBlockFooter *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockFooter *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->footer_);
  delete var;
}
void TdStackStorerPageBlockFooter (struct TdPageBlockFooter *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockFooter *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockFooter");
  M->new_field ("ID");
  TdStackStorer (var->footer_, M);
  M->new_field ("footer_");
}
struct TdPageBlockFooter *TdStackFetcherPageBlockFooter (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockFooter ();
  res->ID = CODE_PageBlockFooter;
  res->refcnt = 1;
  M->get_field ("footer_");
  if (M->is_nil ()) {
    res->footer_ = nullptr;
  } else {
    res->footer_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockDivider *TdCreateObjectPageBlockDivider (void) {
  auto var = new struct TdPageBlockDivider ();
  var->ID = CODE_PageBlockDivider;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockDivider> TdConvertToInternal (struct TdPageBlockDivider *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::pageBlockDivider>();
}
struct TdPageBlockDivider *TdConvertFromInternal (const td::td_api::pageBlockDivider &from) {
  auto res = new TdPageBlockDivider ();
  res->ID = CODE_PageBlockDivider;
  res->refcnt = 1;
  return res;
}
char *TdSerializePageBlockDivider (struct TdPageBlockDivider *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockDivider *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockDivider (struct TdPageBlockDivider *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockDivider *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPageBlockDivider (struct TdPageBlockDivider *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockDivider *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockDivider");
  M->new_field ("ID");
}
struct TdPageBlockDivider *TdStackFetcherPageBlockDivider (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockDivider ();
  res->ID = CODE_PageBlockDivider;
  res->refcnt = 1;
  return res;
}
struct TdPageBlockAnchor *TdCreateObjectPageBlockAnchor (char *name_) {
  auto var = new struct TdPageBlockAnchor ();
  var->ID = CODE_PageBlockAnchor;
  var->refcnt = 1;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockAnchor> TdConvertToInternal (struct TdPageBlockAnchor *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->name_) ? var->name_: "";
  return td::td_api::make_object<td::td_api::pageBlockAnchor>(std::move (v0));
}
struct TdPageBlockAnchor *TdConvertFromInternal (const td::td_api::pageBlockAnchor &from) {
  auto res = new TdPageBlockAnchor ();
  res->ID = CODE_PageBlockAnchor;
  res->refcnt = 1;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  return res;
}
char *TdSerializePageBlockAnchor (struct TdPageBlockAnchor *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockAnchor *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockAnchor (struct TdPageBlockAnchor *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockAnchor *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->name_);
  delete var;
}
void TdStackStorerPageBlockAnchor (struct TdPageBlockAnchor *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockAnchor *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockAnchor");
  M->new_field ("ID");
  M->pack_string (var->name_);
  M->new_field ("name_");
}
struct TdPageBlockAnchor *TdStackFetcherPageBlockAnchor (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockAnchor ();
  res->ID = CODE_PageBlockAnchor;
  res->refcnt = 1;
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPageBlockList *TdCreateObjectPageBlockList (struct TdVectorRichText *items_, int is_ordered_) {
  auto var = new struct TdPageBlockList ();
  var->ID = CODE_PageBlockList;
  var->refcnt = 1;
  var->items_ = items_;
  var->is_ordered_ = is_ordered_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockList> TdConvertToInternal (struct TdPageBlockList *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::RichText>> v0;
  for (int i0 = 0; i0 < var->items_->len; i0++) {
    td::td_api::object_ptr<td::td_api::RichText> v1;
    v1 = TdConvertToInternal (var->items_->data[i0]);
    v0.push_back (std::move (v1));
  }
  bool v100;
  v100 = var->is_ordered_ != 0;
  return td::td_api::make_object<td::td_api::pageBlockList>(std::move (v0), std::move (v100));
}
struct TdPageBlockList *TdConvertFromInternal (const td::td_api::pageBlockList &from) {
  auto res = new TdPageBlockList ();
  res->ID = CODE_PageBlockList;
  res->refcnt = 1;
  res->items_ = new TdVectorRichText ();
  res->items_->len = (int)from.items_.size ();
  res->items_->data = new struct TdRichText * [res->items_->len];
  for (int i0 = 0; i0 < res->items_->len; i0++) {
    if (!from.items_[i0]) {
      res->items_->data[i0] = nullptr;
    } else {
      res->items_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.items_[i0]));
    }
  }
  res->is_ordered_ = from.is_ordered_;
  return res;
}
char *TdSerializePageBlockList (struct TdPageBlockList *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockList *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockList (struct TdPageBlockList *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockList *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->items_->len; i0++) {
    TdDestroyObject (var->items_->data[i0]);
  }
  delete[] var->items_->data;
  delete var->items_;
  delete var;
}
void TdStackStorerPageBlockList (struct TdPageBlockList *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockList *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockList");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->items_->len; i0++) {
    TdStackStorer (var->items_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("items_");
  M->pack_bool (var->is_ordered_);
  M->new_field ("is_ordered_");
}
struct TdPageBlockList *TdStackFetcherPageBlockList (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockList ();
  res->ID = CODE_PageBlockList;
  res->refcnt = 1;
  M->get_field ("items_");
  res->items_ = new TdVectorRichText ();
  res->items_->len = M->get_arr_size ();
  res->items_->data = new struct TdRichText * [res->items_->len];
  for (int i0 = 0; i0 < res->items_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->items_->data[i0] = nullptr;
    } else {
      res->items_->data[i0] = TdStackFetcherRichText (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("is_ordered_");
  res->is_ordered_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPageBlockBlockQuote *TdCreateObjectPageBlockBlockQuote (struct TdRichText *text_, struct TdRichText *caption_) {
  auto var = new struct TdPageBlockBlockQuote ();
  var->ID = CODE_PageBlockBlockQuote;
  var->refcnt = 1;
  var->text_ = text_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockBlockQuote> TdConvertToInternal (struct TdPageBlockBlockQuote *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  td::td_api::object_ptr<td::td_api::RichText> v100;
  v100 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::pageBlockBlockQuote>(std::move (v0), std::move (v100));
}
struct TdPageBlockBlockQuote *TdConvertFromInternal (const td::td_api::pageBlockBlockQuote &from) {
  auto res = new TdPageBlockBlockQuote ();
  res->ID = CODE_PageBlockBlockQuote;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  return res;
}
char *TdSerializePageBlockBlockQuote (struct TdPageBlockBlockQuote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockBlockQuote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockBlockQuote (struct TdPageBlockBlockQuote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockBlockQuote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockBlockQuote (struct TdPageBlockBlockQuote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockBlockQuote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockBlockQuote");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdPageBlockBlockQuote *TdStackFetcherPageBlockBlockQuote (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockBlockQuote ();
  res->ID = CODE_PageBlockBlockQuote;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockPullQuote *TdCreateObjectPageBlockPullQuote (struct TdRichText *text_, struct TdRichText *caption_) {
  auto var = new struct TdPageBlockPullQuote ();
  var->ID = CODE_PageBlockPullQuote;
  var->refcnt = 1;
  var->text_ = text_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockPullQuote> TdConvertToInternal (struct TdPageBlockPullQuote *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  td::td_api::object_ptr<td::td_api::RichText> v100;
  v100 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::pageBlockPullQuote>(std::move (v0), std::move (v100));
}
struct TdPageBlockPullQuote *TdConvertFromInternal (const td::td_api::pageBlockPullQuote &from) {
  auto res = new TdPageBlockPullQuote ();
  res->ID = CODE_PageBlockPullQuote;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  return res;
}
char *TdSerializePageBlockPullQuote (struct TdPageBlockPullQuote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockPullQuote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockPullQuote (struct TdPageBlockPullQuote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockPullQuote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockPullQuote (struct TdPageBlockPullQuote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockPullQuote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockPullQuote");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdPageBlockPullQuote *TdStackFetcherPageBlockPullQuote (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockPullQuote ();
  res->ID = CODE_PageBlockPullQuote;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockAnimation *TdCreateObjectPageBlockAnimation (struct TdAnimation *animation_, struct TdRichText *caption_, int need_autoplay_) {
  auto var = new struct TdPageBlockAnimation ();
  var->ID = CODE_PageBlockAnimation;
  var->refcnt = 1;
  var->animation_ = animation_;
  var->caption_ = caption_;
  var->need_autoplay_ = need_autoplay_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockAnimation> TdConvertToInternal (struct TdPageBlockAnimation *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::animation> v0;
  v0 = TdConvertToInternal (var->animation_);
  td::td_api::object_ptr<td::td_api::RichText> v100;
  v100 = TdConvertToInternal (var->caption_);
  bool v200;
  v200 = var->need_autoplay_ != 0;
  return td::td_api::make_object<td::td_api::pageBlockAnimation>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdPageBlockAnimation *TdConvertFromInternal (const td::td_api::pageBlockAnimation &from) {
  auto res = new TdPageBlockAnimation ();
  res->ID = CODE_PageBlockAnimation;
  res->refcnt = 1;
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::animation &>(*from.animation_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  res->need_autoplay_ = from.need_autoplay_;
  return res;
}
char *TdSerializePageBlockAnimation (struct TdPageBlockAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockAnimation (struct TdPageBlockAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->animation_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockAnimation (struct TdPageBlockAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockAnimation");
  M->new_field ("ID");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_bool (var->need_autoplay_);
  M->new_field ("need_autoplay_");
}
struct TdPageBlockAnimation *TdStackFetcherPageBlockAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockAnimation ();
  res->ID = CODE_PageBlockAnimation;
  res->refcnt = 1;
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherAnimation (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("need_autoplay_");
  res->need_autoplay_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPageBlockAudio *TdCreateObjectPageBlockAudio (struct TdAudio *audio_, struct TdRichText *caption_) {
  auto var = new struct TdPageBlockAudio ();
  var->ID = CODE_PageBlockAudio;
  var->refcnt = 1;
  var->audio_ = audio_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockAudio> TdConvertToInternal (struct TdPageBlockAudio *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::audio> v0;
  v0 = TdConvertToInternal (var->audio_);
  td::td_api::object_ptr<td::td_api::RichText> v100;
  v100 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::pageBlockAudio>(std::move (v0), std::move (v100));
}
struct TdPageBlockAudio *TdConvertFromInternal (const td::td_api::pageBlockAudio &from) {
  auto res = new TdPageBlockAudio ();
  res->ID = CODE_PageBlockAudio;
  res->refcnt = 1;
  if (!from.audio_) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdConvertFromInternal (static_cast<const td::td_api::audio &>(*from.audio_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  return res;
}
char *TdSerializePageBlockAudio (struct TdPageBlockAudio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockAudio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockAudio (struct TdPageBlockAudio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockAudio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->audio_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockAudio (struct TdPageBlockAudio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockAudio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockAudio");
  M->new_field ("ID");
  TdStackStorer (var->audio_, M);
  M->new_field ("audio_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdPageBlockAudio *TdStackFetcherPageBlockAudio (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockAudio ();
  res->ID = CODE_PageBlockAudio;
  res->refcnt = 1;
  M->get_field ("audio_");
  if (M->is_nil ()) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdStackFetcherAudio (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockPhoto *TdCreateObjectPageBlockPhoto (struct TdPhoto *photo_, struct TdRichText *caption_) {
  auto var = new struct TdPageBlockPhoto ();
  var->ID = CODE_PageBlockPhoto;
  var->refcnt = 1;
  var->photo_ = photo_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockPhoto> TdConvertToInternal (struct TdPageBlockPhoto *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::photo> v0;
  v0 = TdConvertToInternal (var->photo_);
  td::td_api::object_ptr<td::td_api::RichText> v100;
  v100 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::pageBlockPhoto>(std::move (v0), std::move (v100));
}
struct TdPageBlockPhoto *TdConvertFromInternal (const td::td_api::pageBlockPhoto &from) {
  auto res = new TdPageBlockPhoto ();
  res->ID = CODE_PageBlockPhoto;
  res->refcnt = 1;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.photo_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  return res;
}
char *TdSerializePageBlockPhoto (struct TdPageBlockPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockPhoto (struct TdPageBlockPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->photo_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockPhoto (struct TdPageBlockPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockPhoto");
  M->new_field ("ID");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdPageBlockPhoto *TdStackFetcherPageBlockPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockPhoto ();
  res->ID = CODE_PageBlockPhoto;
  res->refcnt = 1;
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockVideo *TdCreateObjectPageBlockVideo (struct TdVideo *video_, struct TdRichText *caption_, int need_autoplay_, int is_looped_) {
  auto var = new struct TdPageBlockVideo ();
  var->ID = CODE_PageBlockVideo;
  var->refcnt = 1;
  var->video_ = video_;
  var->caption_ = caption_;
  var->need_autoplay_ = need_autoplay_;
  var->is_looped_ = is_looped_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockVideo> TdConvertToInternal (struct TdPageBlockVideo *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::video> v0;
  v0 = TdConvertToInternal (var->video_);
  td::td_api::object_ptr<td::td_api::RichText> v100;
  v100 = TdConvertToInternal (var->caption_);
  bool v200;
  v200 = var->need_autoplay_ != 0;
  bool v300;
  v300 = var->is_looped_ != 0;
  return td::td_api::make_object<td::td_api::pageBlockVideo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdPageBlockVideo *TdConvertFromInternal (const td::td_api::pageBlockVideo &from) {
  auto res = new TdPageBlockVideo ();
  res->ID = CODE_PageBlockVideo;
  res->refcnt = 1;
  if (!from.video_) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdConvertFromInternal (static_cast<const td::td_api::video &>(*from.video_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  res->need_autoplay_ = from.need_autoplay_;
  res->is_looped_ = from.is_looped_;
  return res;
}
char *TdSerializePageBlockVideo (struct TdPageBlockVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockVideo (struct TdPageBlockVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->video_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockVideo (struct TdPageBlockVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockVideo");
  M->new_field ("ID");
  TdStackStorer (var->video_, M);
  M->new_field ("video_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_bool (var->need_autoplay_);
  M->new_field ("need_autoplay_");
  M->pack_bool (var->is_looped_);
  M->new_field ("is_looped_");
}
struct TdPageBlockVideo *TdStackFetcherPageBlockVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockVideo ();
  res->ID = CODE_PageBlockVideo;
  res->refcnt = 1;
  M->get_field ("video_");
  if (M->is_nil ()) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdStackFetcherVideo (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("need_autoplay_");
  res->need_autoplay_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_looped_");
  res->is_looped_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPageBlockCover *TdCreateObjectPageBlockCover (struct TdPageBlock *cover_) {
  auto var = new struct TdPageBlockCover ();
  var->ID = CODE_PageBlockCover;
  var->refcnt = 1;
  var->cover_ = cover_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockCover> TdConvertToInternal (struct TdPageBlockCover *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::PageBlock> v0;
  v0 = TdConvertToInternal (var->cover_);
  return td::td_api::make_object<td::td_api::pageBlockCover>(std::move (v0));
}
struct TdPageBlockCover *TdConvertFromInternal (const td::td_api::pageBlockCover &from) {
  auto res = new TdPageBlockCover ();
  res->ID = CODE_PageBlockCover;
  res->refcnt = 1;
  if (!from.cover_) {
    res->cover_ = nullptr;
  } else {
    res->cover_ = TdConvertFromInternal (static_cast<const td::td_api::PageBlock &>(*from.cover_));
  }
  return res;
}
char *TdSerializePageBlockCover (struct TdPageBlockCover *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockCover *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockCover (struct TdPageBlockCover *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockCover *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->cover_);
  delete var;
}
void TdStackStorerPageBlockCover (struct TdPageBlockCover *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockCover *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockCover");
  M->new_field ("ID");
  TdStackStorer (var->cover_, M);
  M->new_field ("cover_");
}
struct TdPageBlockCover *TdStackFetcherPageBlockCover (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockCover ();
  res->ID = CODE_PageBlockCover;
  res->refcnt = 1;
  M->get_field ("cover_");
  if (M->is_nil ()) {
    res->cover_ = nullptr;
  } else {
    res->cover_ = TdStackFetcherPageBlock (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockEmbedded *TdCreateObjectPageBlockEmbedded (char *url_, char *html_, struct TdPhoto *poster_photo_, int width_, int height_, struct TdRichText *caption_, int is_full_width_, int allow_scrolling_) {
  auto var = new struct TdPageBlockEmbedded ();
  var->ID = CODE_PageBlockEmbedded;
  var->refcnt = 1;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->html_ = (html_) ? td::str_dup (td::Slice (html_)) : nullptr;
  var->poster_photo_ = poster_photo_;
  var->width_ = width_;
  var->height_ = height_;
  var->caption_ = caption_;
  var->is_full_width_ = is_full_width_;
  var->allow_scrolling_ = allow_scrolling_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockEmbedded> TdConvertToInternal (struct TdPageBlockEmbedded *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->url_) ? var->url_: "";
  std::string v100;
  v100 = (var->html_) ? var->html_: "";
  td::td_api::object_ptr<td::td_api::photo> v200;
  v200 = TdConvertToInternal (var->poster_photo_);
  std::int32_t v300;
  v300 = var->width_;
  std::int32_t v400;
  v400 = var->height_;
  td::td_api::object_ptr<td::td_api::RichText> v500;
  v500 = TdConvertToInternal (var->caption_);
  bool v600;
  v600 = var->is_full_width_ != 0;
  bool v700;
  v700 = var->allow_scrolling_ != 0;
  return td::td_api::make_object<td::td_api::pageBlockEmbedded>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700));
}
struct TdPageBlockEmbedded *TdConvertFromInternal (const td::td_api::pageBlockEmbedded &from) {
  auto res = new TdPageBlockEmbedded ();
  res->ID = CODE_PageBlockEmbedded;
  res->refcnt = 1;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  res->html_ = (from.html_.length ()) ? td::str_dup (from.html_) : nullptr;
  if (!from.poster_photo_) {
    res->poster_photo_ = nullptr;
  } else {
    res->poster_photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.poster_photo_));
  }
  res->width_ = from.width_;
  res->height_ = from.height_;
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  res->is_full_width_ = from.is_full_width_;
  res->allow_scrolling_ = from.allow_scrolling_;
  return res;
}
char *TdSerializePageBlockEmbedded (struct TdPageBlockEmbedded *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockEmbedded *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockEmbedded (struct TdPageBlockEmbedded *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockEmbedded *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->url_);
  free (var->html_);
  TdDestroyObject (var->poster_photo_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockEmbedded (struct TdPageBlockEmbedded *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockEmbedded *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockEmbedded");
  M->new_field ("ID");
  M->pack_string (var->url_);
  M->new_field ("url_");
  M->pack_string (var->html_);
  M->new_field ("html_");
  TdStackStorer (var->poster_photo_, M);
  M->new_field ("poster_photo_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
  M->pack_bool (var->is_full_width_);
  M->new_field ("is_full_width_");
  M->pack_bool (var->allow_scrolling_);
  M->new_field ("allow_scrolling_");
}
struct TdPageBlockEmbedded *TdStackFetcherPageBlockEmbedded (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockEmbedded ();
  res->ID = CODE_PageBlockEmbedded;
  res->refcnt = 1;
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("html_");
  res->html_ = M->get_string ();
  M->pop ();
  M->get_field ("poster_photo_");
  if (M->is_nil ()) {
    res->poster_photo_ = nullptr;
  } else {
    res->poster_photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("is_full_width_");
  res->is_full_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("allow_scrolling_");
  res->allow_scrolling_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPageBlockEmbeddedPost *TdCreateObjectPageBlockEmbeddedPost (char *url_, char *author_, struct TdPhoto *author_photo_, int date_, struct TdVectorPageBlock *page_blocks_, struct TdRichText *caption_) {
  auto var = new struct TdPageBlockEmbeddedPost ();
  var->ID = CODE_PageBlockEmbeddedPost;
  var->refcnt = 1;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->author_ = (author_) ? td::str_dup (td::Slice (author_)) : nullptr;
  var->author_photo_ = author_photo_;
  var->date_ = date_;
  var->page_blocks_ = page_blocks_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockEmbeddedPost> TdConvertToInternal (struct TdPageBlockEmbeddedPost *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->url_) ? var->url_: "";
  std::string v100;
  v100 = (var->author_) ? var->author_: "";
  td::td_api::object_ptr<td::td_api::photo> v200;
  v200 = TdConvertToInternal (var->author_photo_);
  std::int32_t v300;
  v300 = var->date_;
  std::vector<td::td_api::object_ptr<td::td_api::PageBlock>> v400;
  for (int i400 = 0; i400 < var->page_blocks_->len; i400++) {
    td::td_api::object_ptr<td::td_api::PageBlock> v401;
    v401 = TdConvertToInternal (var->page_blocks_->data[i400]);
    v400.push_back (std::move (v401));
  }
  td::td_api::object_ptr<td::td_api::RichText> v500;
  v500 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::pageBlockEmbeddedPost>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdPageBlockEmbeddedPost *TdConvertFromInternal (const td::td_api::pageBlockEmbeddedPost &from) {
  auto res = new TdPageBlockEmbeddedPost ();
  res->ID = CODE_PageBlockEmbeddedPost;
  res->refcnt = 1;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  res->author_ = (from.author_.length ()) ? td::str_dup (from.author_) : nullptr;
  if (!from.author_photo_) {
    res->author_photo_ = nullptr;
  } else {
    res->author_photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.author_photo_));
  }
  res->date_ = from.date_;
  res->page_blocks_ = new TdVectorPageBlock ();
  res->page_blocks_->len = (int)from.page_blocks_.size ();
  res->page_blocks_->data = new struct TdPageBlock * [res->page_blocks_->len];
  for (int i400 = 0; i400 < res->page_blocks_->len; i400++) {
    if (!from.page_blocks_[i400]) {
      res->page_blocks_->data[i400] = nullptr;
    } else {
      res->page_blocks_->data[i400] = TdConvertFromInternal (static_cast<const td::td_api::PageBlock &>(*from.page_blocks_[i400]));
    }
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  return res;
}
char *TdSerializePageBlockEmbeddedPost (struct TdPageBlockEmbeddedPost *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockEmbeddedPost *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockEmbeddedPost (struct TdPageBlockEmbeddedPost *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockEmbeddedPost *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->url_);
  free (var->author_);
  TdDestroyObject (var->author_photo_);
  for (int i400 = 0; i400 < var->page_blocks_->len; i400++) {
    TdDestroyObject (var->page_blocks_->data[i400]);
  }
  delete[] var->page_blocks_->data;
  delete var->page_blocks_;
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockEmbeddedPost (struct TdPageBlockEmbeddedPost *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockEmbeddedPost *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockEmbeddedPost");
  M->new_field ("ID");
  M->pack_string (var->url_);
  M->new_field ("url_");
  M->pack_string (var->author_);
  M->new_field ("author_");
  TdStackStorer (var->author_photo_, M);
  M->new_field ("author_photo_");
  M->pack_long (var->date_);
  M->new_field ("date_");
  M->new_array ();
  for (int i400 = 0; i400 < var->page_blocks_->len; i400++) {
    TdStackStorer (var->page_blocks_->data[i400], M);
    M->new_arr_field (i400);
  }
  M->new_field ("page_blocks_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdPageBlockEmbeddedPost *TdStackFetcherPageBlockEmbeddedPost (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockEmbeddedPost ();
  res->ID = CODE_PageBlockEmbeddedPost;
  res->refcnt = 1;
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("author_");
  res->author_ = M->get_string ();
  M->pop ();
  M->get_field ("author_photo_");
  if (M->is_nil ()) {
    res->author_photo_ = nullptr;
  } else {
    res->author_photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("page_blocks_");
  res->page_blocks_ = new TdVectorPageBlock ();
  res->page_blocks_->len = M->get_arr_size ();
  res->page_blocks_->data = new struct TdPageBlock * [res->page_blocks_->len];
  for (int i400 = 0; i400 < res->page_blocks_->len; i400++) {
    M->get_arr_field (i400);
    if (M->is_nil ()) {
      res->page_blocks_->data[i400] = nullptr;
    } else {
      res->page_blocks_->data[i400] = TdStackFetcherPageBlock (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockCollage *TdCreateObjectPageBlockCollage (struct TdVectorPageBlock *page_blocks_, struct TdRichText *caption_) {
  auto var = new struct TdPageBlockCollage ();
  var->ID = CODE_PageBlockCollage;
  var->refcnt = 1;
  var->page_blocks_ = page_blocks_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockCollage> TdConvertToInternal (struct TdPageBlockCollage *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::PageBlock>> v0;
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    td::td_api::object_ptr<td::td_api::PageBlock> v1;
    v1 = TdConvertToInternal (var->page_blocks_->data[i0]);
    v0.push_back (std::move (v1));
  }
  td::td_api::object_ptr<td::td_api::RichText> v100;
  v100 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::pageBlockCollage>(std::move (v0), std::move (v100));
}
struct TdPageBlockCollage *TdConvertFromInternal (const td::td_api::pageBlockCollage &from) {
  auto res = new TdPageBlockCollage ();
  res->ID = CODE_PageBlockCollage;
  res->refcnt = 1;
  res->page_blocks_ = new TdVectorPageBlock ();
  res->page_blocks_->len = (int)from.page_blocks_.size ();
  res->page_blocks_->data = new struct TdPageBlock * [res->page_blocks_->len];
  for (int i0 = 0; i0 < res->page_blocks_->len; i0++) {
    if (!from.page_blocks_[i0]) {
      res->page_blocks_->data[i0] = nullptr;
    } else {
      res->page_blocks_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::PageBlock &>(*from.page_blocks_[i0]));
    }
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  return res;
}
char *TdSerializePageBlockCollage (struct TdPageBlockCollage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockCollage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockCollage (struct TdPageBlockCollage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockCollage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    TdDestroyObject (var->page_blocks_->data[i0]);
  }
  delete[] var->page_blocks_->data;
  delete var->page_blocks_;
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockCollage (struct TdPageBlockCollage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockCollage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockCollage");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    TdStackStorer (var->page_blocks_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("page_blocks_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdPageBlockCollage *TdStackFetcherPageBlockCollage (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockCollage ();
  res->ID = CODE_PageBlockCollage;
  res->refcnt = 1;
  M->get_field ("page_blocks_");
  res->page_blocks_ = new TdVectorPageBlock ();
  res->page_blocks_->len = M->get_arr_size ();
  res->page_blocks_->data = new struct TdPageBlock * [res->page_blocks_->len];
  for (int i0 = 0; i0 < res->page_blocks_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->page_blocks_->data[i0] = nullptr;
    } else {
      res->page_blocks_->data[i0] = TdStackFetcherPageBlock (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockSlideshow *TdCreateObjectPageBlockSlideshow (struct TdVectorPageBlock *page_blocks_, struct TdRichText *caption_) {
  auto var = new struct TdPageBlockSlideshow ();
  var->ID = CODE_PageBlockSlideshow;
  var->refcnt = 1;
  var->page_blocks_ = page_blocks_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockSlideshow> TdConvertToInternal (struct TdPageBlockSlideshow *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::PageBlock>> v0;
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    td::td_api::object_ptr<td::td_api::PageBlock> v1;
    v1 = TdConvertToInternal (var->page_blocks_->data[i0]);
    v0.push_back (std::move (v1));
  }
  td::td_api::object_ptr<td::td_api::RichText> v100;
  v100 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::pageBlockSlideshow>(std::move (v0), std::move (v100));
}
struct TdPageBlockSlideshow *TdConvertFromInternal (const td::td_api::pageBlockSlideshow &from) {
  auto res = new TdPageBlockSlideshow ();
  res->ID = CODE_PageBlockSlideshow;
  res->refcnt = 1;
  res->page_blocks_ = new TdVectorPageBlock ();
  res->page_blocks_->len = (int)from.page_blocks_.size ();
  res->page_blocks_->data = new struct TdPageBlock * [res->page_blocks_->len];
  for (int i0 = 0; i0 < res->page_blocks_->len; i0++) {
    if (!from.page_blocks_[i0]) {
      res->page_blocks_->data[i0] = nullptr;
    } else {
      res->page_blocks_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::PageBlock &>(*from.page_blocks_[i0]));
    }
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.caption_));
  }
  return res;
}
char *TdSerializePageBlockSlideshow (struct TdPageBlockSlideshow *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockSlideshow *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockSlideshow (struct TdPageBlockSlideshow *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockSlideshow *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    TdDestroyObject (var->page_blocks_->data[i0]);
  }
  delete[] var->page_blocks_->data;
  delete var->page_blocks_;
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerPageBlockSlideshow (struct TdPageBlockSlideshow *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockSlideshow *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockSlideshow");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    TdStackStorer (var->page_blocks_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("page_blocks_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdPageBlockSlideshow *TdStackFetcherPageBlockSlideshow (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockSlideshow ();
  res->ID = CODE_PageBlockSlideshow;
  res->refcnt = 1;
  M->get_field ("page_blocks_");
  res->page_blocks_ = new TdVectorPageBlock ();
  res->page_blocks_->len = M->get_arr_size ();
  res->page_blocks_->data = new struct TdPageBlock * [res->page_blocks_->len];
  for (int i0 = 0; i0 < res->page_blocks_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->page_blocks_->data[i0] = nullptr;
    } else {
      res->page_blocks_->data[i0] = TdStackFetcherPageBlock (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdPageBlockChatLink *TdCreateObjectPageBlockChatLink (char *title_, struct TdChatPhoto *photo_, char *username_) {
  auto var = new struct TdPageBlockChatLink ();
  var->ID = CODE_PageBlockChatLink;
  var->refcnt = 1;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->photo_ = photo_;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::pageBlockChatLink> TdConvertToInternal (struct TdPageBlockChatLink *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->title_) ? var->title_: "";
  td::td_api::object_ptr<td::td_api::chatPhoto> v100;
  v100 = TdConvertToInternal (var->photo_);
  std::string v200;
  v200 = (var->username_) ? var->username_: "";
  return td::td_api::make_object<td::td_api::pageBlockChatLink>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdPageBlockChatLink *TdConvertFromInternal (const td::td_api::pageBlockChatLink &from) {
  auto res = new TdPageBlockChatLink ();
  res->ID = CODE_PageBlockChatLink;
  res->refcnt = 1;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::chatPhoto &>(*from.photo_));
  }
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  return res;
}
char *TdSerializePageBlockChatLink (struct TdPageBlockChatLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPageBlockChatLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPageBlockChatLink (struct TdPageBlockChatLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPageBlockChatLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  TdDestroyObject (var->photo_);
  free (var->username_);
  delete var;
}
void TdStackStorerPageBlockChatLink (struct TdPageBlockChatLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPageBlockChatLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PageBlockChatLink");
  M->new_field ("ID");
  M->pack_string (var->title_);
  M->new_field ("title_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  M->pack_string (var->username_);
  M->new_field ("username_");
}
struct TdPageBlockChatLink *TdStackFetcherPageBlockChatLink (struct TdStackFetcherMethods *M) {
  auto res = new TdPageBlockChatLink ();
  res->ID = CODE_PageBlockChatLink;
  res->refcnt = 1;
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherChatPhoto (M);
  }
  M->pop ();
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPassportAuthorizationForm *TdCreateObjectPassportAuthorizationForm (int id_, struct TdVectorPassportRequiredElement *required_elements_, struct TdVectorPassportElement *elements_, struct TdVectorPassportElementError *errors_, char *privacy_policy_url_) {
  auto var = new struct TdPassportAuthorizationForm ();
  var->ID = CODE_PassportAuthorizationForm;
  var->refcnt = 1;
  var->id_ = id_;
  var->required_elements_ = required_elements_;
  var->elements_ = elements_;
  var->errors_ = errors_;
  var->privacy_policy_url_ = (privacy_policy_url_) ? td::str_dup (td::Slice (privacy_policy_url_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::passportAuthorizationForm> TdConvertToInternal (struct TdPassportAuthorizationForm *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::vector<td::td_api::object_ptr<td::td_api::passportRequiredElement>> v100;
  for (int i100 = 0; i100 < var->required_elements_->len; i100++) {
    td::td_api::object_ptr<td::td_api::passportRequiredElement> v101;
    v101 = TdConvertToInternal (var->required_elements_->data[i100]);
    v100.push_back (std::move (v101));
  }
  std::vector<td::td_api::object_ptr<td::td_api::PassportElement>> v200;
  for (int i200 = 0; i200 < var->elements_->len; i200++) {
    td::td_api::object_ptr<td::td_api::PassportElement> v201;
    v201 = TdConvertToInternal (var->elements_->data[i200]);
    v200.push_back (std::move (v201));
  }
  std::vector<td::td_api::object_ptr<td::td_api::passportElementError>> v300;
  for (int i300 = 0; i300 < var->errors_->len; i300++) {
    td::td_api::object_ptr<td::td_api::passportElementError> v301;
    v301 = TdConvertToInternal (var->errors_->data[i300]);
    v300.push_back (std::move (v301));
  }
  std::string v400;
  v400 = (var->privacy_policy_url_) ? var->privacy_policy_url_: "";
  return td::td_api::make_object<td::td_api::passportAuthorizationForm>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdPassportAuthorizationForm *TdConvertFromInternal (const td::td_api::passportAuthorizationForm &from) {
  auto res = new TdPassportAuthorizationForm ();
  res->ID = CODE_PassportAuthorizationForm;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->required_elements_ = new TdVectorPassportRequiredElement ();
  res->required_elements_->len = (int)from.required_elements_.size ();
  res->required_elements_->data = new struct TdPassportRequiredElement * [res->required_elements_->len];
  for (int i100 = 0; i100 < res->required_elements_->len; i100++) {
    if (!from.required_elements_[i100]) {
      res->required_elements_->data[i100] = nullptr;
    } else {
      res->required_elements_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::passportRequiredElement &>(*from.required_elements_[i100]));
    }
  }
  res->elements_ = new TdVectorPassportElement ();
  res->elements_->len = (int)from.elements_.size ();
  res->elements_->data = new struct TdPassportElement * [res->elements_->len];
  for (int i200 = 0; i200 < res->elements_->len; i200++) {
    if (!from.elements_[i200]) {
      res->elements_->data[i200] = nullptr;
    } else {
      res->elements_->data[i200] = TdConvertFromInternal (static_cast<const td::td_api::PassportElement &>(*from.elements_[i200]));
    }
  }
  res->errors_ = new TdVectorPassportElementError ();
  res->errors_->len = (int)from.errors_.size ();
  res->errors_->data = new struct TdPassportElementError * [res->errors_->len];
  for (int i300 = 0; i300 < res->errors_->len; i300++) {
    if (!from.errors_[i300]) {
      res->errors_->data[i300] = nullptr;
    } else {
      res->errors_->data[i300] = TdConvertFromInternal (static_cast<const td::td_api::passportElementError &>(*from.errors_[i300]));
    }
  }
  res->privacy_policy_url_ = (from.privacy_policy_url_.length ()) ? td::str_dup (from.privacy_policy_url_) : nullptr;
  return res;
}
char *TdSerializePassportAuthorizationForm (struct TdPassportAuthorizationForm *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportAuthorizationForm *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportAuthorizationForm (struct TdPassportAuthorizationForm *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportAuthorizationForm *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->required_elements_->len; i100++) {
    TdDestroyObject (var->required_elements_->data[i100]);
  }
  delete[] var->required_elements_->data;
  delete var->required_elements_;
  for (int i200 = 0; i200 < var->elements_->len; i200++) {
    TdDestroyObject (var->elements_->data[i200]);
  }
  delete[] var->elements_->data;
  delete var->elements_;
  for (int i300 = 0; i300 < var->errors_->len; i300++) {
    TdDestroyObject (var->errors_->data[i300]);
  }
  delete[] var->errors_->data;
  delete var->errors_;
  free (var->privacy_policy_url_);
  delete var;
}
void TdStackStorerPassportAuthorizationForm (struct TdPassportAuthorizationForm *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportAuthorizationForm *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportAuthorizationForm");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->required_elements_->len; i100++) {
    TdStackStorer (var->required_elements_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("required_elements_");
  M->new_array ();
  for (int i200 = 0; i200 < var->elements_->len; i200++) {
    TdStackStorer (var->elements_->data[i200], M);
    M->new_arr_field (i200);
  }
  M->new_field ("elements_");
  M->new_array ();
  for (int i300 = 0; i300 < var->errors_->len; i300++) {
    TdStackStorer (var->errors_->data[i300], M);
    M->new_arr_field (i300);
  }
  M->new_field ("errors_");
  M->pack_string (var->privacy_policy_url_);
  M->new_field ("privacy_policy_url_");
}
struct TdPassportAuthorizationForm *TdStackFetcherPassportAuthorizationForm (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportAuthorizationForm ();
  res->ID = CODE_PassportAuthorizationForm;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("required_elements_");
  res->required_elements_ = new TdVectorPassportRequiredElement ();
  res->required_elements_->len = M->get_arr_size ();
  res->required_elements_->data = new struct TdPassportRequiredElement * [res->required_elements_->len];
  for (int i100 = 0; i100 < res->required_elements_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->required_elements_->data[i100] = nullptr;
    } else {
      res->required_elements_->data[i100] = TdStackFetcherPassportRequiredElement (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("elements_");
  res->elements_ = new TdVectorPassportElement ();
  res->elements_->len = M->get_arr_size ();
  res->elements_->data = new struct TdPassportElement * [res->elements_->len];
  for (int i200 = 0; i200 < res->elements_->len; i200++) {
    M->get_arr_field (i200);
    if (M->is_nil ()) {
      res->elements_->data[i200] = nullptr;
    } else {
      res->elements_->data[i200] = TdStackFetcherPassportElement (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("errors_");
  res->errors_ = new TdVectorPassportElementError ();
  res->errors_->len = M->get_arr_size ();
  res->errors_->data = new struct TdPassportElementError * [res->errors_->len];
  for (int i300 = 0; i300 < res->errors_->len; i300++) {
    M->get_arr_field (i300);
    if (M->is_nil ()) {
      res->errors_->data[i300] = nullptr;
    } else {
      res->errors_->data[i300] = TdStackFetcherPassportElementError (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("privacy_policy_url_");
  res->privacy_policy_url_ = M->get_string ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::PassportElement> TdConvertToInternal (struct TdPassportElement *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementPersonalDetails: return TdConvertToInternal ((struct TdPassportElementPersonalDetails *)var);
    case CODE_PassportElementPassport: return TdConvertToInternal ((struct TdPassportElementPassport *)var);
    case CODE_PassportElementDriverLicense: return TdConvertToInternal ((struct TdPassportElementDriverLicense *)var);
    case CODE_PassportElementIdentityCard: return TdConvertToInternal ((struct TdPassportElementIdentityCard *)var);
    case CODE_PassportElementInternalPassport: return TdConvertToInternal ((struct TdPassportElementInternalPassport *)var);
    case CODE_PassportElementAddress: return TdConvertToInternal ((struct TdPassportElementAddress *)var);
    case CODE_PassportElementUtilityBill: return TdConvertToInternal ((struct TdPassportElementUtilityBill *)var);
    case CODE_PassportElementBankStatement: return TdConvertToInternal ((struct TdPassportElementBankStatement *)var);
    case CODE_PassportElementRentalAgreement: return TdConvertToInternal ((struct TdPassportElementRentalAgreement *)var);
    case CODE_PassportElementPassportRegistration: return TdConvertToInternal ((struct TdPassportElementPassportRegistration *)var);
    case CODE_PassportElementTemporaryRegistration: return TdConvertToInternal ((struct TdPassportElementTemporaryRegistration *)var);
    case CODE_PassportElementPhoneNumber: return TdConvertToInternal ((struct TdPassportElementPhoneNumber *)var);
    case CODE_PassportElementEmailAddress: return TdConvertToInternal ((struct TdPassportElementEmailAddress *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdPassportElement *TdConvertFromInternal (const td::td_api::PassportElement &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_PassportElementPersonalDetails: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementPersonalDetails &>(from));
    case CODE_PassportElementPassport: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementPassport &>(from));
    case CODE_PassportElementDriverLicense: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementDriverLicense &>(from));
    case CODE_PassportElementIdentityCard: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementIdentityCard &>(from));
    case CODE_PassportElementInternalPassport: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementInternalPassport &>(from));
    case CODE_PassportElementAddress: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementAddress &>(from));
    case CODE_PassportElementUtilityBill: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementUtilityBill &>(from));
    case CODE_PassportElementBankStatement: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementBankStatement &>(from));
    case CODE_PassportElementRentalAgreement: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementRentalAgreement &>(from));
    case CODE_PassportElementPassportRegistration: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementPassportRegistration &>(from));
    case CODE_PassportElementTemporaryRegistration: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTemporaryRegistration &>(from));
    case CODE_PassportElementPhoneNumber: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementPhoneNumber &>(from));
    case CODE_PassportElementEmailAddress: return (struct TdPassportElement *)TdConvertFromInternal(static_cast<const td::td_api::passportElementEmailAddress &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializePassportElement (struct TdPassportElement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElement (struct TdPassportElement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElement *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementPersonalDetails: return TdDestroyObject ((struct TdPassportElementPersonalDetails *)var);
    case CODE_PassportElementPassport: return TdDestroyObject ((struct TdPassportElementPassport *)var);
    case CODE_PassportElementDriverLicense: return TdDestroyObject ((struct TdPassportElementDriverLicense *)var);
    case CODE_PassportElementIdentityCard: return TdDestroyObject ((struct TdPassportElementIdentityCard *)var);
    case CODE_PassportElementInternalPassport: return TdDestroyObject ((struct TdPassportElementInternalPassport *)var);
    case CODE_PassportElementAddress: return TdDestroyObject ((struct TdPassportElementAddress *)var);
    case CODE_PassportElementUtilityBill: return TdDestroyObject ((struct TdPassportElementUtilityBill *)var);
    case CODE_PassportElementBankStatement: return TdDestroyObject ((struct TdPassportElementBankStatement *)var);
    case CODE_PassportElementRentalAgreement: return TdDestroyObject ((struct TdPassportElementRentalAgreement *)var);
    case CODE_PassportElementPassportRegistration: return TdDestroyObject ((struct TdPassportElementPassportRegistration *)var);
    case CODE_PassportElementTemporaryRegistration: return TdDestroyObject ((struct TdPassportElementTemporaryRegistration *)var);
    case CODE_PassportElementPhoneNumber: return TdDestroyObject ((struct TdPassportElementPhoneNumber *)var);
    case CODE_PassportElementEmailAddress: return TdDestroyObject ((struct TdPassportElementEmailAddress *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerPassportElement (struct TdPassportElement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElement *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementPersonalDetails: return TdStackStorer ((struct TdPassportElementPersonalDetails *)var, M);
    case CODE_PassportElementPassport: return TdStackStorer ((struct TdPassportElementPassport *)var, M);
    case CODE_PassportElementDriverLicense: return TdStackStorer ((struct TdPassportElementDriverLicense *)var, M);
    case CODE_PassportElementIdentityCard: return TdStackStorer ((struct TdPassportElementIdentityCard *)var, M);
    case CODE_PassportElementInternalPassport: return TdStackStorer ((struct TdPassportElementInternalPassport *)var, M);
    case CODE_PassportElementAddress: return TdStackStorer ((struct TdPassportElementAddress *)var, M);
    case CODE_PassportElementUtilityBill: return TdStackStorer ((struct TdPassportElementUtilityBill *)var, M);
    case CODE_PassportElementBankStatement: return TdStackStorer ((struct TdPassportElementBankStatement *)var, M);
    case CODE_PassportElementRentalAgreement: return TdStackStorer ((struct TdPassportElementRentalAgreement *)var, M);
    case CODE_PassportElementPassportRegistration: return TdStackStorer ((struct TdPassportElementPassportRegistration *)var, M);
    case CODE_PassportElementTemporaryRegistration: return TdStackStorer ((struct TdPassportElementTemporaryRegistration *)var, M);
    case CODE_PassportElementPhoneNumber: return TdStackStorer ((struct TdPassportElementPhoneNumber *)var, M);
    case CODE_PassportElementEmailAddress: return TdStackStorer ((struct TdPassportElementEmailAddress *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdPassportElement *TdStackFetcherPassportElement (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "PassportElementPersonalDetails") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementPersonalDetails (M);
  }
  if (constructor == "PassportElementPassport") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementPassport (M);
  }
  if (constructor == "PassportElementDriverLicense") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementDriverLicense (M);
  }
  if (constructor == "PassportElementIdentityCard") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementIdentityCard (M);
  }
  if (constructor == "PassportElementInternalPassport") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementInternalPassport (M);
  }
  if (constructor == "PassportElementAddress") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementAddress (M);
  }
  if (constructor == "PassportElementUtilityBill") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementUtilityBill (M);
  }
  if (constructor == "PassportElementBankStatement") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementBankStatement (M);
  }
  if (constructor == "PassportElementRentalAgreement") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementRentalAgreement (M);
  }
  if (constructor == "PassportElementPassportRegistration") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementPassportRegistration (M);
  }
  if (constructor == "PassportElementTemporaryRegistration") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementTemporaryRegistration (M);
  }
  if (constructor == "PassportElementPhoneNumber") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementPhoneNumber (M);
  }
  if (constructor == "PassportElementEmailAddress") {
    return (struct TdPassportElement *)TdStackFetcherPassportElementEmailAddress (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdPassportElementPersonalDetails *TdCreateObjectPassportElementPersonalDetails (struct TdPersonalDetails *personal_details_) {
  auto var = new struct TdPassportElementPersonalDetails ();
  var->ID = CODE_PassportElementPersonalDetails;
  var->refcnt = 1;
  var->personal_details_ = personal_details_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementPersonalDetails> TdConvertToInternal (struct TdPassportElementPersonalDetails *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::personalDetails> v0;
  v0 = TdConvertToInternal (var->personal_details_);
  return td::td_api::make_object<td::td_api::passportElementPersonalDetails>(std::move (v0));
}
struct TdPassportElementPersonalDetails *TdConvertFromInternal (const td::td_api::passportElementPersonalDetails &from) {
  auto res = new TdPassportElementPersonalDetails ();
  res->ID = CODE_PassportElementPersonalDetails;
  res->refcnt = 1;
  if (!from.personal_details_) {
    res->personal_details_ = nullptr;
  } else {
    res->personal_details_ = TdConvertFromInternal (static_cast<const td::td_api::personalDetails &>(*from.personal_details_));
  }
  return res;
}
char *TdSerializePassportElementPersonalDetails (struct TdPassportElementPersonalDetails *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementPersonalDetails *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementPersonalDetails (struct TdPassportElementPersonalDetails *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementPersonalDetails *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->personal_details_);
  delete var;
}
void TdStackStorerPassportElementPersonalDetails (struct TdPassportElementPersonalDetails *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementPersonalDetails *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementPersonalDetails");
  M->new_field ("ID");
  TdStackStorer (var->personal_details_, M);
  M->new_field ("personal_details_");
}
struct TdPassportElementPersonalDetails *TdStackFetcherPassportElementPersonalDetails (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementPersonalDetails ();
  res->ID = CODE_PassportElementPersonalDetails;
  res->refcnt = 1;
  M->get_field ("personal_details_");
  if (M->is_nil ()) {
    res->personal_details_ = nullptr;
  } else {
    res->personal_details_ = TdStackFetcherPersonalDetails (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementPassport *TdCreateObjectPassportElementPassport (struct TdIdentityDocument *passport_) {
  auto var = new struct TdPassportElementPassport ();
  var->ID = CODE_PassportElementPassport;
  var->refcnt = 1;
  var->passport_ = passport_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementPassport> TdConvertToInternal (struct TdPassportElementPassport *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::identityDocument> v0;
  v0 = TdConvertToInternal (var->passport_);
  return td::td_api::make_object<td::td_api::passportElementPassport>(std::move (v0));
}
struct TdPassportElementPassport *TdConvertFromInternal (const td::td_api::passportElementPassport &from) {
  auto res = new TdPassportElementPassport ();
  res->ID = CODE_PassportElementPassport;
  res->refcnt = 1;
  if (!from.passport_) {
    res->passport_ = nullptr;
  } else {
    res->passport_ = TdConvertFromInternal (static_cast<const td::td_api::identityDocument &>(*from.passport_));
  }
  return res;
}
char *TdSerializePassportElementPassport (struct TdPassportElementPassport *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementPassport *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementPassport (struct TdPassportElementPassport *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementPassport *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->passport_);
  delete var;
}
void TdStackStorerPassportElementPassport (struct TdPassportElementPassport *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementPassport *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementPassport");
  M->new_field ("ID");
  TdStackStorer (var->passport_, M);
  M->new_field ("passport_");
}
struct TdPassportElementPassport *TdStackFetcherPassportElementPassport (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementPassport ();
  res->ID = CODE_PassportElementPassport;
  res->refcnt = 1;
  M->get_field ("passport_");
  if (M->is_nil ()) {
    res->passport_ = nullptr;
  } else {
    res->passport_ = TdStackFetcherIdentityDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementDriverLicense *TdCreateObjectPassportElementDriverLicense (struct TdIdentityDocument *driver_license_) {
  auto var = new struct TdPassportElementDriverLicense ();
  var->ID = CODE_PassportElementDriverLicense;
  var->refcnt = 1;
  var->driver_license_ = driver_license_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementDriverLicense> TdConvertToInternal (struct TdPassportElementDriverLicense *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::identityDocument> v0;
  v0 = TdConvertToInternal (var->driver_license_);
  return td::td_api::make_object<td::td_api::passportElementDriverLicense>(std::move (v0));
}
struct TdPassportElementDriverLicense *TdConvertFromInternal (const td::td_api::passportElementDriverLicense &from) {
  auto res = new TdPassportElementDriverLicense ();
  res->ID = CODE_PassportElementDriverLicense;
  res->refcnt = 1;
  if (!from.driver_license_) {
    res->driver_license_ = nullptr;
  } else {
    res->driver_license_ = TdConvertFromInternal (static_cast<const td::td_api::identityDocument &>(*from.driver_license_));
  }
  return res;
}
char *TdSerializePassportElementDriverLicense (struct TdPassportElementDriverLicense *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementDriverLicense *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementDriverLicense (struct TdPassportElementDriverLicense *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementDriverLicense *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->driver_license_);
  delete var;
}
void TdStackStorerPassportElementDriverLicense (struct TdPassportElementDriverLicense *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementDriverLicense *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementDriverLicense");
  M->new_field ("ID");
  TdStackStorer (var->driver_license_, M);
  M->new_field ("driver_license_");
}
struct TdPassportElementDriverLicense *TdStackFetcherPassportElementDriverLicense (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementDriverLicense ();
  res->ID = CODE_PassportElementDriverLicense;
  res->refcnt = 1;
  M->get_field ("driver_license_");
  if (M->is_nil ()) {
    res->driver_license_ = nullptr;
  } else {
    res->driver_license_ = TdStackFetcherIdentityDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementIdentityCard *TdCreateObjectPassportElementIdentityCard (struct TdIdentityDocument *identity_card_) {
  auto var = new struct TdPassportElementIdentityCard ();
  var->ID = CODE_PassportElementIdentityCard;
  var->refcnt = 1;
  var->identity_card_ = identity_card_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementIdentityCard> TdConvertToInternal (struct TdPassportElementIdentityCard *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::identityDocument> v0;
  v0 = TdConvertToInternal (var->identity_card_);
  return td::td_api::make_object<td::td_api::passportElementIdentityCard>(std::move (v0));
}
struct TdPassportElementIdentityCard *TdConvertFromInternal (const td::td_api::passportElementIdentityCard &from) {
  auto res = new TdPassportElementIdentityCard ();
  res->ID = CODE_PassportElementIdentityCard;
  res->refcnt = 1;
  if (!from.identity_card_) {
    res->identity_card_ = nullptr;
  } else {
    res->identity_card_ = TdConvertFromInternal (static_cast<const td::td_api::identityDocument &>(*from.identity_card_));
  }
  return res;
}
char *TdSerializePassportElementIdentityCard (struct TdPassportElementIdentityCard *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementIdentityCard *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementIdentityCard (struct TdPassportElementIdentityCard *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementIdentityCard *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->identity_card_);
  delete var;
}
void TdStackStorerPassportElementIdentityCard (struct TdPassportElementIdentityCard *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementIdentityCard *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementIdentityCard");
  M->new_field ("ID");
  TdStackStorer (var->identity_card_, M);
  M->new_field ("identity_card_");
}
struct TdPassportElementIdentityCard *TdStackFetcherPassportElementIdentityCard (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementIdentityCard ();
  res->ID = CODE_PassportElementIdentityCard;
  res->refcnt = 1;
  M->get_field ("identity_card_");
  if (M->is_nil ()) {
    res->identity_card_ = nullptr;
  } else {
    res->identity_card_ = TdStackFetcherIdentityDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementInternalPassport *TdCreateObjectPassportElementInternalPassport (struct TdIdentityDocument *internal_passport_) {
  auto var = new struct TdPassportElementInternalPassport ();
  var->ID = CODE_PassportElementInternalPassport;
  var->refcnt = 1;
  var->internal_passport_ = internal_passport_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementInternalPassport> TdConvertToInternal (struct TdPassportElementInternalPassport *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::identityDocument> v0;
  v0 = TdConvertToInternal (var->internal_passport_);
  return td::td_api::make_object<td::td_api::passportElementInternalPassport>(std::move (v0));
}
struct TdPassportElementInternalPassport *TdConvertFromInternal (const td::td_api::passportElementInternalPassport &from) {
  auto res = new TdPassportElementInternalPassport ();
  res->ID = CODE_PassportElementInternalPassport;
  res->refcnt = 1;
  if (!from.internal_passport_) {
    res->internal_passport_ = nullptr;
  } else {
    res->internal_passport_ = TdConvertFromInternal (static_cast<const td::td_api::identityDocument &>(*from.internal_passport_));
  }
  return res;
}
char *TdSerializePassportElementInternalPassport (struct TdPassportElementInternalPassport *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementInternalPassport *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementInternalPassport (struct TdPassportElementInternalPassport *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementInternalPassport *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->internal_passport_);
  delete var;
}
void TdStackStorerPassportElementInternalPassport (struct TdPassportElementInternalPassport *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementInternalPassport *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementInternalPassport");
  M->new_field ("ID");
  TdStackStorer (var->internal_passport_, M);
  M->new_field ("internal_passport_");
}
struct TdPassportElementInternalPassport *TdStackFetcherPassportElementInternalPassport (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementInternalPassport ();
  res->ID = CODE_PassportElementInternalPassport;
  res->refcnt = 1;
  M->get_field ("internal_passport_");
  if (M->is_nil ()) {
    res->internal_passport_ = nullptr;
  } else {
    res->internal_passport_ = TdStackFetcherIdentityDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementAddress *TdCreateObjectPassportElementAddress (struct TdAddress *address_) {
  auto var = new struct TdPassportElementAddress ();
  var->ID = CODE_PassportElementAddress;
  var->refcnt = 1;
  var->address_ = address_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementAddress> TdConvertToInternal (struct TdPassportElementAddress *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::address> v0;
  v0 = TdConvertToInternal (var->address_);
  return td::td_api::make_object<td::td_api::passportElementAddress>(std::move (v0));
}
struct TdPassportElementAddress *TdConvertFromInternal (const td::td_api::passportElementAddress &from) {
  auto res = new TdPassportElementAddress ();
  res->ID = CODE_PassportElementAddress;
  res->refcnt = 1;
  if (!from.address_) {
    res->address_ = nullptr;
  } else {
    res->address_ = TdConvertFromInternal (static_cast<const td::td_api::address &>(*from.address_));
  }
  return res;
}
char *TdSerializePassportElementAddress (struct TdPassportElementAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementAddress (struct TdPassportElementAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->address_);
  delete var;
}
void TdStackStorerPassportElementAddress (struct TdPassportElementAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementAddress");
  M->new_field ("ID");
  TdStackStorer (var->address_, M);
  M->new_field ("address_");
}
struct TdPassportElementAddress *TdStackFetcherPassportElementAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementAddress ();
  res->ID = CODE_PassportElementAddress;
  res->refcnt = 1;
  M->get_field ("address_");
  if (M->is_nil ()) {
    res->address_ = nullptr;
  } else {
    res->address_ = TdStackFetcherAddress (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementUtilityBill *TdCreateObjectPassportElementUtilityBill (struct TdPersonalDocument *utility_bill_) {
  auto var = new struct TdPassportElementUtilityBill ();
  var->ID = CODE_PassportElementUtilityBill;
  var->refcnt = 1;
  var->utility_bill_ = utility_bill_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementUtilityBill> TdConvertToInternal (struct TdPassportElementUtilityBill *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::personalDocument> v0;
  v0 = TdConvertToInternal (var->utility_bill_);
  return td::td_api::make_object<td::td_api::passportElementUtilityBill>(std::move (v0));
}
struct TdPassportElementUtilityBill *TdConvertFromInternal (const td::td_api::passportElementUtilityBill &from) {
  auto res = new TdPassportElementUtilityBill ();
  res->ID = CODE_PassportElementUtilityBill;
  res->refcnt = 1;
  if (!from.utility_bill_) {
    res->utility_bill_ = nullptr;
  } else {
    res->utility_bill_ = TdConvertFromInternal (static_cast<const td::td_api::personalDocument &>(*from.utility_bill_));
  }
  return res;
}
char *TdSerializePassportElementUtilityBill (struct TdPassportElementUtilityBill *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementUtilityBill *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementUtilityBill (struct TdPassportElementUtilityBill *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementUtilityBill *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->utility_bill_);
  delete var;
}
void TdStackStorerPassportElementUtilityBill (struct TdPassportElementUtilityBill *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementUtilityBill *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementUtilityBill");
  M->new_field ("ID");
  TdStackStorer (var->utility_bill_, M);
  M->new_field ("utility_bill_");
}
struct TdPassportElementUtilityBill *TdStackFetcherPassportElementUtilityBill (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementUtilityBill ();
  res->ID = CODE_PassportElementUtilityBill;
  res->refcnt = 1;
  M->get_field ("utility_bill_");
  if (M->is_nil ()) {
    res->utility_bill_ = nullptr;
  } else {
    res->utility_bill_ = TdStackFetcherPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementBankStatement *TdCreateObjectPassportElementBankStatement (struct TdPersonalDocument *bank_statement_) {
  auto var = new struct TdPassportElementBankStatement ();
  var->ID = CODE_PassportElementBankStatement;
  var->refcnt = 1;
  var->bank_statement_ = bank_statement_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementBankStatement> TdConvertToInternal (struct TdPassportElementBankStatement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::personalDocument> v0;
  v0 = TdConvertToInternal (var->bank_statement_);
  return td::td_api::make_object<td::td_api::passportElementBankStatement>(std::move (v0));
}
struct TdPassportElementBankStatement *TdConvertFromInternal (const td::td_api::passportElementBankStatement &from) {
  auto res = new TdPassportElementBankStatement ();
  res->ID = CODE_PassportElementBankStatement;
  res->refcnt = 1;
  if (!from.bank_statement_) {
    res->bank_statement_ = nullptr;
  } else {
    res->bank_statement_ = TdConvertFromInternal (static_cast<const td::td_api::personalDocument &>(*from.bank_statement_));
  }
  return res;
}
char *TdSerializePassportElementBankStatement (struct TdPassportElementBankStatement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementBankStatement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementBankStatement (struct TdPassportElementBankStatement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementBankStatement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->bank_statement_);
  delete var;
}
void TdStackStorerPassportElementBankStatement (struct TdPassportElementBankStatement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementBankStatement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementBankStatement");
  M->new_field ("ID");
  TdStackStorer (var->bank_statement_, M);
  M->new_field ("bank_statement_");
}
struct TdPassportElementBankStatement *TdStackFetcherPassportElementBankStatement (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementBankStatement ();
  res->ID = CODE_PassportElementBankStatement;
  res->refcnt = 1;
  M->get_field ("bank_statement_");
  if (M->is_nil ()) {
    res->bank_statement_ = nullptr;
  } else {
    res->bank_statement_ = TdStackFetcherPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementRentalAgreement *TdCreateObjectPassportElementRentalAgreement (struct TdPersonalDocument *rental_agreement_) {
  auto var = new struct TdPassportElementRentalAgreement ();
  var->ID = CODE_PassportElementRentalAgreement;
  var->refcnt = 1;
  var->rental_agreement_ = rental_agreement_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementRentalAgreement> TdConvertToInternal (struct TdPassportElementRentalAgreement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::personalDocument> v0;
  v0 = TdConvertToInternal (var->rental_agreement_);
  return td::td_api::make_object<td::td_api::passportElementRentalAgreement>(std::move (v0));
}
struct TdPassportElementRentalAgreement *TdConvertFromInternal (const td::td_api::passportElementRentalAgreement &from) {
  auto res = new TdPassportElementRentalAgreement ();
  res->ID = CODE_PassportElementRentalAgreement;
  res->refcnt = 1;
  if (!from.rental_agreement_) {
    res->rental_agreement_ = nullptr;
  } else {
    res->rental_agreement_ = TdConvertFromInternal (static_cast<const td::td_api::personalDocument &>(*from.rental_agreement_));
  }
  return res;
}
char *TdSerializePassportElementRentalAgreement (struct TdPassportElementRentalAgreement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementRentalAgreement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementRentalAgreement (struct TdPassportElementRentalAgreement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementRentalAgreement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->rental_agreement_);
  delete var;
}
void TdStackStorerPassportElementRentalAgreement (struct TdPassportElementRentalAgreement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementRentalAgreement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementRentalAgreement");
  M->new_field ("ID");
  TdStackStorer (var->rental_agreement_, M);
  M->new_field ("rental_agreement_");
}
struct TdPassportElementRentalAgreement *TdStackFetcherPassportElementRentalAgreement (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementRentalAgreement ();
  res->ID = CODE_PassportElementRentalAgreement;
  res->refcnt = 1;
  M->get_field ("rental_agreement_");
  if (M->is_nil ()) {
    res->rental_agreement_ = nullptr;
  } else {
    res->rental_agreement_ = TdStackFetcherPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementPassportRegistration *TdCreateObjectPassportElementPassportRegistration (struct TdPersonalDocument *passport_registration_) {
  auto var = new struct TdPassportElementPassportRegistration ();
  var->ID = CODE_PassportElementPassportRegistration;
  var->refcnt = 1;
  var->passport_registration_ = passport_registration_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementPassportRegistration> TdConvertToInternal (struct TdPassportElementPassportRegistration *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::personalDocument> v0;
  v0 = TdConvertToInternal (var->passport_registration_);
  return td::td_api::make_object<td::td_api::passportElementPassportRegistration>(std::move (v0));
}
struct TdPassportElementPassportRegistration *TdConvertFromInternal (const td::td_api::passportElementPassportRegistration &from) {
  auto res = new TdPassportElementPassportRegistration ();
  res->ID = CODE_PassportElementPassportRegistration;
  res->refcnt = 1;
  if (!from.passport_registration_) {
    res->passport_registration_ = nullptr;
  } else {
    res->passport_registration_ = TdConvertFromInternal (static_cast<const td::td_api::personalDocument &>(*from.passport_registration_));
  }
  return res;
}
char *TdSerializePassportElementPassportRegistration (struct TdPassportElementPassportRegistration *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementPassportRegistration *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementPassportRegistration (struct TdPassportElementPassportRegistration *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementPassportRegistration *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->passport_registration_);
  delete var;
}
void TdStackStorerPassportElementPassportRegistration (struct TdPassportElementPassportRegistration *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementPassportRegistration *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementPassportRegistration");
  M->new_field ("ID");
  TdStackStorer (var->passport_registration_, M);
  M->new_field ("passport_registration_");
}
struct TdPassportElementPassportRegistration *TdStackFetcherPassportElementPassportRegistration (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementPassportRegistration ();
  res->ID = CODE_PassportElementPassportRegistration;
  res->refcnt = 1;
  M->get_field ("passport_registration_");
  if (M->is_nil ()) {
    res->passport_registration_ = nullptr;
  } else {
    res->passport_registration_ = TdStackFetcherPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementTemporaryRegistration *TdCreateObjectPassportElementTemporaryRegistration (struct TdPersonalDocument *temporary_registration_) {
  auto var = new struct TdPassportElementTemporaryRegistration ();
  var->ID = CODE_PassportElementTemporaryRegistration;
  var->refcnt = 1;
  var->temporary_registration_ = temporary_registration_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTemporaryRegistration> TdConvertToInternal (struct TdPassportElementTemporaryRegistration *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::personalDocument> v0;
  v0 = TdConvertToInternal (var->temporary_registration_);
  return td::td_api::make_object<td::td_api::passportElementTemporaryRegistration>(std::move (v0));
}
struct TdPassportElementTemporaryRegistration *TdConvertFromInternal (const td::td_api::passportElementTemporaryRegistration &from) {
  auto res = new TdPassportElementTemporaryRegistration ();
  res->ID = CODE_PassportElementTemporaryRegistration;
  res->refcnt = 1;
  if (!from.temporary_registration_) {
    res->temporary_registration_ = nullptr;
  } else {
    res->temporary_registration_ = TdConvertFromInternal (static_cast<const td::td_api::personalDocument &>(*from.temporary_registration_));
  }
  return res;
}
char *TdSerializePassportElementTemporaryRegistration (struct TdPassportElementTemporaryRegistration *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTemporaryRegistration *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTemporaryRegistration (struct TdPassportElementTemporaryRegistration *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTemporaryRegistration *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->temporary_registration_);
  delete var;
}
void TdStackStorerPassportElementTemporaryRegistration (struct TdPassportElementTemporaryRegistration *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTemporaryRegistration *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTemporaryRegistration");
  M->new_field ("ID");
  TdStackStorer (var->temporary_registration_, M);
  M->new_field ("temporary_registration_");
}
struct TdPassportElementTemporaryRegistration *TdStackFetcherPassportElementTemporaryRegistration (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTemporaryRegistration ();
  res->ID = CODE_PassportElementTemporaryRegistration;
  res->refcnt = 1;
  M->get_field ("temporary_registration_");
  if (M->is_nil ()) {
    res->temporary_registration_ = nullptr;
  } else {
    res->temporary_registration_ = TdStackFetcherPersonalDocument (M);
  }
  M->pop ();
  return res;
}
struct TdPassportElementPhoneNumber *TdCreateObjectPassportElementPhoneNumber (char *phone_number_) {
  auto var = new struct TdPassportElementPhoneNumber ();
  var->ID = CODE_PassportElementPhoneNumber;
  var->refcnt = 1;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementPhoneNumber> TdConvertToInternal (struct TdPassportElementPhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->phone_number_) ? var->phone_number_: "";
  return td::td_api::make_object<td::td_api::passportElementPhoneNumber>(std::move (v0));
}
struct TdPassportElementPhoneNumber *TdConvertFromInternal (const td::td_api::passportElementPhoneNumber &from) {
  auto res = new TdPassportElementPhoneNumber ();
  res->ID = CODE_PassportElementPhoneNumber;
  res->refcnt = 1;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  return res;
}
char *TdSerializePassportElementPhoneNumber (struct TdPassportElementPhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementPhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementPhoneNumber (struct TdPassportElementPhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementPhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->phone_number_);
  delete var;
}
void TdStackStorerPassportElementPhoneNumber (struct TdPassportElementPhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementPhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementPhoneNumber");
  M->new_field ("ID");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
}
struct TdPassportElementPhoneNumber *TdStackFetcherPassportElementPhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementPhoneNumber ();
  res->ID = CODE_PassportElementPhoneNumber;
  res->refcnt = 1;
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPassportElementEmailAddress *TdCreateObjectPassportElementEmailAddress (char *email_address_) {
  auto var = new struct TdPassportElementEmailAddress ();
  var->ID = CODE_PassportElementEmailAddress;
  var->refcnt = 1;
  var->email_address_ = (email_address_) ? td::str_dup (td::Slice (email_address_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementEmailAddress> TdConvertToInternal (struct TdPassportElementEmailAddress *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->email_address_) ? var->email_address_: "";
  return td::td_api::make_object<td::td_api::passportElementEmailAddress>(std::move (v0));
}
struct TdPassportElementEmailAddress *TdConvertFromInternal (const td::td_api::passportElementEmailAddress &from) {
  auto res = new TdPassportElementEmailAddress ();
  res->ID = CODE_PassportElementEmailAddress;
  res->refcnt = 1;
  res->email_address_ = (from.email_address_.length ()) ? td::str_dup (from.email_address_) : nullptr;
  return res;
}
char *TdSerializePassportElementEmailAddress (struct TdPassportElementEmailAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementEmailAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementEmailAddress (struct TdPassportElementEmailAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementEmailAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->email_address_);
  delete var;
}
void TdStackStorerPassportElementEmailAddress (struct TdPassportElementEmailAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementEmailAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementEmailAddress");
  M->new_field ("ID");
  M->pack_string (var->email_address_);
  M->new_field ("email_address_");
}
struct TdPassportElementEmailAddress *TdStackFetcherPassportElementEmailAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementEmailAddress ();
  res->ID = CODE_PassportElementEmailAddress;
  res->refcnt = 1;
  M->get_field ("email_address_");
  res->email_address_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPassportElementError *TdCreateObjectPassportElementError (struct TdPassportElementType *type_, char *message_, struct TdPassportElementErrorSource *source_) {
  auto var = new struct TdPassportElementError ();
  var->ID = CODE_PassportElementError;
  var->refcnt = 1;
  var->type_ = type_;
  var->message_ = (message_) ? td::str_dup (td::Slice (message_)) : nullptr;
  var->source_ = source_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementError> TdConvertToInternal (struct TdPassportElementError *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::PassportElementType> v0;
  v0 = TdConvertToInternal (var->type_);
  std::string v100;
  v100 = (var->message_) ? var->message_: "";
  td::td_api::object_ptr<td::td_api::PassportElementErrorSource> v200;
  v200 = TdConvertToInternal (var->source_);
  return td::td_api::make_object<td::td_api::passportElementError>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdPassportElementError *TdConvertFromInternal (const td::td_api::passportElementError &from) {
  auto res = new TdPassportElementError ();
  res->ID = CODE_PassportElementError;
  res->refcnt = 1;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::PassportElementType &>(*from.type_));
  }
  res->message_ = (from.message_.length ()) ? td::str_dup (from.message_) : nullptr;
  if (!from.source_) {
    res->source_ = nullptr;
  } else {
    res->source_ = TdConvertFromInternal (static_cast<const td::td_api::PassportElementErrorSource &>(*from.source_));
  }
  return res;
}
char *TdSerializePassportElementError (struct TdPassportElementError *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementError *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementError (struct TdPassportElementError *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementError *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  free (var->message_);
  TdDestroyObject (var->source_);
  delete var;
}
void TdStackStorerPassportElementError (struct TdPassportElementError *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementError *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementError");
  M->new_field ("ID");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  M->pack_string (var->message_);
  M->new_field ("message_");
  TdStackStorer (var->source_, M);
  M->new_field ("source_");
}
struct TdPassportElementError *TdStackFetcherPassportElementError (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementError ();
  res->ID = CODE_PassportElementError;
  res->refcnt = 1;
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherPassportElementType (M);
  }
  M->pop ();
  M->get_field ("message_");
  res->message_ = M->get_string ();
  M->pop ();
  M->get_field ("source_");
  if (M->is_nil ()) {
    res->source_ = nullptr;
  } else {
    res->source_ = TdStackFetcherPassportElementErrorSource (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::PassportElementErrorSource> TdConvertToInternal (struct TdPassportElementErrorSource *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementErrorSourceUnspecified: return TdConvertToInternal ((struct TdPassportElementErrorSourceUnspecified *)var);
    case CODE_PassportElementErrorSourceDataField: return TdConvertToInternal ((struct TdPassportElementErrorSourceDataField *)var);
    case CODE_PassportElementErrorSourceFrontSide: return TdConvertToInternal ((struct TdPassportElementErrorSourceFrontSide *)var);
    case CODE_PassportElementErrorSourceReverseSide: return TdConvertToInternal ((struct TdPassportElementErrorSourceReverseSide *)var);
    case CODE_PassportElementErrorSourceSelfie: return TdConvertToInternal ((struct TdPassportElementErrorSourceSelfie *)var);
    case CODE_PassportElementErrorSourceTranslationFile: return TdConvertToInternal ((struct TdPassportElementErrorSourceTranslationFile *)var);
    case CODE_PassportElementErrorSourceTranslationFiles: return TdConvertToInternal ((struct TdPassportElementErrorSourceTranslationFiles *)var);
    case CODE_PassportElementErrorSourceFile: return TdConvertToInternal ((struct TdPassportElementErrorSourceFile *)var);
    case CODE_PassportElementErrorSourceFiles: return TdConvertToInternal ((struct TdPassportElementErrorSourceFiles *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdPassportElementErrorSource *TdConvertFromInternal (const td::td_api::PassportElementErrorSource &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_PassportElementErrorSourceUnspecified: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceUnspecified &>(from));
    case CODE_PassportElementErrorSourceDataField: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceDataField &>(from));
    case CODE_PassportElementErrorSourceFrontSide: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceFrontSide &>(from));
    case CODE_PassportElementErrorSourceReverseSide: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceReverseSide &>(from));
    case CODE_PassportElementErrorSourceSelfie: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceSelfie &>(from));
    case CODE_PassportElementErrorSourceTranslationFile: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceTranslationFile &>(from));
    case CODE_PassportElementErrorSourceTranslationFiles: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceTranslationFiles &>(from));
    case CODE_PassportElementErrorSourceFile: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceFile &>(from));
    case CODE_PassportElementErrorSourceFiles: return (struct TdPassportElementErrorSource *)TdConvertFromInternal(static_cast<const td::td_api::passportElementErrorSourceFiles &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializePassportElementErrorSource (struct TdPassportElementErrorSource *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSource *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSource (struct TdPassportElementErrorSource *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSource *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementErrorSourceUnspecified: return TdDestroyObject ((struct TdPassportElementErrorSourceUnspecified *)var);
    case CODE_PassportElementErrorSourceDataField: return TdDestroyObject ((struct TdPassportElementErrorSourceDataField *)var);
    case CODE_PassportElementErrorSourceFrontSide: return TdDestroyObject ((struct TdPassportElementErrorSourceFrontSide *)var);
    case CODE_PassportElementErrorSourceReverseSide: return TdDestroyObject ((struct TdPassportElementErrorSourceReverseSide *)var);
    case CODE_PassportElementErrorSourceSelfie: return TdDestroyObject ((struct TdPassportElementErrorSourceSelfie *)var);
    case CODE_PassportElementErrorSourceTranslationFile: return TdDestroyObject ((struct TdPassportElementErrorSourceTranslationFile *)var);
    case CODE_PassportElementErrorSourceTranslationFiles: return TdDestroyObject ((struct TdPassportElementErrorSourceTranslationFiles *)var);
    case CODE_PassportElementErrorSourceFile: return TdDestroyObject ((struct TdPassportElementErrorSourceFile *)var);
    case CODE_PassportElementErrorSourceFiles: return TdDestroyObject ((struct TdPassportElementErrorSourceFiles *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerPassportElementErrorSource (struct TdPassportElementErrorSource *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSource *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementErrorSourceUnspecified: return TdStackStorer ((struct TdPassportElementErrorSourceUnspecified *)var, M);
    case CODE_PassportElementErrorSourceDataField: return TdStackStorer ((struct TdPassportElementErrorSourceDataField *)var, M);
    case CODE_PassportElementErrorSourceFrontSide: return TdStackStorer ((struct TdPassportElementErrorSourceFrontSide *)var, M);
    case CODE_PassportElementErrorSourceReverseSide: return TdStackStorer ((struct TdPassportElementErrorSourceReverseSide *)var, M);
    case CODE_PassportElementErrorSourceSelfie: return TdStackStorer ((struct TdPassportElementErrorSourceSelfie *)var, M);
    case CODE_PassportElementErrorSourceTranslationFile: return TdStackStorer ((struct TdPassportElementErrorSourceTranslationFile *)var, M);
    case CODE_PassportElementErrorSourceTranslationFiles: return TdStackStorer ((struct TdPassportElementErrorSourceTranslationFiles *)var, M);
    case CODE_PassportElementErrorSourceFile: return TdStackStorer ((struct TdPassportElementErrorSourceFile *)var, M);
    case CODE_PassportElementErrorSourceFiles: return TdStackStorer ((struct TdPassportElementErrorSourceFiles *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdPassportElementErrorSource *TdStackFetcherPassportElementErrorSource (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "PassportElementErrorSourceUnspecified") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceUnspecified (M);
  }
  if (constructor == "PassportElementErrorSourceDataField") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceDataField (M);
  }
  if (constructor == "PassportElementErrorSourceFrontSide") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceFrontSide (M);
  }
  if (constructor == "PassportElementErrorSourceReverseSide") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceReverseSide (M);
  }
  if (constructor == "PassportElementErrorSourceSelfie") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceSelfie (M);
  }
  if (constructor == "PassportElementErrorSourceTranslationFile") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceTranslationFile (M);
  }
  if (constructor == "PassportElementErrorSourceTranslationFiles") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceTranslationFiles (M);
  }
  if (constructor == "PassportElementErrorSourceFile") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceFile (M);
  }
  if (constructor == "PassportElementErrorSourceFiles") {
    return (struct TdPassportElementErrorSource *)TdStackFetcherPassportElementErrorSourceFiles (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdPassportElementErrorSourceUnspecified *TdCreateObjectPassportElementErrorSourceUnspecified (void) {
  auto var = new struct TdPassportElementErrorSourceUnspecified ();
  var->ID = CODE_PassportElementErrorSourceUnspecified;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceUnspecified> TdConvertToInternal (struct TdPassportElementErrorSourceUnspecified *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementErrorSourceUnspecified>();
}
struct TdPassportElementErrorSourceUnspecified *TdConvertFromInternal (const td::td_api::passportElementErrorSourceUnspecified &from) {
  auto res = new TdPassportElementErrorSourceUnspecified ();
  res->ID = CODE_PassportElementErrorSourceUnspecified;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementErrorSourceUnspecified (struct TdPassportElementErrorSourceUnspecified *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceUnspecified *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceUnspecified (struct TdPassportElementErrorSourceUnspecified *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceUnspecified *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementErrorSourceUnspecified (struct TdPassportElementErrorSourceUnspecified *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceUnspecified *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceUnspecified");
  M->new_field ("ID");
}
struct TdPassportElementErrorSourceUnspecified *TdStackFetcherPassportElementErrorSourceUnspecified (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceUnspecified ();
  res->ID = CODE_PassportElementErrorSourceUnspecified;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementErrorSourceDataField *TdCreateObjectPassportElementErrorSourceDataField (char *field_name_) {
  auto var = new struct TdPassportElementErrorSourceDataField ();
  var->ID = CODE_PassportElementErrorSourceDataField;
  var->refcnt = 1;
  var->field_name_ = (field_name_) ? td::str_dup (td::Slice (field_name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceDataField> TdConvertToInternal (struct TdPassportElementErrorSourceDataField *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->field_name_) ? var->field_name_: "";
  return td::td_api::make_object<td::td_api::passportElementErrorSourceDataField>(std::move (v0));
}
struct TdPassportElementErrorSourceDataField *TdConvertFromInternal (const td::td_api::passportElementErrorSourceDataField &from) {
  auto res = new TdPassportElementErrorSourceDataField ();
  res->ID = CODE_PassportElementErrorSourceDataField;
  res->refcnt = 1;
  res->field_name_ = (from.field_name_.length ()) ? td::str_dup (from.field_name_) : nullptr;
  return res;
}
char *TdSerializePassportElementErrorSourceDataField (struct TdPassportElementErrorSourceDataField *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceDataField *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceDataField (struct TdPassportElementErrorSourceDataField *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceDataField *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->field_name_);
  delete var;
}
void TdStackStorerPassportElementErrorSourceDataField (struct TdPassportElementErrorSourceDataField *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceDataField *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceDataField");
  M->new_field ("ID");
  M->pack_string (var->field_name_);
  M->new_field ("field_name_");
}
struct TdPassportElementErrorSourceDataField *TdStackFetcherPassportElementErrorSourceDataField (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceDataField ();
  res->ID = CODE_PassportElementErrorSourceDataField;
  res->refcnt = 1;
  M->get_field ("field_name_");
  res->field_name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPassportElementErrorSourceFrontSide *TdCreateObjectPassportElementErrorSourceFrontSide (void) {
  auto var = new struct TdPassportElementErrorSourceFrontSide ();
  var->ID = CODE_PassportElementErrorSourceFrontSide;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceFrontSide> TdConvertToInternal (struct TdPassportElementErrorSourceFrontSide *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementErrorSourceFrontSide>();
}
struct TdPassportElementErrorSourceFrontSide *TdConvertFromInternal (const td::td_api::passportElementErrorSourceFrontSide &from) {
  auto res = new TdPassportElementErrorSourceFrontSide ();
  res->ID = CODE_PassportElementErrorSourceFrontSide;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementErrorSourceFrontSide (struct TdPassportElementErrorSourceFrontSide *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceFrontSide *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceFrontSide (struct TdPassportElementErrorSourceFrontSide *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceFrontSide *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementErrorSourceFrontSide (struct TdPassportElementErrorSourceFrontSide *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceFrontSide *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceFrontSide");
  M->new_field ("ID");
}
struct TdPassportElementErrorSourceFrontSide *TdStackFetcherPassportElementErrorSourceFrontSide (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceFrontSide ();
  res->ID = CODE_PassportElementErrorSourceFrontSide;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementErrorSourceReverseSide *TdCreateObjectPassportElementErrorSourceReverseSide (void) {
  auto var = new struct TdPassportElementErrorSourceReverseSide ();
  var->ID = CODE_PassportElementErrorSourceReverseSide;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceReverseSide> TdConvertToInternal (struct TdPassportElementErrorSourceReverseSide *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementErrorSourceReverseSide>();
}
struct TdPassportElementErrorSourceReverseSide *TdConvertFromInternal (const td::td_api::passportElementErrorSourceReverseSide &from) {
  auto res = new TdPassportElementErrorSourceReverseSide ();
  res->ID = CODE_PassportElementErrorSourceReverseSide;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementErrorSourceReverseSide (struct TdPassportElementErrorSourceReverseSide *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceReverseSide *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceReverseSide (struct TdPassportElementErrorSourceReverseSide *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceReverseSide *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementErrorSourceReverseSide (struct TdPassportElementErrorSourceReverseSide *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceReverseSide *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceReverseSide");
  M->new_field ("ID");
}
struct TdPassportElementErrorSourceReverseSide *TdStackFetcherPassportElementErrorSourceReverseSide (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceReverseSide ();
  res->ID = CODE_PassportElementErrorSourceReverseSide;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementErrorSourceSelfie *TdCreateObjectPassportElementErrorSourceSelfie (void) {
  auto var = new struct TdPassportElementErrorSourceSelfie ();
  var->ID = CODE_PassportElementErrorSourceSelfie;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceSelfie> TdConvertToInternal (struct TdPassportElementErrorSourceSelfie *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementErrorSourceSelfie>();
}
struct TdPassportElementErrorSourceSelfie *TdConvertFromInternal (const td::td_api::passportElementErrorSourceSelfie &from) {
  auto res = new TdPassportElementErrorSourceSelfie ();
  res->ID = CODE_PassportElementErrorSourceSelfie;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementErrorSourceSelfie (struct TdPassportElementErrorSourceSelfie *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceSelfie *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceSelfie (struct TdPassportElementErrorSourceSelfie *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceSelfie *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementErrorSourceSelfie (struct TdPassportElementErrorSourceSelfie *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceSelfie *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceSelfie");
  M->new_field ("ID");
}
struct TdPassportElementErrorSourceSelfie *TdStackFetcherPassportElementErrorSourceSelfie (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceSelfie ();
  res->ID = CODE_PassportElementErrorSourceSelfie;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementErrorSourceTranslationFile *TdCreateObjectPassportElementErrorSourceTranslationFile (void) {
  auto var = new struct TdPassportElementErrorSourceTranslationFile ();
  var->ID = CODE_PassportElementErrorSourceTranslationFile;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceTranslationFile> TdConvertToInternal (struct TdPassportElementErrorSourceTranslationFile *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementErrorSourceTranslationFile>();
}
struct TdPassportElementErrorSourceTranslationFile *TdConvertFromInternal (const td::td_api::passportElementErrorSourceTranslationFile &from) {
  auto res = new TdPassportElementErrorSourceTranslationFile ();
  res->ID = CODE_PassportElementErrorSourceTranslationFile;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementErrorSourceTranslationFile (struct TdPassportElementErrorSourceTranslationFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceTranslationFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceTranslationFile (struct TdPassportElementErrorSourceTranslationFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceTranslationFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementErrorSourceTranslationFile (struct TdPassportElementErrorSourceTranslationFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceTranslationFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceTranslationFile");
  M->new_field ("ID");
}
struct TdPassportElementErrorSourceTranslationFile *TdStackFetcherPassportElementErrorSourceTranslationFile (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceTranslationFile ();
  res->ID = CODE_PassportElementErrorSourceTranslationFile;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementErrorSourceTranslationFiles *TdCreateObjectPassportElementErrorSourceTranslationFiles (void) {
  auto var = new struct TdPassportElementErrorSourceTranslationFiles ();
  var->ID = CODE_PassportElementErrorSourceTranslationFiles;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceTranslationFiles> TdConvertToInternal (struct TdPassportElementErrorSourceTranslationFiles *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementErrorSourceTranslationFiles>();
}
struct TdPassportElementErrorSourceTranslationFiles *TdConvertFromInternal (const td::td_api::passportElementErrorSourceTranslationFiles &from) {
  auto res = new TdPassportElementErrorSourceTranslationFiles ();
  res->ID = CODE_PassportElementErrorSourceTranslationFiles;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementErrorSourceTranslationFiles (struct TdPassportElementErrorSourceTranslationFiles *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceTranslationFiles *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceTranslationFiles (struct TdPassportElementErrorSourceTranslationFiles *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceTranslationFiles *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementErrorSourceTranslationFiles (struct TdPassportElementErrorSourceTranslationFiles *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceTranslationFiles *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceTranslationFiles");
  M->new_field ("ID");
}
struct TdPassportElementErrorSourceTranslationFiles *TdStackFetcherPassportElementErrorSourceTranslationFiles (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceTranslationFiles ();
  res->ID = CODE_PassportElementErrorSourceTranslationFiles;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementErrorSourceFile *TdCreateObjectPassportElementErrorSourceFile (void) {
  auto var = new struct TdPassportElementErrorSourceFile ();
  var->ID = CODE_PassportElementErrorSourceFile;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceFile> TdConvertToInternal (struct TdPassportElementErrorSourceFile *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementErrorSourceFile>();
}
struct TdPassportElementErrorSourceFile *TdConvertFromInternal (const td::td_api::passportElementErrorSourceFile &from) {
  auto res = new TdPassportElementErrorSourceFile ();
  res->ID = CODE_PassportElementErrorSourceFile;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementErrorSourceFile (struct TdPassportElementErrorSourceFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceFile (struct TdPassportElementErrorSourceFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementErrorSourceFile (struct TdPassportElementErrorSourceFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceFile");
  M->new_field ("ID");
}
struct TdPassportElementErrorSourceFile *TdStackFetcherPassportElementErrorSourceFile (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceFile ();
  res->ID = CODE_PassportElementErrorSourceFile;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementErrorSourceFiles *TdCreateObjectPassportElementErrorSourceFiles (void) {
  auto var = new struct TdPassportElementErrorSourceFiles ();
  var->ID = CODE_PassportElementErrorSourceFiles;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementErrorSourceFiles> TdConvertToInternal (struct TdPassportElementErrorSourceFiles *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementErrorSourceFiles>();
}
struct TdPassportElementErrorSourceFiles *TdConvertFromInternal (const td::td_api::passportElementErrorSourceFiles &from) {
  auto res = new TdPassportElementErrorSourceFiles ();
  res->ID = CODE_PassportElementErrorSourceFiles;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementErrorSourceFiles (struct TdPassportElementErrorSourceFiles *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementErrorSourceFiles *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementErrorSourceFiles (struct TdPassportElementErrorSourceFiles *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementErrorSourceFiles *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementErrorSourceFiles (struct TdPassportElementErrorSourceFiles *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementErrorSourceFiles *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementErrorSourceFiles");
  M->new_field ("ID");
}
struct TdPassportElementErrorSourceFiles *TdStackFetcherPassportElementErrorSourceFiles (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementErrorSourceFiles ();
  res->ID = CODE_PassportElementErrorSourceFiles;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::PassportElementType> TdConvertToInternal (struct TdPassportElementType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementTypePersonalDetails: return TdConvertToInternal ((struct TdPassportElementTypePersonalDetails *)var);
    case CODE_PassportElementTypePassport: return TdConvertToInternal ((struct TdPassportElementTypePassport *)var);
    case CODE_PassportElementTypeDriverLicense: return TdConvertToInternal ((struct TdPassportElementTypeDriverLicense *)var);
    case CODE_PassportElementTypeIdentityCard: return TdConvertToInternal ((struct TdPassportElementTypeIdentityCard *)var);
    case CODE_PassportElementTypeInternalPassport: return TdConvertToInternal ((struct TdPassportElementTypeInternalPassport *)var);
    case CODE_PassportElementTypeAddress: return TdConvertToInternal ((struct TdPassportElementTypeAddress *)var);
    case CODE_PassportElementTypeUtilityBill: return TdConvertToInternal ((struct TdPassportElementTypeUtilityBill *)var);
    case CODE_PassportElementTypeBankStatement: return TdConvertToInternal ((struct TdPassportElementTypeBankStatement *)var);
    case CODE_PassportElementTypeRentalAgreement: return TdConvertToInternal ((struct TdPassportElementTypeRentalAgreement *)var);
    case CODE_PassportElementTypePassportRegistration: return TdConvertToInternal ((struct TdPassportElementTypePassportRegistration *)var);
    case CODE_PassportElementTypeTemporaryRegistration: return TdConvertToInternal ((struct TdPassportElementTypeTemporaryRegistration *)var);
    case CODE_PassportElementTypePhoneNumber: return TdConvertToInternal ((struct TdPassportElementTypePhoneNumber *)var);
    case CODE_PassportElementTypeEmailAddress: return TdConvertToInternal ((struct TdPassportElementTypeEmailAddress *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdPassportElementType *TdConvertFromInternal (const td::td_api::PassportElementType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_PassportElementTypePersonalDetails: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypePersonalDetails &>(from));
    case CODE_PassportElementTypePassport: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypePassport &>(from));
    case CODE_PassportElementTypeDriverLicense: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeDriverLicense &>(from));
    case CODE_PassportElementTypeIdentityCard: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeIdentityCard &>(from));
    case CODE_PassportElementTypeInternalPassport: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeInternalPassport &>(from));
    case CODE_PassportElementTypeAddress: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeAddress &>(from));
    case CODE_PassportElementTypeUtilityBill: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeUtilityBill &>(from));
    case CODE_PassportElementTypeBankStatement: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeBankStatement &>(from));
    case CODE_PassportElementTypeRentalAgreement: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeRentalAgreement &>(from));
    case CODE_PassportElementTypePassportRegistration: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypePassportRegistration &>(from));
    case CODE_PassportElementTypeTemporaryRegistration: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeTemporaryRegistration &>(from));
    case CODE_PassportElementTypePhoneNumber: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypePhoneNumber &>(from));
    case CODE_PassportElementTypeEmailAddress: return (struct TdPassportElementType *)TdConvertFromInternal(static_cast<const td::td_api::passportElementTypeEmailAddress &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializePassportElementType (struct TdPassportElementType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementType (struct TdPassportElementType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementTypePersonalDetails: return TdDestroyObject ((struct TdPassportElementTypePersonalDetails *)var);
    case CODE_PassportElementTypePassport: return TdDestroyObject ((struct TdPassportElementTypePassport *)var);
    case CODE_PassportElementTypeDriverLicense: return TdDestroyObject ((struct TdPassportElementTypeDriverLicense *)var);
    case CODE_PassportElementTypeIdentityCard: return TdDestroyObject ((struct TdPassportElementTypeIdentityCard *)var);
    case CODE_PassportElementTypeInternalPassport: return TdDestroyObject ((struct TdPassportElementTypeInternalPassport *)var);
    case CODE_PassportElementTypeAddress: return TdDestroyObject ((struct TdPassportElementTypeAddress *)var);
    case CODE_PassportElementTypeUtilityBill: return TdDestroyObject ((struct TdPassportElementTypeUtilityBill *)var);
    case CODE_PassportElementTypeBankStatement: return TdDestroyObject ((struct TdPassportElementTypeBankStatement *)var);
    case CODE_PassportElementTypeRentalAgreement: return TdDestroyObject ((struct TdPassportElementTypeRentalAgreement *)var);
    case CODE_PassportElementTypePassportRegistration: return TdDestroyObject ((struct TdPassportElementTypePassportRegistration *)var);
    case CODE_PassportElementTypeTemporaryRegistration: return TdDestroyObject ((struct TdPassportElementTypeTemporaryRegistration *)var);
    case CODE_PassportElementTypePhoneNumber: return TdDestroyObject ((struct TdPassportElementTypePhoneNumber *)var);
    case CODE_PassportElementTypeEmailAddress: return TdDestroyObject ((struct TdPassportElementTypeEmailAddress *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerPassportElementType (struct TdPassportElementType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_PassportElementTypePersonalDetails: return TdStackStorer ((struct TdPassportElementTypePersonalDetails *)var, M);
    case CODE_PassportElementTypePassport: return TdStackStorer ((struct TdPassportElementTypePassport *)var, M);
    case CODE_PassportElementTypeDriverLicense: return TdStackStorer ((struct TdPassportElementTypeDriverLicense *)var, M);
    case CODE_PassportElementTypeIdentityCard: return TdStackStorer ((struct TdPassportElementTypeIdentityCard *)var, M);
    case CODE_PassportElementTypeInternalPassport: return TdStackStorer ((struct TdPassportElementTypeInternalPassport *)var, M);
    case CODE_PassportElementTypeAddress: return TdStackStorer ((struct TdPassportElementTypeAddress *)var, M);
    case CODE_PassportElementTypeUtilityBill: return TdStackStorer ((struct TdPassportElementTypeUtilityBill *)var, M);
    case CODE_PassportElementTypeBankStatement: return TdStackStorer ((struct TdPassportElementTypeBankStatement *)var, M);
    case CODE_PassportElementTypeRentalAgreement: return TdStackStorer ((struct TdPassportElementTypeRentalAgreement *)var, M);
    case CODE_PassportElementTypePassportRegistration: return TdStackStorer ((struct TdPassportElementTypePassportRegistration *)var, M);
    case CODE_PassportElementTypeTemporaryRegistration: return TdStackStorer ((struct TdPassportElementTypeTemporaryRegistration *)var, M);
    case CODE_PassportElementTypePhoneNumber: return TdStackStorer ((struct TdPassportElementTypePhoneNumber *)var, M);
    case CODE_PassportElementTypeEmailAddress: return TdStackStorer ((struct TdPassportElementTypeEmailAddress *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdPassportElementType *TdStackFetcherPassportElementType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "PassportElementTypePersonalDetails") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypePersonalDetails (M);
  }
  if (constructor == "PassportElementTypePassport") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypePassport (M);
  }
  if (constructor == "PassportElementTypeDriverLicense") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeDriverLicense (M);
  }
  if (constructor == "PassportElementTypeIdentityCard") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeIdentityCard (M);
  }
  if (constructor == "PassportElementTypeInternalPassport") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeInternalPassport (M);
  }
  if (constructor == "PassportElementTypeAddress") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeAddress (M);
  }
  if (constructor == "PassportElementTypeUtilityBill") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeUtilityBill (M);
  }
  if (constructor == "PassportElementTypeBankStatement") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeBankStatement (M);
  }
  if (constructor == "PassportElementTypeRentalAgreement") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeRentalAgreement (M);
  }
  if (constructor == "PassportElementTypePassportRegistration") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypePassportRegistration (M);
  }
  if (constructor == "PassportElementTypeTemporaryRegistration") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeTemporaryRegistration (M);
  }
  if (constructor == "PassportElementTypePhoneNumber") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypePhoneNumber (M);
  }
  if (constructor == "PassportElementTypeEmailAddress") {
    return (struct TdPassportElementType *)TdStackFetcherPassportElementTypeEmailAddress (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdPassportElementTypePersonalDetails *TdCreateObjectPassportElementTypePersonalDetails (void) {
  auto var = new struct TdPassportElementTypePersonalDetails ();
  var->ID = CODE_PassportElementTypePersonalDetails;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypePersonalDetails> TdConvertToInternal (struct TdPassportElementTypePersonalDetails *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypePersonalDetails>();
}
struct TdPassportElementTypePersonalDetails *TdConvertFromInternal (const td::td_api::passportElementTypePersonalDetails &from) {
  auto res = new TdPassportElementTypePersonalDetails ();
  res->ID = CODE_PassportElementTypePersonalDetails;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypePersonalDetails (struct TdPassportElementTypePersonalDetails *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypePersonalDetails *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypePersonalDetails (struct TdPassportElementTypePersonalDetails *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypePersonalDetails *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypePersonalDetails (struct TdPassportElementTypePersonalDetails *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypePersonalDetails *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypePersonalDetails");
  M->new_field ("ID");
}
struct TdPassportElementTypePersonalDetails *TdStackFetcherPassportElementTypePersonalDetails (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypePersonalDetails ();
  res->ID = CODE_PassportElementTypePersonalDetails;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypePassport *TdCreateObjectPassportElementTypePassport (void) {
  auto var = new struct TdPassportElementTypePassport ();
  var->ID = CODE_PassportElementTypePassport;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypePassport> TdConvertToInternal (struct TdPassportElementTypePassport *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypePassport>();
}
struct TdPassportElementTypePassport *TdConvertFromInternal (const td::td_api::passportElementTypePassport &from) {
  auto res = new TdPassportElementTypePassport ();
  res->ID = CODE_PassportElementTypePassport;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypePassport (struct TdPassportElementTypePassport *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypePassport *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypePassport (struct TdPassportElementTypePassport *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypePassport *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypePassport (struct TdPassportElementTypePassport *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypePassport *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypePassport");
  M->new_field ("ID");
}
struct TdPassportElementTypePassport *TdStackFetcherPassportElementTypePassport (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypePassport ();
  res->ID = CODE_PassportElementTypePassport;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeDriverLicense *TdCreateObjectPassportElementTypeDriverLicense (void) {
  auto var = new struct TdPassportElementTypeDriverLicense ();
  var->ID = CODE_PassportElementTypeDriverLicense;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeDriverLicense> TdConvertToInternal (struct TdPassportElementTypeDriverLicense *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeDriverLicense>();
}
struct TdPassportElementTypeDriverLicense *TdConvertFromInternal (const td::td_api::passportElementTypeDriverLicense &from) {
  auto res = new TdPassportElementTypeDriverLicense ();
  res->ID = CODE_PassportElementTypeDriverLicense;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeDriverLicense (struct TdPassportElementTypeDriverLicense *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeDriverLicense *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeDriverLicense (struct TdPassportElementTypeDriverLicense *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeDriverLicense *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeDriverLicense (struct TdPassportElementTypeDriverLicense *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeDriverLicense *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeDriverLicense");
  M->new_field ("ID");
}
struct TdPassportElementTypeDriverLicense *TdStackFetcherPassportElementTypeDriverLicense (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeDriverLicense ();
  res->ID = CODE_PassportElementTypeDriverLicense;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeIdentityCard *TdCreateObjectPassportElementTypeIdentityCard (void) {
  auto var = new struct TdPassportElementTypeIdentityCard ();
  var->ID = CODE_PassportElementTypeIdentityCard;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeIdentityCard> TdConvertToInternal (struct TdPassportElementTypeIdentityCard *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeIdentityCard>();
}
struct TdPassportElementTypeIdentityCard *TdConvertFromInternal (const td::td_api::passportElementTypeIdentityCard &from) {
  auto res = new TdPassportElementTypeIdentityCard ();
  res->ID = CODE_PassportElementTypeIdentityCard;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeIdentityCard (struct TdPassportElementTypeIdentityCard *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeIdentityCard *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeIdentityCard (struct TdPassportElementTypeIdentityCard *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeIdentityCard *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeIdentityCard (struct TdPassportElementTypeIdentityCard *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeIdentityCard *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeIdentityCard");
  M->new_field ("ID");
}
struct TdPassportElementTypeIdentityCard *TdStackFetcherPassportElementTypeIdentityCard (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeIdentityCard ();
  res->ID = CODE_PassportElementTypeIdentityCard;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeInternalPassport *TdCreateObjectPassportElementTypeInternalPassport (void) {
  auto var = new struct TdPassportElementTypeInternalPassport ();
  var->ID = CODE_PassportElementTypeInternalPassport;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeInternalPassport> TdConvertToInternal (struct TdPassportElementTypeInternalPassport *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeInternalPassport>();
}
struct TdPassportElementTypeInternalPassport *TdConvertFromInternal (const td::td_api::passportElementTypeInternalPassport &from) {
  auto res = new TdPassportElementTypeInternalPassport ();
  res->ID = CODE_PassportElementTypeInternalPassport;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeInternalPassport (struct TdPassportElementTypeInternalPassport *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeInternalPassport *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeInternalPassport (struct TdPassportElementTypeInternalPassport *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeInternalPassport *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeInternalPassport (struct TdPassportElementTypeInternalPassport *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeInternalPassport *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeInternalPassport");
  M->new_field ("ID");
}
struct TdPassportElementTypeInternalPassport *TdStackFetcherPassportElementTypeInternalPassport (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeInternalPassport ();
  res->ID = CODE_PassportElementTypeInternalPassport;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeAddress *TdCreateObjectPassportElementTypeAddress (void) {
  auto var = new struct TdPassportElementTypeAddress ();
  var->ID = CODE_PassportElementTypeAddress;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeAddress> TdConvertToInternal (struct TdPassportElementTypeAddress *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeAddress>();
}
struct TdPassportElementTypeAddress *TdConvertFromInternal (const td::td_api::passportElementTypeAddress &from) {
  auto res = new TdPassportElementTypeAddress ();
  res->ID = CODE_PassportElementTypeAddress;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeAddress (struct TdPassportElementTypeAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeAddress (struct TdPassportElementTypeAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeAddress (struct TdPassportElementTypeAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeAddress");
  M->new_field ("ID");
}
struct TdPassportElementTypeAddress *TdStackFetcherPassportElementTypeAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeAddress ();
  res->ID = CODE_PassportElementTypeAddress;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeUtilityBill *TdCreateObjectPassportElementTypeUtilityBill (void) {
  auto var = new struct TdPassportElementTypeUtilityBill ();
  var->ID = CODE_PassportElementTypeUtilityBill;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeUtilityBill> TdConvertToInternal (struct TdPassportElementTypeUtilityBill *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeUtilityBill>();
}
struct TdPassportElementTypeUtilityBill *TdConvertFromInternal (const td::td_api::passportElementTypeUtilityBill &from) {
  auto res = new TdPassportElementTypeUtilityBill ();
  res->ID = CODE_PassportElementTypeUtilityBill;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeUtilityBill (struct TdPassportElementTypeUtilityBill *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeUtilityBill *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeUtilityBill (struct TdPassportElementTypeUtilityBill *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeUtilityBill *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeUtilityBill (struct TdPassportElementTypeUtilityBill *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeUtilityBill *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeUtilityBill");
  M->new_field ("ID");
}
struct TdPassportElementTypeUtilityBill *TdStackFetcherPassportElementTypeUtilityBill (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeUtilityBill ();
  res->ID = CODE_PassportElementTypeUtilityBill;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeBankStatement *TdCreateObjectPassportElementTypeBankStatement (void) {
  auto var = new struct TdPassportElementTypeBankStatement ();
  var->ID = CODE_PassportElementTypeBankStatement;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeBankStatement> TdConvertToInternal (struct TdPassportElementTypeBankStatement *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeBankStatement>();
}
struct TdPassportElementTypeBankStatement *TdConvertFromInternal (const td::td_api::passportElementTypeBankStatement &from) {
  auto res = new TdPassportElementTypeBankStatement ();
  res->ID = CODE_PassportElementTypeBankStatement;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeBankStatement (struct TdPassportElementTypeBankStatement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeBankStatement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeBankStatement (struct TdPassportElementTypeBankStatement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeBankStatement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeBankStatement (struct TdPassportElementTypeBankStatement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeBankStatement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeBankStatement");
  M->new_field ("ID");
}
struct TdPassportElementTypeBankStatement *TdStackFetcherPassportElementTypeBankStatement (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeBankStatement ();
  res->ID = CODE_PassportElementTypeBankStatement;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeRentalAgreement *TdCreateObjectPassportElementTypeRentalAgreement (void) {
  auto var = new struct TdPassportElementTypeRentalAgreement ();
  var->ID = CODE_PassportElementTypeRentalAgreement;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeRentalAgreement> TdConvertToInternal (struct TdPassportElementTypeRentalAgreement *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeRentalAgreement>();
}
struct TdPassportElementTypeRentalAgreement *TdConvertFromInternal (const td::td_api::passportElementTypeRentalAgreement &from) {
  auto res = new TdPassportElementTypeRentalAgreement ();
  res->ID = CODE_PassportElementTypeRentalAgreement;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeRentalAgreement (struct TdPassportElementTypeRentalAgreement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeRentalAgreement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeRentalAgreement (struct TdPassportElementTypeRentalAgreement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeRentalAgreement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeRentalAgreement (struct TdPassportElementTypeRentalAgreement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeRentalAgreement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeRentalAgreement");
  M->new_field ("ID");
}
struct TdPassportElementTypeRentalAgreement *TdStackFetcherPassportElementTypeRentalAgreement (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeRentalAgreement ();
  res->ID = CODE_PassportElementTypeRentalAgreement;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypePassportRegistration *TdCreateObjectPassportElementTypePassportRegistration (void) {
  auto var = new struct TdPassportElementTypePassportRegistration ();
  var->ID = CODE_PassportElementTypePassportRegistration;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypePassportRegistration> TdConvertToInternal (struct TdPassportElementTypePassportRegistration *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypePassportRegistration>();
}
struct TdPassportElementTypePassportRegistration *TdConvertFromInternal (const td::td_api::passportElementTypePassportRegistration &from) {
  auto res = new TdPassportElementTypePassportRegistration ();
  res->ID = CODE_PassportElementTypePassportRegistration;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypePassportRegistration (struct TdPassportElementTypePassportRegistration *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypePassportRegistration *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypePassportRegistration (struct TdPassportElementTypePassportRegistration *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypePassportRegistration *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypePassportRegistration (struct TdPassportElementTypePassportRegistration *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypePassportRegistration *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypePassportRegistration");
  M->new_field ("ID");
}
struct TdPassportElementTypePassportRegistration *TdStackFetcherPassportElementTypePassportRegistration (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypePassportRegistration ();
  res->ID = CODE_PassportElementTypePassportRegistration;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeTemporaryRegistration *TdCreateObjectPassportElementTypeTemporaryRegistration (void) {
  auto var = new struct TdPassportElementTypeTemporaryRegistration ();
  var->ID = CODE_PassportElementTypeTemporaryRegistration;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeTemporaryRegistration> TdConvertToInternal (struct TdPassportElementTypeTemporaryRegistration *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeTemporaryRegistration>();
}
struct TdPassportElementTypeTemporaryRegistration *TdConvertFromInternal (const td::td_api::passportElementTypeTemporaryRegistration &from) {
  auto res = new TdPassportElementTypeTemporaryRegistration ();
  res->ID = CODE_PassportElementTypeTemporaryRegistration;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeTemporaryRegistration (struct TdPassportElementTypeTemporaryRegistration *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeTemporaryRegistration *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeTemporaryRegistration (struct TdPassportElementTypeTemporaryRegistration *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeTemporaryRegistration *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeTemporaryRegistration (struct TdPassportElementTypeTemporaryRegistration *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeTemporaryRegistration *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeTemporaryRegistration");
  M->new_field ("ID");
}
struct TdPassportElementTypeTemporaryRegistration *TdStackFetcherPassportElementTypeTemporaryRegistration (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeTemporaryRegistration ();
  res->ID = CODE_PassportElementTypeTemporaryRegistration;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypePhoneNumber *TdCreateObjectPassportElementTypePhoneNumber (void) {
  auto var = new struct TdPassportElementTypePhoneNumber ();
  var->ID = CODE_PassportElementTypePhoneNumber;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypePhoneNumber> TdConvertToInternal (struct TdPassportElementTypePhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypePhoneNumber>();
}
struct TdPassportElementTypePhoneNumber *TdConvertFromInternal (const td::td_api::passportElementTypePhoneNumber &from) {
  auto res = new TdPassportElementTypePhoneNumber ();
  res->ID = CODE_PassportElementTypePhoneNumber;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypePhoneNumber (struct TdPassportElementTypePhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypePhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypePhoneNumber (struct TdPassportElementTypePhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypePhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypePhoneNumber (struct TdPassportElementTypePhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypePhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypePhoneNumber");
  M->new_field ("ID");
}
struct TdPassportElementTypePhoneNumber *TdStackFetcherPassportElementTypePhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypePhoneNumber ();
  res->ID = CODE_PassportElementTypePhoneNumber;
  res->refcnt = 1;
  return res;
}
struct TdPassportElementTypeEmailAddress *TdCreateObjectPassportElementTypeEmailAddress (void) {
  auto var = new struct TdPassportElementTypeEmailAddress ();
  var->ID = CODE_PassportElementTypeEmailAddress;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElementTypeEmailAddress> TdConvertToInternal (struct TdPassportElementTypeEmailAddress *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::passportElementTypeEmailAddress>();
}
struct TdPassportElementTypeEmailAddress *TdConvertFromInternal (const td::td_api::passportElementTypeEmailAddress &from) {
  auto res = new TdPassportElementTypeEmailAddress ();
  res->ID = CODE_PassportElementTypeEmailAddress;
  res->refcnt = 1;
  return res;
}
char *TdSerializePassportElementTypeEmailAddress (struct TdPassportElementTypeEmailAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElementTypeEmailAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElementTypeEmailAddress (struct TdPassportElementTypeEmailAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElementTypeEmailAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPassportElementTypeEmailAddress (struct TdPassportElementTypeEmailAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElementTypeEmailAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElementTypeEmailAddress");
  M->new_field ("ID");
}
struct TdPassportElementTypeEmailAddress *TdStackFetcherPassportElementTypeEmailAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElementTypeEmailAddress ();
  res->ID = CODE_PassportElementTypeEmailAddress;
  res->refcnt = 1;
  return res;
}
struct TdPassportElements *TdCreateObjectPassportElements (struct TdVectorPassportElement *elements_) {
  auto var = new struct TdPassportElements ();
  var->ID = CODE_PassportElements;
  var->refcnt = 1;
  var->elements_ = elements_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportElements> TdConvertToInternal (struct TdPassportElements *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::PassportElement>> v0;
  for (int i0 = 0; i0 < var->elements_->len; i0++) {
    td::td_api::object_ptr<td::td_api::PassportElement> v1;
    v1 = TdConvertToInternal (var->elements_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::passportElements>(std::move (v0));
}
struct TdPassportElements *TdConvertFromInternal (const td::td_api::passportElements &from) {
  auto res = new TdPassportElements ();
  res->ID = CODE_PassportElements;
  res->refcnt = 1;
  res->elements_ = new TdVectorPassportElement ();
  res->elements_->len = (int)from.elements_.size ();
  res->elements_->data = new struct TdPassportElement * [res->elements_->len];
  for (int i0 = 0; i0 < res->elements_->len; i0++) {
    if (!from.elements_[i0]) {
      res->elements_->data[i0] = nullptr;
    } else {
      res->elements_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::PassportElement &>(*from.elements_[i0]));
    }
  }
  return res;
}
char *TdSerializePassportElements (struct TdPassportElements *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportElements *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportElements (struct TdPassportElements *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportElements *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->elements_->len; i0++) {
    TdDestroyObject (var->elements_->data[i0]);
  }
  delete[] var->elements_->data;
  delete var->elements_;
  delete var;
}
void TdStackStorerPassportElements (struct TdPassportElements *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportElements *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportElements");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->elements_->len; i0++) {
    TdStackStorer (var->elements_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("elements_");
}
struct TdPassportElements *TdStackFetcherPassportElements (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportElements ();
  res->ID = CODE_PassportElements;
  res->refcnt = 1;
  M->get_field ("elements_");
  res->elements_ = new TdVectorPassportElement ();
  res->elements_->len = M->get_arr_size ();
  res->elements_->data = new struct TdPassportElement * [res->elements_->len];
  for (int i0 = 0; i0 < res->elements_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->elements_->data[i0] = nullptr;
    } else {
      res->elements_->data[i0] = TdStackFetcherPassportElement (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdPassportRequiredElement *TdCreateObjectPassportRequiredElement (struct TdVectorPassportSuitableElement *suitable_elements_) {
  auto var = new struct TdPassportRequiredElement ();
  var->ID = CODE_PassportRequiredElement;
  var->refcnt = 1;
  var->suitable_elements_ = suitable_elements_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportRequiredElement> TdConvertToInternal (struct TdPassportRequiredElement *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::passportSuitableElement>> v0;
  for (int i0 = 0; i0 < var->suitable_elements_->len; i0++) {
    td::td_api::object_ptr<td::td_api::passportSuitableElement> v1;
    v1 = TdConvertToInternal (var->suitable_elements_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::passportRequiredElement>(std::move (v0));
}
struct TdPassportRequiredElement *TdConvertFromInternal (const td::td_api::passportRequiredElement &from) {
  auto res = new TdPassportRequiredElement ();
  res->ID = CODE_PassportRequiredElement;
  res->refcnt = 1;
  res->suitable_elements_ = new TdVectorPassportSuitableElement ();
  res->suitable_elements_->len = (int)from.suitable_elements_.size ();
  res->suitable_elements_->data = new struct TdPassportSuitableElement * [res->suitable_elements_->len];
  for (int i0 = 0; i0 < res->suitable_elements_->len; i0++) {
    if (!from.suitable_elements_[i0]) {
      res->suitable_elements_->data[i0] = nullptr;
    } else {
      res->suitable_elements_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::passportSuitableElement &>(*from.suitable_elements_[i0]));
    }
  }
  return res;
}
char *TdSerializePassportRequiredElement (struct TdPassportRequiredElement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportRequiredElement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportRequiredElement (struct TdPassportRequiredElement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportRequiredElement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->suitable_elements_->len; i0++) {
    TdDestroyObject (var->suitable_elements_->data[i0]);
  }
  delete[] var->suitable_elements_->data;
  delete var->suitable_elements_;
  delete var;
}
void TdStackStorerPassportRequiredElement (struct TdPassportRequiredElement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportRequiredElement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportRequiredElement");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->suitable_elements_->len; i0++) {
    TdStackStorer (var->suitable_elements_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("suitable_elements_");
}
struct TdPassportRequiredElement *TdStackFetcherPassportRequiredElement (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportRequiredElement ();
  res->ID = CODE_PassportRequiredElement;
  res->refcnt = 1;
  M->get_field ("suitable_elements_");
  res->suitable_elements_ = new TdVectorPassportSuitableElement ();
  res->suitable_elements_->len = M->get_arr_size ();
  res->suitable_elements_->data = new struct TdPassportSuitableElement * [res->suitable_elements_->len];
  for (int i0 = 0; i0 < res->suitable_elements_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->suitable_elements_->data[i0] = nullptr;
    } else {
      res->suitable_elements_->data[i0] = TdStackFetcherPassportSuitableElement (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdPassportSuitableElement *TdCreateObjectPassportSuitableElement (struct TdPassportElementType *type_, int is_selfie_required_, int is_translation_required_, int is_native_name_required_) {
  auto var = new struct TdPassportSuitableElement ();
  var->ID = CODE_PassportSuitableElement;
  var->refcnt = 1;
  var->type_ = type_;
  var->is_selfie_required_ = is_selfie_required_;
  var->is_translation_required_ = is_translation_required_;
  var->is_native_name_required_ = is_native_name_required_;
  return var;
}
td::td_api::object_ptr<td::td_api::passportSuitableElement> TdConvertToInternal (struct TdPassportSuitableElement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::PassportElementType> v0;
  v0 = TdConvertToInternal (var->type_);
  bool v100;
  v100 = var->is_selfie_required_ != 0;
  bool v200;
  v200 = var->is_translation_required_ != 0;
  bool v300;
  v300 = var->is_native_name_required_ != 0;
  return td::td_api::make_object<td::td_api::passportSuitableElement>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdPassportSuitableElement *TdConvertFromInternal (const td::td_api::passportSuitableElement &from) {
  auto res = new TdPassportSuitableElement ();
  res->ID = CODE_PassportSuitableElement;
  res->refcnt = 1;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::PassportElementType &>(*from.type_));
  }
  res->is_selfie_required_ = from.is_selfie_required_;
  res->is_translation_required_ = from.is_translation_required_;
  res->is_native_name_required_ = from.is_native_name_required_;
  return res;
}
char *TdSerializePassportSuitableElement (struct TdPassportSuitableElement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPassportSuitableElement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPassportSuitableElement (struct TdPassportSuitableElement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPassportSuitableElement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerPassportSuitableElement (struct TdPassportSuitableElement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPassportSuitableElement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PassportSuitableElement");
  M->new_field ("ID");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  M->pack_bool (var->is_selfie_required_);
  M->new_field ("is_selfie_required_");
  M->pack_bool (var->is_translation_required_);
  M->new_field ("is_translation_required_");
  M->pack_bool (var->is_native_name_required_);
  M->new_field ("is_native_name_required_");
}
struct TdPassportSuitableElement *TdStackFetcherPassportSuitableElement (struct TdStackFetcherMethods *M) {
  auto res = new TdPassportSuitableElement ();
  res->ID = CODE_PassportSuitableElement;
  res->refcnt = 1;
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherPassportElementType (M);
  }
  M->pop ();
  M->get_field ("is_selfie_required_");
  res->is_selfie_required_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_translation_required_");
  res->is_translation_required_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_native_name_required_");
  res->is_native_name_required_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPasswordState *TdCreateObjectPasswordState (int has_password_, char *password_hint_, int has_recovery_email_address_, int has_passport_data_, char *unconfirmed_recovery_email_address_pattern_) {
  auto var = new struct TdPasswordState ();
  var->ID = CODE_PasswordState;
  var->refcnt = 1;
  var->has_password_ = has_password_;
  var->password_hint_ = (password_hint_) ? td::str_dup (td::Slice (password_hint_)) : nullptr;
  var->has_recovery_email_address_ = has_recovery_email_address_;
  var->has_passport_data_ = has_passport_data_;
  var->unconfirmed_recovery_email_address_pattern_ = (unconfirmed_recovery_email_address_pattern_) ? td::str_dup (td::Slice (unconfirmed_recovery_email_address_pattern_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::passwordState> TdConvertToInternal (struct TdPasswordState *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->has_password_ != 0;
  std::string v100;
  v100 = (var->password_hint_) ? var->password_hint_: "";
  bool v200;
  v200 = var->has_recovery_email_address_ != 0;
  bool v300;
  v300 = var->has_passport_data_ != 0;
  std::string v400;
  v400 = (var->unconfirmed_recovery_email_address_pattern_) ? var->unconfirmed_recovery_email_address_pattern_: "";
  return td::td_api::make_object<td::td_api::passwordState>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdPasswordState *TdConvertFromInternal (const td::td_api::passwordState &from) {
  auto res = new TdPasswordState ();
  res->ID = CODE_PasswordState;
  res->refcnt = 1;
  res->has_password_ = from.has_password_;
  res->password_hint_ = (from.password_hint_.length ()) ? td::str_dup (from.password_hint_) : nullptr;
  res->has_recovery_email_address_ = from.has_recovery_email_address_;
  res->has_passport_data_ = from.has_passport_data_;
  res->unconfirmed_recovery_email_address_pattern_ = (from.unconfirmed_recovery_email_address_pattern_.length ()) ? td::str_dup (from.unconfirmed_recovery_email_address_pattern_) : nullptr;
  return res;
}
char *TdSerializePasswordState (struct TdPasswordState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPasswordState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPasswordState (struct TdPasswordState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPasswordState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->password_hint_);
  free (var->unconfirmed_recovery_email_address_pattern_);
  delete var;
}
void TdStackStorerPasswordState (struct TdPasswordState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPasswordState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PasswordState");
  M->new_field ("ID");
  M->pack_bool (var->has_password_);
  M->new_field ("has_password_");
  M->pack_string (var->password_hint_);
  M->new_field ("password_hint_");
  M->pack_bool (var->has_recovery_email_address_);
  M->new_field ("has_recovery_email_address_");
  M->pack_bool (var->has_passport_data_);
  M->new_field ("has_passport_data_");
  M->pack_string (var->unconfirmed_recovery_email_address_pattern_);
  M->new_field ("unconfirmed_recovery_email_address_pattern_");
}
struct TdPasswordState *TdStackFetcherPasswordState (struct TdStackFetcherMethods *M) {
  auto res = new TdPasswordState ();
  res->ID = CODE_PasswordState;
  res->refcnt = 1;
  M->get_field ("has_password_");
  res->has_password_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("password_hint_");
  res->password_hint_ = M->get_string ();
  M->pop ();
  M->get_field ("has_recovery_email_address_");
  res->has_recovery_email_address_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("has_passport_data_");
  res->has_passport_data_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("unconfirmed_recovery_email_address_pattern_");
  res->unconfirmed_recovery_email_address_pattern_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPaymentForm *TdCreateObjectPaymentForm (struct TdInvoice *invoice_, char *url_, struct TdPaymentsProviderStripe *payments_provider_, struct TdOrderInfo *saved_order_info_, struct TdSavedCredentials *saved_credentials_, int can_save_credentials_, int need_password_) {
  auto var = new struct TdPaymentForm ();
  var->ID = CODE_PaymentForm;
  var->refcnt = 1;
  var->invoice_ = invoice_;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->payments_provider_ = payments_provider_;
  var->saved_order_info_ = saved_order_info_;
  var->saved_credentials_ = saved_credentials_;
  var->can_save_credentials_ = can_save_credentials_;
  var->need_password_ = need_password_;
  return var;
}
td::td_api::object_ptr<td::td_api::paymentForm> TdConvertToInternal (struct TdPaymentForm *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::invoice> v0;
  v0 = TdConvertToInternal (var->invoice_);
  std::string v100;
  v100 = (var->url_) ? var->url_: "";
  td::td_api::object_ptr<td::td_api::paymentsProviderStripe> v200;
  v200 = TdConvertToInternal (var->payments_provider_);
  td::td_api::object_ptr<td::td_api::orderInfo> v300;
  v300 = TdConvertToInternal (var->saved_order_info_);
  td::td_api::object_ptr<td::td_api::savedCredentials> v400;
  v400 = TdConvertToInternal (var->saved_credentials_);
  bool v500;
  v500 = var->can_save_credentials_ != 0;
  bool v600;
  v600 = var->need_password_ != 0;
  return td::td_api::make_object<td::td_api::paymentForm>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdPaymentForm *TdConvertFromInternal (const td::td_api::paymentForm &from) {
  auto res = new TdPaymentForm ();
  res->ID = CODE_PaymentForm;
  res->refcnt = 1;
  if (!from.invoice_) {
    res->invoice_ = nullptr;
  } else {
    res->invoice_ = TdConvertFromInternal (static_cast<const td::td_api::invoice &>(*from.invoice_));
  }
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  if (!from.payments_provider_) {
    res->payments_provider_ = nullptr;
  } else {
    res->payments_provider_ = TdConvertFromInternal (static_cast<const td::td_api::paymentsProviderStripe &>(*from.payments_provider_));
  }
  if (!from.saved_order_info_) {
    res->saved_order_info_ = nullptr;
  } else {
    res->saved_order_info_ = TdConvertFromInternal (static_cast<const td::td_api::orderInfo &>(*from.saved_order_info_));
  }
  if (!from.saved_credentials_) {
    res->saved_credentials_ = nullptr;
  } else {
    res->saved_credentials_ = TdConvertFromInternal (static_cast<const td::td_api::savedCredentials &>(*from.saved_credentials_));
  }
  res->can_save_credentials_ = from.can_save_credentials_;
  res->need_password_ = from.need_password_;
  return res;
}
char *TdSerializePaymentForm (struct TdPaymentForm *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPaymentForm *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPaymentForm (struct TdPaymentForm *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPaymentForm *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->invoice_);
  free (var->url_);
  TdDestroyObject (var->payments_provider_);
  TdDestroyObject (var->saved_order_info_);
  TdDestroyObject (var->saved_credentials_);
  delete var;
}
void TdStackStorerPaymentForm (struct TdPaymentForm *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPaymentForm *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PaymentForm");
  M->new_field ("ID");
  TdStackStorer (var->invoice_, M);
  M->new_field ("invoice_");
  M->pack_string (var->url_);
  M->new_field ("url_");
  TdStackStorer (var->payments_provider_, M);
  M->new_field ("payments_provider_");
  TdStackStorer (var->saved_order_info_, M);
  M->new_field ("saved_order_info_");
  TdStackStorer (var->saved_credentials_, M);
  M->new_field ("saved_credentials_");
  M->pack_bool (var->can_save_credentials_);
  M->new_field ("can_save_credentials_");
  M->pack_bool (var->need_password_);
  M->new_field ("need_password_");
}
struct TdPaymentForm *TdStackFetcherPaymentForm (struct TdStackFetcherMethods *M) {
  auto res = new TdPaymentForm ();
  res->ID = CODE_PaymentForm;
  res->refcnt = 1;
  M->get_field ("invoice_");
  if (M->is_nil ()) {
    res->invoice_ = nullptr;
  } else {
    res->invoice_ = TdStackFetcherInvoice (M);
  }
  M->pop ();
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("payments_provider_");
  if (M->is_nil ()) {
    res->payments_provider_ = nullptr;
  } else {
    res->payments_provider_ = TdStackFetcherPaymentsProviderStripe (M);
  }
  M->pop ();
  M->get_field ("saved_order_info_");
  if (M->is_nil ()) {
    res->saved_order_info_ = nullptr;
  } else {
    res->saved_order_info_ = TdStackFetcherOrderInfo (M);
  }
  M->pop ();
  M->get_field ("saved_credentials_");
  if (M->is_nil ()) {
    res->saved_credentials_ = nullptr;
  } else {
    res->saved_credentials_ = TdStackFetcherSavedCredentials (M);
  }
  M->pop ();
  M->get_field ("can_save_credentials_");
  res->can_save_credentials_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_password_");
  res->need_password_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPaymentReceipt *TdCreateObjectPaymentReceipt (int date_, int payments_provider_user_id_, struct TdInvoice *invoice_, struct TdOrderInfo *order_info_, struct TdShippingOption *shipping_option_, char *credentials_title_) {
  auto var = new struct TdPaymentReceipt ();
  var->ID = CODE_PaymentReceipt;
  var->refcnt = 1;
  var->date_ = date_;
  var->payments_provider_user_id_ = payments_provider_user_id_;
  var->invoice_ = invoice_;
  var->order_info_ = order_info_;
  var->shipping_option_ = shipping_option_;
  var->credentials_title_ = (credentials_title_) ? td::str_dup (td::Slice (credentials_title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::paymentReceipt> TdConvertToInternal (struct TdPaymentReceipt *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->date_;
  std::int32_t v100;
  v100 = var->payments_provider_user_id_;
  td::td_api::object_ptr<td::td_api::invoice> v200;
  v200 = TdConvertToInternal (var->invoice_);
  td::td_api::object_ptr<td::td_api::orderInfo> v300;
  v300 = TdConvertToInternal (var->order_info_);
  td::td_api::object_ptr<td::td_api::shippingOption> v400;
  v400 = TdConvertToInternal (var->shipping_option_);
  std::string v500;
  v500 = (var->credentials_title_) ? var->credentials_title_: "";
  return td::td_api::make_object<td::td_api::paymentReceipt>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdPaymentReceipt *TdConvertFromInternal (const td::td_api::paymentReceipt &from) {
  auto res = new TdPaymentReceipt ();
  res->ID = CODE_PaymentReceipt;
  res->refcnt = 1;
  res->date_ = from.date_;
  res->payments_provider_user_id_ = from.payments_provider_user_id_;
  if (!from.invoice_) {
    res->invoice_ = nullptr;
  } else {
    res->invoice_ = TdConvertFromInternal (static_cast<const td::td_api::invoice &>(*from.invoice_));
  }
  if (!from.order_info_) {
    res->order_info_ = nullptr;
  } else {
    res->order_info_ = TdConvertFromInternal (static_cast<const td::td_api::orderInfo &>(*from.order_info_));
  }
  if (!from.shipping_option_) {
    res->shipping_option_ = nullptr;
  } else {
    res->shipping_option_ = TdConvertFromInternal (static_cast<const td::td_api::shippingOption &>(*from.shipping_option_));
  }
  res->credentials_title_ = (from.credentials_title_.length ()) ? td::str_dup (from.credentials_title_) : nullptr;
  return res;
}
char *TdSerializePaymentReceipt (struct TdPaymentReceipt *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPaymentReceipt *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPaymentReceipt (struct TdPaymentReceipt *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPaymentReceipt *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->invoice_);
  TdDestroyObject (var->order_info_);
  TdDestroyObject (var->shipping_option_);
  free (var->credentials_title_);
  delete var;
}
void TdStackStorerPaymentReceipt (struct TdPaymentReceipt *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPaymentReceipt *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PaymentReceipt");
  M->new_field ("ID");
  M->pack_long (var->date_);
  M->new_field ("date_");
  M->pack_long (var->payments_provider_user_id_);
  M->new_field ("payments_provider_user_id_");
  TdStackStorer (var->invoice_, M);
  M->new_field ("invoice_");
  TdStackStorer (var->order_info_, M);
  M->new_field ("order_info_");
  TdStackStorer (var->shipping_option_, M);
  M->new_field ("shipping_option_");
  M->pack_string (var->credentials_title_);
  M->new_field ("credentials_title_");
}
struct TdPaymentReceipt *TdStackFetcherPaymentReceipt (struct TdStackFetcherMethods *M) {
  auto res = new TdPaymentReceipt ();
  res->ID = CODE_PaymentReceipt;
  res->refcnt = 1;
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("payments_provider_user_id_");
  res->payments_provider_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("invoice_");
  if (M->is_nil ()) {
    res->invoice_ = nullptr;
  } else {
    res->invoice_ = TdStackFetcherInvoice (M);
  }
  M->pop ();
  M->get_field ("order_info_");
  if (M->is_nil ()) {
    res->order_info_ = nullptr;
  } else {
    res->order_info_ = TdStackFetcherOrderInfo (M);
  }
  M->pop ();
  M->get_field ("shipping_option_");
  if (M->is_nil ()) {
    res->shipping_option_ = nullptr;
  } else {
    res->shipping_option_ = TdStackFetcherShippingOption (M);
  }
  M->pop ();
  M->get_field ("credentials_title_");
  res->credentials_title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPaymentResult *TdCreateObjectPaymentResult (int success_, char *verification_url_) {
  auto var = new struct TdPaymentResult ();
  var->ID = CODE_PaymentResult;
  var->refcnt = 1;
  var->success_ = success_;
  var->verification_url_ = (verification_url_) ? td::str_dup (td::Slice (verification_url_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::paymentResult> TdConvertToInternal (struct TdPaymentResult *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->success_ != 0;
  std::string v100;
  v100 = (var->verification_url_) ? var->verification_url_: "";
  return td::td_api::make_object<td::td_api::paymentResult>(std::move (v0), std::move (v100));
}
struct TdPaymentResult *TdConvertFromInternal (const td::td_api::paymentResult &from) {
  auto res = new TdPaymentResult ();
  res->ID = CODE_PaymentResult;
  res->refcnt = 1;
  res->success_ = from.success_;
  res->verification_url_ = (from.verification_url_.length ()) ? td::str_dup (from.verification_url_) : nullptr;
  return res;
}
char *TdSerializePaymentResult (struct TdPaymentResult *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPaymentResult *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPaymentResult (struct TdPaymentResult *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPaymentResult *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->verification_url_);
  delete var;
}
void TdStackStorerPaymentResult (struct TdPaymentResult *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPaymentResult *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PaymentResult");
  M->new_field ("ID");
  M->pack_bool (var->success_);
  M->new_field ("success_");
  M->pack_string (var->verification_url_);
  M->new_field ("verification_url_");
}
struct TdPaymentResult *TdStackFetcherPaymentResult (struct TdStackFetcherMethods *M) {
  auto res = new TdPaymentResult ();
  res->ID = CODE_PaymentResult;
  res->refcnt = 1;
  M->get_field ("success_");
  res->success_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("verification_url_");
  res->verification_url_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPaymentsProviderStripe *TdCreateObjectPaymentsProviderStripe (char *publishable_key_, int need_country_, int need_postal_code_, int need_cardholder_name_) {
  auto var = new struct TdPaymentsProviderStripe ();
  var->ID = CODE_PaymentsProviderStripe;
  var->refcnt = 1;
  var->publishable_key_ = (publishable_key_) ? td::str_dup (td::Slice (publishable_key_)) : nullptr;
  var->need_country_ = need_country_;
  var->need_postal_code_ = need_postal_code_;
  var->need_cardholder_name_ = need_cardholder_name_;
  return var;
}
td::td_api::object_ptr<td::td_api::paymentsProviderStripe> TdConvertToInternal (struct TdPaymentsProviderStripe *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->publishable_key_) ? var->publishable_key_: "";
  bool v100;
  v100 = var->need_country_ != 0;
  bool v200;
  v200 = var->need_postal_code_ != 0;
  bool v300;
  v300 = var->need_cardholder_name_ != 0;
  return td::td_api::make_object<td::td_api::paymentsProviderStripe>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdPaymentsProviderStripe *TdConvertFromInternal (const td::td_api::paymentsProviderStripe &from) {
  auto res = new TdPaymentsProviderStripe ();
  res->ID = CODE_PaymentsProviderStripe;
  res->refcnt = 1;
  res->publishable_key_ = (from.publishable_key_.length ()) ? td::str_dup (from.publishable_key_) : nullptr;
  res->need_country_ = from.need_country_;
  res->need_postal_code_ = from.need_postal_code_;
  res->need_cardholder_name_ = from.need_cardholder_name_;
  return res;
}
char *TdSerializePaymentsProviderStripe (struct TdPaymentsProviderStripe *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPaymentsProviderStripe *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPaymentsProviderStripe (struct TdPaymentsProviderStripe *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPaymentsProviderStripe *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->publishable_key_);
  delete var;
}
void TdStackStorerPaymentsProviderStripe (struct TdPaymentsProviderStripe *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPaymentsProviderStripe *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PaymentsProviderStripe");
  M->new_field ("ID");
  M->pack_string (var->publishable_key_);
  M->new_field ("publishable_key_");
  M->pack_bool (var->need_country_);
  M->new_field ("need_country_");
  M->pack_bool (var->need_postal_code_);
  M->new_field ("need_postal_code_");
  M->pack_bool (var->need_cardholder_name_);
  M->new_field ("need_cardholder_name_");
}
struct TdPaymentsProviderStripe *TdStackFetcherPaymentsProviderStripe (struct TdStackFetcherMethods *M) {
  auto res = new TdPaymentsProviderStripe ();
  res->ID = CODE_PaymentsProviderStripe;
  res->refcnt = 1;
  M->get_field ("publishable_key_");
  res->publishable_key_ = M->get_string ();
  M->pop ();
  M->get_field ("need_country_");
  res->need_country_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_postal_code_");
  res->need_postal_code_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("need_cardholder_name_");
  res->need_cardholder_name_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPersonalDetails *TdCreateObjectPersonalDetails (char *first_name_, char *middle_name_, char *last_name_, char *native_first_name_, char *native_middle_name_, char *native_last_name_, struct TdDate *birthdate_, char *gender_, char *country_code_, char *residence_country_code_) {
  auto var = new struct TdPersonalDetails ();
  var->ID = CODE_PersonalDetails;
  var->refcnt = 1;
  var->first_name_ = (first_name_) ? td::str_dup (td::Slice (first_name_)) : nullptr;
  var->middle_name_ = (middle_name_) ? td::str_dup (td::Slice (middle_name_)) : nullptr;
  var->last_name_ = (last_name_) ? td::str_dup (td::Slice (last_name_)) : nullptr;
  var->native_first_name_ = (native_first_name_) ? td::str_dup (td::Slice (native_first_name_)) : nullptr;
  var->native_middle_name_ = (native_middle_name_) ? td::str_dup (td::Slice (native_middle_name_)) : nullptr;
  var->native_last_name_ = (native_last_name_) ? td::str_dup (td::Slice (native_last_name_)) : nullptr;
  var->birthdate_ = birthdate_;
  var->gender_ = (gender_) ? td::str_dup (td::Slice (gender_)) : nullptr;
  var->country_code_ = (country_code_) ? td::str_dup (td::Slice (country_code_)) : nullptr;
  var->residence_country_code_ = (residence_country_code_) ? td::str_dup (td::Slice (residence_country_code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::personalDetails> TdConvertToInternal (struct TdPersonalDetails *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->first_name_) ? var->first_name_: "";
  std::string v100;
  v100 = (var->middle_name_) ? var->middle_name_: "";
  std::string v200;
  v200 = (var->last_name_) ? var->last_name_: "";
  std::string v300;
  v300 = (var->native_first_name_) ? var->native_first_name_: "";
  std::string v400;
  v400 = (var->native_middle_name_) ? var->native_middle_name_: "";
  std::string v500;
  v500 = (var->native_last_name_) ? var->native_last_name_: "";
  td::td_api::object_ptr<td::td_api::date> v600;
  v600 = TdConvertToInternal (var->birthdate_);
  std::string v700;
  v700 = (var->gender_) ? var->gender_: "";
  std::string v800;
  v800 = (var->country_code_) ? var->country_code_: "";
  std::string v900;
  v900 = (var->residence_country_code_) ? var->residence_country_code_: "";
  return td::td_api::make_object<td::td_api::personalDetails>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900));
}
struct TdPersonalDetails *TdConvertFromInternal (const td::td_api::personalDetails &from) {
  auto res = new TdPersonalDetails ();
  res->ID = CODE_PersonalDetails;
  res->refcnt = 1;
  res->first_name_ = (from.first_name_.length ()) ? td::str_dup (from.first_name_) : nullptr;
  res->middle_name_ = (from.middle_name_.length ()) ? td::str_dup (from.middle_name_) : nullptr;
  res->last_name_ = (from.last_name_.length ()) ? td::str_dup (from.last_name_) : nullptr;
  res->native_first_name_ = (from.native_first_name_.length ()) ? td::str_dup (from.native_first_name_) : nullptr;
  res->native_middle_name_ = (from.native_middle_name_.length ()) ? td::str_dup (from.native_middle_name_) : nullptr;
  res->native_last_name_ = (from.native_last_name_.length ()) ? td::str_dup (from.native_last_name_) : nullptr;
  if (!from.birthdate_) {
    res->birthdate_ = nullptr;
  } else {
    res->birthdate_ = TdConvertFromInternal (static_cast<const td::td_api::date &>(*from.birthdate_));
  }
  res->gender_ = (from.gender_.length ()) ? td::str_dup (from.gender_) : nullptr;
  res->country_code_ = (from.country_code_.length ()) ? td::str_dup (from.country_code_) : nullptr;
  res->residence_country_code_ = (from.residence_country_code_.length ()) ? td::str_dup (from.residence_country_code_) : nullptr;
  return res;
}
char *TdSerializePersonalDetails (struct TdPersonalDetails *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPersonalDetails *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPersonalDetails (struct TdPersonalDetails *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPersonalDetails *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->first_name_);
  free (var->middle_name_);
  free (var->last_name_);
  free (var->native_first_name_);
  free (var->native_middle_name_);
  free (var->native_last_name_);
  TdDestroyObject (var->birthdate_);
  free (var->gender_);
  free (var->country_code_);
  free (var->residence_country_code_);
  delete var;
}
void TdStackStorerPersonalDetails (struct TdPersonalDetails *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPersonalDetails *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PersonalDetails");
  M->new_field ("ID");
  M->pack_string (var->first_name_);
  M->new_field ("first_name_");
  M->pack_string (var->middle_name_);
  M->new_field ("middle_name_");
  M->pack_string (var->last_name_);
  M->new_field ("last_name_");
  M->pack_string (var->native_first_name_);
  M->new_field ("native_first_name_");
  M->pack_string (var->native_middle_name_);
  M->new_field ("native_middle_name_");
  M->pack_string (var->native_last_name_);
  M->new_field ("native_last_name_");
  TdStackStorer (var->birthdate_, M);
  M->new_field ("birthdate_");
  M->pack_string (var->gender_);
  M->new_field ("gender_");
  M->pack_string (var->country_code_);
  M->new_field ("country_code_");
  M->pack_string (var->residence_country_code_);
  M->new_field ("residence_country_code_");
}
struct TdPersonalDetails *TdStackFetcherPersonalDetails (struct TdStackFetcherMethods *M) {
  auto res = new TdPersonalDetails ();
  res->ID = CODE_PersonalDetails;
  res->refcnt = 1;
  M->get_field ("first_name_");
  res->first_name_ = M->get_string ();
  M->pop ();
  M->get_field ("middle_name_");
  res->middle_name_ = M->get_string ();
  M->pop ();
  M->get_field ("last_name_");
  res->last_name_ = M->get_string ();
  M->pop ();
  M->get_field ("native_first_name_");
  res->native_first_name_ = M->get_string ();
  M->pop ();
  M->get_field ("native_middle_name_");
  res->native_middle_name_ = M->get_string ();
  M->pop ();
  M->get_field ("native_last_name_");
  res->native_last_name_ = M->get_string ();
  M->pop ();
  M->get_field ("birthdate_");
  if (M->is_nil ()) {
    res->birthdate_ = nullptr;
  } else {
    res->birthdate_ = TdStackFetcherDate (M);
  }
  M->pop ();
  M->get_field ("gender_");
  res->gender_ = M->get_string ();
  M->pop ();
  M->get_field ("country_code_");
  res->country_code_ = M->get_string ();
  M->pop ();
  M->get_field ("residence_country_code_");
  res->residence_country_code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPersonalDocument *TdCreateObjectPersonalDocument (struct TdVectorDatedFile *files_, struct TdVectorDatedFile *translation_) {
  auto var = new struct TdPersonalDocument ();
  var->ID = CODE_PersonalDocument;
  var->refcnt = 1;
  var->files_ = files_;
  var->translation_ = translation_;
  return var;
}
td::td_api::object_ptr<td::td_api::personalDocument> TdConvertToInternal (struct TdPersonalDocument *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::datedFile>> v0;
  for (int i0 = 0; i0 < var->files_->len; i0++) {
    td::td_api::object_ptr<td::td_api::datedFile> v1;
    v1 = TdConvertToInternal (var->files_->data[i0]);
    v0.push_back (std::move (v1));
  }
  std::vector<td::td_api::object_ptr<td::td_api::datedFile>> v100;
  for (int i100 = 0; i100 < var->translation_->len; i100++) {
    td::td_api::object_ptr<td::td_api::datedFile> v101;
    v101 = TdConvertToInternal (var->translation_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::personalDocument>(std::move (v0), std::move (v100));
}
struct TdPersonalDocument *TdConvertFromInternal (const td::td_api::personalDocument &from) {
  auto res = new TdPersonalDocument ();
  res->ID = CODE_PersonalDocument;
  res->refcnt = 1;
  res->files_ = new TdVectorDatedFile ();
  res->files_->len = (int)from.files_.size ();
  res->files_->data = new struct TdDatedFile * [res->files_->len];
  for (int i0 = 0; i0 < res->files_->len; i0++) {
    if (!from.files_[i0]) {
      res->files_->data[i0] = nullptr;
    } else {
      res->files_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.files_[i0]));
    }
  }
  res->translation_ = new TdVectorDatedFile ();
  res->translation_->len = (int)from.translation_.size ();
  res->translation_->data = new struct TdDatedFile * [res->translation_->len];
  for (int i100 = 0; i100 < res->translation_->len; i100++) {
    if (!from.translation_[i100]) {
      res->translation_->data[i100] = nullptr;
    } else {
      res->translation_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::datedFile &>(*from.translation_[i100]));
    }
  }
  return res;
}
char *TdSerializePersonalDocument (struct TdPersonalDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPersonalDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPersonalDocument (struct TdPersonalDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPersonalDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->files_->len; i0++) {
    TdDestroyObject (var->files_->data[i0]);
  }
  delete[] var->files_->data;
  delete var->files_;
  for (int i100 = 0; i100 < var->translation_->len; i100++) {
    TdDestroyObject (var->translation_->data[i100]);
  }
  delete[] var->translation_->data;
  delete var->translation_;
  delete var;
}
void TdStackStorerPersonalDocument (struct TdPersonalDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPersonalDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PersonalDocument");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->files_->len; i0++) {
    TdStackStorer (var->files_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("files_");
  M->new_array ();
  for (int i100 = 0; i100 < var->translation_->len; i100++) {
    TdStackStorer (var->translation_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("translation_");
}
struct TdPersonalDocument *TdStackFetcherPersonalDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdPersonalDocument ();
  res->ID = CODE_PersonalDocument;
  res->refcnt = 1;
  M->get_field ("files_");
  res->files_ = new TdVectorDatedFile ();
  res->files_->len = M->get_arr_size ();
  res->files_->data = new struct TdDatedFile * [res->files_->len];
  for (int i0 = 0; i0 < res->files_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->files_->data[i0] = nullptr;
    } else {
      res->files_->data[i0] = TdStackFetcherDatedFile (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("translation_");
  res->translation_ = new TdVectorDatedFile ();
  res->translation_->len = M->get_arr_size ();
  res->translation_->data = new struct TdDatedFile * [res->translation_->len];
  for (int i100 = 0; i100 < res->translation_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->translation_->data[i100] = nullptr;
    } else {
      res->translation_->data[i100] = TdStackFetcherDatedFile (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdPhoto *TdCreateObjectPhoto (long long id_, int has_stickers_, struct TdVectorPhotoSize *sizes_) {
  auto var = new struct TdPhoto ();
  var->ID = CODE_Photo;
  var->refcnt = 1;
  var->id_ = id_;
  var->has_stickers_ = has_stickers_;
  var->sizes_ = sizes_;
  return var;
}
td::td_api::object_ptr<td::td_api::photo> TdConvertToInternal (struct TdPhoto *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  bool v100;
  v100 = var->has_stickers_ != 0;
  std::vector<td::td_api::object_ptr<td::td_api::photoSize>> v200;
  for (int i200 = 0; i200 < var->sizes_->len; i200++) {
    td::td_api::object_ptr<td::td_api::photoSize> v201;
    v201 = TdConvertToInternal (var->sizes_->data[i200]);
    v200.push_back (std::move (v201));
  }
  return td::td_api::make_object<td::td_api::photo>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdPhoto *TdConvertFromInternal (const td::td_api::photo &from) {
  auto res = new TdPhoto ();
  res->ID = CODE_Photo;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->has_stickers_ = from.has_stickers_;
  res->sizes_ = new TdVectorPhotoSize ();
  res->sizes_->len = (int)from.sizes_.size ();
  res->sizes_->data = new struct TdPhotoSize * [res->sizes_->len];
  for (int i200 = 0; i200 < res->sizes_->len; i200++) {
    if (!from.sizes_[i200]) {
      res->sizes_->data[i200] = nullptr;
    } else {
      res->sizes_->data[i200] = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.sizes_[i200]));
    }
  }
  return res;
}
char *TdSerializePhoto (struct TdPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPhoto (struct TdPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i200 = 0; i200 < var->sizes_->len; i200++) {
    TdDestroyObject (var->sizes_->data[i200]);
  }
  delete[] var->sizes_->data;
  delete var->sizes_;
  delete var;
}
void TdStackStorerPhoto (struct TdPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Photo");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_bool (var->has_stickers_);
  M->new_field ("has_stickers_");
  M->new_array ();
  for (int i200 = 0; i200 < var->sizes_->len; i200++) {
    TdStackStorer (var->sizes_->data[i200], M);
    M->new_arr_field (i200);
  }
  M->new_field ("sizes_");
}
struct TdPhoto *TdStackFetcherPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdPhoto ();
  res->ID = CODE_Photo;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("has_stickers_");
  res->has_stickers_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sizes_");
  res->sizes_ = new TdVectorPhotoSize ();
  res->sizes_->len = M->get_arr_size ();
  res->sizes_->data = new struct TdPhotoSize * [res->sizes_->len];
  for (int i200 = 0; i200 < res->sizes_->len; i200++) {
    M->get_arr_field (i200);
    if (M->is_nil ()) {
      res->sizes_->data[i200] = nullptr;
    } else {
      res->sizes_->data[i200] = TdStackFetcherPhotoSize (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdPhotoSize *TdCreateObjectPhotoSize (char *type_, struct TdFile *photo_, int width_, int height_) {
  auto var = new struct TdPhotoSize ();
  var->ID = CODE_PhotoSize;
  var->refcnt = 1;
  var->type_ = (type_) ? td::str_dup (td::Slice (type_)) : nullptr;
  var->photo_ = photo_;
  var->width_ = width_;
  var->height_ = height_;
  return var;
}
td::td_api::object_ptr<td::td_api::photoSize> TdConvertToInternal (struct TdPhotoSize *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->type_) ? var->type_: "";
  td::td_api::object_ptr<td::td_api::file> v100;
  v100 = TdConvertToInternal (var->photo_);
  std::int32_t v200;
  v200 = var->width_;
  std::int32_t v300;
  v300 = var->height_;
  return td::td_api::make_object<td::td_api::photoSize>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdPhotoSize *TdConvertFromInternal (const td::td_api::photoSize &from) {
  auto res = new TdPhotoSize ();
  res->ID = CODE_PhotoSize;
  res->refcnt = 1;
  res->type_ = (from.type_.length ()) ? td::str_dup (from.type_) : nullptr;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.photo_));
  }
  res->width_ = from.width_;
  res->height_ = from.height_;
  return res;
}
char *TdSerializePhotoSize (struct TdPhotoSize *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPhotoSize *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPhotoSize (struct TdPhotoSize *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPhotoSize *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->type_);
  TdDestroyObject (var->photo_);
  delete var;
}
void TdStackStorerPhotoSize (struct TdPhotoSize *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPhotoSize *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PhotoSize");
  M->new_field ("ID");
  M->pack_string (var->type_);
  M->new_field ("type_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
}
struct TdPhotoSize *TdStackFetcherPhotoSize (struct TdStackFetcherMethods *M) {
  auto res = new TdPhotoSize ();
  res->ID = CODE_PhotoSize;
  res->refcnt = 1;
  M->get_field ("type_");
  res->type_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherFile (M);
  }
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdProfilePhoto *TdCreateObjectProfilePhoto (long long id_, struct TdFile *small_, struct TdFile *big_) {
  auto var = new struct TdProfilePhoto ();
  var->ID = CODE_ProfilePhoto;
  var->refcnt = 1;
  var->id_ = id_;
  var->small_ = small_;
  var->big_ = big_;
  return var;
}
td::td_api::object_ptr<td::td_api::profilePhoto> TdConvertToInternal (struct TdProfilePhoto *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  td::td_api::object_ptr<td::td_api::file> v100;
  v100 = TdConvertToInternal (var->small_);
  td::td_api::object_ptr<td::td_api::file> v200;
  v200 = TdConvertToInternal (var->big_);
  return td::td_api::make_object<td::td_api::profilePhoto>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdProfilePhoto *TdConvertFromInternal (const td::td_api::profilePhoto &from) {
  auto res = new TdProfilePhoto ();
  res->ID = CODE_ProfilePhoto;
  res->refcnt = 1;
  res->id_ = from.id_;
  if (!from.small_) {
    res->small_ = nullptr;
  } else {
    res->small_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.small_));
  }
  if (!from.big_) {
    res->big_ = nullptr;
  } else {
    res->big_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.big_));
  }
  return res;
}
char *TdSerializeProfilePhoto (struct TdProfilePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdProfilePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectProfilePhoto (struct TdProfilePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdProfilePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->small_);
  TdDestroyObject (var->big_);
  delete var;
}
void TdStackStorerProfilePhoto (struct TdProfilePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdProfilePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ProfilePhoto");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  TdStackStorer (var->small_, M);
  M->new_field ("small_");
  TdStackStorer (var->big_, M);
  M->new_field ("big_");
}
struct TdProfilePhoto *TdStackFetcherProfilePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdProfilePhoto ();
  res->ID = CODE_ProfilePhoto;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("small_");
  if (M->is_nil ()) {
    res->small_ = nullptr;
  } else {
    res->small_ = TdStackFetcherFile (M);
  }
  M->pop ();
  M->get_field ("big_");
  if (M->is_nil ()) {
    res->big_ = nullptr;
  } else {
    res->big_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdProxies *TdCreateObjectProxies (struct TdVectorProxy *proxies_) {
  auto var = new struct TdProxies ();
  var->ID = CODE_Proxies;
  var->refcnt = 1;
  var->proxies_ = proxies_;
  return var;
}
td::td_api::object_ptr<td::td_api::proxies> TdConvertToInternal (struct TdProxies *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::proxy>> v0;
  for (int i0 = 0; i0 < var->proxies_->len; i0++) {
    td::td_api::object_ptr<td::td_api::proxy> v1;
    v1 = TdConvertToInternal (var->proxies_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::proxies>(std::move (v0));
}
struct TdProxies *TdConvertFromInternal (const td::td_api::proxies &from) {
  auto res = new TdProxies ();
  res->ID = CODE_Proxies;
  res->refcnt = 1;
  res->proxies_ = new TdVectorProxy ();
  res->proxies_->len = (int)from.proxies_.size ();
  res->proxies_->data = new struct TdProxy * [res->proxies_->len];
  for (int i0 = 0; i0 < res->proxies_->len; i0++) {
    if (!from.proxies_[i0]) {
      res->proxies_->data[i0] = nullptr;
    } else {
      res->proxies_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::proxy &>(*from.proxies_[i0]));
    }
  }
  return res;
}
char *TdSerializeProxies (struct TdProxies *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdProxies *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectProxies (struct TdProxies *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdProxies *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->proxies_->len; i0++) {
    TdDestroyObject (var->proxies_->data[i0]);
  }
  delete[] var->proxies_->data;
  delete var->proxies_;
  delete var;
}
void TdStackStorerProxies (struct TdProxies *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdProxies *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Proxies");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->proxies_->len; i0++) {
    TdStackStorer (var->proxies_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("proxies_");
}
struct TdProxies *TdStackFetcherProxies (struct TdStackFetcherMethods *M) {
  auto res = new TdProxies ();
  res->ID = CODE_Proxies;
  res->refcnt = 1;
  M->get_field ("proxies_");
  res->proxies_ = new TdVectorProxy ();
  res->proxies_->len = M->get_arr_size ();
  res->proxies_->data = new struct TdProxy * [res->proxies_->len];
  for (int i0 = 0; i0 < res->proxies_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->proxies_->data[i0] = nullptr;
    } else {
      res->proxies_->data[i0] = TdStackFetcherProxy (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdProxy *TdCreateObjectProxy (int id_, char *server_, int port_, int last_used_date_, int is_enabled_, struct TdProxyType *type_) {
  auto var = new struct TdProxy ();
  var->ID = CODE_Proxy;
  var->refcnt = 1;
  var->id_ = id_;
  var->server_ = (server_) ? td::str_dup (td::Slice (server_)) : nullptr;
  var->port_ = port_;
  var->last_used_date_ = last_used_date_;
  var->is_enabled_ = is_enabled_;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::proxy> TdConvertToInternal (struct TdProxy *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->server_) ? var->server_: "";
  std::int32_t v200;
  v200 = var->port_;
  std::int32_t v300;
  v300 = var->last_used_date_;
  bool v400;
  v400 = var->is_enabled_ != 0;
  td::td_api::object_ptr<td::td_api::ProxyType> v500;
  v500 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::proxy>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdProxy *TdConvertFromInternal (const td::td_api::proxy &from) {
  auto res = new TdProxy ();
  res->ID = CODE_Proxy;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->server_ = (from.server_.length ()) ? td::str_dup (from.server_) : nullptr;
  res->port_ = from.port_;
  res->last_used_date_ = from.last_used_date_;
  res->is_enabled_ = from.is_enabled_;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::ProxyType &>(*from.type_));
  }
  return res;
}
char *TdSerializeProxy (struct TdProxy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdProxy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectProxy (struct TdProxy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdProxy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->server_);
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerProxy (struct TdProxy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdProxy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Proxy");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->server_);
  M->new_field ("server_");
  M->pack_long (var->port_);
  M->new_field ("port_");
  M->pack_long (var->last_used_date_);
  M->new_field ("last_used_date_");
  M->pack_bool (var->is_enabled_);
  M->new_field ("is_enabled_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdProxy *TdStackFetcherProxy (struct TdStackFetcherMethods *M) {
  auto res = new TdProxy ();
  res->ID = CODE_Proxy;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("server_");
  res->server_ = M->get_string ();
  M->pop ();
  M->get_field ("port_");
  res->port_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("last_used_date_");
  res->last_used_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_enabled_");
  res->is_enabled_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherProxyType (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ProxyType> TdConvertToInternal (struct TdProxyType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ProxyTypeSocks5: return TdConvertToInternal ((struct TdProxyTypeSocks5 *)var);
    case CODE_ProxyTypeHttp: return TdConvertToInternal ((struct TdProxyTypeHttp *)var);
    case CODE_ProxyTypeMtproto: return TdConvertToInternal ((struct TdProxyTypeMtproto *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdProxyType *TdConvertFromInternal (const td::td_api::ProxyType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ProxyTypeSocks5: return (struct TdProxyType *)TdConvertFromInternal(static_cast<const td::td_api::proxyTypeSocks5 &>(from));
    case CODE_ProxyTypeHttp: return (struct TdProxyType *)TdConvertFromInternal(static_cast<const td::td_api::proxyTypeHttp &>(from));
    case CODE_ProxyTypeMtproto: return (struct TdProxyType *)TdConvertFromInternal(static_cast<const td::td_api::proxyTypeMtproto &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeProxyType (struct TdProxyType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdProxyType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectProxyType (struct TdProxyType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdProxyType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ProxyTypeSocks5: return TdDestroyObject ((struct TdProxyTypeSocks5 *)var);
    case CODE_ProxyTypeHttp: return TdDestroyObject ((struct TdProxyTypeHttp *)var);
    case CODE_ProxyTypeMtproto: return TdDestroyObject ((struct TdProxyTypeMtproto *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerProxyType (struct TdProxyType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdProxyType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ProxyTypeSocks5: return TdStackStorer ((struct TdProxyTypeSocks5 *)var, M);
    case CODE_ProxyTypeHttp: return TdStackStorer ((struct TdProxyTypeHttp *)var, M);
    case CODE_ProxyTypeMtproto: return TdStackStorer ((struct TdProxyTypeMtproto *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdProxyType *TdStackFetcherProxyType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ProxyTypeSocks5") {
    return (struct TdProxyType *)TdStackFetcherProxyTypeSocks5 (M);
  }
  if (constructor == "ProxyTypeHttp") {
    return (struct TdProxyType *)TdStackFetcherProxyTypeHttp (M);
  }
  if (constructor == "ProxyTypeMtproto") {
    return (struct TdProxyType *)TdStackFetcherProxyTypeMtproto (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdProxyTypeSocks5 *TdCreateObjectProxyTypeSocks5 (char *username_, char *password_) {
  auto var = new struct TdProxyTypeSocks5 ();
  var->ID = CODE_ProxyTypeSocks5;
  var->refcnt = 1;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::proxyTypeSocks5> TdConvertToInternal (struct TdProxyTypeSocks5 *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->username_) ? var->username_: "";
  std::string v100;
  v100 = (var->password_) ? var->password_: "";
  return td::td_api::make_object<td::td_api::proxyTypeSocks5>(std::move (v0), std::move (v100));
}
struct TdProxyTypeSocks5 *TdConvertFromInternal (const td::td_api::proxyTypeSocks5 &from) {
  auto res = new TdProxyTypeSocks5 ();
  res->ID = CODE_ProxyTypeSocks5;
  res->refcnt = 1;
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  return res;
}
char *TdSerializeProxyTypeSocks5 (struct TdProxyTypeSocks5 *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdProxyTypeSocks5 *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectProxyTypeSocks5 (struct TdProxyTypeSocks5 *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdProxyTypeSocks5 *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->username_);
  free (var->password_);
  delete var;
}
void TdStackStorerProxyTypeSocks5 (struct TdProxyTypeSocks5 *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdProxyTypeSocks5 *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ProxyTypeSocks5");
  M->new_field ("ID");
  M->pack_string (var->username_);
  M->new_field ("username_");
  M->pack_string (var->password_);
  M->new_field ("password_");
}
struct TdProxyTypeSocks5 *TdStackFetcherProxyTypeSocks5 (struct TdStackFetcherMethods *M) {
  auto res = new TdProxyTypeSocks5 ();
  res->ID = CODE_ProxyTypeSocks5;
  res->refcnt = 1;
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdProxyTypeHttp *TdCreateObjectProxyTypeHttp (char *username_, char *password_, int http_only_) {
  auto var = new struct TdProxyTypeHttp ();
  var->ID = CODE_ProxyTypeHttp;
  var->refcnt = 1;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  var->http_only_ = http_only_;
  return var;
}
td::td_api::object_ptr<td::td_api::proxyTypeHttp> TdConvertToInternal (struct TdProxyTypeHttp *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->username_) ? var->username_: "";
  std::string v100;
  v100 = (var->password_) ? var->password_: "";
  bool v200;
  v200 = var->http_only_ != 0;
  return td::td_api::make_object<td::td_api::proxyTypeHttp>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdProxyTypeHttp *TdConvertFromInternal (const td::td_api::proxyTypeHttp &from) {
  auto res = new TdProxyTypeHttp ();
  res->ID = CODE_ProxyTypeHttp;
  res->refcnt = 1;
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  res->http_only_ = from.http_only_;
  return res;
}
char *TdSerializeProxyTypeHttp (struct TdProxyTypeHttp *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdProxyTypeHttp *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectProxyTypeHttp (struct TdProxyTypeHttp *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdProxyTypeHttp *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->username_);
  free (var->password_);
  delete var;
}
void TdStackStorerProxyTypeHttp (struct TdProxyTypeHttp *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdProxyTypeHttp *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ProxyTypeHttp");
  M->new_field ("ID");
  M->pack_string (var->username_);
  M->new_field ("username_");
  M->pack_string (var->password_);
  M->new_field ("password_");
  M->pack_bool (var->http_only_);
  M->new_field ("http_only_");
}
struct TdProxyTypeHttp *TdStackFetcherProxyTypeHttp (struct TdStackFetcherMethods *M) {
  auto res = new TdProxyTypeHttp ();
  res->ID = CODE_ProxyTypeHttp;
  res->refcnt = 1;
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  M->get_field ("http_only_");
  res->http_only_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdProxyTypeMtproto *TdCreateObjectProxyTypeMtproto (char *secret_) {
  auto var = new struct TdProxyTypeMtproto ();
  var->ID = CODE_ProxyTypeMtproto;
  var->refcnt = 1;
  var->secret_ = (secret_) ? td::str_dup (td::Slice (secret_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::proxyTypeMtproto> TdConvertToInternal (struct TdProxyTypeMtproto *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->secret_) ? var->secret_: "";
  return td::td_api::make_object<td::td_api::proxyTypeMtproto>(std::move (v0));
}
struct TdProxyTypeMtproto *TdConvertFromInternal (const td::td_api::proxyTypeMtproto &from) {
  auto res = new TdProxyTypeMtproto ();
  res->ID = CODE_ProxyTypeMtproto;
  res->refcnt = 1;
  res->secret_ = (from.secret_.length ()) ? td::str_dup (from.secret_) : nullptr;
  return res;
}
char *TdSerializeProxyTypeMtproto (struct TdProxyTypeMtproto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdProxyTypeMtproto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectProxyTypeMtproto (struct TdProxyTypeMtproto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdProxyTypeMtproto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->secret_);
  delete var;
}
void TdStackStorerProxyTypeMtproto (struct TdProxyTypeMtproto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdProxyTypeMtproto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ProxyTypeMtproto");
  M->new_field ("ID");
  M->pack_string (var->secret_);
  M->new_field ("secret_");
}
struct TdProxyTypeMtproto *TdStackFetcherProxyTypeMtproto (struct TdStackFetcherMethods *M) {
  auto res = new TdProxyTypeMtproto ();
  res->ID = CODE_ProxyTypeMtproto;
  res->refcnt = 1;
  M->get_field ("secret_");
  res->secret_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdPublicMessageLink *TdCreateObjectPublicMessageLink (char *link_, char *html_) {
  auto var = new struct TdPublicMessageLink ();
  var->ID = CODE_PublicMessageLink;
  var->refcnt = 1;
  var->link_ = (link_) ? td::str_dup (td::Slice (link_)) : nullptr;
  var->html_ = (html_) ? td::str_dup (td::Slice (html_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::publicMessageLink> TdConvertToInternal (struct TdPublicMessageLink *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->link_) ? var->link_: "";
  std::string v100;
  v100 = (var->html_) ? var->html_: "";
  return td::td_api::make_object<td::td_api::publicMessageLink>(std::move (v0), std::move (v100));
}
struct TdPublicMessageLink *TdConvertFromInternal (const td::td_api::publicMessageLink &from) {
  auto res = new TdPublicMessageLink ();
  res->ID = CODE_PublicMessageLink;
  res->refcnt = 1;
  res->link_ = (from.link_.length ()) ? td::str_dup (from.link_) : nullptr;
  res->html_ = (from.html_.length ()) ? td::str_dup (from.html_) : nullptr;
  return res;
}
char *TdSerializePublicMessageLink (struct TdPublicMessageLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPublicMessageLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPublicMessageLink (struct TdPublicMessageLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPublicMessageLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->link_);
  free (var->html_);
  delete var;
}
void TdStackStorerPublicMessageLink (struct TdPublicMessageLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPublicMessageLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PublicMessageLink");
  M->new_field ("ID");
  M->pack_string (var->link_);
  M->new_field ("link_");
  M->pack_string (var->html_);
  M->new_field ("html_");
}
struct TdPublicMessageLink *TdStackFetcherPublicMessageLink (struct TdStackFetcherMethods *M) {
  auto res = new TdPublicMessageLink ();
  res->ID = CODE_PublicMessageLink;
  res->refcnt = 1;
  M->get_field ("link_");
  res->link_ = M->get_string ();
  M->pop ();
  M->get_field ("html_");
  res->html_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdRecoveryEmailAddress *TdCreateObjectRecoveryEmailAddress (char *recovery_email_address_) {
  auto var = new struct TdRecoveryEmailAddress ();
  var->ID = CODE_RecoveryEmailAddress;
  var->refcnt = 1;
  var->recovery_email_address_ = (recovery_email_address_) ? td::str_dup (td::Slice (recovery_email_address_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::recoveryEmailAddress> TdConvertToInternal (struct TdRecoveryEmailAddress *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->recovery_email_address_) ? var->recovery_email_address_: "";
  return td::td_api::make_object<td::td_api::recoveryEmailAddress>(std::move (v0));
}
struct TdRecoveryEmailAddress *TdConvertFromInternal (const td::td_api::recoveryEmailAddress &from) {
  auto res = new TdRecoveryEmailAddress ();
  res->ID = CODE_RecoveryEmailAddress;
  res->refcnt = 1;
  res->recovery_email_address_ = (from.recovery_email_address_.length ()) ? td::str_dup (from.recovery_email_address_) : nullptr;
  return res;
}
char *TdSerializeRecoveryEmailAddress (struct TdRecoveryEmailAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRecoveryEmailAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRecoveryEmailAddress (struct TdRecoveryEmailAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRecoveryEmailAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->recovery_email_address_);
  delete var;
}
void TdStackStorerRecoveryEmailAddress (struct TdRecoveryEmailAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRecoveryEmailAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RecoveryEmailAddress");
  M->new_field ("ID");
  M->pack_string (var->recovery_email_address_);
  M->new_field ("recovery_email_address_");
}
struct TdRecoveryEmailAddress *TdStackFetcherRecoveryEmailAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdRecoveryEmailAddress ();
  res->ID = CODE_RecoveryEmailAddress;
  res->refcnt = 1;
  M->get_field ("recovery_email_address_");
  res->recovery_email_address_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdRemoteFile *TdCreateObjectRemoteFile (char *id_, int is_uploading_active_, int is_uploading_completed_, int uploaded_size_) {
  auto var = new struct TdRemoteFile ();
  var->ID = CODE_RemoteFile;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->is_uploading_active_ = is_uploading_active_;
  var->is_uploading_completed_ = is_uploading_completed_;
  var->uploaded_size_ = uploaded_size_;
  return var;
}
td::td_api::object_ptr<td::td_api::remoteFile> TdConvertToInternal (struct TdRemoteFile *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  bool v100;
  v100 = var->is_uploading_active_ != 0;
  bool v200;
  v200 = var->is_uploading_completed_ != 0;
  std::int32_t v300;
  v300 = var->uploaded_size_;
  return td::td_api::make_object<td::td_api::remoteFile>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdRemoteFile *TdConvertFromInternal (const td::td_api::remoteFile &from) {
  auto res = new TdRemoteFile ();
  res->ID = CODE_RemoteFile;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->is_uploading_active_ = from.is_uploading_active_;
  res->is_uploading_completed_ = from.is_uploading_completed_;
  res->uploaded_size_ = from.uploaded_size_;
  return res;
}
char *TdSerializeRemoteFile (struct TdRemoteFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoteFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoteFile (struct TdRemoteFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoteFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  delete var;
}
void TdStackStorerRemoteFile (struct TdRemoteFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoteFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoteFile");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_bool (var->is_uploading_active_);
  M->new_field ("is_uploading_active_");
  M->pack_bool (var->is_uploading_completed_);
  M->new_field ("is_uploading_completed_");
  M->pack_long (var->uploaded_size_);
  M->new_field ("uploaded_size_");
}
struct TdRemoteFile *TdStackFetcherRemoteFile (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoteFile ();
  res->ID = CODE_RemoteFile;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("is_uploading_active_");
  res->is_uploading_active_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_uploading_completed_");
  res->is_uploading_completed_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("uploaded_size_");
  res->uploaded_size_ = (int)M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::ReplyMarkup> TdConvertToInternal (struct TdReplyMarkup *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ReplyMarkupRemoveKeyboard: return TdConvertToInternal ((struct TdReplyMarkupRemoveKeyboard *)var);
    case CODE_ReplyMarkupForceReply: return TdConvertToInternal ((struct TdReplyMarkupForceReply *)var);
    case CODE_ReplyMarkupShowKeyboard: return TdConvertToInternal ((struct TdReplyMarkupShowKeyboard *)var);
    case CODE_ReplyMarkupInlineKeyboard: return TdConvertToInternal ((struct TdReplyMarkupInlineKeyboard *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdReplyMarkup *TdConvertFromInternal (const td::td_api::ReplyMarkup &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_ReplyMarkupRemoveKeyboard: return (struct TdReplyMarkup *)TdConvertFromInternal(static_cast<const td::td_api::replyMarkupRemoveKeyboard &>(from));
    case CODE_ReplyMarkupForceReply: return (struct TdReplyMarkup *)TdConvertFromInternal(static_cast<const td::td_api::replyMarkupForceReply &>(from));
    case CODE_ReplyMarkupShowKeyboard: return (struct TdReplyMarkup *)TdConvertFromInternal(static_cast<const td::td_api::replyMarkupShowKeyboard &>(from));
    case CODE_ReplyMarkupInlineKeyboard: return (struct TdReplyMarkup *)TdConvertFromInternal(static_cast<const td::td_api::replyMarkupInlineKeyboard &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeReplyMarkup (struct TdReplyMarkup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReplyMarkup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReplyMarkup (struct TdReplyMarkup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReplyMarkup *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ReplyMarkupRemoveKeyboard: return TdDestroyObject ((struct TdReplyMarkupRemoveKeyboard *)var);
    case CODE_ReplyMarkupForceReply: return TdDestroyObject ((struct TdReplyMarkupForceReply *)var);
    case CODE_ReplyMarkupShowKeyboard: return TdDestroyObject ((struct TdReplyMarkupShowKeyboard *)var);
    case CODE_ReplyMarkupInlineKeyboard: return TdDestroyObject ((struct TdReplyMarkupInlineKeyboard *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerReplyMarkup (struct TdReplyMarkup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReplyMarkup *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_ReplyMarkupRemoveKeyboard: return TdStackStorer ((struct TdReplyMarkupRemoveKeyboard *)var, M);
    case CODE_ReplyMarkupForceReply: return TdStackStorer ((struct TdReplyMarkupForceReply *)var, M);
    case CODE_ReplyMarkupShowKeyboard: return TdStackStorer ((struct TdReplyMarkupShowKeyboard *)var, M);
    case CODE_ReplyMarkupInlineKeyboard: return TdStackStorer ((struct TdReplyMarkupInlineKeyboard *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdReplyMarkup *TdStackFetcherReplyMarkup (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "ReplyMarkupRemoveKeyboard") {
    return (struct TdReplyMarkup *)TdStackFetcherReplyMarkupRemoveKeyboard (M);
  }
  if (constructor == "ReplyMarkupForceReply") {
    return (struct TdReplyMarkup *)TdStackFetcherReplyMarkupForceReply (M);
  }
  if (constructor == "ReplyMarkupShowKeyboard") {
    return (struct TdReplyMarkup *)TdStackFetcherReplyMarkupShowKeyboard (M);
  }
  if (constructor == "ReplyMarkupInlineKeyboard") {
    return (struct TdReplyMarkup *)TdStackFetcherReplyMarkupInlineKeyboard (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdReplyMarkupRemoveKeyboard *TdCreateObjectReplyMarkupRemoveKeyboard (int is_personal_) {
  auto var = new struct TdReplyMarkupRemoveKeyboard ();
  var->ID = CODE_ReplyMarkupRemoveKeyboard;
  var->refcnt = 1;
  var->is_personal_ = is_personal_;
  return var;
}
td::td_api::object_ptr<td::td_api::replyMarkupRemoveKeyboard> TdConvertToInternal (struct TdReplyMarkupRemoveKeyboard *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_personal_ != 0;
  return td::td_api::make_object<td::td_api::replyMarkupRemoveKeyboard>(std::move (v0));
}
struct TdReplyMarkupRemoveKeyboard *TdConvertFromInternal (const td::td_api::replyMarkupRemoveKeyboard &from) {
  auto res = new TdReplyMarkupRemoveKeyboard ();
  res->ID = CODE_ReplyMarkupRemoveKeyboard;
  res->refcnt = 1;
  res->is_personal_ = from.is_personal_;
  return res;
}
char *TdSerializeReplyMarkupRemoveKeyboard (struct TdReplyMarkupRemoveKeyboard *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReplyMarkupRemoveKeyboard *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReplyMarkupRemoveKeyboard (struct TdReplyMarkupRemoveKeyboard *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReplyMarkupRemoveKeyboard *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerReplyMarkupRemoveKeyboard (struct TdReplyMarkupRemoveKeyboard *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReplyMarkupRemoveKeyboard *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ReplyMarkupRemoveKeyboard");
  M->new_field ("ID");
  M->pack_bool (var->is_personal_);
  M->new_field ("is_personal_");
}
struct TdReplyMarkupRemoveKeyboard *TdStackFetcherReplyMarkupRemoveKeyboard (struct TdStackFetcherMethods *M) {
  auto res = new TdReplyMarkupRemoveKeyboard ();
  res->ID = CODE_ReplyMarkupRemoveKeyboard;
  res->refcnt = 1;
  M->get_field ("is_personal_");
  res->is_personal_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdReplyMarkupForceReply *TdCreateObjectReplyMarkupForceReply (int is_personal_) {
  auto var = new struct TdReplyMarkupForceReply ();
  var->ID = CODE_ReplyMarkupForceReply;
  var->refcnt = 1;
  var->is_personal_ = is_personal_;
  return var;
}
td::td_api::object_ptr<td::td_api::replyMarkupForceReply> TdConvertToInternal (struct TdReplyMarkupForceReply *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_personal_ != 0;
  return td::td_api::make_object<td::td_api::replyMarkupForceReply>(std::move (v0));
}
struct TdReplyMarkupForceReply *TdConvertFromInternal (const td::td_api::replyMarkupForceReply &from) {
  auto res = new TdReplyMarkupForceReply ();
  res->ID = CODE_ReplyMarkupForceReply;
  res->refcnt = 1;
  res->is_personal_ = from.is_personal_;
  return res;
}
char *TdSerializeReplyMarkupForceReply (struct TdReplyMarkupForceReply *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReplyMarkupForceReply *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReplyMarkupForceReply (struct TdReplyMarkupForceReply *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReplyMarkupForceReply *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerReplyMarkupForceReply (struct TdReplyMarkupForceReply *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReplyMarkupForceReply *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ReplyMarkupForceReply");
  M->new_field ("ID");
  M->pack_bool (var->is_personal_);
  M->new_field ("is_personal_");
}
struct TdReplyMarkupForceReply *TdStackFetcherReplyMarkupForceReply (struct TdStackFetcherMethods *M) {
  auto res = new TdReplyMarkupForceReply ();
  res->ID = CODE_ReplyMarkupForceReply;
  res->refcnt = 1;
  M->get_field ("is_personal_");
  res->is_personal_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdReplyMarkupShowKeyboard *TdCreateObjectReplyMarkupShowKeyboard (struct TdVectorVectorKeyboardButton *rows_, int resize_keyboard_, int one_time_, int is_personal_) {
  auto var = new struct TdReplyMarkupShowKeyboard ();
  var->ID = CODE_ReplyMarkupShowKeyboard;
  var->refcnt = 1;
  var->rows_ = rows_;
  var->resize_keyboard_ = resize_keyboard_;
  var->one_time_ = one_time_;
  var->is_personal_ = is_personal_;
  return var;
}
td::td_api::object_ptr<td::td_api::replyMarkupShowKeyboard> TdConvertToInternal (struct TdReplyMarkupShowKeyboard *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::vector<td::td_api::object_ptr<td::td_api::keyboardButton>>> v0;
  for (int i0 = 0; i0 < var->rows_->len; i0++) {
    std::vector<td::td_api::object_ptr<td::td_api::keyboardButton>> v1;
    for (int i1 = 0; i1 < var->rows_->data[i0]->len; i1++) {
      td::td_api::object_ptr<td::td_api::keyboardButton> v2;
      v2 = TdConvertToInternal (var->rows_->data[i0]->data[i1]);
      v1.push_back (std::move (v2));
    }
    v0.push_back (std::move (v1));
  }
  bool v100;
  v100 = var->resize_keyboard_ != 0;
  bool v200;
  v200 = var->one_time_ != 0;
  bool v300;
  v300 = var->is_personal_ != 0;
  return td::td_api::make_object<td::td_api::replyMarkupShowKeyboard>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdReplyMarkupShowKeyboard *TdConvertFromInternal (const td::td_api::replyMarkupShowKeyboard &from) {
  auto res = new TdReplyMarkupShowKeyboard ();
  res->ID = CODE_ReplyMarkupShowKeyboard;
  res->refcnt = 1;
  res->rows_ = new TdVectorVectorKeyboardButton ();
  res->rows_->len = (int)from.rows_.size ();
  res->rows_->data = new struct TdVectorKeyboardButton * [res->rows_->len];
  for (int i0 = 0; i0 < res->rows_->len; i0++) {
    res->rows_->data[i0] = new TdVectorKeyboardButton ();
    res->rows_->data[i0]->len = (int)from.rows_[i0].size ();
    res->rows_->data[i0]->data = new struct TdKeyboardButton * [res->rows_->data[i0]->len];
    for (int i1 = 0; i1 < res->rows_->data[i0]->len; i1++) {
      if (!from.rows_[i0][i1]) {
        res->rows_->data[i0]->data[i1] = nullptr;
      } else {
        res->rows_->data[i0]->data[i1] = TdConvertFromInternal (static_cast<const td::td_api::keyboardButton &>(*from.rows_[i0][i1]));
      }
    }
  }
  res->resize_keyboard_ = from.resize_keyboard_;
  res->one_time_ = from.one_time_;
  res->is_personal_ = from.is_personal_;
  return res;
}
char *TdSerializeReplyMarkupShowKeyboard (struct TdReplyMarkupShowKeyboard *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReplyMarkupShowKeyboard *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReplyMarkupShowKeyboard (struct TdReplyMarkupShowKeyboard *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReplyMarkupShowKeyboard *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->rows_->len; i0++) {
    for (int i1 = 0; i1 < var->rows_->data[i0]->len; i1++) {
      TdDestroyObject (var->rows_->data[i0]->data[i1]);
    }
    delete[] var->rows_->data[i0]->data;
    delete var->rows_->data[i0];
  }
  delete[] var->rows_->data;
  delete var->rows_;
  delete var;
}
void TdStackStorerReplyMarkupShowKeyboard (struct TdReplyMarkupShowKeyboard *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReplyMarkupShowKeyboard *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ReplyMarkupShowKeyboard");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->rows_->len; i0++) {
    M->new_array ();
    for (int i1 = 0; i1 < var->rows_->data[i0]->len; i1++) {
      TdStackStorer (var->rows_->data[i0]->data[i1], M);
      M->new_arr_field (i1);
    }
    M->new_arr_field (i0);
  }
  M->new_field ("rows_");
  M->pack_bool (var->resize_keyboard_);
  M->new_field ("resize_keyboard_");
  M->pack_bool (var->one_time_);
  M->new_field ("one_time_");
  M->pack_bool (var->is_personal_);
  M->new_field ("is_personal_");
}
struct TdReplyMarkupShowKeyboard *TdStackFetcherReplyMarkupShowKeyboard (struct TdStackFetcherMethods *M) {
  auto res = new TdReplyMarkupShowKeyboard ();
  res->ID = CODE_ReplyMarkupShowKeyboard;
  res->refcnt = 1;
  M->get_field ("rows_");
  res->rows_ = new TdVectorVectorKeyboardButton ();
  res->rows_->len = M->get_arr_size ();
  res->rows_->data = new struct TdVectorKeyboardButton * [res->rows_->len];
  for (int i0 = 0; i0 < res->rows_->len; i0++) {
    M->get_arr_field (i0);
    res->rows_->data[i0] = new TdVectorKeyboardButton ();
    res->rows_->data[i0]->len = M->get_arr_size ();
    res->rows_->data[i0]->data = new struct TdKeyboardButton * [res->rows_->data[i0]->len];
    for (int i1 = 0; i1 < res->rows_->data[i0]->len; i1++) {
      M->get_arr_field (i1);
      if (M->is_nil ()) {
        res->rows_->data[i0]->data[i1] = nullptr;
      } else {
        res->rows_->data[i0]->data[i1] = TdStackFetcherKeyboardButton (M);
      }
      M->pop ();
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("resize_keyboard_");
  res->resize_keyboard_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("one_time_");
  res->one_time_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_personal_");
  res->is_personal_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdReplyMarkupInlineKeyboard *TdCreateObjectReplyMarkupInlineKeyboard (struct TdVectorVectorInlineKeyboardButton *rows_) {
  auto var = new struct TdReplyMarkupInlineKeyboard ();
  var->ID = CODE_ReplyMarkupInlineKeyboard;
  var->refcnt = 1;
  var->rows_ = rows_;
  return var;
}
td::td_api::object_ptr<td::td_api::replyMarkupInlineKeyboard> TdConvertToInternal (struct TdReplyMarkupInlineKeyboard *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::vector<td::td_api::object_ptr<td::td_api::inlineKeyboardButton>>> v0;
  for (int i0 = 0; i0 < var->rows_->len; i0++) {
    std::vector<td::td_api::object_ptr<td::td_api::inlineKeyboardButton>> v1;
    for (int i1 = 0; i1 < var->rows_->data[i0]->len; i1++) {
      td::td_api::object_ptr<td::td_api::inlineKeyboardButton> v2;
      v2 = TdConvertToInternal (var->rows_->data[i0]->data[i1]);
      v1.push_back (std::move (v2));
    }
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::replyMarkupInlineKeyboard>(std::move (v0));
}
struct TdReplyMarkupInlineKeyboard *TdConvertFromInternal (const td::td_api::replyMarkupInlineKeyboard &from) {
  auto res = new TdReplyMarkupInlineKeyboard ();
  res->ID = CODE_ReplyMarkupInlineKeyboard;
  res->refcnt = 1;
  res->rows_ = new TdVectorVectorInlineKeyboardButton ();
  res->rows_->len = (int)from.rows_.size ();
  res->rows_->data = new struct TdVectorInlineKeyboardButton * [res->rows_->len];
  for (int i0 = 0; i0 < res->rows_->len; i0++) {
    res->rows_->data[i0] = new TdVectorInlineKeyboardButton ();
    res->rows_->data[i0]->len = (int)from.rows_[i0].size ();
    res->rows_->data[i0]->data = new struct TdInlineKeyboardButton * [res->rows_->data[i0]->len];
    for (int i1 = 0; i1 < res->rows_->data[i0]->len; i1++) {
      if (!from.rows_[i0][i1]) {
        res->rows_->data[i0]->data[i1] = nullptr;
      } else {
        res->rows_->data[i0]->data[i1] = TdConvertFromInternal (static_cast<const td::td_api::inlineKeyboardButton &>(*from.rows_[i0][i1]));
      }
    }
  }
  return res;
}
char *TdSerializeReplyMarkupInlineKeyboard (struct TdReplyMarkupInlineKeyboard *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReplyMarkupInlineKeyboard *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReplyMarkupInlineKeyboard (struct TdReplyMarkupInlineKeyboard *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReplyMarkupInlineKeyboard *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->rows_->len; i0++) {
    for (int i1 = 0; i1 < var->rows_->data[i0]->len; i1++) {
      TdDestroyObject (var->rows_->data[i0]->data[i1]);
    }
    delete[] var->rows_->data[i0]->data;
    delete var->rows_->data[i0];
  }
  delete[] var->rows_->data;
  delete var->rows_;
  delete var;
}
void TdStackStorerReplyMarkupInlineKeyboard (struct TdReplyMarkupInlineKeyboard *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReplyMarkupInlineKeyboard *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ReplyMarkupInlineKeyboard");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->rows_->len; i0++) {
    M->new_array ();
    for (int i1 = 0; i1 < var->rows_->data[i0]->len; i1++) {
      TdStackStorer (var->rows_->data[i0]->data[i1], M);
      M->new_arr_field (i1);
    }
    M->new_arr_field (i0);
  }
  M->new_field ("rows_");
}
struct TdReplyMarkupInlineKeyboard *TdStackFetcherReplyMarkupInlineKeyboard (struct TdStackFetcherMethods *M) {
  auto res = new TdReplyMarkupInlineKeyboard ();
  res->ID = CODE_ReplyMarkupInlineKeyboard;
  res->refcnt = 1;
  M->get_field ("rows_");
  res->rows_ = new TdVectorVectorInlineKeyboardButton ();
  res->rows_->len = M->get_arr_size ();
  res->rows_->data = new struct TdVectorInlineKeyboardButton * [res->rows_->len];
  for (int i0 = 0; i0 < res->rows_->len; i0++) {
    M->get_arr_field (i0);
    res->rows_->data[i0] = new TdVectorInlineKeyboardButton ();
    res->rows_->data[i0]->len = M->get_arr_size ();
    res->rows_->data[i0]->data = new struct TdInlineKeyboardButton * [res->rows_->data[i0]->len];
    for (int i1 = 0; i1 < res->rows_->data[i0]->len; i1++) {
      M->get_arr_field (i1);
      if (M->is_nil ()) {
        res->rows_->data[i0]->data[i1] = nullptr;
      } else {
        res->rows_->data[i0]->data[i1] = TdStackFetcherInlineKeyboardButton (M);
      }
      M->pop ();
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::RichText> TdConvertToInternal (struct TdRichText *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_RichTextPlain: return TdConvertToInternal ((struct TdRichTextPlain *)var);
    case CODE_RichTextBold: return TdConvertToInternal ((struct TdRichTextBold *)var);
    case CODE_RichTextItalic: return TdConvertToInternal ((struct TdRichTextItalic *)var);
    case CODE_RichTextUnderline: return TdConvertToInternal ((struct TdRichTextUnderline *)var);
    case CODE_RichTextStrikethrough: return TdConvertToInternal ((struct TdRichTextStrikethrough *)var);
    case CODE_RichTextFixed: return TdConvertToInternal ((struct TdRichTextFixed *)var);
    case CODE_RichTextUrl: return TdConvertToInternal ((struct TdRichTextUrl *)var);
    case CODE_RichTextEmailAddress: return TdConvertToInternal ((struct TdRichTextEmailAddress *)var);
    case CODE_RichTexts: return TdConvertToInternal ((struct TdRichTexts *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdRichText *TdConvertFromInternal (const td::td_api::RichText &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_RichTextPlain: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTextPlain &>(from));
    case CODE_RichTextBold: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTextBold &>(from));
    case CODE_RichTextItalic: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTextItalic &>(from));
    case CODE_RichTextUnderline: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTextUnderline &>(from));
    case CODE_RichTextStrikethrough: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTextStrikethrough &>(from));
    case CODE_RichTextFixed: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTextFixed &>(from));
    case CODE_RichTextUrl: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTextUrl &>(from));
    case CODE_RichTextEmailAddress: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTextEmailAddress &>(from));
    case CODE_RichTexts: return (struct TdRichText *)TdConvertFromInternal(static_cast<const td::td_api::richTexts &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeRichText (struct TdRichText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichText (struct TdRichText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichText *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_RichTextPlain: return TdDestroyObject ((struct TdRichTextPlain *)var);
    case CODE_RichTextBold: return TdDestroyObject ((struct TdRichTextBold *)var);
    case CODE_RichTextItalic: return TdDestroyObject ((struct TdRichTextItalic *)var);
    case CODE_RichTextUnderline: return TdDestroyObject ((struct TdRichTextUnderline *)var);
    case CODE_RichTextStrikethrough: return TdDestroyObject ((struct TdRichTextStrikethrough *)var);
    case CODE_RichTextFixed: return TdDestroyObject ((struct TdRichTextFixed *)var);
    case CODE_RichTextUrl: return TdDestroyObject ((struct TdRichTextUrl *)var);
    case CODE_RichTextEmailAddress: return TdDestroyObject ((struct TdRichTextEmailAddress *)var);
    case CODE_RichTexts: return TdDestroyObject ((struct TdRichTexts *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerRichText (struct TdRichText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichText *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_RichTextPlain: return TdStackStorer ((struct TdRichTextPlain *)var, M);
    case CODE_RichTextBold: return TdStackStorer ((struct TdRichTextBold *)var, M);
    case CODE_RichTextItalic: return TdStackStorer ((struct TdRichTextItalic *)var, M);
    case CODE_RichTextUnderline: return TdStackStorer ((struct TdRichTextUnderline *)var, M);
    case CODE_RichTextStrikethrough: return TdStackStorer ((struct TdRichTextStrikethrough *)var, M);
    case CODE_RichTextFixed: return TdStackStorer ((struct TdRichTextFixed *)var, M);
    case CODE_RichTextUrl: return TdStackStorer ((struct TdRichTextUrl *)var, M);
    case CODE_RichTextEmailAddress: return TdStackStorer ((struct TdRichTextEmailAddress *)var, M);
    case CODE_RichTexts: return TdStackStorer ((struct TdRichTexts *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdRichText *TdStackFetcherRichText (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "RichTextPlain") {
    return (struct TdRichText *)TdStackFetcherRichTextPlain (M);
  }
  if (constructor == "RichTextBold") {
    return (struct TdRichText *)TdStackFetcherRichTextBold (M);
  }
  if (constructor == "RichTextItalic") {
    return (struct TdRichText *)TdStackFetcherRichTextItalic (M);
  }
  if (constructor == "RichTextUnderline") {
    return (struct TdRichText *)TdStackFetcherRichTextUnderline (M);
  }
  if (constructor == "RichTextStrikethrough") {
    return (struct TdRichText *)TdStackFetcherRichTextStrikethrough (M);
  }
  if (constructor == "RichTextFixed") {
    return (struct TdRichText *)TdStackFetcherRichTextFixed (M);
  }
  if (constructor == "RichTextUrl") {
    return (struct TdRichText *)TdStackFetcherRichTextUrl (M);
  }
  if (constructor == "RichTextEmailAddress") {
    return (struct TdRichText *)TdStackFetcherRichTextEmailAddress (M);
  }
  if (constructor == "RichTexts") {
    return (struct TdRichText *)TdStackFetcherRichTexts (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdRichTextPlain *TdCreateObjectRichTextPlain (char *text_) {
  auto var = new struct TdRichTextPlain ();
  var->ID = CODE_RichTextPlain;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::richTextPlain> TdConvertToInternal (struct TdRichTextPlain *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  return td::td_api::make_object<td::td_api::richTextPlain>(std::move (v0));
}
struct TdRichTextPlain *TdConvertFromInternal (const td::td_api::richTextPlain &from) {
  auto res = new TdRichTextPlain ();
  res->ID = CODE_RichTextPlain;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  return res;
}
char *TdSerializeRichTextPlain (struct TdRichTextPlain *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTextPlain *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTextPlain (struct TdRichTextPlain *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTextPlain *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  delete var;
}
void TdStackStorerRichTextPlain (struct TdRichTextPlain *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTextPlain *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTextPlain");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
}
struct TdRichTextPlain *TdStackFetcherRichTextPlain (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTextPlain ();
  res->ID = CODE_RichTextPlain;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdRichTextBold *TdCreateObjectRichTextBold (struct TdRichText *text_) {
  auto var = new struct TdRichTextBold ();
  var->ID = CODE_RichTextBold;
  var->refcnt = 1;
  var->text_ = text_;
  return var;
}
td::td_api::object_ptr<td::td_api::richTextBold> TdConvertToInternal (struct TdRichTextBold *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  return td::td_api::make_object<td::td_api::richTextBold>(std::move (v0));
}
struct TdRichTextBold *TdConvertFromInternal (const td::td_api::richTextBold &from) {
  auto res = new TdRichTextBold ();
  res->ID = CODE_RichTextBold;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  return res;
}
char *TdSerializeRichTextBold (struct TdRichTextBold *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTextBold *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTextBold (struct TdRichTextBold *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTextBold *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerRichTextBold (struct TdRichTextBold *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTextBold *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTextBold");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
}
struct TdRichTextBold *TdStackFetcherRichTextBold (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTextBold ();
  res->ID = CODE_RichTextBold;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdRichTextItalic *TdCreateObjectRichTextItalic (struct TdRichText *text_) {
  auto var = new struct TdRichTextItalic ();
  var->ID = CODE_RichTextItalic;
  var->refcnt = 1;
  var->text_ = text_;
  return var;
}
td::td_api::object_ptr<td::td_api::richTextItalic> TdConvertToInternal (struct TdRichTextItalic *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  return td::td_api::make_object<td::td_api::richTextItalic>(std::move (v0));
}
struct TdRichTextItalic *TdConvertFromInternal (const td::td_api::richTextItalic &from) {
  auto res = new TdRichTextItalic ();
  res->ID = CODE_RichTextItalic;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  return res;
}
char *TdSerializeRichTextItalic (struct TdRichTextItalic *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTextItalic *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTextItalic (struct TdRichTextItalic *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTextItalic *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerRichTextItalic (struct TdRichTextItalic *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTextItalic *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTextItalic");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
}
struct TdRichTextItalic *TdStackFetcherRichTextItalic (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTextItalic ();
  res->ID = CODE_RichTextItalic;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdRichTextUnderline *TdCreateObjectRichTextUnderline (struct TdRichText *text_) {
  auto var = new struct TdRichTextUnderline ();
  var->ID = CODE_RichTextUnderline;
  var->refcnt = 1;
  var->text_ = text_;
  return var;
}
td::td_api::object_ptr<td::td_api::richTextUnderline> TdConvertToInternal (struct TdRichTextUnderline *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  return td::td_api::make_object<td::td_api::richTextUnderline>(std::move (v0));
}
struct TdRichTextUnderline *TdConvertFromInternal (const td::td_api::richTextUnderline &from) {
  auto res = new TdRichTextUnderline ();
  res->ID = CODE_RichTextUnderline;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  return res;
}
char *TdSerializeRichTextUnderline (struct TdRichTextUnderline *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTextUnderline *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTextUnderline (struct TdRichTextUnderline *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTextUnderline *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerRichTextUnderline (struct TdRichTextUnderline *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTextUnderline *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTextUnderline");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
}
struct TdRichTextUnderline *TdStackFetcherRichTextUnderline (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTextUnderline ();
  res->ID = CODE_RichTextUnderline;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdRichTextStrikethrough *TdCreateObjectRichTextStrikethrough (struct TdRichText *text_) {
  auto var = new struct TdRichTextStrikethrough ();
  var->ID = CODE_RichTextStrikethrough;
  var->refcnt = 1;
  var->text_ = text_;
  return var;
}
td::td_api::object_ptr<td::td_api::richTextStrikethrough> TdConvertToInternal (struct TdRichTextStrikethrough *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  return td::td_api::make_object<td::td_api::richTextStrikethrough>(std::move (v0));
}
struct TdRichTextStrikethrough *TdConvertFromInternal (const td::td_api::richTextStrikethrough &from) {
  auto res = new TdRichTextStrikethrough ();
  res->ID = CODE_RichTextStrikethrough;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  return res;
}
char *TdSerializeRichTextStrikethrough (struct TdRichTextStrikethrough *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTextStrikethrough *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTextStrikethrough (struct TdRichTextStrikethrough *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTextStrikethrough *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerRichTextStrikethrough (struct TdRichTextStrikethrough *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTextStrikethrough *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTextStrikethrough");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
}
struct TdRichTextStrikethrough *TdStackFetcherRichTextStrikethrough (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTextStrikethrough ();
  res->ID = CODE_RichTextStrikethrough;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdRichTextFixed *TdCreateObjectRichTextFixed (struct TdRichText *text_) {
  auto var = new struct TdRichTextFixed ();
  var->ID = CODE_RichTextFixed;
  var->refcnt = 1;
  var->text_ = text_;
  return var;
}
td::td_api::object_ptr<td::td_api::richTextFixed> TdConvertToInternal (struct TdRichTextFixed *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  return td::td_api::make_object<td::td_api::richTextFixed>(std::move (v0));
}
struct TdRichTextFixed *TdConvertFromInternal (const td::td_api::richTextFixed &from) {
  auto res = new TdRichTextFixed ();
  res->ID = CODE_RichTextFixed;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  return res;
}
char *TdSerializeRichTextFixed (struct TdRichTextFixed *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTextFixed *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTextFixed (struct TdRichTextFixed *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTextFixed *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerRichTextFixed (struct TdRichTextFixed *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTextFixed *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTextFixed");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
}
struct TdRichTextFixed *TdStackFetcherRichTextFixed (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTextFixed ();
  res->ID = CODE_RichTextFixed;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  return res;
}
struct TdRichTextUrl *TdCreateObjectRichTextUrl (struct TdRichText *text_, char *url_) {
  auto var = new struct TdRichTextUrl ();
  var->ID = CODE_RichTextUrl;
  var->refcnt = 1;
  var->text_ = text_;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::richTextUrl> TdConvertToInternal (struct TdRichTextUrl *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  std::string v100;
  v100 = (var->url_) ? var->url_: "";
  return td::td_api::make_object<td::td_api::richTextUrl>(std::move (v0), std::move (v100));
}
struct TdRichTextUrl *TdConvertFromInternal (const td::td_api::richTextUrl &from) {
  auto res = new TdRichTextUrl ();
  res->ID = CODE_RichTextUrl;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  return res;
}
char *TdSerializeRichTextUrl (struct TdRichTextUrl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTextUrl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTextUrl (struct TdRichTextUrl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTextUrl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  free (var->url_);
  delete var;
}
void TdStackStorerRichTextUrl (struct TdRichTextUrl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTextUrl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTextUrl");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  M->pack_string (var->url_);
  M->new_field ("url_");
}
struct TdRichTextUrl *TdStackFetcherRichTextUrl (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTextUrl ();
  res->ID = CODE_RichTextUrl;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdRichTextEmailAddress *TdCreateObjectRichTextEmailAddress (struct TdRichText *text_, char *email_address_) {
  auto var = new struct TdRichTextEmailAddress ();
  var->ID = CODE_RichTextEmailAddress;
  var->refcnt = 1;
  var->text_ = text_;
  var->email_address_ = (email_address_) ? td::str_dup (td::Slice (email_address_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::richTextEmailAddress> TdConvertToInternal (struct TdRichTextEmailAddress *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::RichText> v0;
  v0 = TdConvertToInternal (var->text_);
  std::string v100;
  v100 = (var->email_address_) ? var->email_address_: "";
  return td::td_api::make_object<td::td_api::richTextEmailAddress>(std::move (v0), std::move (v100));
}
struct TdRichTextEmailAddress *TdConvertFromInternal (const td::td_api::richTextEmailAddress &from) {
  auto res = new TdRichTextEmailAddress ();
  res->ID = CODE_RichTextEmailAddress;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.text_));
  }
  res->email_address_ = (from.email_address_.length ()) ? td::str_dup (from.email_address_) : nullptr;
  return res;
}
char *TdSerializeRichTextEmailAddress (struct TdRichTextEmailAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTextEmailAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTextEmailAddress (struct TdRichTextEmailAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTextEmailAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  free (var->email_address_);
  delete var;
}
void TdStackStorerRichTextEmailAddress (struct TdRichTextEmailAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTextEmailAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTextEmailAddress");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  M->pack_string (var->email_address_);
  M->new_field ("email_address_");
}
struct TdRichTextEmailAddress *TdStackFetcherRichTextEmailAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTextEmailAddress ();
  res->ID = CODE_RichTextEmailAddress;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherRichText (M);
  }
  M->pop ();
  M->get_field ("email_address_");
  res->email_address_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdRichTexts *TdCreateObjectRichTexts (struct TdVectorRichText *texts_) {
  auto var = new struct TdRichTexts ();
  var->ID = CODE_RichTexts;
  var->refcnt = 1;
  var->texts_ = texts_;
  return var;
}
td::td_api::object_ptr<td::td_api::richTexts> TdConvertToInternal (struct TdRichTexts *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::RichText>> v0;
  for (int i0 = 0; i0 < var->texts_->len; i0++) {
    td::td_api::object_ptr<td::td_api::RichText> v1;
    v1 = TdConvertToInternal (var->texts_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::richTexts>(std::move (v0));
}
struct TdRichTexts *TdConvertFromInternal (const td::td_api::richTexts &from) {
  auto res = new TdRichTexts ();
  res->ID = CODE_RichTexts;
  res->refcnt = 1;
  res->texts_ = new TdVectorRichText ();
  res->texts_->len = (int)from.texts_.size ();
  res->texts_->data = new struct TdRichText * [res->texts_->len];
  for (int i0 = 0; i0 < res->texts_->len; i0++) {
    if (!from.texts_[i0]) {
      res->texts_->data[i0] = nullptr;
    } else {
      res->texts_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::RichText &>(*from.texts_[i0]));
    }
  }
  return res;
}
char *TdSerializeRichTexts (struct TdRichTexts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRichTexts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRichTexts (struct TdRichTexts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRichTexts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->texts_->len; i0++) {
    TdDestroyObject (var->texts_->data[i0]);
  }
  delete[] var->texts_->data;
  delete var->texts_;
  delete var;
}
void TdStackStorerRichTexts (struct TdRichTexts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRichTexts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RichTexts");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->texts_->len; i0++) {
    TdStackStorer (var->texts_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("texts_");
}
struct TdRichTexts *TdStackFetcherRichTexts (struct TdStackFetcherMethods *M) {
  auto res = new TdRichTexts ();
  res->ID = CODE_RichTexts;
  res->refcnt = 1;
  M->get_field ("texts_");
  res->texts_ = new TdVectorRichText ();
  res->texts_->len = M->get_arr_size ();
  res->texts_->data = new struct TdRichText * [res->texts_->len];
  for (int i0 = 0; i0 < res->texts_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->texts_->data[i0] = nullptr;
    } else {
      res->texts_->data[i0] = TdStackFetcherRichText (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdSavedCredentials *TdCreateObjectSavedCredentials (char *id_, char *title_) {
  auto var = new struct TdSavedCredentials ();
  var->ID = CODE_SavedCredentials;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::savedCredentials> TdConvertToInternal (struct TdSavedCredentials *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  return td::td_api::make_object<td::td_api::savedCredentials>(std::move (v0), std::move (v100));
}
struct TdSavedCredentials *TdConvertFromInternal (const td::td_api::savedCredentials &from) {
  auto res = new TdSavedCredentials ();
  res->ID = CODE_SavedCredentials;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  return res;
}
char *TdSerializeSavedCredentials (struct TdSavedCredentials *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSavedCredentials *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSavedCredentials (struct TdSavedCredentials *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSavedCredentials *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  delete var;
}
void TdStackStorerSavedCredentials (struct TdSavedCredentials *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSavedCredentials *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SavedCredentials");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
}
struct TdSavedCredentials *TdStackFetcherSavedCredentials (struct TdStackFetcherMethods *M) {
  auto res = new TdSavedCredentials ();
  res->ID = CODE_SavedCredentials;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdScopeNotificationSettings *TdCreateObjectScopeNotificationSettings (int mute_for_, char *sound_, int show_preview_) {
  auto var = new struct TdScopeNotificationSettings ();
  var->ID = CODE_ScopeNotificationSettings;
  var->refcnt = 1;
  var->mute_for_ = mute_for_;
  var->sound_ = (sound_) ? td::str_dup (td::Slice (sound_)) : nullptr;
  var->show_preview_ = show_preview_;
  return var;
}
td::td_api::object_ptr<td::td_api::scopeNotificationSettings> TdConvertToInternal (struct TdScopeNotificationSettings *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->mute_for_;
  std::string v100;
  v100 = (var->sound_) ? var->sound_: "";
  bool v200;
  v200 = var->show_preview_ != 0;
  return td::td_api::make_object<td::td_api::scopeNotificationSettings>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdScopeNotificationSettings *TdConvertFromInternal (const td::td_api::scopeNotificationSettings &from) {
  auto res = new TdScopeNotificationSettings ();
  res->ID = CODE_ScopeNotificationSettings;
  res->refcnt = 1;
  res->mute_for_ = from.mute_for_;
  res->sound_ = (from.sound_.length ()) ? td::str_dup (from.sound_) : nullptr;
  res->show_preview_ = from.show_preview_;
  return res;
}
char *TdSerializeScopeNotificationSettings (struct TdScopeNotificationSettings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdScopeNotificationSettings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectScopeNotificationSettings (struct TdScopeNotificationSettings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdScopeNotificationSettings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->sound_);
  delete var;
}
void TdStackStorerScopeNotificationSettings (struct TdScopeNotificationSettings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdScopeNotificationSettings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ScopeNotificationSettings");
  M->new_field ("ID");
  M->pack_long (var->mute_for_);
  M->new_field ("mute_for_");
  M->pack_string (var->sound_);
  M->new_field ("sound_");
  M->pack_bool (var->show_preview_);
  M->new_field ("show_preview_");
}
struct TdScopeNotificationSettings *TdStackFetcherScopeNotificationSettings (struct TdStackFetcherMethods *M) {
  auto res = new TdScopeNotificationSettings ();
  res->ID = CODE_ScopeNotificationSettings;
  res->refcnt = 1;
  M->get_field ("mute_for_");
  res->mute_for_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sound_");
  res->sound_ = M->get_string ();
  M->pop ();
  M->get_field ("show_preview_");
  res->show_preview_ = (int)M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::SearchMessagesFilter> TdConvertToInternal (struct TdSearchMessagesFilter *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SearchMessagesFilterEmpty: return TdConvertToInternal ((struct TdSearchMessagesFilterEmpty *)var);
    case CODE_SearchMessagesFilterAnimation: return TdConvertToInternal ((struct TdSearchMessagesFilterAnimation *)var);
    case CODE_SearchMessagesFilterAudio: return TdConvertToInternal ((struct TdSearchMessagesFilterAudio *)var);
    case CODE_SearchMessagesFilterDocument: return TdConvertToInternal ((struct TdSearchMessagesFilterDocument *)var);
    case CODE_SearchMessagesFilterPhoto: return TdConvertToInternal ((struct TdSearchMessagesFilterPhoto *)var);
    case CODE_SearchMessagesFilterVideo: return TdConvertToInternal ((struct TdSearchMessagesFilterVideo *)var);
    case CODE_SearchMessagesFilterVoiceNote: return TdConvertToInternal ((struct TdSearchMessagesFilterVoiceNote *)var);
    case CODE_SearchMessagesFilterPhotoAndVideo: return TdConvertToInternal ((struct TdSearchMessagesFilterPhotoAndVideo *)var);
    case CODE_SearchMessagesFilterUrl: return TdConvertToInternal ((struct TdSearchMessagesFilterUrl *)var);
    case CODE_SearchMessagesFilterChatPhoto: return TdConvertToInternal ((struct TdSearchMessagesFilterChatPhoto *)var);
    case CODE_SearchMessagesFilterCall: return TdConvertToInternal ((struct TdSearchMessagesFilterCall *)var);
    case CODE_SearchMessagesFilterMissedCall: return TdConvertToInternal ((struct TdSearchMessagesFilterMissedCall *)var);
    case CODE_SearchMessagesFilterVideoNote: return TdConvertToInternal ((struct TdSearchMessagesFilterVideoNote *)var);
    case CODE_SearchMessagesFilterVoiceAndVideoNote: return TdConvertToInternal ((struct TdSearchMessagesFilterVoiceAndVideoNote *)var);
    case CODE_SearchMessagesFilterMention: return TdConvertToInternal ((struct TdSearchMessagesFilterMention *)var);
    case CODE_SearchMessagesFilterUnreadMention: return TdConvertToInternal ((struct TdSearchMessagesFilterUnreadMention *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdSearchMessagesFilter *TdConvertFromInternal (const td::td_api::SearchMessagesFilter &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_SearchMessagesFilterEmpty: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterEmpty &>(from));
    case CODE_SearchMessagesFilterAnimation: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterAnimation &>(from));
    case CODE_SearchMessagesFilterAudio: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterAudio &>(from));
    case CODE_SearchMessagesFilterDocument: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterDocument &>(from));
    case CODE_SearchMessagesFilterPhoto: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterPhoto &>(from));
    case CODE_SearchMessagesFilterVideo: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterVideo &>(from));
    case CODE_SearchMessagesFilterVoiceNote: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterVoiceNote &>(from));
    case CODE_SearchMessagesFilterPhotoAndVideo: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterPhotoAndVideo &>(from));
    case CODE_SearchMessagesFilterUrl: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterUrl &>(from));
    case CODE_SearchMessagesFilterChatPhoto: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterChatPhoto &>(from));
    case CODE_SearchMessagesFilterCall: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterCall &>(from));
    case CODE_SearchMessagesFilterMissedCall: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterMissedCall &>(from));
    case CODE_SearchMessagesFilterVideoNote: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterVideoNote &>(from));
    case CODE_SearchMessagesFilterVoiceAndVideoNote: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterVoiceAndVideoNote &>(from));
    case CODE_SearchMessagesFilterMention: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterMention &>(from));
    case CODE_SearchMessagesFilterUnreadMention: return (struct TdSearchMessagesFilter *)TdConvertFromInternal(static_cast<const td::td_api::searchMessagesFilterUnreadMention &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeSearchMessagesFilter (struct TdSearchMessagesFilter *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilter *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilter (struct TdSearchMessagesFilter *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilter *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SearchMessagesFilterEmpty: return TdDestroyObject ((struct TdSearchMessagesFilterEmpty *)var);
    case CODE_SearchMessagesFilterAnimation: return TdDestroyObject ((struct TdSearchMessagesFilterAnimation *)var);
    case CODE_SearchMessagesFilterAudio: return TdDestroyObject ((struct TdSearchMessagesFilterAudio *)var);
    case CODE_SearchMessagesFilterDocument: return TdDestroyObject ((struct TdSearchMessagesFilterDocument *)var);
    case CODE_SearchMessagesFilterPhoto: return TdDestroyObject ((struct TdSearchMessagesFilterPhoto *)var);
    case CODE_SearchMessagesFilterVideo: return TdDestroyObject ((struct TdSearchMessagesFilterVideo *)var);
    case CODE_SearchMessagesFilterVoiceNote: return TdDestroyObject ((struct TdSearchMessagesFilterVoiceNote *)var);
    case CODE_SearchMessagesFilterPhotoAndVideo: return TdDestroyObject ((struct TdSearchMessagesFilterPhotoAndVideo *)var);
    case CODE_SearchMessagesFilterUrl: return TdDestroyObject ((struct TdSearchMessagesFilterUrl *)var);
    case CODE_SearchMessagesFilterChatPhoto: return TdDestroyObject ((struct TdSearchMessagesFilterChatPhoto *)var);
    case CODE_SearchMessagesFilterCall: return TdDestroyObject ((struct TdSearchMessagesFilterCall *)var);
    case CODE_SearchMessagesFilterMissedCall: return TdDestroyObject ((struct TdSearchMessagesFilterMissedCall *)var);
    case CODE_SearchMessagesFilterVideoNote: return TdDestroyObject ((struct TdSearchMessagesFilterVideoNote *)var);
    case CODE_SearchMessagesFilterVoiceAndVideoNote: return TdDestroyObject ((struct TdSearchMessagesFilterVoiceAndVideoNote *)var);
    case CODE_SearchMessagesFilterMention: return TdDestroyObject ((struct TdSearchMessagesFilterMention *)var);
    case CODE_SearchMessagesFilterUnreadMention: return TdDestroyObject ((struct TdSearchMessagesFilterUnreadMention *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerSearchMessagesFilter (struct TdSearchMessagesFilter *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilter *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SearchMessagesFilterEmpty: return TdStackStorer ((struct TdSearchMessagesFilterEmpty *)var, M);
    case CODE_SearchMessagesFilterAnimation: return TdStackStorer ((struct TdSearchMessagesFilterAnimation *)var, M);
    case CODE_SearchMessagesFilterAudio: return TdStackStorer ((struct TdSearchMessagesFilterAudio *)var, M);
    case CODE_SearchMessagesFilterDocument: return TdStackStorer ((struct TdSearchMessagesFilterDocument *)var, M);
    case CODE_SearchMessagesFilterPhoto: return TdStackStorer ((struct TdSearchMessagesFilterPhoto *)var, M);
    case CODE_SearchMessagesFilterVideo: return TdStackStorer ((struct TdSearchMessagesFilterVideo *)var, M);
    case CODE_SearchMessagesFilterVoiceNote: return TdStackStorer ((struct TdSearchMessagesFilterVoiceNote *)var, M);
    case CODE_SearchMessagesFilterPhotoAndVideo: return TdStackStorer ((struct TdSearchMessagesFilterPhotoAndVideo *)var, M);
    case CODE_SearchMessagesFilterUrl: return TdStackStorer ((struct TdSearchMessagesFilterUrl *)var, M);
    case CODE_SearchMessagesFilterChatPhoto: return TdStackStorer ((struct TdSearchMessagesFilterChatPhoto *)var, M);
    case CODE_SearchMessagesFilterCall: return TdStackStorer ((struct TdSearchMessagesFilterCall *)var, M);
    case CODE_SearchMessagesFilterMissedCall: return TdStackStorer ((struct TdSearchMessagesFilterMissedCall *)var, M);
    case CODE_SearchMessagesFilterVideoNote: return TdStackStorer ((struct TdSearchMessagesFilterVideoNote *)var, M);
    case CODE_SearchMessagesFilterVoiceAndVideoNote: return TdStackStorer ((struct TdSearchMessagesFilterVoiceAndVideoNote *)var, M);
    case CODE_SearchMessagesFilterMention: return TdStackStorer ((struct TdSearchMessagesFilterMention *)var, M);
    case CODE_SearchMessagesFilterUnreadMention: return TdStackStorer ((struct TdSearchMessagesFilterUnreadMention *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdSearchMessagesFilter *TdStackFetcherSearchMessagesFilter (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "SearchMessagesFilterEmpty") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterEmpty (M);
  }
  if (constructor == "SearchMessagesFilterAnimation") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterAnimation (M);
  }
  if (constructor == "SearchMessagesFilterAudio") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterAudio (M);
  }
  if (constructor == "SearchMessagesFilterDocument") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterDocument (M);
  }
  if (constructor == "SearchMessagesFilterPhoto") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterPhoto (M);
  }
  if (constructor == "SearchMessagesFilterVideo") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterVideo (M);
  }
  if (constructor == "SearchMessagesFilterVoiceNote") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterVoiceNote (M);
  }
  if (constructor == "SearchMessagesFilterPhotoAndVideo") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterPhotoAndVideo (M);
  }
  if (constructor == "SearchMessagesFilterUrl") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterUrl (M);
  }
  if (constructor == "SearchMessagesFilterChatPhoto") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterChatPhoto (M);
  }
  if (constructor == "SearchMessagesFilterCall") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterCall (M);
  }
  if (constructor == "SearchMessagesFilterMissedCall") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterMissedCall (M);
  }
  if (constructor == "SearchMessagesFilterVideoNote") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterVideoNote (M);
  }
  if (constructor == "SearchMessagesFilterVoiceAndVideoNote") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterVoiceAndVideoNote (M);
  }
  if (constructor == "SearchMessagesFilterMention") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterMention (M);
  }
  if (constructor == "SearchMessagesFilterUnreadMention") {
    return (struct TdSearchMessagesFilter *)TdStackFetcherSearchMessagesFilterUnreadMention (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdSearchMessagesFilterEmpty *TdCreateObjectSearchMessagesFilterEmpty (void) {
  auto var = new struct TdSearchMessagesFilterEmpty ();
  var->ID = CODE_SearchMessagesFilterEmpty;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterEmpty> TdConvertToInternal (struct TdSearchMessagesFilterEmpty *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterEmpty>();
}
struct TdSearchMessagesFilterEmpty *TdConvertFromInternal (const td::td_api::searchMessagesFilterEmpty &from) {
  auto res = new TdSearchMessagesFilterEmpty ();
  res->ID = CODE_SearchMessagesFilterEmpty;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterEmpty (struct TdSearchMessagesFilterEmpty *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterEmpty *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterEmpty (struct TdSearchMessagesFilterEmpty *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterEmpty *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterEmpty (struct TdSearchMessagesFilterEmpty *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterEmpty *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterEmpty");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterEmpty *TdStackFetcherSearchMessagesFilterEmpty (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterEmpty ();
  res->ID = CODE_SearchMessagesFilterEmpty;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterAnimation *TdCreateObjectSearchMessagesFilterAnimation (void) {
  auto var = new struct TdSearchMessagesFilterAnimation ();
  var->ID = CODE_SearchMessagesFilterAnimation;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterAnimation> TdConvertToInternal (struct TdSearchMessagesFilterAnimation *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterAnimation>();
}
struct TdSearchMessagesFilterAnimation *TdConvertFromInternal (const td::td_api::searchMessagesFilterAnimation &from) {
  auto res = new TdSearchMessagesFilterAnimation ();
  res->ID = CODE_SearchMessagesFilterAnimation;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterAnimation (struct TdSearchMessagesFilterAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterAnimation (struct TdSearchMessagesFilterAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterAnimation (struct TdSearchMessagesFilterAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterAnimation");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterAnimation *TdStackFetcherSearchMessagesFilterAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterAnimation ();
  res->ID = CODE_SearchMessagesFilterAnimation;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterAudio *TdCreateObjectSearchMessagesFilterAudio (void) {
  auto var = new struct TdSearchMessagesFilterAudio ();
  var->ID = CODE_SearchMessagesFilterAudio;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterAudio> TdConvertToInternal (struct TdSearchMessagesFilterAudio *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterAudio>();
}
struct TdSearchMessagesFilterAudio *TdConvertFromInternal (const td::td_api::searchMessagesFilterAudio &from) {
  auto res = new TdSearchMessagesFilterAudio ();
  res->ID = CODE_SearchMessagesFilterAudio;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterAudio (struct TdSearchMessagesFilterAudio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterAudio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterAudio (struct TdSearchMessagesFilterAudio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterAudio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterAudio (struct TdSearchMessagesFilterAudio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterAudio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterAudio");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterAudio *TdStackFetcherSearchMessagesFilterAudio (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterAudio ();
  res->ID = CODE_SearchMessagesFilterAudio;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterDocument *TdCreateObjectSearchMessagesFilterDocument (void) {
  auto var = new struct TdSearchMessagesFilterDocument ();
  var->ID = CODE_SearchMessagesFilterDocument;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterDocument> TdConvertToInternal (struct TdSearchMessagesFilterDocument *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterDocument>();
}
struct TdSearchMessagesFilterDocument *TdConvertFromInternal (const td::td_api::searchMessagesFilterDocument &from) {
  auto res = new TdSearchMessagesFilterDocument ();
  res->ID = CODE_SearchMessagesFilterDocument;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterDocument (struct TdSearchMessagesFilterDocument *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterDocument *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterDocument (struct TdSearchMessagesFilterDocument *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterDocument *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterDocument (struct TdSearchMessagesFilterDocument *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterDocument *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterDocument");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterDocument *TdStackFetcherSearchMessagesFilterDocument (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterDocument ();
  res->ID = CODE_SearchMessagesFilterDocument;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterPhoto *TdCreateObjectSearchMessagesFilterPhoto (void) {
  auto var = new struct TdSearchMessagesFilterPhoto ();
  var->ID = CODE_SearchMessagesFilterPhoto;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterPhoto> TdConvertToInternal (struct TdSearchMessagesFilterPhoto *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterPhoto>();
}
struct TdSearchMessagesFilterPhoto *TdConvertFromInternal (const td::td_api::searchMessagesFilterPhoto &from) {
  auto res = new TdSearchMessagesFilterPhoto ();
  res->ID = CODE_SearchMessagesFilterPhoto;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterPhoto (struct TdSearchMessagesFilterPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterPhoto (struct TdSearchMessagesFilterPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterPhoto (struct TdSearchMessagesFilterPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterPhoto");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterPhoto *TdStackFetcherSearchMessagesFilterPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterPhoto ();
  res->ID = CODE_SearchMessagesFilterPhoto;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterVideo *TdCreateObjectSearchMessagesFilterVideo (void) {
  auto var = new struct TdSearchMessagesFilterVideo ();
  var->ID = CODE_SearchMessagesFilterVideo;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterVideo> TdConvertToInternal (struct TdSearchMessagesFilterVideo *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterVideo>();
}
struct TdSearchMessagesFilterVideo *TdConvertFromInternal (const td::td_api::searchMessagesFilterVideo &from) {
  auto res = new TdSearchMessagesFilterVideo ();
  res->ID = CODE_SearchMessagesFilterVideo;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterVideo (struct TdSearchMessagesFilterVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterVideo (struct TdSearchMessagesFilterVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterVideo (struct TdSearchMessagesFilterVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterVideo");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterVideo *TdStackFetcherSearchMessagesFilterVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterVideo ();
  res->ID = CODE_SearchMessagesFilterVideo;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterVoiceNote *TdCreateObjectSearchMessagesFilterVoiceNote (void) {
  auto var = new struct TdSearchMessagesFilterVoiceNote ();
  var->ID = CODE_SearchMessagesFilterVoiceNote;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterVoiceNote> TdConvertToInternal (struct TdSearchMessagesFilterVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterVoiceNote>();
}
struct TdSearchMessagesFilterVoiceNote *TdConvertFromInternal (const td::td_api::searchMessagesFilterVoiceNote &from) {
  auto res = new TdSearchMessagesFilterVoiceNote ();
  res->ID = CODE_SearchMessagesFilterVoiceNote;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterVoiceNote (struct TdSearchMessagesFilterVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterVoiceNote (struct TdSearchMessagesFilterVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterVoiceNote (struct TdSearchMessagesFilterVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterVoiceNote");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterVoiceNote *TdStackFetcherSearchMessagesFilterVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterVoiceNote ();
  res->ID = CODE_SearchMessagesFilterVoiceNote;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterPhotoAndVideo *TdCreateObjectSearchMessagesFilterPhotoAndVideo (void) {
  auto var = new struct TdSearchMessagesFilterPhotoAndVideo ();
  var->ID = CODE_SearchMessagesFilterPhotoAndVideo;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterPhotoAndVideo> TdConvertToInternal (struct TdSearchMessagesFilterPhotoAndVideo *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterPhotoAndVideo>();
}
struct TdSearchMessagesFilterPhotoAndVideo *TdConvertFromInternal (const td::td_api::searchMessagesFilterPhotoAndVideo &from) {
  auto res = new TdSearchMessagesFilterPhotoAndVideo ();
  res->ID = CODE_SearchMessagesFilterPhotoAndVideo;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterPhotoAndVideo (struct TdSearchMessagesFilterPhotoAndVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterPhotoAndVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterPhotoAndVideo (struct TdSearchMessagesFilterPhotoAndVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterPhotoAndVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterPhotoAndVideo (struct TdSearchMessagesFilterPhotoAndVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterPhotoAndVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterPhotoAndVideo");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterPhotoAndVideo *TdStackFetcherSearchMessagesFilterPhotoAndVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterPhotoAndVideo ();
  res->ID = CODE_SearchMessagesFilterPhotoAndVideo;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterUrl *TdCreateObjectSearchMessagesFilterUrl (void) {
  auto var = new struct TdSearchMessagesFilterUrl ();
  var->ID = CODE_SearchMessagesFilterUrl;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterUrl> TdConvertToInternal (struct TdSearchMessagesFilterUrl *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterUrl>();
}
struct TdSearchMessagesFilterUrl *TdConvertFromInternal (const td::td_api::searchMessagesFilterUrl &from) {
  auto res = new TdSearchMessagesFilterUrl ();
  res->ID = CODE_SearchMessagesFilterUrl;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterUrl (struct TdSearchMessagesFilterUrl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterUrl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterUrl (struct TdSearchMessagesFilterUrl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterUrl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterUrl (struct TdSearchMessagesFilterUrl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterUrl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterUrl");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterUrl *TdStackFetcherSearchMessagesFilterUrl (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterUrl ();
  res->ID = CODE_SearchMessagesFilterUrl;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterChatPhoto *TdCreateObjectSearchMessagesFilterChatPhoto (void) {
  auto var = new struct TdSearchMessagesFilterChatPhoto ();
  var->ID = CODE_SearchMessagesFilterChatPhoto;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterChatPhoto> TdConvertToInternal (struct TdSearchMessagesFilterChatPhoto *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterChatPhoto>();
}
struct TdSearchMessagesFilterChatPhoto *TdConvertFromInternal (const td::td_api::searchMessagesFilterChatPhoto &from) {
  auto res = new TdSearchMessagesFilterChatPhoto ();
  res->ID = CODE_SearchMessagesFilterChatPhoto;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterChatPhoto (struct TdSearchMessagesFilterChatPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterChatPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterChatPhoto (struct TdSearchMessagesFilterChatPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterChatPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterChatPhoto (struct TdSearchMessagesFilterChatPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterChatPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterChatPhoto");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterChatPhoto *TdStackFetcherSearchMessagesFilterChatPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterChatPhoto ();
  res->ID = CODE_SearchMessagesFilterChatPhoto;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterCall *TdCreateObjectSearchMessagesFilterCall (void) {
  auto var = new struct TdSearchMessagesFilterCall ();
  var->ID = CODE_SearchMessagesFilterCall;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterCall> TdConvertToInternal (struct TdSearchMessagesFilterCall *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterCall>();
}
struct TdSearchMessagesFilterCall *TdConvertFromInternal (const td::td_api::searchMessagesFilterCall &from) {
  auto res = new TdSearchMessagesFilterCall ();
  res->ID = CODE_SearchMessagesFilterCall;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterCall (struct TdSearchMessagesFilterCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterCall (struct TdSearchMessagesFilterCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterCall (struct TdSearchMessagesFilterCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterCall");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterCall *TdStackFetcherSearchMessagesFilterCall (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterCall ();
  res->ID = CODE_SearchMessagesFilterCall;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterMissedCall *TdCreateObjectSearchMessagesFilterMissedCall (void) {
  auto var = new struct TdSearchMessagesFilterMissedCall ();
  var->ID = CODE_SearchMessagesFilterMissedCall;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterMissedCall> TdConvertToInternal (struct TdSearchMessagesFilterMissedCall *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterMissedCall>();
}
struct TdSearchMessagesFilterMissedCall *TdConvertFromInternal (const td::td_api::searchMessagesFilterMissedCall &from) {
  auto res = new TdSearchMessagesFilterMissedCall ();
  res->ID = CODE_SearchMessagesFilterMissedCall;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterMissedCall (struct TdSearchMessagesFilterMissedCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterMissedCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterMissedCall (struct TdSearchMessagesFilterMissedCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterMissedCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterMissedCall (struct TdSearchMessagesFilterMissedCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterMissedCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterMissedCall");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterMissedCall *TdStackFetcherSearchMessagesFilterMissedCall (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterMissedCall ();
  res->ID = CODE_SearchMessagesFilterMissedCall;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterVideoNote *TdCreateObjectSearchMessagesFilterVideoNote (void) {
  auto var = new struct TdSearchMessagesFilterVideoNote ();
  var->ID = CODE_SearchMessagesFilterVideoNote;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterVideoNote> TdConvertToInternal (struct TdSearchMessagesFilterVideoNote *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterVideoNote>();
}
struct TdSearchMessagesFilterVideoNote *TdConvertFromInternal (const td::td_api::searchMessagesFilterVideoNote &from) {
  auto res = new TdSearchMessagesFilterVideoNote ();
  res->ID = CODE_SearchMessagesFilterVideoNote;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterVideoNote (struct TdSearchMessagesFilterVideoNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterVideoNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterVideoNote (struct TdSearchMessagesFilterVideoNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterVideoNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterVideoNote (struct TdSearchMessagesFilterVideoNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterVideoNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterVideoNote");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterVideoNote *TdStackFetcherSearchMessagesFilterVideoNote (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterVideoNote ();
  res->ID = CODE_SearchMessagesFilterVideoNote;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterVoiceAndVideoNote *TdCreateObjectSearchMessagesFilterVoiceAndVideoNote (void) {
  auto var = new struct TdSearchMessagesFilterVoiceAndVideoNote ();
  var->ID = CODE_SearchMessagesFilterVoiceAndVideoNote;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterVoiceAndVideoNote> TdConvertToInternal (struct TdSearchMessagesFilterVoiceAndVideoNote *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterVoiceAndVideoNote>();
}
struct TdSearchMessagesFilterVoiceAndVideoNote *TdConvertFromInternal (const td::td_api::searchMessagesFilterVoiceAndVideoNote &from) {
  auto res = new TdSearchMessagesFilterVoiceAndVideoNote ();
  res->ID = CODE_SearchMessagesFilterVoiceAndVideoNote;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterVoiceAndVideoNote (struct TdSearchMessagesFilterVoiceAndVideoNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterVoiceAndVideoNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterVoiceAndVideoNote (struct TdSearchMessagesFilterVoiceAndVideoNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterVoiceAndVideoNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterVoiceAndVideoNote (struct TdSearchMessagesFilterVoiceAndVideoNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterVoiceAndVideoNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterVoiceAndVideoNote");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterVoiceAndVideoNote *TdStackFetcherSearchMessagesFilterVoiceAndVideoNote (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterVoiceAndVideoNote ();
  res->ID = CODE_SearchMessagesFilterVoiceAndVideoNote;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterMention *TdCreateObjectSearchMessagesFilterMention (void) {
  auto var = new struct TdSearchMessagesFilterMention ();
  var->ID = CODE_SearchMessagesFilterMention;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterMention> TdConvertToInternal (struct TdSearchMessagesFilterMention *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterMention>();
}
struct TdSearchMessagesFilterMention *TdConvertFromInternal (const td::td_api::searchMessagesFilterMention &from) {
  auto res = new TdSearchMessagesFilterMention ();
  res->ID = CODE_SearchMessagesFilterMention;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterMention (struct TdSearchMessagesFilterMention *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterMention *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterMention (struct TdSearchMessagesFilterMention *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterMention *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterMention (struct TdSearchMessagesFilterMention *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterMention *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterMention");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterMention *TdStackFetcherSearchMessagesFilterMention (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterMention ();
  res->ID = CODE_SearchMessagesFilterMention;
  res->refcnt = 1;
  return res;
}
struct TdSearchMessagesFilterUnreadMention *TdCreateObjectSearchMessagesFilterUnreadMention (void) {
  auto var = new struct TdSearchMessagesFilterUnreadMention ();
  var->ID = CODE_SearchMessagesFilterUnreadMention;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessagesFilterUnreadMention> TdConvertToInternal (struct TdSearchMessagesFilterUnreadMention *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::searchMessagesFilterUnreadMention>();
}
struct TdSearchMessagesFilterUnreadMention *TdConvertFromInternal (const td::td_api::searchMessagesFilterUnreadMention &from) {
  auto res = new TdSearchMessagesFilterUnreadMention ();
  res->ID = CODE_SearchMessagesFilterUnreadMention;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSearchMessagesFilterUnreadMention (struct TdSearchMessagesFilterUnreadMention *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessagesFilterUnreadMention *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessagesFilterUnreadMention (struct TdSearchMessagesFilterUnreadMention *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessagesFilterUnreadMention *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchMessagesFilterUnreadMention (struct TdSearchMessagesFilterUnreadMention *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessagesFilterUnreadMention *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessagesFilterUnreadMention");
  M->new_field ("ID");
}
struct TdSearchMessagesFilterUnreadMention *TdStackFetcherSearchMessagesFilterUnreadMention (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessagesFilterUnreadMention ();
  res->ID = CODE_SearchMessagesFilterUnreadMention;
  res->refcnt = 1;
  return res;
}
struct TdSeconds *TdCreateObjectSeconds (double seconds_) {
  auto var = new struct TdSeconds ();
  var->ID = CODE_Seconds;
  var->refcnt = 1;
  var->seconds_ = seconds_;
  return var;
}
td::td_api::object_ptr<td::td_api::seconds> TdConvertToInternal (struct TdSeconds *var) {
  if (!var) {
    return nullptr;
  }
  double v0;
  v0 = var->seconds_;
  return td::td_api::make_object<td::td_api::seconds>(std::move (v0));
}
struct TdSeconds *TdConvertFromInternal (const td::td_api::seconds &from) {
  auto res = new TdSeconds ();
  res->ID = CODE_Seconds;
  res->refcnt = 1;
  res->seconds_ = from.seconds_;
  return res;
}
char *TdSerializeSeconds (struct TdSeconds *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSeconds *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSeconds (struct TdSeconds *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSeconds *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSeconds (struct TdSeconds *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSeconds *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Seconds");
  M->new_field ("ID");
  M->pack_double (var->seconds_);
  M->new_field ("seconds_");
}
struct TdSeconds *TdStackFetcherSeconds (struct TdStackFetcherMethods *M) {
  auto res = new TdSeconds ();
  res->ID = CODE_Seconds;
  res->refcnt = 1;
  M->get_field ("seconds_");
  res->seconds_ = M->get_double ();
  M->pop ();
  return res;
}
struct TdSecretChat *TdCreateObjectSecretChat (int id_, int user_id_, struct TdSecretChatState *state_, int is_outbound_, int ttl_, struct TdBytes key_hash_, int layer_) {
  auto var = new struct TdSecretChat ();
  var->ID = CODE_SecretChat;
  var->refcnt = 1;
  var->id_ = id_;
  var->user_id_ = user_id_;
  var->state_ = state_;
  var->is_outbound_ = is_outbound_;
  var->ttl_ = ttl_;
  var->key_hash_ = key_hash_;
  var->layer_ = layer_;
  return var;
}
td::td_api::object_ptr<td::td_api::secretChat> TdConvertToInternal (struct TdSecretChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->user_id_;
  td::td_api::object_ptr<td::td_api::SecretChatState> v200;
  v200 = TdConvertToInternal (var->state_);
  bool v300;
  v300 = var->is_outbound_ != 0;
  std::int32_t v400;
  v400 = var->ttl_;
  std::string v500;
  v500 = std::string ((char *)var->key_hash_.data, var->key_hash_.len);
  std::int32_t v600;
  v600 = var->layer_;
  return td::td_api::make_object<td::td_api::secretChat>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdSecretChat *TdConvertFromInternal (const td::td_api::secretChat &from) {
  auto res = new TdSecretChat ();
  res->ID = CODE_SecretChat;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->user_id_ = from.user_id_;
  if (!from.state_) {
    res->state_ = nullptr;
  } else {
    res->state_ = TdConvertFromInternal (static_cast<const td::td_api::SecretChatState &>(*from.state_));
  }
  res->is_outbound_ = from.is_outbound_;
  res->ttl_ = from.ttl_;
  res->key_hash_.len = (int)from.key_hash_.length ();
  if (res->key_hash_.len) {
    res->key_hash_.data = new unsigned char[res->key_hash_.len];
    memcpy (res->key_hash_.data, from.key_hash_.c_str (), res->key_hash_.len);
  } else {
    res->key_hash_.data = nullptr;
  }
  res->layer_ = from.layer_;
  return res;
}
char *TdSerializeSecretChat (struct TdSecretChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSecretChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSecretChat (struct TdSecretChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSecretChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->state_);
  delete[]var->key_hash_.data;
  delete var;
}
void TdStackStorerSecretChat (struct TdSecretChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSecretChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SecretChat");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->state_, M);
  M->new_field ("state_");
  M->pack_bool (var->is_outbound_);
  M->new_field ("is_outbound_");
  M->pack_long (var->ttl_);
  M->new_field ("ttl_");
  M->pack_bytes (var->key_hash_.data, var->key_hash_.len);
  M->new_field ("key_hash_");
  M->pack_long (var->layer_);
  M->new_field ("layer_");
}
struct TdSecretChat *TdStackFetcherSecretChat (struct TdStackFetcherMethods *M) {
  auto res = new TdSecretChat ();
  res->ID = CODE_SecretChat;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("state_");
  if (M->is_nil ()) {
    res->state_ = nullptr;
  } else {
    res->state_ = TdStackFetcherSecretChatState (M);
  }
  M->pop ();
  M->get_field ("is_outbound_");
  res->is_outbound_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("ttl_");
  res->ttl_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("key_hash_");
  res->key_hash_.data = M->get_bytes (&res->key_hash_.len);
  M->pop ();
  M->get_field ("layer_");
  res->layer_ = (int)M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::SecretChatState> TdConvertToInternal (struct TdSecretChatState *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SecretChatStatePending: return TdConvertToInternal ((struct TdSecretChatStatePending *)var);
    case CODE_SecretChatStateReady: return TdConvertToInternal ((struct TdSecretChatStateReady *)var);
    case CODE_SecretChatStateClosed: return TdConvertToInternal ((struct TdSecretChatStateClosed *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdSecretChatState *TdConvertFromInternal (const td::td_api::SecretChatState &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_SecretChatStatePending: return (struct TdSecretChatState *)TdConvertFromInternal(static_cast<const td::td_api::secretChatStatePending &>(from));
    case CODE_SecretChatStateReady: return (struct TdSecretChatState *)TdConvertFromInternal(static_cast<const td::td_api::secretChatStateReady &>(from));
    case CODE_SecretChatStateClosed: return (struct TdSecretChatState *)TdConvertFromInternal(static_cast<const td::td_api::secretChatStateClosed &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeSecretChatState (struct TdSecretChatState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSecretChatState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSecretChatState (struct TdSecretChatState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSecretChatState *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SecretChatStatePending: return TdDestroyObject ((struct TdSecretChatStatePending *)var);
    case CODE_SecretChatStateReady: return TdDestroyObject ((struct TdSecretChatStateReady *)var);
    case CODE_SecretChatStateClosed: return TdDestroyObject ((struct TdSecretChatStateClosed *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerSecretChatState (struct TdSecretChatState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSecretChatState *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SecretChatStatePending: return TdStackStorer ((struct TdSecretChatStatePending *)var, M);
    case CODE_SecretChatStateReady: return TdStackStorer ((struct TdSecretChatStateReady *)var, M);
    case CODE_SecretChatStateClosed: return TdStackStorer ((struct TdSecretChatStateClosed *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdSecretChatState *TdStackFetcherSecretChatState (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "SecretChatStatePending") {
    return (struct TdSecretChatState *)TdStackFetcherSecretChatStatePending (M);
  }
  if (constructor == "SecretChatStateReady") {
    return (struct TdSecretChatState *)TdStackFetcherSecretChatStateReady (M);
  }
  if (constructor == "SecretChatStateClosed") {
    return (struct TdSecretChatState *)TdStackFetcherSecretChatStateClosed (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdSecretChatStatePending *TdCreateObjectSecretChatStatePending (void) {
  auto var = new struct TdSecretChatStatePending ();
  var->ID = CODE_SecretChatStatePending;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::secretChatStatePending> TdConvertToInternal (struct TdSecretChatStatePending *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::secretChatStatePending>();
}
struct TdSecretChatStatePending *TdConvertFromInternal (const td::td_api::secretChatStatePending &from) {
  auto res = new TdSecretChatStatePending ();
  res->ID = CODE_SecretChatStatePending;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSecretChatStatePending (struct TdSecretChatStatePending *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSecretChatStatePending *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSecretChatStatePending (struct TdSecretChatStatePending *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSecretChatStatePending *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSecretChatStatePending (struct TdSecretChatStatePending *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSecretChatStatePending *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SecretChatStatePending");
  M->new_field ("ID");
}
struct TdSecretChatStatePending *TdStackFetcherSecretChatStatePending (struct TdStackFetcherMethods *M) {
  auto res = new TdSecretChatStatePending ();
  res->ID = CODE_SecretChatStatePending;
  res->refcnt = 1;
  return res;
}
struct TdSecretChatStateReady *TdCreateObjectSecretChatStateReady (void) {
  auto var = new struct TdSecretChatStateReady ();
  var->ID = CODE_SecretChatStateReady;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::secretChatStateReady> TdConvertToInternal (struct TdSecretChatStateReady *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::secretChatStateReady>();
}
struct TdSecretChatStateReady *TdConvertFromInternal (const td::td_api::secretChatStateReady &from) {
  auto res = new TdSecretChatStateReady ();
  res->ID = CODE_SecretChatStateReady;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSecretChatStateReady (struct TdSecretChatStateReady *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSecretChatStateReady *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSecretChatStateReady (struct TdSecretChatStateReady *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSecretChatStateReady *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSecretChatStateReady (struct TdSecretChatStateReady *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSecretChatStateReady *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SecretChatStateReady");
  M->new_field ("ID");
}
struct TdSecretChatStateReady *TdStackFetcherSecretChatStateReady (struct TdStackFetcherMethods *M) {
  auto res = new TdSecretChatStateReady ();
  res->ID = CODE_SecretChatStateReady;
  res->refcnt = 1;
  return res;
}
struct TdSecretChatStateClosed *TdCreateObjectSecretChatStateClosed (void) {
  auto var = new struct TdSecretChatStateClosed ();
  var->ID = CODE_SecretChatStateClosed;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::secretChatStateClosed> TdConvertToInternal (struct TdSecretChatStateClosed *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::secretChatStateClosed>();
}
struct TdSecretChatStateClosed *TdConvertFromInternal (const td::td_api::secretChatStateClosed &from) {
  auto res = new TdSecretChatStateClosed ();
  res->ID = CODE_SecretChatStateClosed;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSecretChatStateClosed (struct TdSecretChatStateClosed *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSecretChatStateClosed *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSecretChatStateClosed (struct TdSecretChatStateClosed *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSecretChatStateClosed *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSecretChatStateClosed (struct TdSecretChatStateClosed *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSecretChatStateClosed *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SecretChatStateClosed");
  M->new_field ("ID");
}
struct TdSecretChatStateClosed *TdStackFetcherSecretChatStateClosed (struct TdStackFetcherMethods *M) {
  auto res = new TdSecretChatStateClosed ();
  res->ID = CODE_SecretChatStateClosed;
  res->refcnt = 1;
  return res;
}
struct TdSession *TdCreateObjectSession (long long id_, int is_current_, int api_id_, char *application_name_, char *application_version_, int is_official_application_, char *device_model_, char *platform_, char *system_version_, int log_in_date_, int last_active_date_, char *ip_, char *country_, char *region_) {
  auto var = new struct TdSession ();
  var->ID = CODE_Session;
  var->refcnt = 1;
  var->id_ = id_;
  var->is_current_ = is_current_;
  var->api_id_ = api_id_;
  var->application_name_ = (application_name_) ? td::str_dup (td::Slice (application_name_)) : nullptr;
  var->application_version_ = (application_version_) ? td::str_dup (td::Slice (application_version_)) : nullptr;
  var->is_official_application_ = is_official_application_;
  var->device_model_ = (device_model_) ? td::str_dup (td::Slice (device_model_)) : nullptr;
  var->platform_ = (platform_) ? td::str_dup (td::Slice (platform_)) : nullptr;
  var->system_version_ = (system_version_) ? td::str_dup (td::Slice (system_version_)) : nullptr;
  var->log_in_date_ = log_in_date_;
  var->last_active_date_ = last_active_date_;
  var->ip_ = (ip_) ? td::str_dup (td::Slice (ip_)) : nullptr;
  var->country_ = (country_) ? td::str_dup (td::Slice (country_)) : nullptr;
  var->region_ = (region_) ? td::str_dup (td::Slice (region_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::session> TdConvertToInternal (struct TdSession *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  bool v100;
  v100 = var->is_current_ != 0;
  std::int32_t v200;
  v200 = var->api_id_;
  std::string v300;
  v300 = (var->application_name_) ? var->application_name_: "";
  std::string v400;
  v400 = (var->application_version_) ? var->application_version_: "";
  bool v500;
  v500 = var->is_official_application_ != 0;
  std::string v600;
  v600 = (var->device_model_) ? var->device_model_: "";
  std::string v700;
  v700 = (var->platform_) ? var->platform_: "";
  std::string v800;
  v800 = (var->system_version_) ? var->system_version_: "";
  std::int32_t v900;
  v900 = var->log_in_date_;
  std::int32_t v1000;
  v1000 = var->last_active_date_;
  std::string v1100;
  v1100 = (var->ip_) ? var->ip_: "";
  std::string v1200;
  v1200 = (var->country_) ? var->country_: "";
  std::string v1300;
  v1300 = (var->region_) ? var->region_: "";
  return td::td_api::make_object<td::td_api::session>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000), std::move (v1100), std::move (v1200), std::move (v1300));
}
struct TdSession *TdConvertFromInternal (const td::td_api::session &from) {
  auto res = new TdSession ();
  res->ID = CODE_Session;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->is_current_ = from.is_current_;
  res->api_id_ = from.api_id_;
  res->application_name_ = (from.application_name_.length ()) ? td::str_dup (from.application_name_) : nullptr;
  res->application_version_ = (from.application_version_.length ()) ? td::str_dup (from.application_version_) : nullptr;
  res->is_official_application_ = from.is_official_application_;
  res->device_model_ = (from.device_model_.length ()) ? td::str_dup (from.device_model_) : nullptr;
  res->platform_ = (from.platform_.length ()) ? td::str_dup (from.platform_) : nullptr;
  res->system_version_ = (from.system_version_.length ()) ? td::str_dup (from.system_version_) : nullptr;
  res->log_in_date_ = from.log_in_date_;
  res->last_active_date_ = from.last_active_date_;
  res->ip_ = (from.ip_.length ()) ? td::str_dup (from.ip_) : nullptr;
  res->country_ = (from.country_.length ()) ? td::str_dup (from.country_) : nullptr;
  res->region_ = (from.region_.length ()) ? td::str_dup (from.region_) : nullptr;
  return res;
}
char *TdSerializeSession (struct TdSession *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSession *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSession (struct TdSession *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSession *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->application_name_);
  free (var->application_version_);
  free (var->device_model_);
  free (var->platform_);
  free (var->system_version_);
  free (var->ip_);
  free (var->country_);
  free (var->region_);
  delete var;
}
void TdStackStorerSession (struct TdSession *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSession *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Session");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_bool (var->is_current_);
  M->new_field ("is_current_");
  M->pack_long (var->api_id_);
  M->new_field ("api_id_");
  M->pack_string (var->application_name_);
  M->new_field ("application_name_");
  M->pack_string (var->application_version_);
  M->new_field ("application_version_");
  M->pack_bool (var->is_official_application_);
  M->new_field ("is_official_application_");
  M->pack_string (var->device_model_);
  M->new_field ("device_model_");
  M->pack_string (var->platform_);
  M->new_field ("platform_");
  M->pack_string (var->system_version_);
  M->new_field ("system_version_");
  M->pack_long (var->log_in_date_);
  M->new_field ("log_in_date_");
  M->pack_long (var->last_active_date_);
  M->new_field ("last_active_date_");
  M->pack_string (var->ip_);
  M->new_field ("ip_");
  M->pack_string (var->country_);
  M->new_field ("country_");
  M->pack_string (var->region_);
  M->new_field ("region_");
}
struct TdSession *TdStackFetcherSession (struct TdStackFetcherMethods *M) {
  auto res = new TdSession ();
  res->ID = CODE_Session;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_current_");
  res->is_current_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("api_id_");
  res->api_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("application_name_");
  res->application_name_ = M->get_string ();
  M->pop ();
  M->get_field ("application_version_");
  res->application_version_ = M->get_string ();
  M->pop ();
  M->get_field ("is_official_application_");
  res->is_official_application_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("device_model_");
  res->device_model_ = M->get_string ();
  M->pop ();
  M->get_field ("platform_");
  res->platform_ = M->get_string ();
  M->pop ();
  M->get_field ("system_version_");
  res->system_version_ = M->get_string ();
  M->pop ();
  M->get_field ("log_in_date_");
  res->log_in_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("last_active_date_");
  res->last_active_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("ip_");
  res->ip_ = M->get_string ();
  M->pop ();
  M->get_field ("country_");
  res->country_ = M->get_string ();
  M->pop ();
  M->get_field ("region_");
  res->region_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSessions *TdCreateObjectSessions (struct TdVectorSession *sessions_) {
  auto var = new struct TdSessions ();
  var->ID = CODE_Sessions;
  var->refcnt = 1;
  var->sessions_ = sessions_;
  return var;
}
td::td_api::object_ptr<td::td_api::sessions> TdConvertToInternal (struct TdSessions *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::session>> v0;
  for (int i0 = 0; i0 < var->sessions_->len; i0++) {
    td::td_api::object_ptr<td::td_api::session> v1;
    v1 = TdConvertToInternal (var->sessions_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::sessions>(std::move (v0));
}
struct TdSessions *TdConvertFromInternal (const td::td_api::sessions &from) {
  auto res = new TdSessions ();
  res->ID = CODE_Sessions;
  res->refcnt = 1;
  res->sessions_ = new TdVectorSession ();
  res->sessions_->len = (int)from.sessions_.size ();
  res->sessions_->data = new struct TdSession * [res->sessions_->len];
  for (int i0 = 0; i0 < res->sessions_->len; i0++) {
    if (!from.sessions_[i0]) {
      res->sessions_->data[i0] = nullptr;
    } else {
      res->sessions_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::session &>(*from.sessions_[i0]));
    }
  }
  return res;
}
char *TdSerializeSessions (struct TdSessions *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSessions *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSessions (struct TdSessions *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSessions *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->sessions_->len; i0++) {
    TdDestroyObject (var->sessions_->data[i0]);
  }
  delete[] var->sessions_->data;
  delete var->sessions_;
  delete var;
}
void TdStackStorerSessions (struct TdSessions *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSessions *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Sessions");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->sessions_->len; i0++) {
    TdStackStorer (var->sessions_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("sessions_");
}
struct TdSessions *TdStackFetcherSessions (struct TdStackFetcherMethods *M) {
  auto res = new TdSessions ();
  res->ID = CODE_Sessions;
  res->refcnt = 1;
  M->get_field ("sessions_");
  res->sessions_ = new TdVectorSession ();
  res->sessions_->len = M->get_arr_size ();
  res->sessions_->data = new struct TdSession * [res->sessions_->len];
  for (int i0 = 0; i0 < res->sessions_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->sessions_->data[i0] = nullptr;
    } else {
      res->sessions_->data[i0] = TdStackFetcherSession (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdShippingOption *TdCreateObjectShippingOption (char *id_, char *title_, struct TdVectorLabeledPricePart *price_parts_) {
  auto var = new struct TdShippingOption ();
  var->ID = CODE_ShippingOption;
  var->refcnt = 1;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->price_parts_ = price_parts_;
  return var;
}
td::td_api::object_ptr<td::td_api::shippingOption> TdConvertToInternal (struct TdShippingOption *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->id_) ? var->id_: "";
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::vector<td::td_api::object_ptr<td::td_api::labeledPricePart>> v200;
  for (int i200 = 0; i200 < var->price_parts_->len; i200++) {
    td::td_api::object_ptr<td::td_api::labeledPricePart> v201;
    v201 = TdConvertToInternal (var->price_parts_->data[i200]);
    v200.push_back (std::move (v201));
  }
  return td::td_api::make_object<td::td_api::shippingOption>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdShippingOption *TdConvertFromInternal (const td::td_api::shippingOption &from) {
  auto res = new TdShippingOption ();
  res->ID = CODE_ShippingOption;
  res->refcnt = 1;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->price_parts_ = new TdVectorLabeledPricePart ();
  res->price_parts_->len = (int)from.price_parts_.size ();
  res->price_parts_->data = new struct TdLabeledPricePart * [res->price_parts_->len];
  for (int i200 = 0; i200 < res->price_parts_->len; i200++) {
    if (!from.price_parts_[i200]) {
      res->price_parts_->data[i200] = nullptr;
    } else {
      res->price_parts_->data[i200] = TdConvertFromInternal (static_cast<const td::td_api::labeledPricePart &>(*from.price_parts_[i200]));
    }
  }
  return res;
}
char *TdSerializeShippingOption (struct TdShippingOption *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdShippingOption *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectShippingOption (struct TdShippingOption *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdShippingOption *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->id_);
  free (var->title_);
  for (int i200 = 0; i200 < var->price_parts_->len; i200++) {
    TdDestroyObject (var->price_parts_->data[i200]);
  }
  delete[] var->price_parts_->data;
  delete var->price_parts_;
  delete var;
}
void TdStackStorerShippingOption (struct TdShippingOption *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdShippingOption *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ShippingOption");
  M->new_field ("ID");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->new_array ();
  for (int i200 = 0; i200 < var->price_parts_->len; i200++) {
    TdStackStorer (var->price_parts_->data[i200], M);
    M->new_arr_field (i200);
  }
  M->new_field ("price_parts_");
}
struct TdShippingOption *TdStackFetcherShippingOption (struct TdStackFetcherMethods *M) {
  auto res = new TdShippingOption ();
  res->ID = CODE_ShippingOption;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("price_parts_");
  res->price_parts_ = new TdVectorLabeledPricePart ();
  res->price_parts_->len = M->get_arr_size ();
  res->price_parts_->data = new struct TdLabeledPricePart * [res->price_parts_->len];
  for (int i200 = 0; i200 < res->price_parts_->len; i200++) {
    M->get_arr_field (i200);
    if (M->is_nil ()) {
      res->price_parts_->data[i200] = nullptr;
    } else {
      res->price_parts_->data[i200] = TdStackFetcherLabeledPricePart (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdSticker *TdCreateObjectSticker (long long set_id_, int width_, int height_, char *emoji_, int is_mask_, struct TdMaskPosition *mask_position_, struct TdPhotoSize *thumbnail_, struct TdFile *sticker_) {
  auto var = new struct TdSticker ();
  var->ID = CODE_Sticker;
  var->refcnt = 1;
  var->set_id_ = set_id_;
  var->width_ = width_;
  var->height_ = height_;
  var->emoji_ = (emoji_) ? td::str_dup (td::Slice (emoji_)) : nullptr;
  var->is_mask_ = is_mask_;
  var->mask_position_ = mask_position_;
  var->thumbnail_ = thumbnail_;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::sticker> TdConvertToInternal (struct TdSticker *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->set_id_;
  std::int32_t v100;
  v100 = var->width_;
  std::int32_t v200;
  v200 = var->height_;
  std::string v300;
  v300 = (var->emoji_) ? var->emoji_: "";
  bool v400;
  v400 = var->is_mask_ != 0;
  td::td_api::object_ptr<td::td_api::maskPosition> v500;
  v500 = TdConvertToInternal (var->mask_position_);
  td::td_api::object_ptr<td::td_api::photoSize> v600;
  v600 = TdConvertToInternal (var->thumbnail_);
  td::td_api::object_ptr<td::td_api::file> v700;
  v700 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::sticker>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700));
}
struct TdSticker *TdConvertFromInternal (const td::td_api::sticker &from) {
  auto res = new TdSticker ();
  res->ID = CODE_Sticker;
  res->refcnt = 1;
  res->set_id_ = from.set_id_;
  res->width_ = from.width_;
  res->height_ = from.height_;
  res->emoji_ = (from.emoji_.length ()) ? td::str_dup (from.emoji_) : nullptr;
  res->is_mask_ = from.is_mask_;
  if (!from.mask_position_) {
    res->mask_position_ = nullptr;
  } else {
    res->mask_position_ = TdConvertFromInternal (static_cast<const td::td_api::maskPosition &>(*from.mask_position_));
  }
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeSticker (struct TdSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSticker (struct TdSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->emoji_);
  TdDestroyObject (var->mask_position_);
  TdDestroyObject (var->thumbnail_);
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerSticker (struct TdSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Sticker");
  M->new_field ("ID");
  M->pack_long (var->set_id_);
  M->new_field ("set_id_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
  M->pack_string (var->emoji_);
  M->new_field ("emoji_");
  M->pack_bool (var->is_mask_);
  M->new_field ("is_mask_");
  TdStackStorer (var->mask_position_, M);
  M->new_field ("mask_position_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdSticker *TdStackFetcherSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdSticker ();
  res->ID = CODE_Sticker;
  res->refcnt = 1;
  M->get_field ("set_id_");
  res->set_id_ = M->get_long ();
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("emoji_");
  res->emoji_ = M->get_string ();
  M->pop ();
  M->get_field ("is_mask_");
  res->is_mask_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("mask_position_");
  if (M->is_nil ()) {
    res->mask_position_ = nullptr;
  } else {
    res->mask_position_ = TdStackFetcherMaskPosition (M);
  }
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdStickerEmojis *TdCreateObjectStickerEmojis (struct TdVectorString *emojis_) {
  auto var = new struct TdStickerEmojis ();
  var->ID = CODE_StickerEmojis;
  var->refcnt = 1;
  var->emojis_ = emojis_;
  return var;
}
td::td_api::object_ptr<td::td_api::stickerEmojis> TdConvertToInternal (struct TdStickerEmojis *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::string> v0;
  for (int i0 = 0; i0 < var->emojis_->len; i0++) {
    std::string v1;
    v1 = (var->emojis_->data[i0]) ? var->emojis_->data[i0]: "";
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::stickerEmojis>(std::move (v0));
}
struct TdStickerEmojis *TdConvertFromInternal (const td::td_api::stickerEmojis &from) {
  auto res = new TdStickerEmojis ();
  res->ID = CODE_StickerEmojis;
  res->refcnt = 1;
  res->emojis_ = new TdVectorString ();
  res->emojis_->len = (int)from.emojis_.size ();
  res->emojis_->data = new char * [res->emojis_->len];
  for (int i0 = 0; i0 < res->emojis_->len; i0++) {
    res->emojis_->data[i0] = (from.emojis_[i0].length ()) ? td::str_dup (from.emojis_[i0]) : nullptr;
  }
  return res;
}
char *TdSerializeStickerEmojis (struct TdStickerEmojis *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStickerEmojis *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStickerEmojis (struct TdStickerEmojis *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStickerEmojis *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->emojis_->len; i0++) {
    free (var->emojis_->data[i0]);
  }
  delete[] var->emojis_->data;
  delete var->emojis_;
  delete var;
}
void TdStackStorerStickerEmojis (struct TdStickerEmojis *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStickerEmojis *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("StickerEmojis");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->emojis_->len; i0++) {
    M->pack_string (var->emojis_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("emojis_");
}
struct TdStickerEmojis *TdStackFetcherStickerEmojis (struct TdStackFetcherMethods *M) {
  auto res = new TdStickerEmojis ();
  res->ID = CODE_StickerEmojis;
  res->refcnt = 1;
  M->get_field ("emojis_");
  res->emojis_ = new TdVectorString ();
  res->emojis_->len = M->get_arr_size ();
  res->emojis_->data = new char * [res->emojis_->len];
  for (int i0 = 0; i0 < res->emojis_->len; i0++) {
    M->get_arr_field (i0);
    res->emojis_->data[i0] = M->get_string ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdStickerSet *TdCreateObjectStickerSet (long long id_, char *title_, char *name_, int is_installed_, int is_archived_, int is_official_, int is_masks_, int is_viewed_, struct TdVectorSticker *stickers_, struct TdVectorStickerEmojis *emojis_) {
  auto var = new struct TdStickerSet ();
  var->ID = CODE_StickerSet;
  var->refcnt = 1;
  var->id_ = id_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  var->is_installed_ = is_installed_;
  var->is_archived_ = is_archived_;
  var->is_official_ = is_official_;
  var->is_masks_ = is_masks_;
  var->is_viewed_ = is_viewed_;
  var->stickers_ = stickers_;
  var->emojis_ = emojis_;
  return var;
}
td::td_api::object_ptr<td::td_api::stickerSet> TdConvertToInternal (struct TdStickerSet *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->name_) ? var->name_: "";
  bool v300;
  v300 = var->is_installed_ != 0;
  bool v400;
  v400 = var->is_archived_ != 0;
  bool v500;
  v500 = var->is_official_ != 0;
  bool v600;
  v600 = var->is_masks_ != 0;
  bool v700;
  v700 = var->is_viewed_ != 0;
  std::vector<td::td_api::object_ptr<td::td_api::sticker>> v800;
  for (int i800 = 0; i800 < var->stickers_->len; i800++) {
    td::td_api::object_ptr<td::td_api::sticker> v801;
    v801 = TdConvertToInternal (var->stickers_->data[i800]);
    v800.push_back (std::move (v801));
  }
  std::vector<td::td_api::object_ptr<td::td_api::stickerEmojis>> v900;
  for (int i900 = 0; i900 < var->emojis_->len; i900++) {
    td::td_api::object_ptr<td::td_api::stickerEmojis> v901;
    v901 = TdConvertToInternal (var->emojis_->data[i900]);
    v900.push_back (std::move (v901));
  }
  return td::td_api::make_object<td::td_api::stickerSet>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900));
}
struct TdStickerSet *TdConvertFromInternal (const td::td_api::stickerSet &from) {
  auto res = new TdStickerSet ();
  res->ID = CODE_StickerSet;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  res->is_installed_ = from.is_installed_;
  res->is_archived_ = from.is_archived_;
  res->is_official_ = from.is_official_;
  res->is_masks_ = from.is_masks_;
  res->is_viewed_ = from.is_viewed_;
  res->stickers_ = new TdVectorSticker ();
  res->stickers_->len = (int)from.stickers_.size ();
  res->stickers_->data = new struct TdSticker * [res->stickers_->len];
  for (int i800 = 0; i800 < res->stickers_->len; i800++) {
    if (!from.stickers_[i800]) {
      res->stickers_->data[i800] = nullptr;
    } else {
      res->stickers_->data[i800] = TdConvertFromInternal (static_cast<const td::td_api::sticker &>(*from.stickers_[i800]));
    }
  }
  res->emojis_ = new TdVectorStickerEmojis ();
  res->emojis_->len = (int)from.emojis_.size ();
  res->emojis_->data = new struct TdStickerEmojis * [res->emojis_->len];
  for (int i900 = 0; i900 < res->emojis_->len; i900++) {
    if (!from.emojis_[i900]) {
      res->emojis_->data[i900] = nullptr;
    } else {
      res->emojis_->data[i900] = TdConvertFromInternal (static_cast<const td::td_api::stickerEmojis &>(*from.emojis_[i900]));
    }
  }
  return res;
}
char *TdSerializeStickerSet (struct TdStickerSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStickerSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStickerSet (struct TdStickerSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStickerSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  free (var->name_);
  for (int i800 = 0; i800 < var->stickers_->len; i800++) {
    TdDestroyObject (var->stickers_->data[i800]);
  }
  delete[] var->stickers_->data;
  delete var->stickers_;
  for (int i900 = 0; i900 < var->emojis_->len; i900++) {
    TdDestroyObject (var->emojis_->data[i900]);
  }
  delete[] var->emojis_->data;
  delete var->emojis_;
  delete var;
}
void TdStackStorerStickerSet (struct TdStickerSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStickerSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("StickerSet");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->name_);
  M->new_field ("name_");
  M->pack_bool (var->is_installed_);
  M->new_field ("is_installed_");
  M->pack_bool (var->is_archived_);
  M->new_field ("is_archived_");
  M->pack_bool (var->is_official_);
  M->new_field ("is_official_");
  M->pack_bool (var->is_masks_);
  M->new_field ("is_masks_");
  M->pack_bool (var->is_viewed_);
  M->new_field ("is_viewed_");
  M->new_array ();
  for (int i800 = 0; i800 < var->stickers_->len; i800++) {
    TdStackStorer (var->stickers_->data[i800], M);
    M->new_arr_field (i800);
  }
  M->new_field ("stickers_");
  M->new_array ();
  for (int i900 = 0; i900 < var->emojis_->len; i900++) {
    TdStackStorer (var->emojis_->data[i900], M);
    M->new_arr_field (i900);
  }
  M->new_field ("emojis_");
}
struct TdStickerSet *TdStackFetcherStickerSet (struct TdStackFetcherMethods *M) {
  auto res = new TdStickerSet ();
  res->ID = CODE_StickerSet;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  M->get_field ("is_installed_");
  res->is_installed_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_archived_");
  res->is_archived_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_official_");
  res->is_official_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_masks_");
  res->is_masks_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_viewed_");
  res->is_viewed_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("stickers_");
  res->stickers_ = new TdVectorSticker ();
  res->stickers_->len = M->get_arr_size ();
  res->stickers_->data = new struct TdSticker * [res->stickers_->len];
  for (int i800 = 0; i800 < res->stickers_->len; i800++) {
    M->get_arr_field (i800);
    if (M->is_nil ()) {
      res->stickers_->data[i800] = nullptr;
    } else {
      res->stickers_->data[i800] = TdStackFetcherSticker (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("emojis_");
  res->emojis_ = new TdVectorStickerEmojis ();
  res->emojis_->len = M->get_arr_size ();
  res->emojis_->data = new struct TdStickerEmojis * [res->emojis_->len];
  for (int i900 = 0; i900 < res->emojis_->len; i900++) {
    M->get_arr_field (i900);
    if (M->is_nil ()) {
      res->emojis_->data[i900] = nullptr;
    } else {
      res->emojis_->data[i900] = TdStackFetcherStickerEmojis (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdStickerSetInfo *TdCreateObjectStickerSetInfo (long long id_, char *title_, char *name_, int is_installed_, int is_archived_, int is_official_, int is_masks_, int is_viewed_, int size_, struct TdVectorSticker *covers_) {
  auto var = new struct TdStickerSetInfo ();
  var->ID = CODE_StickerSetInfo;
  var->refcnt = 1;
  var->id_ = id_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  var->is_installed_ = is_installed_;
  var->is_archived_ = is_archived_;
  var->is_official_ = is_official_;
  var->is_masks_ = is_masks_;
  var->is_viewed_ = is_viewed_;
  var->size_ = size_;
  var->covers_ = covers_;
  return var;
}
td::td_api::object_ptr<td::td_api::stickerSetInfo> TdConvertToInternal (struct TdStickerSetInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->name_) ? var->name_: "";
  bool v300;
  v300 = var->is_installed_ != 0;
  bool v400;
  v400 = var->is_archived_ != 0;
  bool v500;
  v500 = var->is_official_ != 0;
  bool v600;
  v600 = var->is_masks_ != 0;
  bool v700;
  v700 = var->is_viewed_ != 0;
  std::int32_t v800;
  v800 = var->size_;
  std::vector<td::td_api::object_ptr<td::td_api::sticker>> v900;
  for (int i900 = 0; i900 < var->covers_->len; i900++) {
    td::td_api::object_ptr<td::td_api::sticker> v901;
    v901 = TdConvertToInternal (var->covers_->data[i900]);
    v900.push_back (std::move (v901));
  }
  return td::td_api::make_object<td::td_api::stickerSetInfo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900));
}
struct TdStickerSetInfo *TdConvertFromInternal (const td::td_api::stickerSetInfo &from) {
  auto res = new TdStickerSetInfo ();
  res->ID = CODE_StickerSetInfo;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  res->is_installed_ = from.is_installed_;
  res->is_archived_ = from.is_archived_;
  res->is_official_ = from.is_official_;
  res->is_masks_ = from.is_masks_;
  res->is_viewed_ = from.is_viewed_;
  res->size_ = from.size_;
  res->covers_ = new TdVectorSticker ();
  res->covers_->len = (int)from.covers_.size ();
  res->covers_->data = new struct TdSticker * [res->covers_->len];
  for (int i900 = 0; i900 < res->covers_->len; i900++) {
    if (!from.covers_[i900]) {
      res->covers_->data[i900] = nullptr;
    } else {
      res->covers_->data[i900] = TdConvertFromInternal (static_cast<const td::td_api::sticker &>(*from.covers_[i900]));
    }
  }
  return res;
}
char *TdSerializeStickerSetInfo (struct TdStickerSetInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStickerSetInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStickerSetInfo (struct TdStickerSetInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStickerSetInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  free (var->name_);
  for (int i900 = 0; i900 < var->covers_->len; i900++) {
    TdDestroyObject (var->covers_->data[i900]);
  }
  delete[] var->covers_->data;
  delete var->covers_;
  delete var;
}
void TdStackStorerStickerSetInfo (struct TdStickerSetInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStickerSetInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("StickerSetInfo");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->name_);
  M->new_field ("name_");
  M->pack_bool (var->is_installed_);
  M->new_field ("is_installed_");
  M->pack_bool (var->is_archived_);
  M->new_field ("is_archived_");
  M->pack_bool (var->is_official_);
  M->new_field ("is_official_");
  M->pack_bool (var->is_masks_);
  M->new_field ("is_masks_");
  M->pack_bool (var->is_viewed_);
  M->new_field ("is_viewed_");
  M->pack_long (var->size_);
  M->new_field ("size_");
  M->new_array ();
  for (int i900 = 0; i900 < var->covers_->len; i900++) {
    TdStackStorer (var->covers_->data[i900], M);
    M->new_arr_field (i900);
  }
  M->new_field ("covers_");
}
struct TdStickerSetInfo *TdStackFetcherStickerSetInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdStickerSetInfo ();
  res->ID = CODE_StickerSetInfo;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  M->get_field ("is_installed_");
  res->is_installed_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_archived_");
  res->is_archived_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_official_");
  res->is_official_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_masks_");
  res->is_masks_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_viewed_");
  res->is_viewed_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("size_");
  res->size_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("covers_");
  res->covers_ = new TdVectorSticker ();
  res->covers_->len = M->get_arr_size ();
  res->covers_->data = new struct TdSticker * [res->covers_->len];
  for (int i900 = 0; i900 < res->covers_->len; i900++) {
    M->get_arr_field (i900);
    if (M->is_nil ()) {
      res->covers_->data[i900] = nullptr;
    } else {
      res->covers_->data[i900] = TdStackFetcherSticker (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdStickerSets *TdCreateObjectStickerSets (int total_count_, struct TdVectorStickerSetInfo *sets_) {
  auto var = new struct TdStickerSets ();
  var->ID = CODE_StickerSets;
  var->refcnt = 1;
  var->total_count_ = total_count_;
  var->sets_ = sets_;
  return var;
}
td::td_api::object_ptr<td::td_api::stickerSets> TdConvertToInternal (struct TdStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->total_count_;
  std::vector<td::td_api::object_ptr<td::td_api::stickerSetInfo>> v100;
  for (int i100 = 0; i100 < var->sets_->len; i100++) {
    td::td_api::object_ptr<td::td_api::stickerSetInfo> v101;
    v101 = TdConvertToInternal (var->sets_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::stickerSets>(std::move (v0), std::move (v100));
}
struct TdStickerSets *TdConvertFromInternal (const td::td_api::stickerSets &from) {
  auto res = new TdStickerSets ();
  res->ID = CODE_StickerSets;
  res->refcnt = 1;
  res->total_count_ = from.total_count_;
  res->sets_ = new TdVectorStickerSetInfo ();
  res->sets_->len = (int)from.sets_.size ();
  res->sets_->data = new struct TdStickerSetInfo * [res->sets_->len];
  for (int i100 = 0; i100 < res->sets_->len; i100++) {
    if (!from.sets_[i100]) {
      res->sets_->data[i100] = nullptr;
    } else {
      res->sets_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::stickerSetInfo &>(*from.sets_[i100]));
    }
  }
  return res;
}
char *TdSerializeStickerSets (struct TdStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStickerSets (struct TdStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->sets_->len; i100++) {
    TdDestroyObject (var->sets_->data[i100]);
  }
  delete[] var->sets_->data;
  delete var->sets_;
  delete var;
}
void TdStackStorerStickerSets (struct TdStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("StickerSets");
  M->new_field ("ID");
  M->pack_long (var->total_count_);
  M->new_field ("total_count_");
  M->new_array ();
  for (int i100 = 0; i100 < var->sets_->len; i100++) {
    TdStackStorer (var->sets_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("sets_");
}
struct TdStickerSets *TdStackFetcherStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdStickerSets ();
  res->ID = CODE_StickerSets;
  res->refcnt = 1;
  M->get_field ("total_count_");
  res->total_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sets_");
  res->sets_ = new TdVectorStickerSetInfo ();
  res->sets_->len = M->get_arr_size ();
  res->sets_->data = new struct TdStickerSetInfo * [res->sets_->len];
  for (int i100 = 0; i100 < res->sets_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->sets_->data[i100] = nullptr;
    } else {
      res->sets_->data[i100] = TdStackFetcherStickerSetInfo (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdStickers *TdCreateObjectStickers (struct TdVectorSticker *stickers_) {
  auto var = new struct TdStickers ();
  var->ID = CODE_Stickers;
  var->refcnt = 1;
  var->stickers_ = stickers_;
  return var;
}
td::td_api::object_ptr<td::td_api::stickers> TdConvertToInternal (struct TdStickers *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::sticker>> v0;
  for (int i0 = 0; i0 < var->stickers_->len; i0++) {
    td::td_api::object_ptr<td::td_api::sticker> v1;
    v1 = TdConvertToInternal (var->stickers_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::stickers>(std::move (v0));
}
struct TdStickers *TdConvertFromInternal (const td::td_api::stickers &from) {
  auto res = new TdStickers ();
  res->ID = CODE_Stickers;
  res->refcnt = 1;
  res->stickers_ = new TdVectorSticker ();
  res->stickers_->len = (int)from.stickers_.size ();
  res->stickers_->data = new struct TdSticker * [res->stickers_->len];
  for (int i0 = 0; i0 < res->stickers_->len; i0++) {
    if (!from.stickers_[i0]) {
      res->stickers_->data[i0] = nullptr;
    } else {
      res->stickers_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::sticker &>(*from.stickers_[i0]));
    }
  }
  return res;
}
char *TdSerializeStickers (struct TdStickers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStickers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStickers (struct TdStickers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStickers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->stickers_->len; i0++) {
    TdDestroyObject (var->stickers_->data[i0]);
  }
  delete[] var->stickers_->data;
  delete var->stickers_;
  delete var;
}
void TdStackStorerStickers (struct TdStickers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStickers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Stickers");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->stickers_->len; i0++) {
    TdStackStorer (var->stickers_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("stickers_");
}
struct TdStickers *TdStackFetcherStickers (struct TdStackFetcherMethods *M) {
  auto res = new TdStickers ();
  res->ID = CODE_Stickers;
  res->refcnt = 1;
  M->get_field ("stickers_");
  res->stickers_ = new TdVectorSticker ();
  res->stickers_->len = M->get_arr_size ();
  res->stickers_->data = new struct TdSticker * [res->stickers_->len];
  for (int i0 = 0; i0 < res->stickers_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->stickers_->data[i0] = nullptr;
    } else {
      res->stickers_->data[i0] = TdStackFetcherSticker (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdStorageStatistics *TdCreateObjectStorageStatistics (long long size_, int count_, struct TdVectorStorageStatisticsByChat *by_chat_) {
  auto var = new struct TdStorageStatistics ();
  var->ID = CODE_StorageStatistics;
  var->refcnt = 1;
  var->size_ = size_;
  var->count_ = count_;
  var->by_chat_ = by_chat_;
  return var;
}
td::td_api::object_ptr<td::td_api::storageStatistics> TdConvertToInternal (struct TdStorageStatistics *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->size_;
  std::int32_t v100;
  v100 = var->count_;
  std::vector<td::td_api::object_ptr<td::td_api::storageStatisticsByChat>> v200;
  for (int i200 = 0; i200 < var->by_chat_->len; i200++) {
    td::td_api::object_ptr<td::td_api::storageStatisticsByChat> v201;
    v201 = TdConvertToInternal (var->by_chat_->data[i200]);
    v200.push_back (std::move (v201));
  }
  return td::td_api::make_object<td::td_api::storageStatistics>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdStorageStatistics *TdConvertFromInternal (const td::td_api::storageStatistics &from) {
  auto res = new TdStorageStatistics ();
  res->ID = CODE_StorageStatistics;
  res->refcnt = 1;
  res->size_ = from.size_;
  res->count_ = from.count_;
  res->by_chat_ = new TdVectorStorageStatisticsByChat ();
  res->by_chat_->len = (int)from.by_chat_.size ();
  res->by_chat_->data = new struct TdStorageStatisticsByChat * [res->by_chat_->len];
  for (int i200 = 0; i200 < res->by_chat_->len; i200++) {
    if (!from.by_chat_[i200]) {
      res->by_chat_->data[i200] = nullptr;
    } else {
      res->by_chat_->data[i200] = TdConvertFromInternal (static_cast<const td::td_api::storageStatisticsByChat &>(*from.by_chat_[i200]));
    }
  }
  return res;
}
char *TdSerializeStorageStatistics (struct TdStorageStatistics *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStorageStatistics *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStorageStatistics (struct TdStorageStatistics *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStorageStatistics *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i200 = 0; i200 < var->by_chat_->len; i200++) {
    TdDestroyObject (var->by_chat_->data[i200]);
  }
  delete[] var->by_chat_->data;
  delete var->by_chat_;
  delete var;
}
void TdStackStorerStorageStatistics (struct TdStorageStatistics *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStorageStatistics *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("StorageStatistics");
  M->new_field ("ID");
  M->pack_long (var->size_);
  M->new_field ("size_");
  M->pack_long (var->count_);
  M->new_field ("count_");
  M->new_array ();
  for (int i200 = 0; i200 < var->by_chat_->len; i200++) {
    TdStackStorer (var->by_chat_->data[i200], M);
    M->new_arr_field (i200);
  }
  M->new_field ("by_chat_");
}
struct TdStorageStatistics *TdStackFetcherStorageStatistics (struct TdStackFetcherMethods *M) {
  auto res = new TdStorageStatistics ();
  res->ID = CODE_StorageStatistics;
  res->refcnt = 1;
  M->get_field ("size_");
  res->size_ = M->get_long ();
  M->pop ();
  M->get_field ("count_");
  res->count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("by_chat_");
  res->by_chat_ = new TdVectorStorageStatisticsByChat ();
  res->by_chat_->len = M->get_arr_size ();
  res->by_chat_->data = new struct TdStorageStatisticsByChat * [res->by_chat_->len];
  for (int i200 = 0; i200 < res->by_chat_->len; i200++) {
    M->get_arr_field (i200);
    if (M->is_nil ()) {
      res->by_chat_->data[i200] = nullptr;
    } else {
      res->by_chat_->data[i200] = TdStackFetcherStorageStatisticsByChat (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdStorageStatisticsByChat *TdCreateObjectStorageStatisticsByChat (long long chat_id_, long long size_, int count_, struct TdVectorStorageStatisticsByFileType *by_file_type_) {
  auto var = new struct TdStorageStatisticsByChat ();
  var->ID = CODE_StorageStatisticsByChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->size_ = size_;
  var->count_ = count_;
  var->by_file_type_ = by_file_type_;
  return var;
}
td::td_api::object_ptr<td::td_api::storageStatisticsByChat> TdConvertToInternal (struct TdStorageStatisticsByChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->size_;
  std::int32_t v200;
  v200 = var->count_;
  std::vector<td::td_api::object_ptr<td::td_api::storageStatisticsByFileType>> v300;
  for (int i300 = 0; i300 < var->by_file_type_->len; i300++) {
    td::td_api::object_ptr<td::td_api::storageStatisticsByFileType> v301;
    v301 = TdConvertToInternal (var->by_file_type_->data[i300]);
    v300.push_back (std::move (v301));
  }
  return td::td_api::make_object<td::td_api::storageStatisticsByChat>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdStorageStatisticsByChat *TdConvertFromInternal (const td::td_api::storageStatisticsByChat &from) {
  auto res = new TdStorageStatisticsByChat ();
  res->ID = CODE_StorageStatisticsByChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->size_ = from.size_;
  res->count_ = from.count_;
  res->by_file_type_ = new TdVectorStorageStatisticsByFileType ();
  res->by_file_type_->len = (int)from.by_file_type_.size ();
  res->by_file_type_->data = new struct TdStorageStatisticsByFileType * [res->by_file_type_->len];
  for (int i300 = 0; i300 < res->by_file_type_->len; i300++) {
    if (!from.by_file_type_[i300]) {
      res->by_file_type_->data[i300] = nullptr;
    } else {
      res->by_file_type_->data[i300] = TdConvertFromInternal (static_cast<const td::td_api::storageStatisticsByFileType &>(*from.by_file_type_[i300]));
    }
  }
  return res;
}
char *TdSerializeStorageStatisticsByChat (struct TdStorageStatisticsByChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStorageStatisticsByChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStorageStatisticsByChat (struct TdStorageStatisticsByChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStorageStatisticsByChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i300 = 0; i300 < var->by_file_type_->len; i300++) {
    TdDestroyObject (var->by_file_type_->data[i300]);
  }
  delete[] var->by_file_type_->data;
  delete var->by_file_type_;
  delete var;
}
void TdStackStorerStorageStatisticsByChat (struct TdStorageStatisticsByChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStorageStatisticsByChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("StorageStatisticsByChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->size_);
  M->new_field ("size_");
  M->pack_long (var->count_);
  M->new_field ("count_");
  M->new_array ();
  for (int i300 = 0; i300 < var->by_file_type_->len; i300++) {
    TdStackStorer (var->by_file_type_->data[i300], M);
    M->new_arr_field (i300);
  }
  M->new_field ("by_file_type_");
}
struct TdStorageStatisticsByChat *TdStackFetcherStorageStatisticsByChat (struct TdStackFetcherMethods *M) {
  auto res = new TdStorageStatisticsByChat ();
  res->ID = CODE_StorageStatisticsByChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("size_");
  res->size_ = M->get_long ();
  M->pop ();
  M->get_field ("count_");
  res->count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("by_file_type_");
  res->by_file_type_ = new TdVectorStorageStatisticsByFileType ();
  res->by_file_type_->len = M->get_arr_size ();
  res->by_file_type_->data = new struct TdStorageStatisticsByFileType * [res->by_file_type_->len];
  for (int i300 = 0; i300 < res->by_file_type_->len; i300++) {
    M->get_arr_field (i300);
    if (M->is_nil ()) {
      res->by_file_type_->data[i300] = nullptr;
    } else {
      res->by_file_type_->data[i300] = TdStackFetcherStorageStatisticsByFileType (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdStorageStatisticsByFileType *TdCreateObjectStorageStatisticsByFileType (struct TdFileType *file_type_, long long size_, int count_) {
  auto var = new struct TdStorageStatisticsByFileType ();
  var->ID = CODE_StorageStatisticsByFileType;
  var->refcnt = 1;
  var->file_type_ = file_type_;
  var->size_ = size_;
  var->count_ = count_;
  return var;
}
td::td_api::object_ptr<td::td_api::storageStatisticsByFileType> TdConvertToInternal (struct TdStorageStatisticsByFileType *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::FileType> v0;
  v0 = TdConvertToInternal (var->file_type_);
  std::int64_t v100;
  v100 = var->size_;
  std::int32_t v200;
  v200 = var->count_;
  return td::td_api::make_object<td::td_api::storageStatisticsByFileType>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdStorageStatisticsByFileType *TdConvertFromInternal (const td::td_api::storageStatisticsByFileType &from) {
  auto res = new TdStorageStatisticsByFileType ();
  res->ID = CODE_StorageStatisticsByFileType;
  res->refcnt = 1;
  if (!from.file_type_) {
    res->file_type_ = nullptr;
  } else {
    res->file_type_ = TdConvertFromInternal (static_cast<const td::td_api::FileType &>(*from.file_type_));
  }
  res->size_ = from.size_;
  res->count_ = from.count_;
  return res;
}
char *TdSerializeStorageStatisticsByFileType (struct TdStorageStatisticsByFileType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStorageStatisticsByFileType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStorageStatisticsByFileType (struct TdStorageStatisticsByFileType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStorageStatisticsByFileType *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->file_type_);
  delete var;
}
void TdStackStorerStorageStatisticsByFileType (struct TdStorageStatisticsByFileType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStorageStatisticsByFileType *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("StorageStatisticsByFileType");
  M->new_field ("ID");
  TdStackStorer (var->file_type_, M);
  M->new_field ("file_type_");
  M->pack_long (var->size_);
  M->new_field ("size_");
  M->pack_long (var->count_);
  M->new_field ("count_");
}
struct TdStorageStatisticsByFileType *TdStackFetcherStorageStatisticsByFileType (struct TdStackFetcherMethods *M) {
  auto res = new TdStorageStatisticsByFileType ();
  res->ID = CODE_StorageStatisticsByFileType;
  res->refcnt = 1;
  M->get_field ("file_type_");
  if (M->is_nil ()) {
    res->file_type_ = nullptr;
  } else {
    res->file_type_ = TdStackFetcherFileType (M);
  }
  M->pop ();
  M->get_field ("size_");
  res->size_ = M->get_long ();
  M->pop ();
  M->get_field ("count_");
  res->count_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdStorageStatisticsFast *TdCreateObjectStorageStatisticsFast (long long files_size_, int file_count_, long long database_size_) {
  auto var = new struct TdStorageStatisticsFast ();
  var->ID = CODE_StorageStatisticsFast;
  var->refcnt = 1;
  var->files_size_ = files_size_;
  var->file_count_ = file_count_;
  var->database_size_ = database_size_;
  return var;
}
td::td_api::object_ptr<td::td_api::storageStatisticsFast> TdConvertToInternal (struct TdStorageStatisticsFast *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->files_size_;
  std::int32_t v100;
  v100 = var->file_count_;
  std::int64_t v200;
  v200 = var->database_size_;
  return td::td_api::make_object<td::td_api::storageStatisticsFast>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdStorageStatisticsFast *TdConvertFromInternal (const td::td_api::storageStatisticsFast &from) {
  auto res = new TdStorageStatisticsFast ();
  res->ID = CODE_StorageStatisticsFast;
  res->refcnt = 1;
  res->files_size_ = from.files_size_;
  res->file_count_ = from.file_count_;
  res->database_size_ = from.database_size_;
  return res;
}
char *TdSerializeStorageStatisticsFast (struct TdStorageStatisticsFast *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdStorageStatisticsFast *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectStorageStatisticsFast (struct TdStorageStatisticsFast *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdStorageStatisticsFast *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerStorageStatisticsFast (struct TdStorageStatisticsFast *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdStorageStatisticsFast *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("StorageStatisticsFast");
  M->new_field ("ID");
  M->pack_long (var->files_size_);
  M->new_field ("files_size_");
  M->pack_long (var->file_count_);
  M->new_field ("file_count_");
  M->pack_long (var->database_size_);
  M->new_field ("database_size_");
}
struct TdStorageStatisticsFast *TdStackFetcherStorageStatisticsFast (struct TdStackFetcherMethods *M) {
  auto res = new TdStorageStatisticsFast ();
  res->ID = CODE_StorageStatisticsFast;
  res->refcnt = 1;
  M->get_field ("files_size_");
  res->files_size_ = M->get_long ();
  M->pop ();
  M->get_field ("file_count_");
  res->file_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("database_size_");
  res->database_size_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdSupergroup *TdCreateObjectSupergroup (int id_, char *username_, int date_, struct TdChatMemberStatus *status_, int member_count_, int anyone_can_invite_, int sign_messages_, int is_channel_, int is_verified_, char *restriction_reason_) {
  auto var = new struct TdSupergroup ();
  var->ID = CODE_Supergroup;
  var->refcnt = 1;
  var->id_ = id_;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  var->date_ = date_;
  var->status_ = status_;
  var->member_count_ = member_count_;
  var->anyone_can_invite_ = anyone_can_invite_;
  var->sign_messages_ = sign_messages_;
  var->is_channel_ = is_channel_;
  var->is_verified_ = is_verified_;
  var->restriction_reason_ = (restriction_reason_) ? td::str_dup (td::Slice (restriction_reason_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::supergroup> TdConvertToInternal (struct TdSupergroup *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->username_) ? var->username_: "";
  std::int32_t v200;
  v200 = var->date_;
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v300;
  v300 = TdConvertToInternal (var->status_);
  std::int32_t v400;
  v400 = var->member_count_;
  bool v500;
  v500 = var->anyone_can_invite_ != 0;
  bool v600;
  v600 = var->sign_messages_ != 0;
  bool v700;
  v700 = var->is_channel_ != 0;
  bool v800;
  v800 = var->is_verified_ != 0;
  std::string v900;
  v900 = (var->restriction_reason_) ? var->restriction_reason_: "";
  return td::td_api::make_object<td::td_api::supergroup>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900));
}
struct TdSupergroup *TdConvertFromInternal (const td::td_api::supergroup &from) {
  auto res = new TdSupergroup ();
  res->ID = CODE_Supergroup;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  res->date_ = from.date_;
  if (!from.status_) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.status_));
  }
  res->member_count_ = from.member_count_;
  res->anyone_can_invite_ = from.anyone_can_invite_;
  res->sign_messages_ = from.sign_messages_;
  res->is_channel_ = from.is_channel_;
  res->is_verified_ = from.is_verified_;
  res->restriction_reason_ = (from.restriction_reason_.length ()) ? td::str_dup (from.restriction_reason_) : nullptr;
  return res;
}
char *TdSerializeSupergroup (struct TdSupergroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroup (struct TdSupergroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->username_);
  TdDestroyObject (var->status_);
  free (var->restriction_reason_);
  delete var;
}
void TdStackStorerSupergroup (struct TdSupergroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Supergroup");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->username_);
  M->new_field ("username_");
  M->pack_long (var->date_);
  M->new_field ("date_");
  TdStackStorer (var->status_, M);
  M->new_field ("status_");
  M->pack_long (var->member_count_);
  M->new_field ("member_count_");
  M->pack_bool (var->anyone_can_invite_);
  M->new_field ("anyone_can_invite_");
  M->pack_bool (var->sign_messages_);
  M->new_field ("sign_messages_");
  M->pack_bool (var->is_channel_);
  M->new_field ("is_channel_");
  M->pack_bool (var->is_verified_);
  M->new_field ("is_verified_");
  M->pack_string (var->restriction_reason_);
  M->new_field ("restriction_reason_");
}
struct TdSupergroup *TdStackFetcherSupergroup (struct TdStackFetcherMethods *M) {
  auto res = new TdSupergroup ();
  res->ID = CODE_Supergroup;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("status_");
  if (M->is_nil ()) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  M->get_field ("member_count_");
  res->member_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("anyone_can_invite_");
  res->anyone_can_invite_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sign_messages_");
  res->sign_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_channel_");
  res->is_channel_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_verified_");
  res->is_verified_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("restriction_reason_");
  res->restriction_reason_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSupergroupFullInfo *TdCreateObjectSupergroupFullInfo (char *description_, int member_count_, int administrator_count_, int restricted_count_, int banned_count_, int can_get_members_, int can_set_username_, int can_set_sticker_set_, int is_all_history_available_, long long sticker_set_id_, char *invite_link_, long long pinned_message_id_, int upgraded_from_basic_group_id_, long long upgraded_from_max_message_id_) {
  auto var = new struct TdSupergroupFullInfo ();
  var->ID = CODE_SupergroupFullInfo;
  var->refcnt = 1;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->member_count_ = member_count_;
  var->administrator_count_ = administrator_count_;
  var->restricted_count_ = restricted_count_;
  var->banned_count_ = banned_count_;
  var->can_get_members_ = can_get_members_;
  var->can_set_username_ = can_set_username_;
  var->can_set_sticker_set_ = can_set_sticker_set_;
  var->is_all_history_available_ = is_all_history_available_;
  var->sticker_set_id_ = sticker_set_id_;
  var->invite_link_ = (invite_link_) ? td::str_dup (td::Slice (invite_link_)) : nullptr;
  var->pinned_message_id_ = pinned_message_id_;
  var->upgraded_from_basic_group_id_ = upgraded_from_basic_group_id_;
  var->upgraded_from_max_message_id_ = upgraded_from_max_message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::supergroupFullInfo> TdConvertToInternal (struct TdSupergroupFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->description_) ? var->description_: "";
  std::int32_t v100;
  v100 = var->member_count_;
  std::int32_t v200;
  v200 = var->administrator_count_;
  std::int32_t v300;
  v300 = var->restricted_count_;
  std::int32_t v400;
  v400 = var->banned_count_;
  bool v500;
  v500 = var->can_get_members_ != 0;
  bool v600;
  v600 = var->can_set_username_ != 0;
  bool v700;
  v700 = var->can_set_sticker_set_ != 0;
  bool v800;
  v800 = var->is_all_history_available_ != 0;
  std::int64_t v900;
  v900 = var->sticker_set_id_;
  std::string v1000;
  v1000 = (var->invite_link_) ? var->invite_link_: "";
  std::int64_t v1100;
  v1100 = var->pinned_message_id_;
  std::int32_t v1200;
  v1200 = var->upgraded_from_basic_group_id_;
  std::int64_t v1300;
  v1300 = var->upgraded_from_max_message_id_;
  return td::td_api::make_object<td::td_api::supergroupFullInfo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000), std::move (v1100), std::move (v1200), std::move (v1300));
}
struct TdSupergroupFullInfo *TdConvertFromInternal (const td::td_api::supergroupFullInfo &from) {
  auto res = new TdSupergroupFullInfo ();
  res->ID = CODE_SupergroupFullInfo;
  res->refcnt = 1;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  res->member_count_ = from.member_count_;
  res->administrator_count_ = from.administrator_count_;
  res->restricted_count_ = from.restricted_count_;
  res->banned_count_ = from.banned_count_;
  res->can_get_members_ = from.can_get_members_;
  res->can_set_username_ = from.can_set_username_;
  res->can_set_sticker_set_ = from.can_set_sticker_set_;
  res->is_all_history_available_ = from.is_all_history_available_;
  res->sticker_set_id_ = from.sticker_set_id_;
  res->invite_link_ = (from.invite_link_.length ()) ? td::str_dup (from.invite_link_) : nullptr;
  res->pinned_message_id_ = from.pinned_message_id_;
  res->upgraded_from_basic_group_id_ = from.upgraded_from_basic_group_id_;
  res->upgraded_from_max_message_id_ = from.upgraded_from_max_message_id_;
  return res;
}
char *TdSerializeSupergroupFullInfo (struct TdSupergroupFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroupFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroupFullInfo (struct TdSupergroupFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroupFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->description_);
  free (var->invite_link_);
  delete var;
}
void TdStackStorerSupergroupFullInfo (struct TdSupergroupFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroupFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SupergroupFullInfo");
  M->new_field ("ID");
  M->pack_string (var->description_);
  M->new_field ("description_");
  M->pack_long (var->member_count_);
  M->new_field ("member_count_");
  M->pack_long (var->administrator_count_);
  M->new_field ("administrator_count_");
  M->pack_long (var->restricted_count_);
  M->new_field ("restricted_count_");
  M->pack_long (var->banned_count_);
  M->new_field ("banned_count_");
  M->pack_bool (var->can_get_members_);
  M->new_field ("can_get_members_");
  M->pack_bool (var->can_set_username_);
  M->new_field ("can_set_username_");
  M->pack_bool (var->can_set_sticker_set_);
  M->new_field ("can_set_sticker_set_");
  M->pack_bool (var->is_all_history_available_);
  M->new_field ("is_all_history_available_");
  M->pack_long (var->sticker_set_id_);
  M->new_field ("sticker_set_id_");
  M->pack_string (var->invite_link_);
  M->new_field ("invite_link_");
  M->pack_long (var->pinned_message_id_);
  M->new_field ("pinned_message_id_");
  M->pack_long (var->upgraded_from_basic_group_id_);
  M->new_field ("upgraded_from_basic_group_id_");
  M->pack_long (var->upgraded_from_max_message_id_);
  M->new_field ("upgraded_from_max_message_id_");
}
struct TdSupergroupFullInfo *TdStackFetcherSupergroupFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdSupergroupFullInfo ();
  res->ID = CODE_SupergroupFullInfo;
  res->refcnt = 1;
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("member_count_");
  res->member_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("administrator_count_");
  res->administrator_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("restricted_count_");
  res->restricted_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("banned_count_");
  res->banned_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_get_members_");
  res->can_get_members_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_set_username_");
  res->can_set_username_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_set_sticker_set_");
  res->can_set_sticker_set_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_all_history_available_");
  res->is_all_history_available_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sticker_set_id_");
  res->sticker_set_id_ = M->get_long ();
  M->pop ();
  M->get_field ("invite_link_");
  res->invite_link_ = M->get_string ();
  M->pop ();
  M->get_field ("pinned_message_id_");
  res->pinned_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("upgraded_from_basic_group_id_");
  res->upgraded_from_basic_group_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("upgraded_from_max_message_id_");
  res->upgraded_from_max_message_id_ = M->get_long ();
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::SupergroupMembersFilter> TdConvertToInternal (struct TdSupergroupMembersFilter *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SupergroupMembersFilterRecent: return TdConvertToInternal ((struct TdSupergroupMembersFilterRecent *)var);
    case CODE_SupergroupMembersFilterAdministrators: return TdConvertToInternal ((struct TdSupergroupMembersFilterAdministrators *)var);
    case CODE_SupergroupMembersFilterSearch: return TdConvertToInternal ((struct TdSupergroupMembersFilterSearch *)var);
    case CODE_SupergroupMembersFilterRestricted: return TdConvertToInternal ((struct TdSupergroupMembersFilterRestricted *)var);
    case CODE_SupergroupMembersFilterBanned: return TdConvertToInternal ((struct TdSupergroupMembersFilterBanned *)var);
    case CODE_SupergroupMembersFilterBots: return TdConvertToInternal ((struct TdSupergroupMembersFilterBots *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdSupergroupMembersFilter *TdConvertFromInternal (const td::td_api::SupergroupMembersFilter &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_SupergroupMembersFilterRecent: return (struct TdSupergroupMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterRecent &>(from));
    case CODE_SupergroupMembersFilterAdministrators: return (struct TdSupergroupMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterAdministrators &>(from));
    case CODE_SupergroupMembersFilterSearch: return (struct TdSupergroupMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterSearch &>(from));
    case CODE_SupergroupMembersFilterRestricted: return (struct TdSupergroupMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterRestricted &>(from));
    case CODE_SupergroupMembersFilterBanned: return (struct TdSupergroupMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterBanned &>(from));
    case CODE_SupergroupMembersFilterBots: return (struct TdSupergroupMembersFilter *)TdConvertFromInternal(static_cast<const td::td_api::supergroupMembersFilterBots &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeSupergroupMembersFilter (struct TdSupergroupMembersFilter *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroupMembersFilter *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroupMembersFilter (struct TdSupergroupMembersFilter *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroupMembersFilter *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SupergroupMembersFilterRecent: return TdDestroyObject ((struct TdSupergroupMembersFilterRecent *)var);
    case CODE_SupergroupMembersFilterAdministrators: return TdDestroyObject ((struct TdSupergroupMembersFilterAdministrators *)var);
    case CODE_SupergroupMembersFilterSearch: return TdDestroyObject ((struct TdSupergroupMembersFilterSearch *)var);
    case CODE_SupergroupMembersFilterRestricted: return TdDestroyObject ((struct TdSupergroupMembersFilterRestricted *)var);
    case CODE_SupergroupMembersFilterBanned: return TdDestroyObject ((struct TdSupergroupMembersFilterBanned *)var);
    case CODE_SupergroupMembersFilterBots: return TdDestroyObject ((struct TdSupergroupMembersFilterBots *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerSupergroupMembersFilter (struct TdSupergroupMembersFilter *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroupMembersFilter *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_SupergroupMembersFilterRecent: return TdStackStorer ((struct TdSupergroupMembersFilterRecent *)var, M);
    case CODE_SupergroupMembersFilterAdministrators: return TdStackStorer ((struct TdSupergroupMembersFilterAdministrators *)var, M);
    case CODE_SupergroupMembersFilterSearch: return TdStackStorer ((struct TdSupergroupMembersFilterSearch *)var, M);
    case CODE_SupergroupMembersFilterRestricted: return TdStackStorer ((struct TdSupergroupMembersFilterRestricted *)var, M);
    case CODE_SupergroupMembersFilterBanned: return TdStackStorer ((struct TdSupergroupMembersFilterBanned *)var, M);
    case CODE_SupergroupMembersFilterBots: return TdStackStorer ((struct TdSupergroupMembersFilterBots *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdSupergroupMembersFilter *TdStackFetcherSupergroupMembersFilter (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "SupergroupMembersFilterRecent") {
    return (struct TdSupergroupMembersFilter *)TdStackFetcherSupergroupMembersFilterRecent (M);
  }
  if (constructor == "SupergroupMembersFilterAdministrators") {
    return (struct TdSupergroupMembersFilter *)TdStackFetcherSupergroupMembersFilterAdministrators (M);
  }
  if (constructor == "SupergroupMembersFilterSearch") {
    return (struct TdSupergroupMembersFilter *)TdStackFetcherSupergroupMembersFilterSearch (M);
  }
  if (constructor == "SupergroupMembersFilterRestricted") {
    return (struct TdSupergroupMembersFilter *)TdStackFetcherSupergroupMembersFilterRestricted (M);
  }
  if (constructor == "SupergroupMembersFilterBanned") {
    return (struct TdSupergroupMembersFilter *)TdStackFetcherSupergroupMembersFilterBanned (M);
  }
  if (constructor == "SupergroupMembersFilterBots") {
    return (struct TdSupergroupMembersFilter *)TdStackFetcherSupergroupMembersFilterBots (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdSupergroupMembersFilterRecent *TdCreateObjectSupergroupMembersFilterRecent (void) {
  auto var = new struct TdSupergroupMembersFilterRecent ();
  var->ID = CODE_SupergroupMembersFilterRecent;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::supergroupMembersFilterRecent> TdConvertToInternal (struct TdSupergroupMembersFilterRecent *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::supergroupMembersFilterRecent>();
}
struct TdSupergroupMembersFilterRecent *TdConvertFromInternal (const td::td_api::supergroupMembersFilterRecent &from) {
  auto res = new TdSupergroupMembersFilterRecent ();
  res->ID = CODE_SupergroupMembersFilterRecent;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSupergroupMembersFilterRecent (struct TdSupergroupMembersFilterRecent *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroupMembersFilterRecent *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroupMembersFilterRecent (struct TdSupergroupMembersFilterRecent *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroupMembersFilterRecent *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSupergroupMembersFilterRecent (struct TdSupergroupMembersFilterRecent *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroupMembersFilterRecent *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SupergroupMembersFilterRecent");
  M->new_field ("ID");
}
struct TdSupergroupMembersFilterRecent *TdStackFetcherSupergroupMembersFilterRecent (struct TdStackFetcherMethods *M) {
  auto res = new TdSupergroupMembersFilterRecent ();
  res->ID = CODE_SupergroupMembersFilterRecent;
  res->refcnt = 1;
  return res;
}
struct TdSupergroupMembersFilterAdministrators *TdCreateObjectSupergroupMembersFilterAdministrators (void) {
  auto var = new struct TdSupergroupMembersFilterAdministrators ();
  var->ID = CODE_SupergroupMembersFilterAdministrators;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::supergroupMembersFilterAdministrators> TdConvertToInternal (struct TdSupergroupMembersFilterAdministrators *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::supergroupMembersFilterAdministrators>();
}
struct TdSupergroupMembersFilterAdministrators *TdConvertFromInternal (const td::td_api::supergroupMembersFilterAdministrators &from) {
  auto res = new TdSupergroupMembersFilterAdministrators ();
  res->ID = CODE_SupergroupMembersFilterAdministrators;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSupergroupMembersFilterAdministrators (struct TdSupergroupMembersFilterAdministrators *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroupMembersFilterAdministrators *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroupMembersFilterAdministrators (struct TdSupergroupMembersFilterAdministrators *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroupMembersFilterAdministrators *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSupergroupMembersFilterAdministrators (struct TdSupergroupMembersFilterAdministrators *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroupMembersFilterAdministrators *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SupergroupMembersFilterAdministrators");
  M->new_field ("ID");
}
struct TdSupergroupMembersFilterAdministrators *TdStackFetcherSupergroupMembersFilterAdministrators (struct TdStackFetcherMethods *M) {
  auto res = new TdSupergroupMembersFilterAdministrators ();
  res->ID = CODE_SupergroupMembersFilterAdministrators;
  res->refcnt = 1;
  return res;
}
struct TdSupergroupMembersFilterSearch *TdCreateObjectSupergroupMembersFilterSearch (char *query_) {
  auto var = new struct TdSupergroupMembersFilterSearch ();
  var->ID = CODE_SupergroupMembersFilterSearch;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::supergroupMembersFilterSearch> TdConvertToInternal (struct TdSupergroupMembersFilterSearch *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  return td::td_api::make_object<td::td_api::supergroupMembersFilterSearch>(std::move (v0));
}
struct TdSupergroupMembersFilterSearch *TdConvertFromInternal (const td::td_api::supergroupMembersFilterSearch &from) {
  auto res = new TdSupergroupMembersFilterSearch ();
  res->ID = CODE_SupergroupMembersFilterSearch;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  return res;
}
char *TdSerializeSupergroupMembersFilterSearch (struct TdSupergroupMembersFilterSearch *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroupMembersFilterSearch *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroupMembersFilterSearch (struct TdSupergroupMembersFilterSearch *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroupMembersFilterSearch *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSupergroupMembersFilterSearch (struct TdSupergroupMembersFilterSearch *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroupMembersFilterSearch *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SupergroupMembersFilterSearch");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
}
struct TdSupergroupMembersFilterSearch *TdStackFetcherSupergroupMembersFilterSearch (struct TdStackFetcherMethods *M) {
  auto res = new TdSupergroupMembersFilterSearch ();
  res->ID = CODE_SupergroupMembersFilterSearch;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSupergroupMembersFilterRestricted *TdCreateObjectSupergroupMembersFilterRestricted (char *query_) {
  auto var = new struct TdSupergroupMembersFilterRestricted ();
  var->ID = CODE_SupergroupMembersFilterRestricted;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::supergroupMembersFilterRestricted> TdConvertToInternal (struct TdSupergroupMembersFilterRestricted *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  return td::td_api::make_object<td::td_api::supergroupMembersFilterRestricted>(std::move (v0));
}
struct TdSupergroupMembersFilterRestricted *TdConvertFromInternal (const td::td_api::supergroupMembersFilterRestricted &from) {
  auto res = new TdSupergroupMembersFilterRestricted ();
  res->ID = CODE_SupergroupMembersFilterRestricted;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  return res;
}
char *TdSerializeSupergroupMembersFilterRestricted (struct TdSupergroupMembersFilterRestricted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroupMembersFilterRestricted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroupMembersFilterRestricted (struct TdSupergroupMembersFilterRestricted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroupMembersFilterRestricted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSupergroupMembersFilterRestricted (struct TdSupergroupMembersFilterRestricted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroupMembersFilterRestricted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SupergroupMembersFilterRestricted");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
}
struct TdSupergroupMembersFilterRestricted *TdStackFetcherSupergroupMembersFilterRestricted (struct TdStackFetcherMethods *M) {
  auto res = new TdSupergroupMembersFilterRestricted ();
  res->ID = CODE_SupergroupMembersFilterRestricted;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSupergroupMembersFilterBanned *TdCreateObjectSupergroupMembersFilterBanned (char *query_) {
  auto var = new struct TdSupergroupMembersFilterBanned ();
  var->ID = CODE_SupergroupMembersFilterBanned;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::supergroupMembersFilterBanned> TdConvertToInternal (struct TdSupergroupMembersFilterBanned *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  return td::td_api::make_object<td::td_api::supergroupMembersFilterBanned>(std::move (v0));
}
struct TdSupergroupMembersFilterBanned *TdConvertFromInternal (const td::td_api::supergroupMembersFilterBanned &from) {
  auto res = new TdSupergroupMembersFilterBanned ();
  res->ID = CODE_SupergroupMembersFilterBanned;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  return res;
}
char *TdSerializeSupergroupMembersFilterBanned (struct TdSupergroupMembersFilterBanned *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroupMembersFilterBanned *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroupMembersFilterBanned (struct TdSupergroupMembersFilterBanned *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroupMembersFilterBanned *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSupergroupMembersFilterBanned (struct TdSupergroupMembersFilterBanned *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroupMembersFilterBanned *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SupergroupMembersFilterBanned");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
}
struct TdSupergroupMembersFilterBanned *TdStackFetcherSupergroupMembersFilterBanned (struct TdStackFetcherMethods *M) {
  auto res = new TdSupergroupMembersFilterBanned ();
  res->ID = CODE_SupergroupMembersFilterBanned;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSupergroupMembersFilterBots *TdCreateObjectSupergroupMembersFilterBots (void) {
  auto var = new struct TdSupergroupMembersFilterBots ();
  var->ID = CODE_SupergroupMembersFilterBots;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::supergroupMembersFilterBots> TdConvertToInternal (struct TdSupergroupMembersFilterBots *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::supergroupMembersFilterBots>();
}
struct TdSupergroupMembersFilterBots *TdConvertFromInternal (const td::td_api::supergroupMembersFilterBots &from) {
  auto res = new TdSupergroupMembersFilterBots ();
  res->ID = CODE_SupergroupMembersFilterBots;
  res->refcnt = 1;
  return res;
}
char *TdSerializeSupergroupMembersFilterBots (struct TdSupergroupMembersFilterBots *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSupergroupMembersFilterBots *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSupergroupMembersFilterBots (struct TdSupergroupMembersFilterBots *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSupergroupMembersFilterBots *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSupergroupMembersFilterBots (struct TdSupergroupMembersFilterBots *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSupergroupMembersFilterBots *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SupergroupMembersFilterBots");
  M->new_field ("ID");
}
struct TdSupergroupMembersFilterBots *TdStackFetcherSupergroupMembersFilterBots (struct TdStackFetcherMethods *M) {
  auto res = new TdSupergroupMembersFilterBots ();
  res->ID = CODE_SupergroupMembersFilterBots;
  res->refcnt = 1;
  return res;
}
struct TdTMeUrl *TdCreateObjectTMeUrl (char *url_, struct TdTMeUrlType *type_) {
  auto var = new struct TdTMeUrl ();
  var->ID = CODE_TMeUrl;
  var->refcnt = 1;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::tMeUrl> TdConvertToInternal (struct TdTMeUrl *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->url_) ? var->url_: "";
  td::td_api::object_ptr<td::td_api::TMeUrlType> v100;
  v100 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::tMeUrl>(std::move (v0), std::move (v100));
}
struct TdTMeUrl *TdConvertFromInternal (const td::td_api::tMeUrl &from) {
  auto res = new TdTMeUrl ();
  res->ID = CODE_TMeUrl;
  res->refcnt = 1;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::TMeUrlType &>(*from.type_));
  }
  return res;
}
char *TdSerializeTMeUrl (struct TdTMeUrl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTMeUrl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTMeUrl (struct TdTMeUrl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTMeUrl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->url_);
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerTMeUrl (struct TdTMeUrl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTMeUrl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TMeUrl");
  M->new_field ("ID");
  M->pack_string (var->url_);
  M->new_field ("url_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdTMeUrl *TdStackFetcherTMeUrl (struct TdStackFetcherMethods *M) {
  auto res = new TdTMeUrl ();
  res->ID = CODE_TMeUrl;
  res->refcnt = 1;
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherTMeUrlType (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::TMeUrlType> TdConvertToInternal (struct TdTMeUrlType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TMeUrlTypeUser: return TdConvertToInternal ((struct TdTMeUrlTypeUser *)var);
    case CODE_TMeUrlTypeSupergroup: return TdConvertToInternal ((struct TdTMeUrlTypeSupergroup *)var);
    case CODE_TMeUrlTypeChatInvite: return TdConvertToInternal ((struct TdTMeUrlTypeChatInvite *)var);
    case CODE_TMeUrlTypeStickerSet: return TdConvertToInternal ((struct TdTMeUrlTypeStickerSet *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdTMeUrlType *TdConvertFromInternal (const td::td_api::TMeUrlType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_TMeUrlTypeUser: return (struct TdTMeUrlType *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrlTypeUser &>(from));
    case CODE_TMeUrlTypeSupergroup: return (struct TdTMeUrlType *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrlTypeSupergroup &>(from));
    case CODE_TMeUrlTypeChatInvite: return (struct TdTMeUrlType *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrlTypeChatInvite &>(from));
    case CODE_TMeUrlTypeStickerSet: return (struct TdTMeUrlType *)TdConvertFromInternal(static_cast<const td::td_api::tMeUrlTypeStickerSet &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeTMeUrlType (struct TdTMeUrlType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTMeUrlType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTMeUrlType (struct TdTMeUrlType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTMeUrlType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TMeUrlTypeUser: return TdDestroyObject ((struct TdTMeUrlTypeUser *)var);
    case CODE_TMeUrlTypeSupergroup: return TdDestroyObject ((struct TdTMeUrlTypeSupergroup *)var);
    case CODE_TMeUrlTypeChatInvite: return TdDestroyObject ((struct TdTMeUrlTypeChatInvite *)var);
    case CODE_TMeUrlTypeStickerSet: return TdDestroyObject ((struct TdTMeUrlTypeStickerSet *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerTMeUrlType (struct TdTMeUrlType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTMeUrlType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TMeUrlTypeUser: return TdStackStorer ((struct TdTMeUrlTypeUser *)var, M);
    case CODE_TMeUrlTypeSupergroup: return TdStackStorer ((struct TdTMeUrlTypeSupergroup *)var, M);
    case CODE_TMeUrlTypeChatInvite: return TdStackStorer ((struct TdTMeUrlTypeChatInvite *)var, M);
    case CODE_TMeUrlTypeStickerSet: return TdStackStorer ((struct TdTMeUrlTypeStickerSet *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdTMeUrlType *TdStackFetcherTMeUrlType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "TMeUrlTypeUser") {
    return (struct TdTMeUrlType *)TdStackFetcherTMeUrlTypeUser (M);
  }
  if (constructor == "TMeUrlTypeSupergroup") {
    return (struct TdTMeUrlType *)TdStackFetcherTMeUrlTypeSupergroup (M);
  }
  if (constructor == "TMeUrlTypeChatInvite") {
    return (struct TdTMeUrlType *)TdStackFetcherTMeUrlTypeChatInvite (M);
  }
  if (constructor == "TMeUrlTypeStickerSet") {
    return (struct TdTMeUrlType *)TdStackFetcherTMeUrlTypeStickerSet (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdTMeUrlTypeUser *TdCreateObjectTMeUrlTypeUser (int user_id_) {
  auto var = new struct TdTMeUrlTypeUser ();
  var->ID = CODE_TMeUrlTypeUser;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::tMeUrlTypeUser> TdConvertToInternal (struct TdTMeUrlTypeUser *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::tMeUrlTypeUser>(std::move (v0));
}
struct TdTMeUrlTypeUser *TdConvertFromInternal (const td::td_api::tMeUrlTypeUser &from) {
  auto res = new TdTMeUrlTypeUser ();
  res->ID = CODE_TMeUrlTypeUser;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeTMeUrlTypeUser (struct TdTMeUrlTypeUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTMeUrlTypeUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTMeUrlTypeUser (struct TdTMeUrlTypeUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTMeUrlTypeUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTMeUrlTypeUser (struct TdTMeUrlTypeUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTMeUrlTypeUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TMeUrlTypeUser");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdTMeUrlTypeUser *TdStackFetcherTMeUrlTypeUser (struct TdStackFetcherMethods *M) {
  auto res = new TdTMeUrlTypeUser ();
  res->ID = CODE_TMeUrlTypeUser;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdTMeUrlTypeSupergroup *TdCreateObjectTMeUrlTypeSupergroup (long long supergroup_id_) {
  auto var = new struct TdTMeUrlTypeSupergroup ();
  var->ID = CODE_TMeUrlTypeSupergroup;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::tMeUrlTypeSupergroup> TdConvertToInternal (struct TdTMeUrlTypeSupergroup *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->supergroup_id_;
  return td::td_api::make_object<td::td_api::tMeUrlTypeSupergroup>(std::move (v0));
}
struct TdTMeUrlTypeSupergroup *TdConvertFromInternal (const td::td_api::tMeUrlTypeSupergroup &from) {
  auto res = new TdTMeUrlTypeSupergroup ();
  res->ID = CODE_TMeUrlTypeSupergroup;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  return res;
}
char *TdSerializeTMeUrlTypeSupergroup (struct TdTMeUrlTypeSupergroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTMeUrlTypeSupergroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTMeUrlTypeSupergroup (struct TdTMeUrlTypeSupergroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTMeUrlTypeSupergroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTMeUrlTypeSupergroup (struct TdTMeUrlTypeSupergroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTMeUrlTypeSupergroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TMeUrlTypeSupergroup");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
}
struct TdTMeUrlTypeSupergroup *TdStackFetcherTMeUrlTypeSupergroup (struct TdStackFetcherMethods *M) {
  auto res = new TdTMeUrlTypeSupergroup ();
  res->ID = CODE_TMeUrlTypeSupergroup;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdTMeUrlTypeChatInvite *TdCreateObjectTMeUrlTypeChatInvite (struct TdChatInviteLinkInfo *info_) {
  auto var = new struct TdTMeUrlTypeChatInvite ();
  var->ID = CODE_TMeUrlTypeChatInvite;
  var->refcnt = 1;
  var->info_ = info_;
  return var;
}
td::td_api::object_ptr<td::td_api::tMeUrlTypeChatInvite> TdConvertToInternal (struct TdTMeUrlTypeChatInvite *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::chatInviteLinkInfo> v0;
  v0 = TdConvertToInternal (var->info_);
  return td::td_api::make_object<td::td_api::tMeUrlTypeChatInvite>(std::move (v0));
}
struct TdTMeUrlTypeChatInvite *TdConvertFromInternal (const td::td_api::tMeUrlTypeChatInvite &from) {
  auto res = new TdTMeUrlTypeChatInvite ();
  res->ID = CODE_TMeUrlTypeChatInvite;
  res->refcnt = 1;
  if (!from.info_) {
    res->info_ = nullptr;
  } else {
    res->info_ = TdConvertFromInternal (static_cast<const td::td_api::chatInviteLinkInfo &>(*from.info_));
  }
  return res;
}
char *TdSerializeTMeUrlTypeChatInvite (struct TdTMeUrlTypeChatInvite *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTMeUrlTypeChatInvite *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTMeUrlTypeChatInvite (struct TdTMeUrlTypeChatInvite *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTMeUrlTypeChatInvite *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->info_);
  delete var;
}
void TdStackStorerTMeUrlTypeChatInvite (struct TdTMeUrlTypeChatInvite *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTMeUrlTypeChatInvite *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TMeUrlTypeChatInvite");
  M->new_field ("ID");
  TdStackStorer (var->info_, M);
  M->new_field ("info_");
}
struct TdTMeUrlTypeChatInvite *TdStackFetcherTMeUrlTypeChatInvite (struct TdStackFetcherMethods *M) {
  auto res = new TdTMeUrlTypeChatInvite ();
  res->ID = CODE_TMeUrlTypeChatInvite;
  res->refcnt = 1;
  M->get_field ("info_");
  if (M->is_nil ()) {
    res->info_ = nullptr;
  } else {
    res->info_ = TdStackFetcherChatInviteLinkInfo (M);
  }
  M->pop ();
  return res;
}
struct TdTMeUrlTypeStickerSet *TdCreateObjectTMeUrlTypeStickerSet (long long sticker_set_id_) {
  auto var = new struct TdTMeUrlTypeStickerSet ();
  var->ID = CODE_TMeUrlTypeStickerSet;
  var->refcnt = 1;
  var->sticker_set_id_ = sticker_set_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::tMeUrlTypeStickerSet> TdConvertToInternal (struct TdTMeUrlTypeStickerSet *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->sticker_set_id_;
  return td::td_api::make_object<td::td_api::tMeUrlTypeStickerSet>(std::move (v0));
}
struct TdTMeUrlTypeStickerSet *TdConvertFromInternal (const td::td_api::tMeUrlTypeStickerSet &from) {
  auto res = new TdTMeUrlTypeStickerSet ();
  res->ID = CODE_TMeUrlTypeStickerSet;
  res->refcnt = 1;
  res->sticker_set_id_ = from.sticker_set_id_;
  return res;
}
char *TdSerializeTMeUrlTypeStickerSet (struct TdTMeUrlTypeStickerSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTMeUrlTypeStickerSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTMeUrlTypeStickerSet (struct TdTMeUrlTypeStickerSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTMeUrlTypeStickerSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTMeUrlTypeStickerSet (struct TdTMeUrlTypeStickerSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTMeUrlTypeStickerSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TMeUrlTypeStickerSet");
  M->new_field ("ID");
  M->pack_long (var->sticker_set_id_);
  M->new_field ("sticker_set_id_");
}
struct TdTMeUrlTypeStickerSet *TdStackFetcherTMeUrlTypeStickerSet (struct TdStackFetcherMethods *M) {
  auto res = new TdTMeUrlTypeStickerSet ();
  res->ID = CODE_TMeUrlTypeStickerSet;
  res->refcnt = 1;
  M->get_field ("sticker_set_id_");
  res->sticker_set_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdTMeUrls *TdCreateObjectTMeUrls (struct TdVectorTMeUrl *urls_) {
  auto var = new struct TdTMeUrls ();
  var->ID = CODE_TMeUrls;
  var->refcnt = 1;
  var->urls_ = urls_;
  return var;
}
td::td_api::object_ptr<td::td_api::tMeUrls> TdConvertToInternal (struct TdTMeUrls *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::tMeUrl>> v0;
  for (int i0 = 0; i0 < var->urls_->len; i0++) {
    td::td_api::object_ptr<td::td_api::tMeUrl> v1;
    v1 = TdConvertToInternal (var->urls_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::tMeUrls>(std::move (v0));
}
struct TdTMeUrls *TdConvertFromInternal (const td::td_api::tMeUrls &from) {
  auto res = new TdTMeUrls ();
  res->ID = CODE_TMeUrls;
  res->refcnt = 1;
  res->urls_ = new TdVectorTMeUrl ();
  res->urls_->len = (int)from.urls_.size ();
  res->urls_->data = new struct TdTMeUrl * [res->urls_->len];
  for (int i0 = 0; i0 < res->urls_->len; i0++) {
    if (!from.urls_[i0]) {
      res->urls_->data[i0] = nullptr;
    } else {
      res->urls_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::tMeUrl &>(*from.urls_[i0]));
    }
  }
  return res;
}
char *TdSerializeTMeUrls (struct TdTMeUrls *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTMeUrls *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTMeUrls (struct TdTMeUrls *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTMeUrls *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->urls_->len; i0++) {
    TdDestroyObject (var->urls_->data[i0]);
  }
  delete[] var->urls_->data;
  delete var->urls_;
  delete var;
}
void TdStackStorerTMeUrls (struct TdTMeUrls *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTMeUrls *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TMeUrls");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->urls_->len; i0++) {
    TdStackStorer (var->urls_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("urls_");
}
struct TdTMeUrls *TdStackFetcherTMeUrls (struct TdStackFetcherMethods *M) {
  auto res = new TdTMeUrls ();
  res->ID = CODE_TMeUrls;
  res->refcnt = 1;
  M->get_field ("urls_");
  res->urls_ = new TdVectorTMeUrl ();
  res->urls_->len = M->get_arr_size ();
  res->urls_->data = new struct TdTMeUrl * [res->urls_->len];
  for (int i0 = 0; i0 < res->urls_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->urls_->data[i0] = nullptr;
    } else {
      res->urls_->data[i0] = TdStackFetcherTMeUrl (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTdlibParameters *TdCreateObjectTdlibParameters (int use_test_dc_, char *database_directory_, char *files_directory_, int use_file_database_, int use_chat_info_database_, int use_message_database_, int use_secret_chats_, int api_id_, char *api_hash_, char *system_language_code_, char *device_model_, char *system_version_, char *application_version_, int enable_storage_optimizer_, int ignore_file_names_) {
  auto var = new struct TdTdlibParameters ();
  var->ID = CODE_TdlibParameters;
  var->refcnt = 1;
  var->use_test_dc_ = use_test_dc_;
  var->database_directory_ = (database_directory_) ? td::str_dup (td::Slice (database_directory_)) : nullptr;
  var->files_directory_ = (files_directory_) ? td::str_dup (td::Slice (files_directory_)) : nullptr;
  var->use_file_database_ = use_file_database_;
  var->use_chat_info_database_ = use_chat_info_database_;
  var->use_message_database_ = use_message_database_;
  var->use_secret_chats_ = use_secret_chats_;
  var->api_id_ = api_id_;
  var->api_hash_ = (api_hash_) ? td::str_dup (td::Slice (api_hash_)) : nullptr;
  var->system_language_code_ = (system_language_code_) ? td::str_dup (td::Slice (system_language_code_)) : nullptr;
  var->device_model_ = (device_model_) ? td::str_dup (td::Slice (device_model_)) : nullptr;
  var->system_version_ = (system_version_) ? td::str_dup (td::Slice (system_version_)) : nullptr;
  var->application_version_ = (application_version_) ? td::str_dup (td::Slice (application_version_)) : nullptr;
  var->enable_storage_optimizer_ = enable_storage_optimizer_;
  var->ignore_file_names_ = ignore_file_names_;
  return var;
}
td::td_api::object_ptr<td::td_api::tdlibParameters> TdConvertToInternal (struct TdTdlibParameters *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->use_test_dc_ != 0;
  std::string v100;
  v100 = (var->database_directory_) ? var->database_directory_: "";
  std::string v200;
  v200 = (var->files_directory_) ? var->files_directory_: "";
  bool v300;
  v300 = var->use_file_database_ != 0;
  bool v400;
  v400 = var->use_chat_info_database_ != 0;
  bool v500;
  v500 = var->use_message_database_ != 0;
  bool v600;
  v600 = var->use_secret_chats_ != 0;
  std::int32_t v700;
  v700 = var->api_id_;
  std::string v800;
  v800 = (var->api_hash_) ? var->api_hash_: "";
  std::string v900;
  v900 = (var->system_language_code_) ? var->system_language_code_: "";
  std::string v1000;
  v1000 = (var->device_model_) ? var->device_model_: "";
  std::string v1100;
  v1100 = (var->system_version_) ? var->system_version_: "";
  std::string v1200;
  v1200 = (var->application_version_) ? var->application_version_: "";
  bool v1300;
  v1300 = var->enable_storage_optimizer_ != 0;
  bool v1400;
  v1400 = var->ignore_file_names_ != 0;
  return td::td_api::make_object<td::td_api::tdlibParameters>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000), std::move (v1100), std::move (v1200), std::move (v1300), std::move (v1400));
}
struct TdTdlibParameters *TdConvertFromInternal (const td::td_api::tdlibParameters &from) {
  auto res = new TdTdlibParameters ();
  res->ID = CODE_TdlibParameters;
  res->refcnt = 1;
  res->use_test_dc_ = from.use_test_dc_;
  res->database_directory_ = (from.database_directory_.length ()) ? td::str_dup (from.database_directory_) : nullptr;
  res->files_directory_ = (from.files_directory_.length ()) ? td::str_dup (from.files_directory_) : nullptr;
  res->use_file_database_ = from.use_file_database_;
  res->use_chat_info_database_ = from.use_chat_info_database_;
  res->use_message_database_ = from.use_message_database_;
  res->use_secret_chats_ = from.use_secret_chats_;
  res->api_id_ = from.api_id_;
  res->api_hash_ = (from.api_hash_.length ()) ? td::str_dup (from.api_hash_) : nullptr;
  res->system_language_code_ = (from.system_language_code_.length ()) ? td::str_dup (from.system_language_code_) : nullptr;
  res->device_model_ = (from.device_model_.length ()) ? td::str_dup (from.device_model_) : nullptr;
  res->system_version_ = (from.system_version_.length ()) ? td::str_dup (from.system_version_) : nullptr;
  res->application_version_ = (from.application_version_.length ()) ? td::str_dup (from.application_version_) : nullptr;
  res->enable_storage_optimizer_ = from.enable_storage_optimizer_;
  res->ignore_file_names_ = from.ignore_file_names_;
  return res;
}
char *TdSerializeTdlibParameters (struct TdTdlibParameters *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTdlibParameters *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTdlibParameters (struct TdTdlibParameters *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTdlibParameters *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->database_directory_);
  free (var->files_directory_);
  free (var->api_hash_);
  free (var->system_language_code_);
  free (var->device_model_);
  free (var->system_version_);
  free (var->application_version_);
  delete var;
}
void TdStackStorerTdlibParameters (struct TdTdlibParameters *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTdlibParameters *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TdlibParameters");
  M->new_field ("ID");
  M->pack_bool (var->use_test_dc_);
  M->new_field ("use_test_dc_");
  M->pack_string (var->database_directory_);
  M->new_field ("database_directory_");
  M->pack_string (var->files_directory_);
  M->new_field ("files_directory_");
  M->pack_bool (var->use_file_database_);
  M->new_field ("use_file_database_");
  M->pack_bool (var->use_chat_info_database_);
  M->new_field ("use_chat_info_database_");
  M->pack_bool (var->use_message_database_);
  M->new_field ("use_message_database_");
  M->pack_bool (var->use_secret_chats_);
  M->new_field ("use_secret_chats_");
  M->pack_long (var->api_id_);
  M->new_field ("api_id_");
  M->pack_string (var->api_hash_);
  M->new_field ("api_hash_");
  M->pack_string (var->system_language_code_);
  M->new_field ("system_language_code_");
  M->pack_string (var->device_model_);
  M->new_field ("device_model_");
  M->pack_string (var->system_version_);
  M->new_field ("system_version_");
  M->pack_string (var->application_version_);
  M->new_field ("application_version_");
  M->pack_bool (var->enable_storage_optimizer_);
  M->new_field ("enable_storage_optimizer_");
  M->pack_bool (var->ignore_file_names_);
  M->new_field ("ignore_file_names_");
}
struct TdTdlibParameters *TdStackFetcherTdlibParameters (struct TdStackFetcherMethods *M) {
  auto res = new TdTdlibParameters ();
  res->ID = CODE_TdlibParameters;
  res->refcnt = 1;
  M->get_field ("use_test_dc_");
  res->use_test_dc_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("database_directory_");
  res->database_directory_ = M->get_string ();
  M->pop ();
  M->get_field ("files_directory_");
  res->files_directory_ = M->get_string ();
  M->pop ();
  M->get_field ("use_file_database_");
  res->use_file_database_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("use_chat_info_database_");
  res->use_chat_info_database_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("use_message_database_");
  res->use_message_database_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("use_secret_chats_");
  res->use_secret_chats_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("api_id_");
  res->api_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("api_hash_");
  res->api_hash_ = M->get_string ();
  M->pop ();
  M->get_field ("system_language_code_");
  res->system_language_code_ = M->get_string ();
  M->pop ();
  M->get_field ("device_model_");
  res->device_model_ = M->get_string ();
  M->pop ();
  M->get_field ("system_version_");
  res->system_version_ = M->get_string ();
  M->pop ();
  M->get_field ("application_version_");
  res->application_version_ = M->get_string ();
  M->pop ();
  M->get_field ("enable_storage_optimizer_");
  res->enable_storage_optimizer_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("ignore_file_names_");
  res->ignore_file_names_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdTemporaryPasswordState *TdCreateObjectTemporaryPasswordState (int has_password_, int valid_for_) {
  auto var = new struct TdTemporaryPasswordState ();
  var->ID = CODE_TemporaryPasswordState;
  var->refcnt = 1;
  var->has_password_ = has_password_;
  var->valid_for_ = valid_for_;
  return var;
}
td::td_api::object_ptr<td::td_api::temporaryPasswordState> TdConvertToInternal (struct TdTemporaryPasswordState *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->has_password_ != 0;
  std::int32_t v100;
  v100 = var->valid_for_;
  return td::td_api::make_object<td::td_api::temporaryPasswordState>(std::move (v0), std::move (v100));
}
struct TdTemporaryPasswordState *TdConvertFromInternal (const td::td_api::temporaryPasswordState &from) {
  auto res = new TdTemporaryPasswordState ();
  res->ID = CODE_TemporaryPasswordState;
  res->refcnt = 1;
  res->has_password_ = from.has_password_;
  res->valid_for_ = from.valid_for_;
  return res;
}
char *TdSerializeTemporaryPasswordState (struct TdTemporaryPasswordState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTemporaryPasswordState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTemporaryPasswordState (struct TdTemporaryPasswordState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTemporaryPasswordState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTemporaryPasswordState (struct TdTemporaryPasswordState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTemporaryPasswordState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TemporaryPasswordState");
  M->new_field ("ID");
  M->pack_bool (var->has_password_);
  M->new_field ("has_password_");
  M->pack_long (var->valid_for_);
  M->new_field ("valid_for_");
}
struct TdTemporaryPasswordState *TdStackFetcherTemporaryPasswordState (struct TdStackFetcherMethods *M) {
  auto res = new TdTemporaryPasswordState ();
  res->ID = CODE_TemporaryPasswordState;
  res->refcnt = 1;
  M->get_field ("has_password_");
  res->has_password_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("valid_for_");
  res->valid_for_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdTermsOfService *TdCreateObjectTermsOfService (struct TdFormattedText *text_, int min_user_age_, int show_popup_) {
  auto var = new struct TdTermsOfService ();
  var->ID = CODE_TermsOfService;
  var->refcnt = 1;
  var->text_ = text_;
  var->min_user_age_ = min_user_age_;
  var->show_popup_ = show_popup_;
  return var;
}
td::td_api::object_ptr<td::td_api::termsOfService> TdConvertToInternal (struct TdTermsOfService *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::formattedText> v0;
  v0 = TdConvertToInternal (var->text_);
  std::int32_t v100;
  v100 = var->min_user_age_;
  bool v200;
  v200 = var->show_popup_ != 0;
  return td::td_api::make_object<td::td_api::termsOfService>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdTermsOfService *TdConvertFromInternal (const td::td_api::termsOfService &from) {
  auto res = new TdTermsOfService ();
  res->ID = CODE_TermsOfService;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.text_));
  }
  res->min_user_age_ = from.min_user_age_;
  res->show_popup_ = from.show_popup_;
  return res;
}
char *TdSerializeTermsOfService (struct TdTermsOfService *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTermsOfService *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTermsOfService (struct TdTermsOfService *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTermsOfService *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerTermsOfService (struct TdTermsOfService *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTermsOfService *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TermsOfService");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
  M->pack_long (var->min_user_age_);
  M->new_field ("min_user_age_");
  M->pack_bool (var->show_popup_);
  M->new_field ("show_popup_");
}
struct TdTermsOfService *TdStackFetcherTermsOfService (struct TdStackFetcherMethods *M) {
  auto res = new TdTermsOfService ();
  res->ID = CODE_TermsOfService;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  M->get_field ("min_user_age_");
  res->min_user_age_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("show_popup_");
  res->show_popup_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdTestBytes *TdCreateObjectTestBytes (struct TdBytes value_) {
  auto var = new struct TdTestBytes ();
  var->ID = CODE_TestBytes;
  var->refcnt = 1;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::testBytes> TdConvertToInternal (struct TdTestBytes *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->value_.data, var->value_.len);
  return td::td_api::make_object<td::td_api::testBytes>(std::move (v0));
}
struct TdTestBytes *TdConvertFromInternal (const td::td_api::testBytes &from) {
  auto res = new TdTestBytes ();
  res->ID = CODE_TestBytes;
  res->refcnt = 1;
  res->value_.len = (int)from.value_.length ();
  if (res->value_.len) {
    res->value_.data = new unsigned char[res->value_.len];
    memcpy (res->value_.data, from.value_.c_str (), res->value_.len);
  } else {
    res->value_.data = nullptr;
  }
  return res;
}
char *TdSerializeTestBytes (struct TdTestBytes *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestBytes *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestBytes (struct TdTestBytes *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestBytes *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->value_.data;
  delete var;
}
void TdStackStorerTestBytes (struct TdTestBytes *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestBytes *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestBytes");
  M->new_field ("ID");
  M->pack_bytes (var->value_.data, var->value_.len);
  M->new_field ("value_");
}
struct TdTestBytes *TdStackFetcherTestBytes (struct TdStackFetcherMethods *M) {
  auto res = new TdTestBytes ();
  res->ID = CODE_TestBytes;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_.data = M->get_bytes (&res->value_.len);
  M->pop ();
  return res;
}
struct TdTestInt *TdCreateObjectTestInt (int value_) {
  auto var = new struct TdTestInt ();
  var->ID = CODE_TestInt;
  var->refcnt = 1;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::testInt> TdConvertToInternal (struct TdTestInt *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->value_;
  return td::td_api::make_object<td::td_api::testInt>(std::move (v0));
}
struct TdTestInt *TdConvertFromInternal (const td::td_api::testInt &from) {
  auto res = new TdTestInt ();
  res->ID = CODE_TestInt;
  res->refcnt = 1;
  res->value_ = from.value_;
  return res;
}
char *TdSerializeTestInt (struct TdTestInt *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestInt *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestInt (struct TdTestInt *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestInt *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTestInt (struct TdTestInt *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestInt *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestInt");
  M->new_field ("ID");
  M->pack_long (var->value_);
  M->new_field ("value_");
}
struct TdTestInt *TdStackFetcherTestInt (struct TdStackFetcherMethods *M) {
  auto res = new TdTestInt ();
  res->ID = CODE_TestInt;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdTestString *TdCreateObjectTestString (char *value_) {
  auto var = new struct TdTestString ();
  var->ID = CODE_TestString;
  var->refcnt = 1;
  var->value_ = (value_) ? td::str_dup (td::Slice (value_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::testString> TdConvertToInternal (struct TdTestString *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->value_) ? var->value_: "";
  return td::td_api::make_object<td::td_api::testString>(std::move (v0));
}
struct TdTestString *TdConvertFromInternal (const td::td_api::testString &from) {
  auto res = new TdTestString ();
  res->ID = CODE_TestString;
  res->refcnt = 1;
  res->value_ = (from.value_.length ()) ? td::str_dup (from.value_) : nullptr;
  return res;
}
char *TdSerializeTestString (struct TdTestString *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestString *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestString (struct TdTestString *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestString *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->value_);
  delete var;
}
void TdStackStorerTestString (struct TdTestString *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestString *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestString");
  M->new_field ("ID");
  M->pack_string (var->value_);
  M->new_field ("value_");
}
struct TdTestString *TdStackFetcherTestString (struct TdStackFetcherMethods *M) {
  auto res = new TdTestString ();
  res->ID = CODE_TestString;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdTestVectorInt *TdCreateObjectTestVectorInt (struct TdVectorInt *value_) {
  auto var = new struct TdTestVectorInt ();
  var->ID = CODE_TestVectorInt;
  var->refcnt = 1;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::testVectorInt> TdConvertToInternal (struct TdTestVectorInt *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    std::int32_t v1;
    v1 = var->value_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::testVectorInt>(std::move (v0));
}
struct TdTestVectorInt *TdConvertFromInternal (const td::td_api::testVectorInt &from) {
  auto res = new TdTestVectorInt ();
  res->ID = CODE_TestVectorInt;
  res->refcnt = 1;
  res->value_ = new TdVectorInt ();
  res->value_->len = (int)from.value_.size ();
  res->value_->data = new int  [res->value_->len];
  for (int i0 = 0; i0 < res->value_->len; i0++) {
    res->value_->data[i0] = from.value_[i0];
  }
  return res;
}
char *TdSerializeTestVectorInt (struct TdTestVectorInt *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestVectorInt *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestVectorInt (struct TdTestVectorInt *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestVectorInt *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->value_->len; i0++) {
  }
  delete[] var->value_->data;
  delete var->value_;
  delete var;
}
void TdStackStorerTestVectorInt (struct TdTestVectorInt *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestVectorInt *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestVectorInt");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    M->pack_long (var->value_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("value_");
}
struct TdTestVectorInt *TdStackFetcherTestVectorInt (struct TdStackFetcherMethods *M) {
  auto res = new TdTestVectorInt ();
  res->ID = CODE_TestVectorInt;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = new TdVectorInt ();
  res->value_->len = M->get_arr_size ();
  res->value_->data = new int  [res->value_->len];
  for (int i0 = 0; i0 < res->value_->len; i0++) {
    M->get_arr_field (i0);
    res->value_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTestVectorIntObject *TdCreateObjectTestVectorIntObject (struct TdVectorTestInt *value_) {
  auto var = new struct TdTestVectorIntObject ();
  var->ID = CODE_TestVectorIntObject;
  var->refcnt = 1;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::testVectorIntObject> TdConvertToInternal (struct TdTestVectorIntObject *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::testInt>> v0;
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    td::td_api::object_ptr<td::td_api::testInt> v1;
    v1 = TdConvertToInternal (var->value_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::testVectorIntObject>(std::move (v0));
}
struct TdTestVectorIntObject *TdConvertFromInternal (const td::td_api::testVectorIntObject &from) {
  auto res = new TdTestVectorIntObject ();
  res->ID = CODE_TestVectorIntObject;
  res->refcnt = 1;
  res->value_ = new TdVectorTestInt ();
  res->value_->len = (int)from.value_.size ();
  res->value_->data = new struct TdTestInt * [res->value_->len];
  for (int i0 = 0; i0 < res->value_->len; i0++) {
    if (!from.value_[i0]) {
      res->value_->data[i0] = nullptr;
    } else {
      res->value_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::testInt &>(*from.value_[i0]));
    }
  }
  return res;
}
char *TdSerializeTestVectorIntObject (struct TdTestVectorIntObject *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestVectorIntObject *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestVectorIntObject (struct TdTestVectorIntObject *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestVectorIntObject *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    TdDestroyObject (var->value_->data[i0]);
  }
  delete[] var->value_->data;
  delete var->value_;
  delete var;
}
void TdStackStorerTestVectorIntObject (struct TdTestVectorIntObject *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestVectorIntObject *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestVectorIntObject");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    TdStackStorer (var->value_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("value_");
}
struct TdTestVectorIntObject *TdStackFetcherTestVectorIntObject (struct TdStackFetcherMethods *M) {
  auto res = new TdTestVectorIntObject ();
  res->ID = CODE_TestVectorIntObject;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = new TdVectorTestInt ();
  res->value_->len = M->get_arr_size ();
  res->value_->data = new struct TdTestInt * [res->value_->len];
  for (int i0 = 0; i0 < res->value_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->value_->data[i0] = nullptr;
    } else {
      res->value_->data[i0] = TdStackFetcherTestInt (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTestVectorString *TdCreateObjectTestVectorString (struct TdVectorString *value_) {
  auto var = new struct TdTestVectorString ();
  var->ID = CODE_TestVectorString;
  var->refcnt = 1;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::testVectorString> TdConvertToInternal (struct TdTestVectorString *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::string> v0;
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    std::string v1;
    v1 = (var->value_->data[i0]) ? var->value_->data[i0]: "";
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::testVectorString>(std::move (v0));
}
struct TdTestVectorString *TdConvertFromInternal (const td::td_api::testVectorString &from) {
  auto res = new TdTestVectorString ();
  res->ID = CODE_TestVectorString;
  res->refcnt = 1;
  res->value_ = new TdVectorString ();
  res->value_->len = (int)from.value_.size ();
  res->value_->data = new char * [res->value_->len];
  for (int i0 = 0; i0 < res->value_->len; i0++) {
    res->value_->data[i0] = (from.value_[i0].length ()) ? td::str_dup (from.value_[i0]) : nullptr;
  }
  return res;
}
char *TdSerializeTestVectorString (struct TdTestVectorString *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestVectorString *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestVectorString (struct TdTestVectorString *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestVectorString *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    free (var->value_->data[i0]);
  }
  delete[] var->value_->data;
  delete var->value_;
  delete var;
}
void TdStackStorerTestVectorString (struct TdTestVectorString *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestVectorString *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestVectorString");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    M->pack_string (var->value_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("value_");
}
struct TdTestVectorString *TdStackFetcherTestVectorString (struct TdStackFetcherMethods *M) {
  auto res = new TdTestVectorString ();
  res->ID = CODE_TestVectorString;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = new TdVectorString ();
  res->value_->len = M->get_arr_size ();
  res->value_->data = new char * [res->value_->len];
  for (int i0 = 0; i0 < res->value_->len; i0++) {
    M->get_arr_field (i0);
    res->value_->data[i0] = M->get_string ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTestVectorStringObject *TdCreateObjectTestVectorStringObject (struct TdVectorTestString *value_) {
  auto var = new struct TdTestVectorStringObject ();
  var->ID = CODE_TestVectorStringObject;
  var->refcnt = 1;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::testVectorStringObject> TdConvertToInternal (struct TdTestVectorStringObject *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::testString>> v0;
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    td::td_api::object_ptr<td::td_api::testString> v1;
    v1 = TdConvertToInternal (var->value_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::testVectorStringObject>(std::move (v0));
}
struct TdTestVectorStringObject *TdConvertFromInternal (const td::td_api::testVectorStringObject &from) {
  auto res = new TdTestVectorStringObject ();
  res->ID = CODE_TestVectorStringObject;
  res->refcnt = 1;
  res->value_ = new TdVectorTestString ();
  res->value_->len = (int)from.value_.size ();
  res->value_->data = new struct TdTestString * [res->value_->len];
  for (int i0 = 0; i0 < res->value_->len; i0++) {
    if (!from.value_[i0]) {
      res->value_->data[i0] = nullptr;
    } else {
      res->value_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::testString &>(*from.value_[i0]));
    }
  }
  return res;
}
char *TdSerializeTestVectorStringObject (struct TdTestVectorStringObject *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestVectorStringObject *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestVectorStringObject (struct TdTestVectorStringObject *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestVectorStringObject *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    TdDestroyObject (var->value_->data[i0]);
  }
  delete[] var->value_->data;
  delete var->value_;
  delete var;
}
void TdStackStorerTestVectorStringObject (struct TdTestVectorStringObject *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestVectorStringObject *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestVectorStringObject");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->value_->len; i0++) {
    TdStackStorer (var->value_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("value_");
}
struct TdTestVectorStringObject *TdStackFetcherTestVectorStringObject (struct TdStackFetcherMethods *M) {
  auto res = new TdTestVectorStringObject ();
  res->ID = CODE_TestVectorStringObject;
  res->refcnt = 1;
  M->get_field ("value_");
  res->value_ = new TdVectorTestString ();
  res->value_->len = M->get_arr_size ();
  res->value_->data = new struct TdTestString * [res->value_->len];
  for (int i0 = 0; i0 < res->value_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->value_->data[i0] = nullptr;
    } else {
      res->value_->data[i0] = TdStackFetcherTestString (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdText *TdCreateObjectText (char *text_) {
  auto var = new struct TdText ();
  var->ID = CODE_Text;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::text> TdConvertToInternal (struct TdText *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  return td::td_api::make_object<td::td_api::text>(std::move (v0));
}
struct TdText *TdConvertFromInternal (const td::td_api::text &from) {
  auto res = new TdText ();
  res->ID = CODE_Text;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  return res;
}
char *TdSerializeText (struct TdText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectText (struct TdText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdText *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  delete var;
}
void TdStackStorerText (struct TdText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdText *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Text");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
}
struct TdText *TdStackFetcherText (struct TdStackFetcherMethods *M) {
  auto res = new TdText ();
  res->ID = CODE_Text;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdTextEntities *TdCreateObjectTextEntities (struct TdVectorTextEntity *entities_) {
  auto var = new struct TdTextEntities ();
  var->ID = CODE_TextEntities;
  var->refcnt = 1;
  var->entities_ = entities_;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntities> TdConvertToInternal (struct TdTextEntities *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::textEntity>> v0;
  for (int i0 = 0; i0 < var->entities_->len; i0++) {
    td::td_api::object_ptr<td::td_api::textEntity> v1;
    v1 = TdConvertToInternal (var->entities_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::textEntities>(std::move (v0));
}
struct TdTextEntities *TdConvertFromInternal (const td::td_api::textEntities &from) {
  auto res = new TdTextEntities ();
  res->ID = CODE_TextEntities;
  res->refcnt = 1;
  res->entities_ = new TdVectorTextEntity ();
  res->entities_->len = (int)from.entities_.size ();
  res->entities_->data = new struct TdTextEntity * [res->entities_->len];
  for (int i0 = 0; i0 < res->entities_->len; i0++) {
    if (!from.entities_[i0]) {
      res->entities_->data[i0] = nullptr;
    } else {
      res->entities_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::textEntity &>(*from.entities_[i0]));
    }
  }
  return res;
}
char *TdSerializeTextEntities (struct TdTextEntities *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntities *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntities (struct TdTextEntities *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntities *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->entities_->len; i0++) {
    TdDestroyObject (var->entities_->data[i0]);
  }
  delete[] var->entities_->data;
  delete var->entities_;
  delete var;
}
void TdStackStorerTextEntities (struct TdTextEntities *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntities *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntities");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->entities_->len; i0++) {
    TdStackStorer (var->entities_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("entities_");
}
struct TdTextEntities *TdStackFetcherTextEntities (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntities ();
  res->ID = CODE_TextEntities;
  res->refcnt = 1;
  M->get_field ("entities_");
  res->entities_ = new TdVectorTextEntity ();
  res->entities_->len = M->get_arr_size ();
  res->entities_->data = new struct TdTextEntity * [res->entities_->len];
  for (int i0 = 0; i0 < res->entities_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->entities_->data[i0] = nullptr;
    } else {
      res->entities_->data[i0] = TdStackFetcherTextEntity (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTextEntity *TdCreateObjectTextEntity (int offset_, int length_, struct TdTextEntityType *type_) {
  auto var = new struct TdTextEntity ();
  var->ID = CODE_TextEntity;
  var->refcnt = 1;
  var->offset_ = offset_;
  var->length_ = length_;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntity> TdConvertToInternal (struct TdTextEntity *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->offset_;
  std::int32_t v100;
  v100 = var->length_;
  td::td_api::object_ptr<td::td_api::TextEntityType> v200;
  v200 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::textEntity>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdTextEntity *TdConvertFromInternal (const td::td_api::textEntity &from) {
  auto res = new TdTextEntity ();
  res->ID = CODE_TextEntity;
  res->refcnt = 1;
  res->offset_ = from.offset_;
  res->length_ = from.length_;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::TextEntityType &>(*from.type_));
  }
  return res;
}
char *TdSerializeTextEntity (struct TdTextEntity *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntity *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntity (struct TdTextEntity *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntity *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerTextEntity (struct TdTextEntity *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntity *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntity");
  M->new_field ("ID");
  M->pack_long (var->offset_);
  M->new_field ("offset_");
  M->pack_long (var->length_);
  M->new_field ("length_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdTextEntity *TdStackFetcherTextEntity (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntity ();
  res->ID = CODE_TextEntity;
  res->refcnt = 1;
  M->get_field ("offset_");
  res->offset_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("length_");
  res->length_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherTextEntityType (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::TextEntityType> TdConvertToInternal (struct TdTextEntityType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TextEntityTypeMention: return TdConvertToInternal ((struct TdTextEntityTypeMention *)var);
    case CODE_TextEntityTypeHashtag: return TdConvertToInternal ((struct TdTextEntityTypeHashtag *)var);
    case CODE_TextEntityTypeCashtag: return TdConvertToInternal ((struct TdTextEntityTypeCashtag *)var);
    case CODE_TextEntityTypeBotCommand: return TdConvertToInternal ((struct TdTextEntityTypeBotCommand *)var);
    case CODE_TextEntityTypeUrl: return TdConvertToInternal ((struct TdTextEntityTypeUrl *)var);
    case CODE_TextEntityTypeEmailAddress: return TdConvertToInternal ((struct TdTextEntityTypeEmailAddress *)var);
    case CODE_TextEntityTypeBold: return TdConvertToInternal ((struct TdTextEntityTypeBold *)var);
    case CODE_TextEntityTypeItalic: return TdConvertToInternal ((struct TdTextEntityTypeItalic *)var);
    case CODE_TextEntityTypeCode: return TdConvertToInternal ((struct TdTextEntityTypeCode *)var);
    case CODE_TextEntityTypePre: return TdConvertToInternal ((struct TdTextEntityTypePre *)var);
    case CODE_TextEntityTypePreCode: return TdConvertToInternal ((struct TdTextEntityTypePreCode *)var);
    case CODE_TextEntityTypeTextUrl: return TdConvertToInternal ((struct TdTextEntityTypeTextUrl *)var);
    case CODE_TextEntityTypeMentionName: return TdConvertToInternal ((struct TdTextEntityTypeMentionName *)var);
    case CODE_TextEntityTypePhoneNumber: return TdConvertToInternal ((struct TdTextEntityTypePhoneNumber *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdTextEntityType *TdConvertFromInternal (const td::td_api::TextEntityType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_TextEntityTypeMention: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeMention &>(from));
    case CODE_TextEntityTypeHashtag: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeHashtag &>(from));
    case CODE_TextEntityTypeCashtag: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeCashtag &>(from));
    case CODE_TextEntityTypeBotCommand: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeBotCommand &>(from));
    case CODE_TextEntityTypeUrl: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeUrl &>(from));
    case CODE_TextEntityTypeEmailAddress: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeEmailAddress &>(from));
    case CODE_TextEntityTypeBold: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeBold &>(from));
    case CODE_TextEntityTypeItalic: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeItalic &>(from));
    case CODE_TextEntityTypeCode: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeCode &>(from));
    case CODE_TextEntityTypePre: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypePre &>(from));
    case CODE_TextEntityTypePreCode: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypePreCode &>(from));
    case CODE_TextEntityTypeTextUrl: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeTextUrl &>(from));
    case CODE_TextEntityTypeMentionName: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypeMentionName &>(from));
    case CODE_TextEntityTypePhoneNumber: return (struct TdTextEntityType *)TdConvertFromInternal(static_cast<const td::td_api::textEntityTypePhoneNumber &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeTextEntityType (struct TdTextEntityType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityType (struct TdTextEntityType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TextEntityTypeMention: return TdDestroyObject ((struct TdTextEntityTypeMention *)var);
    case CODE_TextEntityTypeHashtag: return TdDestroyObject ((struct TdTextEntityTypeHashtag *)var);
    case CODE_TextEntityTypeCashtag: return TdDestroyObject ((struct TdTextEntityTypeCashtag *)var);
    case CODE_TextEntityTypeBotCommand: return TdDestroyObject ((struct TdTextEntityTypeBotCommand *)var);
    case CODE_TextEntityTypeUrl: return TdDestroyObject ((struct TdTextEntityTypeUrl *)var);
    case CODE_TextEntityTypeEmailAddress: return TdDestroyObject ((struct TdTextEntityTypeEmailAddress *)var);
    case CODE_TextEntityTypeBold: return TdDestroyObject ((struct TdTextEntityTypeBold *)var);
    case CODE_TextEntityTypeItalic: return TdDestroyObject ((struct TdTextEntityTypeItalic *)var);
    case CODE_TextEntityTypeCode: return TdDestroyObject ((struct TdTextEntityTypeCode *)var);
    case CODE_TextEntityTypePre: return TdDestroyObject ((struct TdTextEntityTypePre *)var);
    case CODE_TextEntityTypePreCode: return TdDestroyObject ((struct TdTextEntityTypePreCode *)var);
    case CODE_TextEntityTypeTextUrl: return TdDestroyObject ((struct TdTextEntityTypeTextUrl *)var);
    case CODE_TextEntityTypeMentionName: return TdDestroyObject ((struct TdTextEntityTypeMentionName *)var);
    case CODE_TextEntityTypePhoneNumber: return TdDestroyObject ((struct TdTextEntityTypePhoneNumber *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerTextEntityType (struct TdTextEntityType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TextEntityTypeMention: return TdStackStorer ((struct TdTextEntityTypeMention *)var, M);
    case CODE_TextEntityTypeHashtag: return TdStackStorer ((struct TdTextEntityTypeHashtag *)var, M);
    case CODE_TextEntityTypeCashtag: return TdStackStorer ((struct TdTextEntityTypeCashtag *)var, M);
    case CODE_TextEntityTypeBotCommand: return TdStackStorer ((struct TdTextEntityTypeBotCommand *)var, M);
    case CODE_TextEntityTypeUrl: return TdStackStorer ((struct TdTextEntityTypeUrl *)var, M);
    case CODE_TextEntityTypeEmailAddress: return TdStackStorer ((struct TdTextEntityTypeEmailAddress *)var, M);
    case CODE_TextEntityTypeBold: return TdStackStorer ((struct TdTextEntityTypeBold *)var, M);
    case CODE_TextEntityTypeItalic: return TdStackStorer ((struct TdTextEntityTypeItalic *)var, M);
    case CODE_TextEntityTypeCode: return TdStackStorer ((struct TdTextEntityTypeCode *)var, M);
    case CODE_TextEntityTypePre: return TdStackStorer ((struct TdTextEntityTypePre *)var, M);
    case CODE_TextEntityTypePreCode: return TdStackStorer ((struct TdTextEntityTypePreCode *)var, M);
    case CODE_TextEntityTypeTextUrl: return TdStackStorer ((struct TdTextEntityTypeTextUrl *)var, M);
    case CODE_TextEntityTypeMentionName: return TdStackStorer ((struct TdTextEntityTypeMentionName *)var, M);
    case CODE_TextEntityTypePhoneNumber: return TdStackStorer ((struct TdTextEntityTypePhoneNumber *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdTextEntityType *TdStackFetcherTextEntityType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "TextEntityTypeMention") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeMention (M);
  }
  if (constructor == "TextEntityTypeHashtag") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeHashtag (M);
  }
  if (constructor == "TextEntityTypeCashtag") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeCashtag (M);
  }
  if (constructor == "TextEntityTypeBotCommand") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeBotCommand (M);
  }
  if (constructor == "TextEntityTypeUrl") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeUrl (M);
  }
  if (constructor == "TextEntityTypeEmailAddress") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeEmailAddress (M);
  }
  if (constructor == "TextEntityTypeBold") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeBold (M);
  }
  if (constructor == "TextEntityTypeItalic") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeItalic (M);
  }
  if (constructor == "TextEntityTypeCode") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeCode (M);
  }
  if (constructor == "TextEntityTypePre") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypePre (M);
  }
  if (constructor == "TextEntityTypePreCode") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypePreCode (M);
  }
  if (constructor == "TextEntityTypeTextUrl") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeTextUrl (M);
  }
  if (constructor == "TextEntityTypeMentionName") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypeMentionName (M);
  }
  if (constructor == "TextEntityTypePhoneNumber") {
    return (struct TdTextEntityType *)TdStackFetcherTextEntityTypePhoneNumber (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdTextEntityTypeMention *TdCreateObjectTextEntityTypeMention (void) {
  auto var = new struct TdTextEntityTypeMention ();
  var->ID = CODE_TextEntityTypeMention;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeMention> TdConvertToInternal (struct TdTextEntityTypeMention *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeMention>();
}
struct TdTextEntityTypeMention *TdConvertFromInternal (const td::td_api::textEntityTypeMention &from) {
  auto res = new TdTextEntityTypeMention ();
  res->ID = CODE_TextEntityTypeMention;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeMention (struct TdTextEntityTypeMention *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeMention *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeMention (struct TdTextEntityTypeMention *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeMention *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeMention (struct TdTextEntityTypeMention *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeMention *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeMention");
  M->new_field ("ID");
}
struct TdTextEntityTypeMention *TdStackFetcherTextEntityTypeMention (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeMention ();
  res->ID = CODE_TextEntityTypeMention;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypeHashtag *TdCreateObjectTextEntityTypeHashtag (void) {
  auto var = new struct TdTextEntityTypeHashtag ();
  var->ID = CODE_TextEntityTypeHashtag;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeHashtag> TdConvertToInternal (struct TdTextEntityTypeHashtag *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeHashtag>();
}
struct TdTextEntityTypeHashtag *TdConvertFromInternal (const td::td_api::textEntityTypeHashtag &from) {
  auto res = new TdTextEntityTypeHashtag ();
  res->ID = CODE_TextEntityTypeHashtag;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeHashtag (struct TdTextEntityTypeHashtag *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeHashtag *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeHashtag (struct TdTextEntityTypeHashtag *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeHashtag *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeHashtag (struct TdTextEntityTypeHashtag *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeHashtag *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeHashtag");
  M->new_field ("ID");
}
struct TdTextEntityTypeHashtag *TdStackFetcherTextEntityTypeHashtag (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeHashtag ();
  res->ID = CODE_TextEntityTypeHashtag;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypeCashtag *TdCreateObjectTextEntityTypeCashtag (void) {
  auto var = new struct TdTextEntityTypeCashtag ();
  var->ID = CODE_TextEntityTypeCashtag;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeCashtag> TdConvertToInternal (struct TdTextEntityTypeCashtag *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeCashtag>();
}
struct TdTextEntityTypeCashtag *TdConvertFromInternal (const td::td_api::textEntityTypeCashtag &from) {
  auto res = new TdTextEntityTypeCashtag ();
  res->ID = CODE_TextEntityTypeCashtag;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeCashtag (struct TdTextEntityTypeCashtag *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeCashtag *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeCashtag (struct TdTextEntityTypeCashtag *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeCashtag *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeCashtag (struct TdTextEntityTypeCashtag *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeCashtag *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeCashtag");
  M->new_field ("ID");
}
struct TdTextEntityTypeCashtag *TdStackFetcherTextEntityTypeCashtag (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeCashtag ();
  res->ID = CODE_TextEntityTypeCashtag;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypeBotCommand *TdCreateObjectTextEntityTypeBotCommand (void) {
  auto var = new struct TdTextEntityTypeBotCommand ();
  var->ID = CODE_TextEntityTypeBotCommand;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeBotCommand> TdConvertToInternal (struct TdTextEntityTypeBotCommand *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeBotCommand>();
}
struct TdTextEntityTypeBotCommand *TdConvertFromInternal (const td::td_api::textEntityTypeBotCommand &from) {
  auto res = new TdTextEntityTypeBotCommand ();
  res->ID = CODE_TextEntityTypeBotCommand;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeBotCommand (struct TdTextEntityTypeBotCommand *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeBotCommand *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeBotCommand (struct TdTextEntityTypeBotCommand *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeBotCommand *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeBotCommand (struct TdTextEntityTypeBotCommand *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeBotCommand *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeBotCommand");
  M->new_field ("ID");
}
struct TdTextEntityTypeBotCommand *TdStackFetcherTextEntityTypeBotCommand (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeBotCommand ();
  res->ID = CODE_TextEntityTypeBotCommand;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypeUrl *TdCreateObjectTextEntityTypeUrl (void) {
  auto var = new struct TdTextEntityTypeUrl ();
  var->ID = CODE_TextEntityTypeUrl;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeUrl> TdConvertToInternal (struct TdTextEntityTypeUrl *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeUrl>();
}
struct TdTextEntityTypeUrl *TdConvertFromInternal (const td::td_api::textEntityTypeUrl &from) {
  auto res = new TdTextEntityTypeUrl ();
  res->ID = CODE_TextEntityTypeUrl;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeUrl (struct TdTextEntityTypeUrl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeUrl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeUrl (struct TdTextEntityTypeUrl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeUrl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeUrl (struct TdTextEntityTypeUrl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeUrl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeUrl");
  M->new_field ("ID");
}
struct TdTextEntityTypeUrl *TdStackFetcherTextEntityTypeUrl (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeUrl ();
  res->ID = CODE_TextEntityTypeUrl;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypeEmailAddress *TdCreateObjectTextEntityTypeEmailAddress (void) {
  auto var = new struct TdTextEntityTypeEmailAddress ();
  var->ID = CODE_TextEntityTypeEmailAddress;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeEmailAddress> TdConvertToInternal (struct TdTextEntityTypeEmailAddress *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeEmailAddress>();
}
struct TdTextEntityTypeEmailAddress *TdConvertFromInternal (const td::td_api::textEntityTypeEmailAddress &from) {
  auto res = new TdTextEntityTypeEmailAddress ();
  res->ID = CODE_TextEntityTypeEmailAddress;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeEmailAddress (struct TdTextEntityTypeEmailAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeEmailAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeEmailAddress (struct TdTextEntityTypeEmailAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeEmailAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeEmailAddress (struct TdTextEntityTypeEmailAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeEmailAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeEmailAddress");
  M->new_field ("ID");
}
struct TdTextEntityTypeEmailAddress *TdStackFetcherTextEntityTypeEmailAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeEmailAddress ();
  res->ID = CODE_TextEntityTypeEmailAddress;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypeBold *TdCreateObjectTextEntityTypeBold (void) {
  auto var = new struct TdTextEntityTypeBold ();
  var->ID = CODE_TextEntityTypeBold;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeBold> TdConvertToInternal (struct TdTextEntityTypeBold *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeBold>();
}
struct TdTextEntityTypeBold *TdConvertFromInternal (const td::td_api::textEntityTypeBold &from) {
  auto res = new TdTextEntityTypeBold ();
  res->ID = CODE_TextEntityTypeBold;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeBold (struct TdTextEntityTypeBold *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeBold *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeBold (struct TdTextEntityTypeBold *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeBold *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeBold (struct TdTextEntityTypeBold *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeBold *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeBold");
  M->new_field ("ID");
}
struct TdTextEntityTypeBold *TdStackFetcherTextEntityTypeBold (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeBold ();
  res->ID = CODE_TextEntityTypeBold;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypeItalic *TdCreateObjectTextEntityTypeItalic (void) {
  auto var = new struct TdTextEntityTypeItalic ();
  var->ID = CODE_TextEntityTypeItalic;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeItalic> TdConvertToInternal (struct TdTextEntityTypeItalic *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeItalic>();
}
struct TdTextEntityTypeItalic *TdConvertFromInternal (const td::td_api::textEntityTypeItalic &from) {
  auto res = new TdTextEntityTypeItalic ();
  res->ID = CODE_TextEntityTypeItalic;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeItalic (struct TdTextEntityTypeItalic *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeItalic *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeItalic (struct TdTextEntityTypeItalic *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeItalic *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeItalic (struct TdTextEntityTypeItalic *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeItalic *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeItalic");
  M->new_field ("ID");
}
struct TdTextEntityTypeItalic *TdStackFetcherTextEntityTypeItalic (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeItalic ();
  res->ID = CODE_TextEntityTypeItalic;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypeCode *TdCreateObjectTextEntityTypeCode (void) {
  auto var = new struct TdTextEntityTypeCode ();
  var->ID = CODE_TextEntityTypeCode;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeCode> TdConvertToInternal (struct TdTextEntityTypeCode *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypeCode>();
}
struct TdTextEntityTypeCode *TdConvertFromInternal (const td::td_api::textEntityTypeCode &from) {
  auto res = new TdTextEntityTypeCode ();
  res->ID = CODE_TextEntityTypeCode;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypeCode (struct TdTextEntityTypeCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeCode (struct TdTextEntityTypeCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeCode (struct TdTextEntityTypeCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeCode");
  M->new_field ("ID");
}
struct TdTextEntityTypeCode *TdStackFetcherTextEntityTypeCode (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeCode ();
  res->ID = CODE_TextEntityTypeCode;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypePre *TdCreateObjectTextEntityTypePre (void) {
  auto var = new struct TdTextEntityTypePre ();
  var->ID = CODE_TextEntityTypePre;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypePre> TdConvertToInternal (struct TdTextEntityTypePre *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypePre>();
}
struct TdTextEntityTypePre *TdConvertFromInternal (const td::td_api::textEntityTypePre &from) {
  auto res = new TdTextEntityTypePre ();
  res->ID = CODE_TextEntityTypePre;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypePre (struct TdTextEntityTypePre *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypePre *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypePre (struct TdTextEntityTypePre *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypePre *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypePre (struct TdTextEntityTypePre *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypePre *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypePre");
  M->new_field ("ID");
}
struct TdTextEntityTypePre *TdStackFetcherTextEntityTypePre (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypePre ();
  res->ID = CODE_TextEntityTypePre;
  res->refcnt = 1;
  return res;
}
struct TdTextEntityTypePreCode *TdCreateObjectTextEntityTypePreCode (char *language_) {
  auto var = new struct TdTextEntityTypePreCode ();
  var->ID = CODE_TextEntityTypePreCode;
  var->refcnt = 1;
  var->language_ = (language_) ? td::str_dup (td::Slice (language_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypePreCode> TdConvertToInternal (struct TdTextEntityTypePreCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->language_) ? var->language_: "";
  return td::td_api::make_object<td::td_api::textEntityTypePreCode>(std::move (v0));
}
struct TdTextEntityTypePreCode *TdConvertFromInternal (const td::td_api::textEntityTypePreCode &from) {
  auto res = new TdTextEntityTypePreCode ();
  res->ID = CODE_TextEntityTypePreCode;
  res->refcnt = 1;
  res->language_ = (from.language_.length ()) ? td::str_dup (from.language_) : nullptr;
  return res;
}
char *TdSerializeTextEntityTypePreCode (struct TdTextEntityTypePreCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypePreCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypePreCode (struct TdTextEntityTypePreCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypePreCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->language_);
  delete var;
}
void TdStackStorerTextEntityTypePreCode (struct TdTextEntityTypePreCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypePreCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypePreCode");
  M->new_field ("ID");
  M->pack_string (var->language_);
  M->new_field ("language_");
}
struct TdTextEntityTypePreCode *TdStackFetcherTextEntityTypePreCode (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypePreCode ();
  res->ID = CODE_TextEntityTypePreCode;
  res->refcnt = 1;
  M->get_field ("language_");
  res->language_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdTextEntityTypeTextUrl *TdCreateObjectTextEntityTypeTextUrl (char *url_) {
  auto var = new struct TdTextEntityTypeTextUrl ();
  var->ID = CODE_TextEntityTypeTextUrl;
  var->refcnt = 1;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeTextUrl> TdConvertToInternal (struct TdTextEntityTypeTextUrl *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->url_) ? var->url_: "";
  return td::td_api::make_object<td::td_api::textEntityTypeTextUrl>(std::move (v0));
}
struct TdTextEntityTypeTextUrl *TdConvertFromInternal (const td::td_api::textEntityTypeTextUrl &from) {
  auto res = new TdTextEntityTypeTextUrl ();
  res->ID = CODE_TextEntityTypeTextUrl;
  res->refcnt = 1;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  return res;
}
char *TdSerializeTextEntityTypeTextUrl (struct TdTextEntityTypeTextUrl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeTextUrl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeTextUrl (struct TdTextEntityTypeTextUrl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeTextUrl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->url_);
  delete var;
}
void TdStackStorerTextEntityTypeTextUrl (struct TdTextEntityTypeTextUrl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeTextUrl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeTextUrl");
  M->new_field ("ID");
  M->pack_string (var->url_);
  M->new_field ("url_");
}
struct TdTextEntityTypeTextUrl *TdStackFetcherTextEntityTypeTextUrl (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeTextUrl ();
  res->ID = CODE_TextEntityTypeTextUrl;
  res->refcnt = 1;
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdTextEntityTypeMentionName *TdCreateObjectTextEntityTypeMentionName (int user_id_) {
  auto var = new struct TdTextEntityTypeMentionName ();
  var->ID = CODE_TextEntityTypeMentionName;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypeMentionName> TdConvertToInternal (struct TdTextEntityTypeMentionName *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::textEntityTypeMentionName>(std::move (v0));
}
struct TdTextEntityTypeMentionName *TdConvertFromInternal (const td::td_api::textEntityTypeMentionName &from) {
  auto res = new TdTextEntityTypeMentionName ();
  res->ID = CODE_TextEntityTypeMentionName;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeTextEntityTypeMentionName (struct TdTextEntityTypeMentionName *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypeMentionName *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypeMentionName (struct TdTextEntityTypeMentionName *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypeMentionName *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypeMentionName (struct TdTextEntityTypeMentionName *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypeMentionName *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypeMentionName");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdTextEntityTypeMentionName *TdStackFetcherTextEntityTypeMentionName (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypeMentionName ();
  res->ID = CODE_TextEntityTypeMentionName;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdTextEntityTypePhoneNumber *TdCreateObjectTextEntityTypePhoneNumber (void) {
  auto var = new struct TdTextEntityTypePhoneNumber ();
  var->ID = CODE_TextEntityTypePhoneNumber;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textEntityTypePhoneNumber> TdConvertToInternal (struct TdTextEntityTypePhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textEntityTypePhoneNumber>();
}
struct TdTextEntityTypePhoneNumber *TdConvertFromInternal (const td::td_api::textEntityTypePhoneNumber &from) {
  auto res = new TdTextEntityTypePhoneNumber ();
  res->ID = CODE_TextEntityTypePhoneNumber;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextEntityTypePhoneNumber (struct TdTextEntityTypePhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextEntityTypePhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextEntityTypePhoneNumber (struct TdTextEntityTypePhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextEntityTypePhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextEntityTypePhoneNumber (struct TdTextEntityTypePhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextEntityTypePhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextEntityTypePhoneNumber");
  M->new_field ("ID");
}
struct TdTextEntityTypePhoneNumber *TdStackFetcherTextEntityTypePhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdTextEntityTypePhoneNumber ();
  res->ID = CODE_TextEntityTypePhoneNumber;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::TextParseMode> TdConvertToInternal (struct TdTextParseMode *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TextParseModeMarkdown: return TdConvertToInternal ((struct TdTextParseModeMarkdown *)var);
    case CODE_TextParseModeHTML: return TdConvertToInternal ((struct TdTextParseModeHTML *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdTextParseMode *TdConvertFromInternal (const td::td_api::TextParseMode &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_TextParseModeMarkdown: return (struct TdTextParseMode *)TdConvertFromInternal(static_cast<const td::td_api::textParseModeMarkdown &>(from));
    case CODE_TextParseModeHTML: return (struct TdTextParseMode *)TdConvertFromInternal(static_cast<const td::td_api::textParseModeHTML &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeTextParseMode (struct TdTextParseMode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextParseMode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextParseMode (struct TdTextParseMode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextParseMode *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TextParseModeMarkdown: return TdDestroyObject ((struct TdTextParseModeMarkdown *)var);
    case CODE_TextParseModeHTML: return TdDestroyObject ((struct TdTextParseModeHTML *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerTextParseMode (struct TdTextParseMode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextParseMode *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TextParseModeMarkdown: return TdStackStorer ((struct TdTextParseModeMarkdown *)var, M);
    case CODE_TextParseModeHTML: return TdStackStorer ((struct TdTextParseModeHTML *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdTextParseMode *TdStackFetcherTextParseMode (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "TextParseModeMarkdown") {
    return (struct TdTextParseMode *)TdStackFetcherTextParseModeMarkdown (M);
  }
  if (constructor == "TextParseModeHTML") {
    return (struct TdTextParseMode *)TdStackFetcherTextParseModeHTML (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdTextParseModeMarkdown *TdCreateObjectTextParseModeMarkdown (void) {
  auto var = new struct TdTextParseModeMarkdown ();
  var->ID = CODE_TextParseModeMarkdown;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textParseModeMarkdown> TdConvertToInternal (struct TdTextParseModeMarkdown *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textParseModeMarkdown>();
}
struct TdTextParseModeMarkdown *TdConvertFromInternal (const td::td_api::textParseModeMarkdown &from) {
  auto res = new TdTextParseModeMarkdown ();
  res->ID = CODE_TextParseModeMarkdown;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextParseModeMarkdown (struct TdTextParseModeMarkdown *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextParseModeMarkdown *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextParseModeMarkdown (struct TdTextParseModeMarkdown *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextParseModeMarkdown *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextParseModeMarkdown (struct TdTextParseModeMarkdown *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextParseModeMarkdown *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextParseModeMarkdown");
  M->new_field ("ID");
}
struct TdTextParseModeMarkdown *TdStackFetcherTextParseModeMarkdown (struct TdStackFetcherMethods *M) {
  auto res = new TdTextParseModeMarkdown ();
  res->ID = CODE_TextParseModeMarkdown;
  res->refcnt = 1;
  return res;
}
struct TdTextParseModeHTML *TdCreateObjectTextParseModeHTML (void) {
  auto var = new struct TdTextParseModeHTML ();
  var->ID = CODE_TextParseModeHTML;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::textParseModeHTML> TdConvertToInternal (struct TdTextParseModeHTML *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::textParseModeHTML>();
}
struct TdTextParseModeHTML *TdConvertFromInternal (const td::td_api::textParseModeHTML &from) {
  auto res = new TdTextParseModeHTML ();
  res->ID = CODE_TextParseModeHTML;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTextParseModeHTML (struct TdTextParseModeHTML *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTextParseModeHTML *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTextParseModeHTML (struct TdTextParseModeHTML *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTextParseModeHTML *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTextParseModeHTML (struct TdTextParseModeHTML *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTextParseModeHTML *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TextParseModeHTML");
  M->new_field ("ID");
}
struct TdTextParseModeHTML *TdStackFetcherTextParseModeHTML (struct TdStackFetcherMethods *M) {
  auto res = new TdTextParseModeHTML ();
  res->ID = CODE_TextParseModeHTML;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::TopChatCategory> TdConvertToInternal (struct TdTopChatCategory *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TopChatCategoryUsers: return TdConvertToInternal ((struct TdTopChatCategoryUsers *)var);
    case CODE_TopChatCategoryBots: return TdConvertToInternal ((struct TdTopChatCategoryBots *)var);
    case CODE_TopChatCategoryGroups: return TdConvertToInternal ((struct TdTopChatCategoryGroups *)var);
    case CODE_TopChatCategoryChannels: return TdConvertToInternal ((struct TdTopChatCategoryChannels *)var);
    case CODE_TopChatCategoryInlineBots: return TdConvertToInternal ((struct TdTopChatCategoryInlineBots *)var);
    case CODE_TopChatCategoryCalls: return TdConvertToInternal ((struct TdTopChatCategoryCalls *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdTopChatCategory *TdConvertFromInternal (const td::td_api::TopChatCategory &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_TopChatCategoryUsers: return (struct TdTopChatCategory *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryUsers &>(from));
    case CODE_TopChatCategoryBots: return (struct TdTopChatCategory *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryBots &>(from));
    case CODE_TopChatCategoryGroups: return (struct TdTopChatCategory *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryGroups &>(from));
    case CODE_TopChatCategoryChannels: return (struct TdTopChatCategory *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryChannels &>(from));
    case CODE_TopChatCategoryInlineBots: return (struct TdTopChatCategory *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryInlineBots &>(from));
    case CODE_TopChatCategoryCalls: return (struct TdTopChatCategory *)TdConvertFromInternal(static_cast<const td::td_api::topChatCategoryCalls &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeTopChatCategory (struct TdTopChatCategory *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTopChatCategory *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTopChatCategory (struct TdTopChatCategory *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTopChatCategory *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TopChatCategoryUsers: return TdDestroyObject ((struct TdTopChatCategoryUsers *)var);
    case CODE_TopChatCategoryBots: return TdDestroyObject ((struct TdTopChatCategoryBots *)var);
    case CODE_TopChatCategoryGroups: return TdDestroyObject ((struct TdTopChatCategoryGroups *)var);
    case CODE_TopChatCategoryChannels: return TdDestroyObject ((struct TdTopChatCategoryChannels *)var);
    case CODE_TopChatCategoryInlineBots: return TdDestroyObject ((struct TdTopChatCategoryInlineBots *)var);
    case CODE_TopChatCategoryCalls: return TdDestroyObject ((struct TdTopChatCategoryCalls *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerTopChatCategory (struct TdTopChatCategory *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTopChatCategory *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_TopChatCategoryUsers: return TdStackStorer ((struct TdTopChatCategoryUsers *)var, M);
    case CODE_TopChatCategoryBots: return TdStackStorer ((struct TdTopChatCategoryBots *)var, M);
    case CODE_TopChatCategoryGroups: return TdStackStorer ((struct TdTopChatCategoryGroups *)var, M);
    case CODE_TopChatCategoryChannels: return TdStackStorer ((struct TdTopChatCategoryChannels *)var, M);
    case CODE_TopChatCategoryInlineBots: return TdStackStorer ((struct TdTopChatCategoryInlineBots *)var, M);
    case CODE_TopChatCategoryCalls: return TdStackStorer ((struct TdTopChatCategoryCalls *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdTopChatCategory *TdStackFetcherTopChatCategory (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "TopChatCategoryUsers") {
    return (struct TdTopChatCategory *)TdStackFetcherTopChatCategoryUsers (M);
  }
  if (constructor == "TopChatCategoryBots") {
    return (struct TdTopChatCategory *)TdStackFetcherTopChatCategoryBots (M);
  }
  if (constructor == "TopChatCategoryGroups") {
    return (struct TdTopChatCategory *)TdStackFetcherTopChatCategoryGroups (M);
  }
  if (constructor == "TopChatCategoryChannels") {
    return (struct TdTopChatCategory *)TdStackFetcherTopChatCategoryChannels (M);
  }
  if (constructor == "TopChatCategoryInlineBots") {
    return (struct TdTopChatCategory *)TdStackFetcherTopChatCategoryInlineBots (M);
  }
  if (constructor == "TopChatCategoryCalls") {
    return (struct TdTopChatCategory *)TdStackFetcherTopChatCategoryCalls (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdTopChatCategoryUsers *TdCreateObjectTopChatCategoryUsers (void) {
  auto var = new struct TdTopChatCategoryUsers ();
  var->ID = CODE_TopChatCategoryUsers;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::topChatCategoryUsers> TdConvertToInternal (struct TdTopChatCategoryUsers *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::topChatCategoryUsers>();
}
struct TdTopChatCategoryUsers *TdConvertFromInternal (const td::td_api::topChatCategoryUsers &from) {
  auto res = new TdTopChatCategoryUsers ();
  res->ID = CODE_TopChatCategoryUsers;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTopChatCategoryUsers (struct TdTopChatCategoryUsers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTopChatCategoryUsers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTopChatCategoryUsers (struct TdTopChatCategoryUsers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTopChatCategoryUsers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTopChatCategoryUsers (struct TdTopChatCategoryUsers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTopChatCategoryUsers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TopChatCategoryUsers");
  M->new_field ("ID");
}
struct TdTopChatCategoryUsers *TdStackFetcherTopChatCategoryUsers (struct TdStackFetcherMethods *M) {
  auto res = new TdTopChatCategoryUsers ();
  res->ID = CODE_TopChatCategoryUsers;
  res->refcnt = 1;
  return res;
}
struct TdTopChatCategoryBots *TdCreateObjectTopChatCategoryBots (void) {
  auto var = new struct TdTopChatCategoryBots ();
  var->ID = CODE_TopChatCategoryBots;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::topChatCategoryBots> TdConvertToInternal (struct TdTopChatCategoryBots *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::topChatCategoryBots>();
}
struct TdTopChatCategoryBots *TdConvertFromInternal (const td::td_api::topChatCategoryBots &from) {
  auto res = new TdTopChatCategoryBots ();
  res->ID = CODE_TopChatCategoryBots;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTopChatCategoryBots (struct TdTopChatCategoryBots *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTopChatCategoryBots *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTopChatCategoryBots (struct TdTopChatCategoryBots *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTopChatCategoryBots *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTopChatCategoryBots (struct TdTopChatCategoryBots *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTopChatCategoryBots *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TopChatCategoryBots");
  M->new_field ("ID");
}
struct TdTopChatCategoryBots *TdStackFetcherTopChatCategoryBots (struct TdStackFetcherMethods *M) {
  auto res = new TdTopChatCategoryBots ();
  res->ID = CODE_TopChatCategoryBots;
  res->refcnt = 1;
  return res;
}
struct TdTopChatCategoryGroups *TdCreateObjectTopChatCategoryGroups (void) {
  auto var = new struct TdTopChatCategoryGroups ();
  var->ID = CODE_TopChatCategoryGroups;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::topChatCategoryGroups> TdConvertToInternal (struct TdTopChatCategoryGroups *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::topChatCategoryGroups>();
}
struct TdTopChatCategoryGroups *TdConvertFromInternal (const td::td_api::topChatCategoryGroups &from) {
  auto res = new TdTopChatCategoryGroups ();
  res->ID = CODE_TopChatCategoryGroups;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTopChatCategoryGroups (struct TdTopChatCategoryGroups *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTopChatCategoryGroups *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTopChatCategoryGroups (struct TdTopChatCategoryGroups *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTopChatCategoryGroups *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTopChatCategoryGroups (struct TdTopChatCategoryGroups *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTopChatCategoryGroups *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TopChatCategoryGroups");
  M->new_field ("ID");
}
struct TdTopChatCategoryGroups *TdStackFetcherTopChatCategoryGroups (struct TdStackFetcherMethods *M) {
  auto res = new TdTopChatCategoryGroups ();
  res->ID = CODE_TopChatCategoryGroups;
  res->refcnt = 1;
  return res;
}
struct TdTopChatCategoryChannels *TdCreateObjectTopChatCategoryChannels (void) {
  auto var = new struct TdTopChatCategoryChannels ();
  var->ID = CODE_TopChatCategoryChannels;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::topChatCategoryChannels> TdConvertToInternal (struct TdTopChatCategoryChannels *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::topChatCategoryChannels>();
}
struct TdTopChatCategoryChannels *TdConvertFromInternal (const td::td_api::topChatCategoryChannels &from) {
  auto res = new TdTopChatCategoryChannels ();
  res->ID = CODE_TopChatCategoryChannels;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTopChatCategoryChannels (struct TdTopChatCategoryChannels *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTopChatCategoryChannels *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTopChatCategoryChannels (struct TdTopChatCategoryChannels *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTopChatCategoryChannels *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTopChatCategoryChannels (struct TdTopChatCategoryChannels *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTopChatCategoryChannels *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TopChatCategoryChannels");
  M->new_field ("ID");
}
struct TdTopChatCategoryChannels *TdStackFetcherTopChatCategoryChannels (struct TdStackFetcherMethods *M) {
  auto res = new TdTopChatCategoryChannels ();
  res->ID = CODE_TopChatCategoryChannels;
  res->refcnt = 1;
  return res;
}
struct TdTopChatCategoryInlineBots *TdCreateObjectTopChatCategoryInlineBots (void) {
  auto var = new struct TdTopChatCategoryInlineBots ();
  var->ID = CODE_TopChatCategoryInlineBots;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::topChatCategoryInlineBots> TdConvertToInternal (struct TdTopChatCategoryInlineBots *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::topChatCategoryInlineBots>();
}
struct TdTopChatCategoryInlineBots *TdConvertFromInternal (const td::td_api::topChatCategoryInlineBots &from) {
  auto res = new TdTopChatCategoryInlineBots ();
  res->ID = CODE_TopChatCategoryInlineBots;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTopChatCategoryInlineBots (struct TdTopChatCategoryInlineBots *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTopChatCategoryInlineBots *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTopChatCategoryInlineBots (struct TdTopChatCategoryInlineBots *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTopChatCategoryInlineBots *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTopChatCategoryInlineBots (struct TdTopChatCategoryInlineBots *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTopChatCategoryInlineBots *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TopChatCategoryInlineBots");
  M->new_field ("ID");
}
struct TdTopChatCategoryInlineBots *TdStackFetcherTopChatCategoryInlineBots (struct TdStackFetcherMethods *M) {
  auto res = new TdTopChatCategoryInlineBots ();
  res->ID = CODE_TopChatCategoryInlineBots;
  res->refcnt = 1;
  return res;
}
struct TdTopChatCategoryCalls *TdCreateObjectTopChatCategoryCalls (void) {
  auto var = new struct TdTopChatCategoryCalls ();
  var->ID = CODE_TopChatCategoryCalls;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::topChatCategoryCalls> TdConvertToInternal (struct TdTopChatCategoryCalls *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::topChatCategoryCalls>();
}
struct TdTopChatCategoryCalls *TdConvertFromInternal (const td::td_api::topChatCategoryCalls &from) {
  auto res = new TdTopChatCategoryCalls ();
  res->ID = CODE_TopChatCategoryCalls;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTopChatCategoryCalls (struct TdTopChatCategoryCalls *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTopChatCategoryCalls *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTopChatCategoryCalls (struct TdTopChatCategoryCalls *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTopChatCategoryCalls *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTopChatCategoryCalls (struct TdTopChatCategoryCalls *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTopChatCategoryCalls *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TopChatCategoryCalls");
  M->new_field ("ID");
}
struct TdTopChatCategoryCalls *TdStackFetcherTopChatCategoryCalls (struct TdStackFetcherMethods *M) {
  auto res = new TdTopChatCategoryCalls ();
  res->ID = CODE_TopChatCategoryCalls;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::Update> TdConvertToInternal (struct TdUpdate *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UpdateAuthorizationState: return TdConvertToInternal ((struct TdUpdateAuthorizationState *)var);
    case CODE_UpdateNewMessage: return TdConvertToInternal ((struct TdUpdateNewMessage *)var);
    case CODE_UpdateMessageSendAcknowledged: return TdConvertToInternal ((struct TdUpdateMessageSendAcknowledged *)var);
    case CODE_UpdateMessageSendSucceeded: return TdConvertToInternal ((struct TdUpdateMessageSendSucceeded *)var);
    case CODE_UpdateMessageSendFailed: return TdConvertToInternal ((struct TdUpdateMessageSendFailed *)var);
    case CODE_UpdateMessageContent: return TdConvertToInternal ((struct TdUpdateMessageContent *)var);
    case CODE_UpdateMessageEdited: return TdConvertToInternal ((struct TdUpdateMessageEdited *)var);
    case CODE_UpdateMessageViews: return TdConvertToInternal ((struct TdUpdateMessageViews *)var);
    case CODE_UpdateMessageContentOpened: return TdConvertToInternal ((struct TdUpdateMessageContentOpened *)var);
    case CODE_UpdateMessageMentionRead: return TdConvertToInternal ((struct TdUpdateMessageMentionRead *)var);
    case CODE_UpdateNewChat: return TdConvertToInternal ((struct TdUpdateNewChat *)var);
    case CODE_UpdateChatTitle: return TdConvertToInternal ((struct TdUpdateChatTitle *)var);
    case CODE_UpdateChatPhoto: return TdConvertToInternal ((struct TdUpdateChatPhoto *)var);
    case CODE_UpdateChatLastMessage: return TdConvertToInternal ((struct TdUpdateChatLastMessage *)var);
    case CODE_UpdateChatOrder: return TdConvertToInternal ((struct TdUpdateChatOrder *)var);
    case CODE_UpdateChatIsPinned: return TdConvertToInternal ((struct TdUpdateChatIsPinned *)var);
    case CODE_UpdateChatIsMarkedAsUnread: return TdConvertToInternal ((struct TdUpdateChatIsMarkedAsUnread *)var);
    case CODE_UpdateChatIsSponsored: return TdConvertToInternal ((struct TdUpdateChatIsSponsored *)var);
    case CODE_UpdateChatDefaultDisableNotification: return TdConvertToInternal ((struct TdUpdateChatDefaultDisableNotification *)var);
    case CODE_UpdateChatReadInbox: return TdConvertToInternal ((struct TdUpdateChatReadInbox *)var);
    case CODE_UpdateChatReadOutbox: return TdConvertToInternal ((struct TdUpdateChatReadOutbox *)var);
    case CODE_UpdateChatUnreadMentionCount: return TdConvertToInternal ((struct TdUpdateChatUnreadMentionCount *)var);
    case CODE_UpdateChatNotificationSettings: return TdConvertToInternal ((struct TdUpdateChatNotificationSettings *)var);
    case CODE_UpdateScopeNotificationSettings: return TdConvertToInternal ((struct TdUpdateScopeNotificationSettings *)var);
    case CODE_UpdateChatReplyMarkup: return TdConvertToInternal ((struct TdUpdateChatReplyMarkup *)var);
    case CODE_UpdateChatDraftMessage: return TdConvertToInternal ((struct TdUpdateChatDraftMessage *)var);
    case CODE_UpdateDeleteMessages: return TdConvertToInternal ((struct TdUpdateDeleteMessages *)var);
    case CODE_UpdateUserChatAction: return TdConvertToInternal ((struct TdUpdateUserChatAction *)var);
    case CODE_UpdateUserStatus: return TdConvertToInternal ((struct TdUpdateUserStatus *)var);
    case CODE_UpdateUser: return TdConvertToInternal ((struct TdUpdateUser *)var);
    case CODE_UpdateBasicGroup: return TdConvertToInternal ((struct TdUpdateBasicGroup *)var);
    case CODE_UpdateSupergroup: return TdConvertToInternal ((struct TdUpdateSupergroup *)var);
    case CODE_UpdateSecretChat: return TdConvertToInternal ((struct TdUpdateSecretChat *)var);
    case CODE_UpdateUserFullInfo: return TdConvertToInternal ((struct TdUpdateUserFullInfo *)var);
    case CODE_UpdateBasicGroupFullInfo: return TdConvertToInternal ((struct TdUpdateBasicGroupFullInfo *)var);
    case CODE_UpdateSupergroupFullInfo: return TdConvertToInternal ((struct TdUpdateSupergroupFullInfo *)var);
    case CODE_UpdateServiceNotification: return TdConvertToInternal ((struct TdUpdateServiceNotification *)var);
    case CODE_UpdateFile: return TdConvertToInternal ((struct TdUpdateFile *)var);
    case CODE_UpdateFileGenerationStart: return TdConvertToInternal ((struct TdUpdateFileGenerationStart *)var);
    case CODE_UpdateFileGenerationStop: return TdConvertToInternal ((struct TdUpdateFileGenerationStop *)var);
    case CODE_UpdateCall: return TdConvertToInternal ((struct TdUpdateCall *)var);
    case CODE_UpdateUserPrivacySettingRules: return TdConvertToInternal ((struct TdUpdateUserPrivacySettingRules *)var);
    case CODE_UpdateUnreadMessageCount: return TdConvertToInternal ((struct TdUpdateUnreadMessageCount *)var);
    case CODE_UpdateUnreadChatCount: return TdConvertToInternal ((struct TdUpdateUnreadChatCount *)var);
    case CODE_UpdateOption: return TdConvertToInternal ((struct TdUpdateOption *)var);
    case CODE_UpdateInstalledStickerSets: return TdConvertToInternal ((struct TdUpdateInstalledStickerSets *)var);
    case CODE_UpdateTrendingStickerSets: return TdConvertToInternal ((struct TdUpdateTrendingStickerSets *)var);
    case CODE_UpdateRecentStickers: return TdConvertToInternal ((struct TdUpdateRecentStickers *)var);
    case CODE_UpdateFavoriteStickers: return TdConvertToInternal ((struct TdUpdateFavoriteStickers *)var);
    case CODE_UpdateSavedAnimations: return TdConvertToInternal ((struct TdUpdateSavedAnimations *)var);
    case CODE_UpdateLanguagePackStrings: return TdConvertToInternal ((struct TdUpdateLanguagePackStrings *)var);
    case CODE_UpdateConnectionState: return TdConvertToInternal ((struct TdUpdateConnectionState *)var);
    case CODE_UpdateTermsOfService: return TdConvertToInternal ((struct TdUpdateTermsOfService *)var);
    case CODE_UpdateNewInlineQuery: return TdConvertToInternal ((struct TdUpdateNewInlineQuery *)var);
    case CODE_UpdateNewChosenInlineResult: return TdConvertToInternal ((struct TdUpdateNewChosenInlineResult *)var);
    case CODE_UpdateNewCallbackQuery: return TdConvertToInternal ((struct TdUpdateNewCallbackQuery *)var);
    case CODE_UpdateNewInlineCallbackQuery: return TdConvertToInternal ((struct TdUpdateNewInlineCallbackQuery *)var);
    case CODE_UpdateNewShippingQuery: return TdConvertToInternal ((struct TdUpdateNewShippingQuery *)var);
    case CODE_UpdateNewPreCheckoutQuery: return TdConvertToInternal ((struct TdUpdateNewPreCheckoutQuery *)var);
    case CODE_UpdateNewCustomEvent: return TdConvertToInternal ((struct TdUpdateNewCustomEvent *)var);
    case CODE_UpdateNewCustomQuery: return TdConvertToInternal ((struct TdUpdateNewCustomQuery *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdUpdate *TdConvertFromInternal (const td::td_api::Update &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_UpdateAuthorizationState: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateAuthorizationState &>(from));
    case CODE_UpdateNewMessage: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewMessage &>(from));
    case CODE_UpdateMessageSendAcknowledged: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageSendAcknowledged &>(from));
    case CODE_UpdateMessageSendSucceeded: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageSendSucceeded &>(from));
    case CODE_UpdateMessageSendFailed: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageSendFailed &>(from));
    case CODE_UpdateMessageContent: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageContent &>(from));
    case CODE_UpdateMessageEdited: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageEdited &>(from));
    case CODE_UpdateMessageViews: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageViews &>(from));
    case CODE_UpdateMessageContentOpened: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageContentOpened &>(from));
    case CODE_UpdateMessageMentionRead: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateMessageMentionRead &>(from));
    case CODE_UpdateNewChat: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewChat &>(from));
    case CODE_UpdateChatTitle: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatTitle &>(from));
    case CODE_UpdateChatPhoto: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatPhoto &>(from));
    case CODE_UpdateChatLastMessage: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatLastMessage &>(from));
    case CODE_UpdateChatOrder: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatOrder &>(from));
    case CODE_UpdateChatIsPinned: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatIsPinned &>(from));
    case CODE_UpdateChatIsMarkedAsUnread: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatIsMarkedAsUnread &>(from));
    case CODE_UpdateChatIsSponsored: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatIsSponsored &>(from));
    case CODE_UpdateChatDefaultDisableNotification: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatDefaultDisableNotification &>(from));
    case CODE_UpdateChatReadInbox: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatReadInbox &>(from));
    case CODE_UpdateChatReadOutbox: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatReadOutbox &>(from));
    case CODE_UpdateChatUnreadMentionCount: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatUnreadMentionCount &>(from));
    case CODE_UpdateChatNotificationSettings: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatNotificationSettings &>(from));
    case CODE_UpdateScopeNotificationSettings: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateScopeNotificationSettings &>(from));
    case CODE_UpdateChatReplyMarkup: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatReplyMarkup &>(from));
    case CODE_UpdateChatDraftMessage: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateChatDraftMessage &>(from));
    case CODE_UpdateDeleteMessages: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateDeleteMessages &>(from));
    case CODE_UpdateUserChatAction: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateUserChatAction &>(from));
    case CODE_UpdateUserStatus: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateUserStatus &>(from));
    case CODE_UpdateUser: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateUser &>(from));
    case CODE_UpdateBasicGroup: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateBasicGroup &>(from));
    case CODE_UpdateSupergroup: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateSupergroup &>(from));
    case CODE_UpdateSecretChat: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateSecretChat &>(from));
    case CODE_UpdateUserFullInfo: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateUserFullInfo &>(from));
    case CODE_UpdateBasicGroupFullInfo: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateBasicGroupFullInfo &>(from));
    case CODE_UpdateSupergroupFullInfo: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateSupergroupFullInfo &>(from));
    case CODE_UpdateServiceNotification: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateServiceNotification &>(from));
    case CODE_UpdateFile: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateFile &>(from));
    case CODE_UpdateFileGenerationStart: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateFileGenerationStart &>(from));
    case CODE_UpdateFileGenerationStop: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateFileGenerationStop &>(from));
    case CODE_UpdateCall: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateCall &>(from));
    case CODE_UpdateUserPrivacySettingRules: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateUserPrivacySettingRules &>(from));
    case CODE_UpdateUnreadMessageCount: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateUnreadMessageCount &>(from));
    case CODE_UpdateUnreadChatCount: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateUnreadChatCount &>(from));
    case CODE_UpdateOption: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateOption &>(from));
    case CODE_UpdateInstalledStickerSets: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateInstalledStickerSets &>(from));
    case CODE_UpdateTrendingStickerSets: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateTrendingStickerSets &>(from));
    case CODE_UpdateRecentStickers: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateRecentStickers &>(from));
    case CODE_UpdateFavoriteStickers: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateFavoriteStickers &>(from));
    case CODE_UpdateSavedAnimations: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateSavedAnimations &>(from));
    case CODE_UpdateLanguagePackStrings: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateLanguagePackStrings &>(from));
    case CODE_UpdateConnectionState: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateConnectionState &>(from));
    case CODE_UpdateTermsOfService: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateTermsOfService &>(from));
    case CODE_UpdateNewInlineQuery: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewInlineQuery &>(from));
    case CODE_UpdateNewChosenInlineResult: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewChosenInlineResult &>(from));
    case CODE_UpdateNewCallbackQuery: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewCallbackQuery &>(from));
    case CODE_UpdateNewInlineCallbackQuery: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewInlineCallbackQuery &>(from));
    case CODE_UpdateNewShippingQuery: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewShippingQuery &>(from));
    case CODE_UpdateNewPreCheckoutQuery: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewPreCheckoutQuery &>(from));
    case CODE_UpdateNewCustomEvent: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewCustomEvent &>(from));
    case CODE_UpdateNewCustomQuery: return (struct TdUpdate *)TdConvertFromInternal(static_cast<const td::td_api::updateNewCustomQuery &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeUpdate (struct TdUpdate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdate (struct TdUpdate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdate *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UpdateAuthorizationState: return TdDestroyObject ((struct TdUpdateAuthorizationState *)var);
    case CODE_UpdateNewMessage: return TdDestroyObject ((struct TdUpdateNewMessage *)var);
    case CODE_UpdateMessageSendAcknowledged: return TdDestroyObject ((struct TdUpdateMessageSendAcknowledged *)var);
    case CODE_UpdateMessageSendSucceeded: return TdDestroyObject ((struct TdUpdateMessageSendSucceeded *)var);
    case CODE_UpdateMessageSendFailed: return TdDestroyObject ((struct TdUpdateMessageSendFailed *)var);
    case CODE_UpdateMessageContent: return TdDestroyObject ((struct TdUpdateMessageContent *)var);
    case CODE_UpdateMessageEdited: return TdDestroyObject ((struct TdUpdateMessageEdited *)var);
    case CODE_UpdateMessageViews: return TdDestroyObject ((struct TdUpdateMessageViews *)var);
    case CODE_UpdateMessageContentOpened: return TdDestroyObject ((struct TdUpdateMessageContentOpened *)var);
    case CODE_UpdateMessageMentionRead: return TdDestroyObject ((struct TdUpdateMessageMentionRead *)var);
    case CODE_UpdateNewChat: return TdDestroyObject ((struct TdUpdateNewChat *)var);
    case CODE_UpdateChatTitle: return TdDestroyObject ((struct TdUpdateChatTitle *)var);
    case CODE_UpdateChatPhoto: return TdDestroyObject ((struct TdUpdateChatPhoto *)var);
    case CODE_UpdateChatLastMessage: return TdDestroyObject ((struct TdUpdateChatLastMessage *)var);
    case CODE_UpdateChatOrder: return TdDestroyObject ((struct TdUpdateChatOrder *)var);
    case CODE_UpdateChatIsPinned: return TdDestroyObject ((struct TdUpdateChatIsPinned *)var);
    case CODE_UpdateChatIsMarkedAsUnread: return TdDestroyObject ((struct TdUpdateChatIsMarkedAsUnread *)var);
    case CODE_UpdateChatIsSponsored: return TdDestroyObject ((struct TdUpdateChatIsSponsored *)var);
    case CODE_UpdateChatDefaultDisableNotification: return TdDestroyObject ((struct TdUpdateChatDefaultDisableNotification *)var);
    case CODE_UpdateChatReadInbox: return TdDestroyObject ((struct TdUpdateChatReadInbox *)var);
    case CODE_UpdateChatReadOutbox: return TdDestroyObject ((struct TdUpdateChatReadOutbox *)var);
    case CODE_UpdateChatUnreadMentionCount: return TdDestroyObject ((struct TdUpdateChatUnreadMentionCount *)var);
    case CODE_UpdateChatNotificationSettings: return TdDestroyObject ((struct TdUpdateChatNotificationSettings *)var);
    case CODE_UpdateScopeNotificationSettings: return TdDestroyObject ((struct TdUpdateScopeNotificationSettings *)var);
    case CODE_UpdateChatReplyMarkup: return TdDestroyObject ((struct TdUpdateChatReplyMarkup *)var);
    case CODE_UpdateChatDraftMessage: return TdDestroyObject ((struct TdUpdateChatDraftMessage *)var);
    case CODE_UpdateDeleteMessages: return TdDestroyObject ((struct TdUpdateDeleteMessages *)var);
    case CODE_UpdateUserChatAction: return TdDestroyObject ((struct TdUpdateUserChatAction *)var);
    case CODE_UpdateUserStatus: return TdDestroyObject ((struct TdUpdateUserStatus *)var);
    case CODE_UpdateUser: return TdDestroyObject ((struct TdUpdateUser *)var);
    case CODE_UpdateBasicGroup: return TdDestroyObject ((struct TdUpdateBasicGroup *)var);
    case CODE_UpdateSupergroup: return TdDestroyObject ((struct TdUpdateSupergroup *)var);
    case CODE_UpdateSecretChat: return TdDestroyObject ((struct TdUpdateSecretChat *)var);
    case CODE_UpdateUserFullInfo: return TdDestroyObject ((struct TdUpdateUserFullInfo *)var);
    case CODE_UpdateBasicGroupFullInfo: return TdDestroyObject ((struct TdUpdateBasicGroupFullInfo *)var);
    case CODE_UpdateSupergroupFullInfo: return TdDestroyObject ((struct TdUpdateSupergroupFullInfo *)var);
    case CODE_UpdateServiceNotification: return TdDestroyObject ((struct TdUpdateServiceNotification *)var);
    case CODE_UpdateFile: return TdDestroyObject ((struct TdUpdateFile *)var);
    case CODE_UpdateFileGenerationStart: return TdDestroyObject ((struct TdUpdateFileGenerationStart *)var);
    case CODE_UpdateFileGenerationStop: return TdDestroyObject ((struct TdUpdateFileGenerationStop *)var);
    case CODE_UpdateCall: return TdDestroyObject ((struct TdUpdateCall *)var);
    case CODE_UpdateUserPrivacySettingRules: return TdDestroyObject ((struct TdUpdateUserPrivacySettingRules *)var);
    case CODE_UpdateUnreadMessageCount: return TdDestroyObject ((struct TdUpdateUnreadMessageCount *)var);
    case CODE_UpdateUnreadChatCount: return TdDestroyObject ((struct TdUpdateUnreadChatCount *)var);
    case CODE_UpdateOption: return TdDestroyObject ((struct TdUpdateOption *)var);
    case CODE_UpdateInstalledStickerSets: return TdDestroyObject ((struct TdUpdateInstalledStickerSets *)var);
    case CODE_UpdateTrendingStickerSets: return TdDestroyObject ((struct TdUpdateTrendingStickerSets *)var);
    case CODE_UpdateRecentStickers: return TdDestroyObject ((struct TdUpdateRecentStickers *)var);
    case CODE_UpdateFavoriteStickers: return TdDestroyObject ((struct TdUpdateFavoriteStickers *)var);
    case CODE_UpdateSavedAnimations: return TdDestroyObject ((struct TdUpdateSavedAnimations *)var);
    case CODE_UpdateLanguagePackStrings: return TdDestroyObject ((struct TdUpdateLanguagePackStrings *)var);
    case CODE_UpdateConnectionState: return TdDestroyObject ((struct TdUpdateConnectionState *)var);
    case CODE_UpdateTermsOfService: return TdDestroyObject ((struct TdUpdateTermsOfService *)var);
    case CODE_UpdateNewInlineQuery: return TdDestroyObject ((struct TdUpdateNewInlineQuery *)var);
    case CODE_UpdateNewChosenInlineResult: return TdDestroyObject ((struct TdUpdateNewChosenInlineResult *)var);
    case CODE_UpdateNewCallbackQuery: return TdDestroyObject ((struct TdUpdateNewCallbackQuery *)var);
    case CODE_UpdateNewInlineCallbackQuery: return TdDestroyObject ((struct TdUpdateNewInlineCallbackQuery *)var);
    case CODE_UpdateNewShippingQuery: return TdDestroyObject ((struct TdUpdateNewShippingQuery *)var);
    case CODE_UpdateNewPreCheckoutQuery: return TdDestroyObject ((struct TdUpdateNewPreCheckoutQuery *)var);
    case CODE_UpdateNewCustomEvent: return TdDestroyObject ((struct TdUpdateNewCustomEvent *)var);
    case CODE_UpdateNewCustomQuery: return TdDestroyObject ((struct TdUpdateNewCustomQuery *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerUpdate (struct TdUpdate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdate *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UpdateAuthorizationState: return TdStackStorer ((struct TdUpdateAuthorizationState *)var, M);
    case CODE_UpdateNewMessage: return TdStackStorer ((struct TdUpdateNewMessage *)var, M);
    case CODE_UpdateMessageSendAcknowledged: return TdStackStorer ((struct TdUpdateMessageSendAcknowledged *)var, M);
    case CODE_UpdateMessageSendSucceeded: return TdStackStorer ((struct TdUpdateMessageSendSucceeded *)var, M);
    case CODE_UpdateMessageSendFailed: return TdStackStorer ((struct TdUpdateMessageSendFailed *)var, M);
    case CODE_UpdateMessageContent: return TdStackStorer ((struct TdUpdateMessageContent *)var, M);
    case CODE_UpdateMessageEdited: return TdStackStorer ((struct TdUpdateMessageEdited *)var, M);
    case CODE_UpdateMessageViews: return TdStackStorer ((struct TdUpdateMessageViews *)var, M);
    case CODE_UpdateMessageContentOpened: return TdStackStorer ((struct TdUpdateMessageContentOpened *)var, M);
    case CODE_UpdateMessageMentionRead: return TdStackStorer ((struct TdUpdateMessageMentionRead *)var, M);
    case CODE_UpdateNewChat: return TdStackStorer ((struct TdUpdateNewChat *)var, M);
    case CODE_UpdateChatTitle: return TdStackStorer ((struct TdUpdateChatTitle *)var, M);
    case CODE_UpdateChatPhoto: return TdStackStorer ((struct TdUpdateChatPhoto *)var, M);
    case CODE_UpdateChatLastMessage: return TdStackStorer ((struct TdUpdateChatLastMessage *)var, M);
    case CODE_UpdateChatOrder: return TdStackStorer ((struct TdUpdateChatOrder *)var, M);
    case CODE_UpdateChatIsPinned: return TdStackStorer ((struct TdUpdateChatIsPinned *)var, M);
    case CODE_UpdateChatIsMarkedAsUnread: return TdStackStorer ((struct TdUpdateChatIsMarkedAsUnread *)var, M);
    case CODE_UpdateChatIsSponsored: return TdStackStorer ((struct TdUpdateChatIsSponsored *)var, M);
    case CODE_UpdateChatDefaultDisableNotification: return TdStackStorer ((struct TdUpdateChatDefaultDisableNotification *)var, M);
    case CODE_UpdateChatReadInbox: return TdStackStorer ((struct TdUpdateChatReadInbox *)var, M);
    case CODE_UpdateChatReadOutbox: return TdStackStorer ((struct TdUpdateChatReadOutbox *)var, M);
    case CODE_UpdateChatUnreadMentionCount: return TdStackStorer ((struct TdUpdateChatUnreadMentionCount *)var, M);
    case CODE_UpdateChatNotificationSettings: return TdStackStorer ((struct TdUpdateChatNotificationSettings *)var, M);
    case CODE_UpdateScopeNotificationSettings: return TdStackStorer ((struct TdUpdateScopeNotificationSettings *)var, M);
    case CODE_UpdateChatReplyMarkup: return TdStackStorer ((struct TdUpdateChatReplyMarkup *)var, M);
    case CODE_UpdateChatDraftMessage: return TdStackStorer ((struct TdUpdateChatDraftMessage *)var, M);
    case CODE_UpdateDeleteMessages: return TdStackStorer ((struct TdUpdateDeleteMessages *)var, M);
    case CODE_UpdateUserChatAction: return TdStackStorer ((struct TdUpdateUserChatAction *)var, M);
    case CODE_UpdateUserStatus: return TdStackStorer ((struct TdUpdateUserStatus *)var, M);
    case CODE_UpdateUser: return TdStackStorer ((struct TdUpdateUser *)var, M);
    case CODE_UpdateBasicGroup: return TdStackStorer ((struct TdUpdateBasicGroup *)var, M);
    case CODE_UpdateSupergroup: return TdStackStorer ((struct TdUpdateSupergroup *)var, M);
    case CODE_UpdateSecretChat: return TdStackStorer ((struct TdUpdateSecretChat *)var, M);
    case CODE_UpdateUserFullInfo: return TdStackStorer ((struct TdUpdateUserFullInfo *)var, M);
    case CODE_UpdateBasicGroupFullInfo: return TdStackStorer ((struct TdUpdateBasicGroupFullInfo *)var, M);
    case CODE_UpdateSupergroupFullInfo: return TdStackStorer ((struct TdUpdateSupergroupFullInfo *)var, M);
    case CODE_UpdateServiceNotification: return TdStackStorer ((struct TdUpdateServiceNotification *)var, M);
    case CODE_UpdateFile: return TdStackStorer ((struct TdUpdateFile *)var, M);
    case CODE_UpdateFileGenerationStart: return TdStackStorer ((struct TdUpdateFileGenerationStart *)var, M);
    case CODE_UpdateFileGenerationStop: return TdStackStorer ((struct TdUpdateFileGenerationStop *)var, M);
    case CODE_UpdateCall: return TdStackStorer ((struct TdUpdateCall *)var, M);
    case CODE_UpdateUserPrivacySettingRules: return TdStackStorer ((struct TdUpdateUserPrivacySettingRules *)var, M);
    case CODE_UpdateUnreadMessageCount: return TdStackStorer ((struct TdUpdateUnreadMessageCount *)var, M);
    case CODE_UpdateUnreadChatCount: return TdStackStorer ((struct TdUpdateUnreadChatCount *)var, M);
    case CODE_UpdateOption: return TdStackStorer ((struct TdUpdateOption *)var, M);
    case CODE_UpdateInstalledStickerSets: return TdStackStorer ((struct TdUpdateInstalledStickerSets *)var, M);
    case CODE_UpdateTrendingStickerSets: return TdStackStorer ((struct TdUpdateTrendingStickerSets *)var, M);
    case CODE_UpdateRecentStickers: return TdStackStorer ((struct TdUpdateRecentStickers *)var, M);
    case CODE_UpdateFavoriteStickers: return TdStackStorer ((struct TdUpdateFavoriteStickers *)var, M);
    case CODE_UpdateSavedAnimations: return TdStackStorer ((struct TdUpdateSavedAnimations *)var, M);
    case CODE_UpdateLanguagePackStrings: return TdStackStorer ((struct TdUpdateLanguagePackStrings *)var, M);
    case CODE_UpdateConnectionState: return TdStackStorer ((struct TdUpdateConnectionState *)var, M);
    case CODE_UpdateTermsOfService: return TdStackStorer ((struct TdUpdateTermsOfService *)var, M);
    case CODE_UpdateNewInlineQuery: return TdStackStorer ((struct TdUpdateNewInlineQuery *)var, M);
    case CODE_UpdateNewChosenInlineResult: return TdStackStorer ((struct TdUpdateNewChosenInlineResult *)var, M);
    case CODE_UpdateNewCallbackQuery: return TdStackStorer ((struct TdUpdateNewCallbackQuery *)var, M);
    case CODE_UpdateNewInlineCallbackQuery: return TdStackStorer ((struct TdUpdateNewInlineCallbackQuery *)var, M);
    case CODE_UpdateNewShippingQuery: return TdStackStorer ((struct TdUpdateNewShippingQuery *)var, M);
    case CODE_UpdateNewPreCheckoutQuery: return TdStackStorer ((struct TdUpdateNewPreCheckoutQuery *)var, M);
    case CODE_UpdateNewCustomEvent: return TdStackStorer ((struct TdUpdateNewCustomEvent *)var, M);
    case CODE_UpdateNewCustomQuery: return TdStackStorer ((struct TdUpdateNewCustomQuery *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdUpdate *TdStackFetcherUpdate (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "UpdateAuthorizationState") {
    return (struct TdUpdate *)TdStackFetcherUpdateAuthorizationState (M);
  }
  if (constructor == "UpdateNewMessage") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewMessage (M);
  }
  if (constructor == "UpdateMessageSendAcknowledged") {
    return (struct TdUpdate *)TdStackFetcherUpdateMessageSendAcknowledged (M);
  }
  if (constructor == "UpdateMessageSendSucceeded") {
    return (struct TdUpdate *)TdStackFetcherUpdateMessageSendSucceeded (M);
  }
  if (constructor == "UpdateMessageSendFailed") {
    return (struct TdUpdate *)TdStackFetcherUpdateMessageSendFailed (M);
  }
  if (constructor == "UpdateMessageContent") {
    return (struct TdUpdate *)TdStackFetcherUpdateMessageContent (M);
  }
  if (constructor == "UpdateMessageEdited") {
    return (struct TdUpdate *)TdStackFetcherUpdateMessageEdited (M);
  }
  if (constructor == "UpdateMessageViews") {
    return (struct TdUpdate *)TdStackFetcherUpdateMessageViews (M);
  }
  if (constructor == "UpdateMessageContentOpened") {
    return (struct TdUpdate *)TdStackFetcherUpdateMessageContentOpened (M);
  }
  if (constructor == "UpdateMessageMentionRead") {
    return (struct TdUpdate *)TdStackFetcherUpdateMessageMentionRead (M);
  }
  if (constructor == "UpdateNewChat") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewChat (M);
  }
  if (constructor == "UpdateChatTitle") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatTitle (M);
  }
  if (constructor == "UpdateChatPhoto") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatPhoto (M);
  }
  if (constructor == "UpdateChatLastMessage") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatLastMessage (M);
  }
  if (constructor == "UpdateChatOrder") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatOrder (M);
  }
  if (constructor == "UpdateChatIsPinned") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatIsPinned (M);
  }
  if (constructor == "UpdateChatIsMarkedAsUnread") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatIsMarkedAsUnread (M);
  }
  if (constructor == "UpdateChatIsSponsored") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatIsSponsored (M);
  }
  if (constructor == "UpdateChatDefaultDisableNotification") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatDefaultDisableNotification (M);
  }
  if (constructor == "UpdateChatReadInbox") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatReadInbox (M);
  }
  if (constructor == "UpdateChatReadOutbox") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatReadOutbox (M);
  }
  if (constructor == "UpdateChatUnreadMentionCount") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatUnreadMentionCount (M);
  }
  if (constructor == "UpdateChatNotificationSettings") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatNotificationSettings (M);
  }
  if (constructor == "UpdateScopeNotificationSettings") {
    return (struct TdUpdate *)TdStackFetcherUpdateScopeNotificationSettings (M);
  }
  if (constructor == "UpdateChatReplyMarkup") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatReplyMarkup (M);
  }
  if (constructor == "UpdateChatDraftMessage") {
    return (struct TdUpdate *)TdStackFetcherUpdateChatDraftMessage (M);
  }
  if (constructor == "UpdateDeleteMessages") {
    return (struct TdUpdate *)TdStackFetcherUpdateDeleteMessages (M);
  }
  if (constructor == "UpdateUserChatAction") {
    return (struct TdUpdate *)TdStackFetcherUpdateUserChatAction (M);
  }
  if (constructor == "UpdateUserStatus") {
    return (struct TdUpdate *)TdStackFetcherUpdateUserStatus (M);
  }
  if (constructor == "UpdateUser") {
    return (struct TdUpdate *)TdStackFetcherUpdateUser (M);
  }
  if (constructor == "UpdateBasicGroup") {
    return (struct TdUpdate *)TdStackFetcherUpdateBasicGroup (M);
  }
  if (constructor == "UpdateSupergroup") {
    return (struct TdUpdate *)TdStackFetcherUpdateSupergroup (M);
  }
  if (constructor == "UpdateSecretChat") {
    return (struct TdUpdate *)TdStackFetcherUpdateSecretChat (M);
  }
  if (constructor == "UpdateUserFullInfo") {
    return (struct TdUpdate *)TdStackFetcherUpdateUserFullInfo (M);
  }
  if (constructor == "UpdateBasicGroupFullInfo") {
    return (struct TdUpdate *)TdStackFetcherUpdateBasicGroupFullInfo (M);
  }
  if (constructor == "UpdateSupergroupFullInfo") {
    return (struct TdUpdate *)TdStackFetcherUpdateSupergroupFullInfo (M);
  }
  if (constructor == "UpdateServiceNotification") {
    return (struct TdUpdate *)TdStackFetcherUpdateServiceNotification (M);
  }
  if (constructor == "UpdateFile") {
    return (struct TdUpdate *)TdStackFetcherUpdateFile (M);
  }
  if (constructor == "UpdateFileGenerationStart") {
    return (struct TdUpdate *)TdStackFetcherUpdateFileGenerationStart (M);
  }
  if (constructor == "UpdateFileGenerationStop") {
    return (struct TdUpdate *)TdStackFetcherUpdateFileGenerationStop (M);
  }
  if (constructor == "UpdateCall") {
    return (struct TdUpdate *)TdStackFetcherUpdateCall (M);
  }
  if (constructor == "UpdateUserPrivacySettingRules") {
    return (struct TdUpdate *)TdStackFetcherUpdateUserPrivacySettingRules (M);
  }
  if (constructor == "UpdateUnreadMessageCount") {
    return (struct TdUpdate *)TdStackFetcherUpdateUnreadMessageCount (M);
  }
  if (constructor == "UpdateUnreadChatCount") {
    return (struct TdUpdate *)TdStackFetcherUpdateUnreadChatCount (M);
  }
  if (constructor == "UpdateOption") {
    return (struct TdUpdate *)TdStackFetcherUpdateOption (M);
  }
  if (constructor == "UpdateInstalledStickerSets") {
    return (struct TdUpdate *)TdStackFetcherUpdateInstalledStickerSets (M);
  }
  if (constructor == "UpdateTrendingStickerSets") {
    return (struct TdUpdate *)TdStackFetcherUpdateTrendingStickerSets (M);
  }
  if (constructor == "UpdateRecentStickers") {
    return (struct TdUpdate *)TdStackFetcherUpdateRecentStickers (M);
  }
  if (constructor == "UpdateFavoriteStickers") {
    return (struct TdUpdate *)TdStackFetcherUpdateFavoriteStickers (M);
  }
  if (constructor == "UpdateSavedAnimations") {
    return (struct TdUpdate *)TdStackFetcherUpdateSavedAnimations (M);
  }
  if (constructor == "UpdateLanguagePackStrings") {
    return (struct TdUpdate *)TdStackFetcherUpdateLanguagePackStrings (M);
  }
  if (constructor == "UpdateConnectionState") {
    return (struct TdUpdate *)TdStackFetcherUpdateConnectionState (M);
  }
  if (constructor == "UpdateTermsOfService") {
    return (struct TdUpdate *)TdStackFetcherUpdateTermsOfService (M);
  }
  if (constructor == "UpdateNewInlineQuery") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewInlineQuery (M);
  }
  if (constructor == "UpdateNewChosenInlineResult") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewChosenInlineResult (M);
  }
  if (constructor == "UpdateNewCallbackQuery") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewCallbackQuery (M);
  }
  if (constructor == "UpdateNewInlineCallbackQuery") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewInlineCallbackQuery (M);
  }
  if (constructor == "UpdateNewShippingQuery") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewShippingQuery (M);
  }
  if (constructor == "UpdateNewPreCheckoutQuery") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewPreCheckoutQuery (M);
  }
  if (constructor == "UpdateNewCustomEvent") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewCustomEvent (M);
  }
  if (constructor == "UpdateNewCustomQuery") {
    return (struct TdUpdate *)TdStackFetcherUpdateNewCustomQuery (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdUpdateAuthorizationState *TdCreateObjectUpdateAuthorizationState (struct TdAuthorizationState *authorization_state_) {
  auto var = new struct TdUpdateAuthorizationState ();
  var->ID = CODE_UpdateAuthorizationState;
  var->refcnt = 1;
  var->authorization_state_ = authorization_state_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateAuthorizationState> TdConvertToInternal (struct TdUpdateAuthorizationState *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::AuthorizationState> v0;
  v0 = TdConvertToInternal (var->authorization_state_);
  return td::td_api::make_object<td::td_api::updateAuthorizationState>(std::move (v0));
}
struct TdUpdateAuthorizationState *TdConvertFromInternal (const td::td_api::updateAuthorizationState &from) {
  auto res = new TdUpdateAuthorizationState ();
  res->ID = CODE_UpdateAuthorizationState;
  res->refcnt = 1;
  if (!from.authorization_state_) {
    res->authorization_state_ = nullptr;
  } else {
    res->authorization_state_ = TdConvertFromInternal (static_cast<const td::td_api::AuthorizationState &>(*from.authorization_state_));
  }
  return res;
}
char *TdSerializeUpdateAuthorizationState (struct TdUpdateAuthorizationState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateAuthorizationState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateAuthorizationState (struct TdUpdateAuthorizationState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateAuthorizationState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->authorization_state_);
  delete var;
}
void TdStackStorerUpdateAuthorizationState (struct TdUpdateAuthorizationState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateAuthorizationState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateAuthorizationState");
  M->new_field ("ID");
  TdStackStorer (var->authorization_state_, M);
  M->new_field ("authorization_state_");
}
struct TdUpdateAuthorizationState *TdStackFetcherUpdateAuthorizationState (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateAuthorizationState ();
  res->ID = CODE_UpdateAuthorizationState;
  res->refcnt = 1;
  M->get_field ("authorization_state_");
  if (M->is_nil ()) {
    res->authorization_state_ = nullptr;
  } else {
    res->authorization_state_ = TdStackFetcherAuthorizationState (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateNewMessage *TdCreateObjectUpdateNewMessage (struct TdMessage *message_, int disable_notification_, int contains_mention_) {
  auto var = new struct TdUpdateNewMessage ();
  var->ID = CODE_UpdateNewMessage;
  var->refcnt = 1;
  var->message_ = message_;
  var->disable_notification_ = disable_notification_;
  var->contains_mention_ = contains_mention_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewMessage> TdConvertToInternal (struct TdUpdateNewMessage *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::message> v0;
  v0 = TdConvertToInternal (var->message_);
  bool v100;
  v100 = var->disable_notification_ != 0;
  bool v200;
  v200 = var->contains_mention_ != 0;
  return td::td_api::make_object<td::td_api::updateNewMessage>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateNewMessage *TdConvertFromInternal (const td::td_api::updateNewMessage &from) {
  auto res = new TdUpdateNewMessage ();
  res->ID = CODE_UpdateNewMessage;
  res->refcnt = 1;
  if (!from.message_) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.message_));
  }
  res->disable_notification_ = from.disable_notification_;
  res->contains_mention_ = from.contains_mention_;
  return res;
}
char *TdSerializeUpdateNewMessage (struct TdUpdateNewMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewMessage (struct TdUpdateNewMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->message_);
  delete var;
}
void TdStackStorerUpdateNewMessage (struct TdUpdateNewMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewMessage");
  M->new_field ("ID");
  TdStackStorer (var->message_, M);
  M->new_field ("message_");
  M->pack_bool (var->disable_notification_);
  M->new_field ("disable_notification_");
  M->pack_bool (var->contains_mention_);
  M->new_field ("contains_mention_");
}
struct TdUpdateNewMessage *TdStackFetcherUpdateNewMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewMessage ();
  res->ID = CODE_UpdateNewMessage;
  res->refcnt = 1;
  M->get_field ("message_");
  if (M->is_nil ()) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  M->get_field ("disable_notification_");
  res->disable_notification_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("contains_mention_");
  res->contains_mention_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateMessageSendAcknowledged *TdCreateObjectUpdateMessageSendAcknowledged (long long chat_id_, long long message_id_) {
  auto var = new struct TdUpdateMessageSendAcknowledged ();
  var->ID = CODE_UpdateMessageSendAcknowledged;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateMessageSendAcknowledged> TdConvertToInternal (struct TdUpdateMessageSendAcknowledged *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  return td::td_api::make_object<td::td_api::updateMessageSendAcknowledged>(std::move (v0), std::move (v100));
}
struct TdUpdateMessageSendAcknowledged *TdConvertFromInternal (const td::td_api::updateMessageSendAcknowledged &from) {
  auto res = new TdUpdateMessageSendAcknowledged ();
  res->ID = CODE_UpdateMessageSendAcknowledged;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeUpdateMessageSendAcknowledged (struct TdUpdateMessageSendAcknowledged *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateMessageSendAcknowledged *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateMessageSendAcknowledged (struct TdUpdateMessageSendAcknowledged *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateMessageSendAcknowledged *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateMessageSendAcknowledged (struct TdUpdateMessageSendAcknowledged *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateMessageSendAcknowledged *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateMessageSendAcknowledged");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdUpdateMessageSendAcknowledged *TdStackFetcherUpdateMessageSendAcknowledged (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateMessageSendAcknowledged ();
  res->ID = CODE_UpdateMessageSendAcknowledged;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateMessageSendSucceeded *TdCreateObjectUpdateMessageSendSucceeded (struct TdMessage *message_, long long old_message_id_) {
  auto var = new struct TdUpdateMessageSendSucceeded ();
  var->ID = CODE_UpdateMessageSendSucceeded;
  var->refcnt = 1;
  var->message_ = message_;
  var->old_message_id_ = old_message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateMessageSendSucceeded> TdConvertToInternal (struct TdUpdateMessageSendSucceeded *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::message> v0;
  v0 = TdConvertToInternal (var->message_);
  std::int64_t v100;
  v100 = var->old_message_id_;
  return td::td_api::make_object<td::td_api::updateMessageSendSucceeded>(std::move (v0), std::move (v100));
}
struct TdUpdateMessageSendSucceeded *TdConvertFromInternal (const td::td_api::updateMessageSendSucceeded &from) {
  auto res = new TdUpdateMessageSendSucceeded ();
  res->ID = CODE_UpdateMessageSendSucceeded;
  res->refcnt = 1;
  if (!from.message_) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.message_));
  }
  res->old_message_id_ = from.old_message_id_;
  return res;
}
char *TdSerializeUpdateMessageSendSucceeded (struct TdUpdateMessageSendSucceeded *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateMessageSendSucceeded *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateMessageSendSucceeded (struct TdUpdateMessageSendSucceeded *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateMessageSendSucceeded *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->message_);
  delete var;
}
void TdStackStorerUpdateMessageSendSucceeded (struct TdUpdateMessageSendSucceeded *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateMessageSendSucceeded *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateMessageSendSucceeded");
  M->new_field ("ID");
  TdStackStorer (var->message_, M);
  M->new_field ("message_");
  M->pack_long (var->old_message_id_);
  M->new_field ("old_message_id_");
}
struct TdUpdateMessageSendSucceeded *TdStackFetcherUpdateMessageSendSucceeded (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateMessageSendSucceeded ();
  res->ID = CODE_UpdateMessageSendSucceeded;
  res->refcnt = 1;
  M->get_field ("message_");
  if (M->is_nil ()) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  M->get_field ("old_message_id_");
  res->old_message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateMessageSendFailed *TdCreateObjectUpdateMessageSendFailed (struct TdMessage *message_, long long old_message_id_, int error_code_, char *error_message_) {
  auto var = new struct TdUpdateMessageSendFailed ();
  var->ID = CODE_UpdateMessageSendFailed;
  var->refcnt = 1;
  var->message_ = message_;
  var->old_message_id_ = old_message_id_;
  var->error_code_ = error_code_;
  var->error_message_ = (error_message_) ? td::str_dup (td::Slice (error_message_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::updateMessageSendFailed> TdConvertToInternal (struct TdUpdateMessageSendFailed *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::message> v0;
  v0 = TdConvertToInternal (var->message_);
  std::int64_t v100;
  v100 = var->old_message_id_;
  std::int32_t v200;
  v200 = var->error_code_;
  std::string v300;
  v300 = (var->error_message_) ? var->error_message_: "";
  return td::td_api::make_object<td::td_api::updateMessageSendFailed>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdUpdateMessageSendFailed *TdConvertFromInternal (const td::td_api::updateMessageSendFailed &from) {
  auto res = new TdUpdateMessageSendFailed ();
  res->ID = CODE_UpdateMessageSendFailed;
  res->refcnt = 1;
  if (!from.message_) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.message_));
  }
  res->old_message_id_ = from.old_message_id_;
  res->error_code_ = from.error_code_;
  res->error_message_ = (from.error_message_.length ()) ? td::str_dup (from.error_message_) : nullptr;
  return res;
}
char *TdSerializeUpdateMessageSendFailed (struct TdUpdateMessageSendFailed *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateMessageSendFailed *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateMessageSendFailed (struct TdUpdateMessageSendFailed *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateMessageSendFailed *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->message_);
  free (var->error_message_);
  delete var;
}
void TdStackStorerUpdateMessageSendFailed (struct TdUpdateMessageSendFailed *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateMessageSendFailed *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateMessageSendFailed");
  M->new_field ("ID");
  TdStackStorer (var->message_, M);
  M->new_field ("message_");
  M->pack_long (var->old_message_id_);
  M->new_field ("old_message_id_");
  M->pack_long (var->error_code_);
  M->new_field ("error_code_");
  M->pack_string (var->error_message_);
  M->new_field ("error_message_");
}
struct TdUpdateMessageSendFailed *TdStackFetcherUpdateMessageSendFailed (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateMessageSendFailed ();
  res->ID = CODE_UpdateMessageSendFailed;
  res->refcnt = 1;
  M->get_field ("message_");
  if (M->is_nil ()) {
    res->message_ = nullptr;
  } else {
    res->message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  M->get_field ("old_message_id_");
  res->old_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("error_code_");
  res->error_code_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("error_message_");
  res->error_message_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdUpdateMessageContent *TdCreateObjectUpdateMessageContent (long long chat_id_, long long message_id_, struct TdMessageContent *new_content_) {
  auto var = new struct TdUpdateMessageContent ();
  var->ID = CODE_UpdateMessageContent;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->new_content_ = new_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateMessageContent> TdConvertToInternal (struct TdUpdateMessageContent *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  td::td_api::object_ptr<td::td_api::MessageContent> v200;
  v200 = TdConvertToInternal (var->new_content_);
  return td::td_api::make_object<td::td_api::updateMessageContent>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateMessageContent *TdConvertFromInternal (const td::td_api::updateMessageContent &from) {
  auto res = new TdUpdateMessageContent ();
  res->ID = CODE_UpdateMessageContent;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  if (!from.new_content_) {
    res->new_content_ = nullptr;
  } else {
    res->new_content_ = TdConvertFromInternal (static_cast<const td::td_api::MessageContent &>(*from.new_content_));
  }
  return res;
}
char *TdSerializeUpdateMessageContent (struct TdUpdateMessageContent *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateMessageContent *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateMessageContent (struct TdUpdateMessageContent *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateMessageContent *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->new_content_);
  delete var;
}
void TdStackStorerUpdateMessageContent (struct TdUpdateMessageContent *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateMessageContent *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateMessageContent");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  TdStackStorer (var->new_content_, M);
  M->new_field ("new_content_");
}
struct TdUpdateMessageContent *TdStackFetcherUpdateMessageContent (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateMessageContent ();
  res->ID = CODE_UpdateMessageContent;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("new_content_");
  if (M->is_nil ()) {
    res->new_content_ = nullptr;
  } else {
    res->new_content_ = TdStackFetcherMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateMessageEdited *TdCreateObjectUpdateMessageEdited (long long chat_id_, long long message_id_, int edit_date_, struct TdReplyMarkup *reply_markup_) {
  auto var = new struct TdUpdateMessageEdited ();
  var->ID = CODE_UpdateMessageEdited;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->edit_date_ = edit_date_;
  var->reply_markup_ = reply_markup_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateMessageEdited> TdConvertToInternal (struct TdUpdateMessageEdited *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  std::int32_t v200;
  v200 = var->edit_date_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v300;
  v300 = TdConvertToInternal (var->reply_markup_);
  return td::td_api::make_object<td::td_api::updateMessageEdited>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdUpdateMessageEdited *TdConvertFromInternal (const td::td_api::updateMessageEdited &from) {
  auto res = new TdUpdateMessageEdited ();
  res->ID = CODE_UpdateMessageEdited;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  res->edit_date_ = from.edit_date_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  return res;
}
char *TdSerializeUpdateMessageEdited (struct TdUpdateMessageEdited *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateMessageEdited *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateMessageEdited (struct TdUpdateMessageEdited *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateMessageEdited *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reply_markup_);
  delete var;
}
void TdStackStorerUpdateMessageEdited (struct TdUpdateMessageEdited *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateMessageEdited *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateMessageEdited");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_long (var->edit_date_);
  M->new_field ("edit_date_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
}
struct TdUpdateMessageEdited *TdStackFetcherUpdateMessageEdited (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateMessageEdited ();
  res->ID = CODE_UpdateMessageEdited;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("edit_date_");
  res->edit_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateMessageViews *TdCreateObjectUpdateMessageViews (long long chat_id_, long long message_id_, int views_) {
  auto var = new struct TdUpdateMessageViews ();
  var->ID = CODE_UpdateMessageViews;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->views_ = views_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateMessageViews> TdConvertToInternal (struct TdUpdateMessageViews *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  std::int32_t v200;
  v200 = var->views_;
  return td::td_api::make_object<td::td_api::updateMessageViews>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateMessageViews *TdConvertFromInternal (const td::td_api::updateMessageViews &from) {
  auto res = new TdUpdateMessageViews ();
  res->ID = CODE_UpdateMessageViews;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  res->views_ = from.views_;
  return res;
}
char *TdSerializeUpdateMessageViews (struct TdUpdateMessageViews *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateMessageViews *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateMessageViews (struct TdUpdateMessageViews *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateMessageViews *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateMessageViews (struct TdUpdateMessageViews *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateMessageViews *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateMessageViews");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_long (var->views_);
  M->new_field ("views_");
}
struct TdUpdateMessageViews *TdStackFetcherUpdateMessageViews (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateMessageViews ();
  res->ID = CODE_UpdateMessageViews;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("views_");
  res->views_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateMessageContentOpened *TdCreateObjectUpdateMessageContentOpened (long long chat_id_, long long message_id_) {
  auto var = new struct TdUpdateMessageContentOpened ();
  var->ID = CODE_UpdateMessageContentOpened;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateMessageContentOpened> TdConvertToInternal (struct TdUpdateMessageContentOpened *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  return td::td_api::make_object<td::td_api::updateMessageContentOpened>(std::move (v0), std::move (v100));
}
struct TdUpdateMessageContentOpened *TdConvertFromInternal (const td::td_api::updateMessageContentOpened &from) {
  auto res = new TdUpdateMessageContentOpened ();
  res->ID = CODE_UpdateMessageContentOpened;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeUpdateMessageContentOpened (struct TdUpdateMessageContentOpened *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateMessageContentOpened *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateMessageContentOpened (struct TdUpdateMessageContentOpened *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateMessageContentOpened *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateMessageContentOpened (struct TdUpdateMessageContentOpened *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateMessageContentOpened *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateMessageContentOpened");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdUpdateMessageContentOpened *TdStackFetcherUpdateMessageContentOpened (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateMessageContentOpened ();
  res->ID = CODE_UpdateMessageContentOpened;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateMessageMentionRead *TdCreateObjectUpdateMessageMentionRead (long long chat_id_, long long message_id_, int unread_mention_count_) {
  auto var = new struct TdUpdateMessageMentionRead ();
  var->ID = CODE_UpdateMessageMentionRead;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->unread_mention_count_ = unread_mention_count_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateMessageMentionRead> TdConvertToInternal (struct TdUpdateMessageMentionRead *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  std::int32_t v200;
  v200 = var->unread_mention_count_;
  return td::td_api::make_object<td::td_api::updateMessageMentionRead>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateMessageMentionRead *TdConvertFromInternal (const td::td_api::updateMessageMentionRead &from) {
  auto res = new TdUpdateMessageMentionRead ();
  res->ID = CODE_UpdateMessageMentionRead;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  res->unread_mention_count_ = from.unread_mention_count_;
  return res;
}
char *TdSerializeUpdateMessageMentionRead (struct TdUpdateMessageMentionRead *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateMessageMentionRead *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateMessageMentionRead (struct TdUpdateMessageMentionRead *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateMessageMentionRead *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateMessageMentionRead (struct TdUpdateMessageMentionRead *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateMessageMentionRead *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateMessageMentionRead");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_long (var->unread_mention_count_);
  M->new_field ("unread_mention_count_");
}
struct TdUpdateMessageMentionRead *TdStackFetcherUpdateMessageMentionRead (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateMessageMentionRead ();
  res->ID = CODE_UpdateMessageMentionRead;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("unread_mention_count_");
  res->unread_mention_count_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateNewChat *TdCreateObjectUpdateNewChat (struct TdChat *chat_) {
  auto var = new struct TdUpdateNewChat ();
  var->ID = CODE_UpdateNewChat;
  var->refcnt = 1;
  var->chat_ = chat_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewChat> TdConvertToInternal (struct TdUpdateNewChat *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::chat> v0;
  v0 = TdConvertToInternal (var->chat_);
  return td::td_api::make_object<td::td_api::updateNewChat>(std::move (v0));
}
struct TdUpdateNewChat *TdConvertFromInternal (const td::td_api::updateNewChat &from) {
  auto res = new TdUpdateNewChat ();
  res->ID = CODE_UpdateNewChat;
  res->refcnt = 1;
  if (!from.chat_) {
    res->chat_ = nullptr;
  } else {
    res->chat_ = TdConvertFromInternal (static_cast<const td::td_api::chat &>(*from.chat_));
  }
  return res;
}
char *TdSerializeUpdateNewChat (struct TdUpdateNewChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewChat (struct TdUpdateNewChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->chat_);
  delete var;
}
void TdStackStorerUpdateNewChat (struct TdUpdateNewChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewChat");
  M->new_field ("ID");
  TdStackStorer (var->chat_, M);
  M->new_field ("chat_");
}
struct TdUpdateNewChat *TdStackFetcherUpdateNewChat (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewChat ();
  res->ID = CODE_UpdateNewChat;
  res->refcnt = 1;
  M->get_field ("chat_");
  if (M->is_nil ()) {
    res->chat_ = nullptr;
  } else {
    res->chat_ = TdStackFetcherChat (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateChatTitle *TdCreateObjectUpdateChatTitle (long long chat_id_, char *title_) {
  auto var = new struct TdUpdateChatTitle ();
  var->ID = CODE_UpdateChatTitle;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatTitle> TdConvertToInternal (struct TdUpdateChatTitle *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  return td::td_api::make_object<td::td_api::updateChatTitle>(std::move (v0), std::move (v100));
}
struct TdUpdateChatTitle *TdConvertFromInternal (const td::td_api::updateChatTitle &from) {
  auto res = new TdUpdateChatTitle ();
  res->ID = CODE_UpdateChatTitle;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  return res;
}
char *TdSerializeUpdateChatTitle (struct TdUpdateChatTitle *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatTitle *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatTitle (struct TdUpdateChatTitle *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatTitle *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  delete var;
}
void TdStackStorerUpdateChatTitle (struct TdUpdateChatTitle *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatTitle *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatTitle");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
}
struct TdUpdateChatTitle *TdStackFetcherUpdateChatTitle (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatTitle ();
  res->ID = CODE_UpdateChatTitle;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdUpdateChatPhoto *TdCreateObjectUpdateChatPhoto (long long chat_id_, struct TdChatPhoto *photo_) {
  auto var = new struct TdUpdateChatPhoto ();
  var->ID = CODE_UpdateChatPhoto;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->photo_ = photo_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatPhoto> TdConvertToInternal (struct TdUpdateChatPhoto *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::chatPhoto> v100;
  v100 = TdConvertToInternal (var->photo_);
  return td::td_api::make_object<td::td_api::updateChatPhoto>(std::move (v0), std::move (v100));
}
struct TdUpdateChatPhoto *TdConvertFromInternal (const td::td_api::updateChatPhoto &from) {
  auto res = new TdUpdateChatPhoto ();
  res->ID = CODE_UpdateChatPhoto;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::chatPhoto &>(*from.photo_));
  }
  return res;
}
char *TdSerializeUpdateChatPhoto (struct TdUpdateChatPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatPhoto (struct TdUpdateChatPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->photo_);
  delete var;
}
void TdStackStorerUpdateChatPhoto (struct TdUpdateChatPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatPhoto");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
}
struct TdUpdateChatPhoto *TdStackFetcherUpdateChatPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatPhoto ();
  res->ID = CODE_UpdateChatPhoto;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherChatPhoto (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateChatLastMessage *TdCreateObjectUpdateChatLastMessage (long long chat_id_, struct TdMessage *last_message_, long long order_) {
  auto var = new struct TdUpdateChatLastMessage ();
  var->ID = CODE_UpdateChatLastMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->last_message_ = last_message_;
  var->order_ = order_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatLastMessage> TdConvertToInternal (struct TdUpdateChatLastMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::message> v100;
  v100 = TdConvertToInternal (var->last_message_);
  std::int64_t v200;
  v200 = var->order_;
  return td::td_api::make_object<td::td_api::updateChatLastMessage>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateChatLastMessage *TdConvertFromInternal (const td::td_api::updateChatLastMessage &from) {
  auto res = new TdUpdateChatLastMessage ();
  res->ID = CODE_UpdateChatLastMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.last_message_) {
    res->last_message_ = nullptr;
  } else {
    res->last_message_ = TdConvertFromInternal (static_cast<const td::td_api::message &>(*from.last_message_));
  }
  res->order_ = from.order_;
  return res;
}
char *TdSerializeUpdateChatLastMessage (struct TdUpdateChatLastMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatLastMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatLastMessage (struct TdUpdateChatLastMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatLastMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->last_message_);
  delete var;
}
void TdStackStorerUpdateChatLastMessage (struct TdUpdateChatLastMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatLastMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatLastMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->last_message_, M);
  M->new_field ("last_message_");
  M->pack_long (var->order_);
  M->new_field ("order_");
}
struct TdUpdateChatLastMessage *TdStackFetcherUpdateChatLastMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatLastMessage ();
  res->ID = CODE_UpdateChatLastMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("last_message_");
  if (M->is_nil ()) {
    res->last_message_ = nullptr;
  } else {
    res->last_message_ = TdStackFetcherMessage (M);
  }
  M->pop ();
  M->get_field ("order_");
  res->order_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatOrder *TdCreateObjectUpdateChatOrder (long long chat_id_, long long order_) {
  auto var = new struct TdUpdateChatOrder ();
  var->ID = CODE_UpdateChatOrder;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->order_ = order_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatOrder> TdConvertToInternal (struct TdUpdateChatOrder *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->order_;
  return td::td_api::make_object<td::td_api::updateChatOrder>(std::move (v0), std::move (v100));
}
struct TdUpdateChatOrder *TdConvertFromInternal (const td::td_api::updateChatOrder &from) {
  auto res = new TdUpdateChatOrder ();
  res->ID = CODE_UpdateChatOrder;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->order_ = from.order_;
  return res;
}
char *TdSerializeUpdateChatOrder (struct TdUpdateChatOrder *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatOrder *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatOrder (struct TdUpdateChatOrder *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatOrder *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatOrder (struct TdUpdateChatOrder *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatOrder *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatOrder");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->order_);
  M->new_field ("order_");
}
struct TdUpdateChatOrder *TdStackFetcherUpdateChatOrder (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatOrder ();
  res->ID = CODE_UpdateChatOrder;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("order_");
  res->order_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatIsPinned *TdCreateObjectUpdateChatIsPinned (long long chat_id_, int is_pinned_, long long order_) {
  auto var = new struct TdUpdateChatIsPinned ();
  var->ID = CODE_UpdateChatIsPinned;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->is_pinned_ = is_pinned_;
  var->order_ = order_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatIsPinned> TdConvertToInternal (struct TdUpdateChatIsPinned *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->is_pinned_ != 0;
  std::int64_t v200;
  v200 = var->order_;
  return td::td_api::make_object<td::td_api::updateChatIsPinned>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateChatIsPinned *TdConvertFromInternal (const td::td_api::updateChatIsPinned &from) {
  auto res = new TdUpdateChatIsPinned ();
  res->ID = CODE_UpdateChatIsPinned;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->is_pinned_ = from.is_pinned_;
  res->order_ = from.order_;
  return res;
}
char *TdSerializeUpdateChatIsPinned (struct TdUpdateChatIsPinned *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatIsPinned *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatIsPinned (struct TdUpdateChatIsPinned *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatIsPinned *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatIsPinned (struct TdUpdateChatIsPinned *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatIsPinned *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatIsPinned");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->is_pinned_);
  M->new_field ("is_pinned_");
  M->pack_long (var->order_);
  M->new_field ("order_");
}
struct TdUpdateChatIsPinned *TdStackFetcherUpdateChatIsPinned (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatIsPinned ();
  res->ID = CODE_UpdateChatIsPinned;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_pinned_");
  res->is_pinned_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("order_");
  res->order_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatIsMarkedAsUnread *TdCreateObjectUpdateChatIsMarkedAsUnread (long long chat_id_, int is_marked_as_unread_) {
  auto var = new struct TdUpdateChatIsMarkedAsUnread ();
  var->ID = CODE_UpdateChatIsMarkedAsUnread;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->is_marked_as_unread_ = is_marked_as_unread_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatIsMarkedAsUnread> TdConvertToInternal (struct TdUpdateChatIsMarkedAsUnread *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->is_marked_as_unread_ != 0;
  return td::td_api::make_object<td::td_api::updateChatIsMarkedAsUnread>(std::move (v0), std::move (v100));
}
struct TdUpdateChatIsMarkedAsUnread *TdConvertFromInternal (const td::td_api::updateChatIsMarkedAsUnread &from) {
  auto res = new TdUpdateChatIsMarkedAsUnread ();
  res->ID = CODE_UpdateChatIsMarkedAsUnread;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->is_marked_as_unread_ = from.is_marked_as_unread_;
  return res;
}
char *TdSerializeUpdateChatIsMarkedAsUnread (struct TdUpdateChatIsMarkedAsUnread *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatIsMarkedAsUnread *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatIsMarkedAsUnread (struct TdUpdateChatIsMarkedAsUnread *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatIsMarkedAsUnread *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatIsMarkedAsUnread (struct TdUpdateChatIsMarkedAsUnread *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatIsMarkedAsUnread *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatIsMarkedAsUnread");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->is_marked_as_unread_);
  M->new_field ("is_marked_as_unread_");
}
struct TdUpdateChatIsMarkedAsUnread *TdStackFetcherUpdateChatIsMarkedAsUnread (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatIsMarkedAsUnread ();
  res->ID = CODE_UpdateChatIsMarkedAsUnread;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_marked_as_unread_");
  res->is_marked_as_unread_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatIsSponsored *TdCreateObjectUpdateChatIsSponsored (long long chat_id_, int is_sponsored_, long long order_) {
  auto var = new struct TdUpdateChatIsSponsored ();
  var->ID = CODE_UpdateChatIsSponsored;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->is_sponsored_ = is_sponsored_;
  var->order_ = order_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatIsSponsored> TdConvertToInternal (struct TdUpdateChatIsSponsored *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->is_sponsored_ != 0;
  std::int64_t v200;
  v200 = var->order_;
  return td::td_api::make_object<td::td_api::updateChatIsSponsored>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateChatIsSponsored *TdConvertFromInternal (const td::td_api::updateChatIsSponsored &from) {
  auto res = new TdUpdateChatIsSponsored ();
  res->ID = CODE_UpdateChatIsSponsored;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->is_sponsored_ = from.is_sponsored_;
  res->order_ = from.order_;
  return res;
}
char *TdSerializeUpdateChatIsSponsored (struct TdUpdateChatIsSponsored *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatIsSponsored *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatIsSponsored (struct TdUpdateChatIsSponsored *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatIsSponsored *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatIsSponsored (struct TdUpdateChatIsSponsored *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatIsSponsored *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatIsSponsored");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->is_sponsored_);
  M->new_field ("is_sponsored_");
  M->pack_long (var->order_);
  M->new_field ("order_");
}
struct TdUpdateChatIsSponsored *TdStackFetcherUpdateChatIsSponsored (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatIsSponsored ();
  res->ID = CODE_UpdateChatIsSponsored;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_sponsored_");
  res->is_sponsored_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("order_");
  res->order_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatDefaultDisableNotification *TdCreateObjectUpdateChatDefaultDisableNotification (long long chat_id_, int default_disable_notification_) {
  auto var = new struct TdUpdateChatDefaultDisableNotification ();
  var->ID = CODE_UpdateChatDefaultDisableNotification;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->default_disable_notification_ = default_disable_notification_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatDefaultDisableNotification> TdConvertToInternal (struct TdUpdateChatDefaultDisableNotification *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->default_disable_notification_ != 0;
  return td::td_api::make_object<td::td_api::updateChatDefaultDisableNotification>(std::move (v0), std::move (v100));
}
struct TdUpdateChatDefaultDisableNotification *TdConvertFromInternal (const td::td_api::updateChatDefaultDisableNotification &from) {
  auto res = new TdUpdateChatDefaultDisableNotification ();
  res->ID = CODE_UpdateChatDefaultDisableNotification;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->default_disable_notification_ = from.default_disable_notification_;
  return res;
}
char *TdSerializeUpdateChatDefaultDisableNotification (struct TdUpdateChatDefaultDisableNotification *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatDefaultDisableNotification *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatDefaultDisableNotification (struct TdUpdateChatDefaultDisableNotification *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatDefaultDisableNotification *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatDefaultDisableNotification (struct TdUpdateChatDefaultDisableNotification *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatDefaultDisableNotification *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatDefaultDisableNotification");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->default_disable_notification_);
  M->new_field ("default_disable_notification_");
}
struct TdUpdateChatDefaultDisableNotification *TdStackFetcherUpdateChatDefaultDisableNotification (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatDefaultDisableNotification ();
  res->ID = CODE_UpdateChatDefaultDisableNotification;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("default_disable_notification_");
  res->default_disable_notification_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatReadInbox *TdCreateObjectUpdateChatReadInbox (long long chat_id_, long long last_read_inbox_message_id_, int unread_count_) {
  auto var = new struct TdUpdateChatReadInbox ();
  var->ID = CODE_UpdateChatReadInbox;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->last_read_inbox_message_id_ = last_read_inbox_message_id_;
  var->unread_count_ = unread_count_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatReadInbox> TdConvertToInternal (struct TdUpdateChatReadInbox *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->last_read_inbox_message_id_;
  std::int32_t v200;
  v200 = var->unread_count_;
  return td::td_api::make_object<td::td_api::updateChatReadInbox>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateChatReadInbox *TdConvertFromInternal (const td::td_api::updateChatReadInbox &from) {
  auto res = new TdUpdateChatReadInbox ();
  res->ID = CODE_UpdateChatReadInbox;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->last_read_inbox_message_id_ = from.last_read_inbox_message_id_;
  res->unread_count_ = from.unread_count_;
  return res;
}
char *TdSerializeUpdateChatReadInbox (struct TdUpdateChatReadInbox *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatReadInbox *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatReadInbox (struct TdUpdateChatReadInbox *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatReadInbox *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatReadInbox (struct TdUpdateChatReadInbox *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatReadInbox *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatReadInbox");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->last_read_inbox_message_id_);
  M->new_field ("last_read_inbox_message_id_");
  M->pack_long (var->unread_count_);
  M->new_field ("unread_count_");
}
struct TdUpdateChatReadInbox *TdStackFetcherUpdateChatReadInbox (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatReadInbox ();
  res->ID = CODE_UpdateChatReadInbox;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("last_read_inbox_message_id_");
  res->last_read_inbox_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("unread_count_");
  res->unread_count_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatReadOutbox *TdCreateObjectUpdateChatReadOutbox (long long chat_id_, long long last_read_outbox_message_id_) {
  auto var = new struct TdUpdateChatReadOutbox ();
  var->ID = CODE_UpdateChatReadOutbox;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->last_read_outbox_message_id_ = last_read_outbox_message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatReadOutbox> TdConvertToInternal (struct TdUpdateChatReadOutbox *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->last_read_outbox_message_id_;
  return td::td_api::make_object<td::td_api::updateChatReadOutbox>(std::move (v0), std::move (v100));
}
struct TdUpdateChatReadOutbox *TdConvertFromInternal (const td::td_api::updateChatReadOutbox &from) {
  auto res = new TdUpdateChatReadOutbox ();
  res->ID = CODE_UpdateChatReadOutbox;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->last_read_outbox_message_id_ = from.last_read_outbox_message_id_;
  return res;
}
char *TdSerializeUpdateChatReadOutbox (struct TdUpdateChatReadOutbox *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatReadOutbox *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatReadOutbox (struct TdUpdateChatReadOutbox *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatReadOutbox *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatReadOutbox (struct TdUpdateChatReadOutbox *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatReadOutbox *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatReadOutbox");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->last_read_outbox_message_id_);
  M->new_field ("last_read_outbox_message_id_");
}
struct TdUpdateChatReadOutbox *TdStackFetcherUpdateChatReadOutbox (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatReadOutbox ();
  res->ID = CODE_UpdateChatReadOutbox;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("last_read_outbox_message_id_");
  res->last_read_outbox_message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatUnreadMentionCount *TdCreateObjectUpdateChatUnreadMentionCount (long long chat_id_, int unread_mention_count_) {
  auto var = new struct TdUpdateChatUnreadMentionCount ();
  var->ID = CODE_UpdateChatUnreadMentionCount;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->unread_mention_count_ = unread_mention_count_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatUnreadMentionCount> TdConvertToInternal (struct TdUpdateChatUnreadMentionCount *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->unread_mention_count_;
  return td::td_api::make_object<td::td_api::updateChatUnreadMentionCount>(std::move (v0), std::move (v100));
}
struct TdUpdateChatUnreadMentionCount *TdConvertFromInternal (const td::td_api::updateChatUnreadMentionCount &from) {
  auto res = new TdUpdateChatUnreadMentionCount ();
  res->ID = CODE_UpdateChatUnreadMentionCount;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->unread_mention_count_ = from.unread_mention_count_;
  return res;
}
char *TdSerializeUpdateChatUnreadMentionCount (struct TdUpdateChatUnreadMentionCount *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatUnreadMentionCount *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatUnreadMentionCount (struct TdUpdateChatUnreadMentionCount *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatUnreadMentionCount *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatUnreadMentionCount (struct TdUpdateChatUnreadMentionCount *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatUnreadMentionCount *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatUnreadMentionCount");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->unread_mention_count_);
  M->new_field ("unread_mention_count_");
}
struct TdUpdateChatUnreadMentionCount *TdStackFetcherUpdateChatUnreadMentionCount (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatUnreadMentionCount ();
  res->ID = CODE_UpdateChatUnreadMentionCount;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("unread_mention_count_");
  res->unread_mention_count_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatNotificationSettings *TdCreateObjectUpdateChatNotificationSettings (long long chat_id_, struct TdChatNotificationSettings *notification_settings_) {
  auto var = new struct TdUpdateChatNotificationSettings ();
  var->ID = CODE_UpdateChatNotificationSettings;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->notification_settings_ = notification_settings_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatNotificationSettings> TdConvertToInternal (struct TdUpdateChatNotificationSettings *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::chatNotificationSettings> v100;
  v100 = TdConvertToInternal (var->notification_settings_);
  return td::td_api::make_object<td::td_api::updateChatNotificationSettings>(std::move (v0), std::move (v100));
}
struct TdUpdateChatNotificationSettings *TdConvertFromInternal (const td::td_api::updateChatNotificationSettings &from) {
  auto res = new TdUpdateChatNotificationSettings ();
  res->ID = CODE_UpdateChatNotificationSettings;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.notification_settings_) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdConvertFromInternal (static_cast<const td::td_api::chatNotificationSettings &>(*from.notification_settings_));
  }
  return res;
}
char *TdSerializeUpdateChatNotificationSettings (struct TdUpdateChatNotificationSettings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatNotificationSettings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatNotificationSettings (struct TdUpdateChatNotificationSettings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatNotificationSettings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->notification_settings_);
  delete var;
}
void TdStackStorerUpdateChatNotificationSettings (struct TdUpdateChatNotificationSettings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatNotificationSettings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatNotificationSettings");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->notification_settings_, M);
  M->new_field ("notification_settings_");
}
struct TdUpdateChatNotificationSettings *TdStackFetcherUpdateChatNotificationSettings (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatNotificationSettings ();
  res->ID = CODE_UpdateChatNotificationSettings;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("notification_settings_");
  if (M->is_nil ()) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdStackFetcherChatNotificationSettings (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateScopeNotificationSettings *TdCreateObjectUpdateScopeNotificationSettings (struct TdNotificationSettingsScope *scope_, struct TdScopeNotificationSettings *notification_settings_) {
  auto var = new struct TdUpdateScopeNotificationSettings ();
  var->ID = CODE_UpdateScopeNotificationSettings;
  var->refcnt = 1;
  var->scope_ = scope_;
  var->notification_settings_ = notification_settings_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateScopeNotificationSettings> TdConvertToInternal (struct TdUpdateScopeNotificationSettings *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::NotificationSettingsScope> v0;
  v0 = TdConvertToInternal (var->scope_);
  td::td_api::object_ptr<td::td_api::scopeNotificationSettings> v100;
  v100 = TdConvertToInternal (var->notification_settings_);
  return td::td_api::make_object<td::td_api::updateScopeNotificationSettings>(std::move (v0), std::move (v100));
}
struct TdUpdateScopeNotificationSettings *TdConvertFromInternal (const td::td_api::updateScopeNotificationSettings &from) {
  auto res = new TdUpdateScopeNotificationSettings ();
  res->ID = CODE_UpdateScopeNotificationSettings;
  res->refcnt = 1;
  if (!from.scope_) {
    res->scope_ = nullptr;
  } else {
    res->scope_ = TdConvertFromInternal (static_cast<const td::td_api::NotificationSettingsScope &>(*from.scope_));
  }
  if (!from.notification_settings_) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdConvertFromInternal (static_cast<const td::td_api::scopeNotificationSettings &>(*from.notification_settings_));
  }
  return res;
}
char *TdSerializeUpdateScopeNotificationSettings (struct TdUpdateScopeNotificationSettings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateScopeNotificationSettings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateScopeNotificationSettings (struct TdUpdateScopeNotificationSettings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateScopeNotificationSettings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->scope_);
  TdDestroyObject (var->notification_settings_);
  delete var;
}
void TdStackStorerUpdateScopeNotificationSettings (struct TdUpdateScopeNotificationSettings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateScopeNotificationSettings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateScopeNotificationSettings");
  M->new_field ("ID");
  TdStackStorer (var->scope_, M);
  M->new_field ("scope_");
  TdStackStorer (var->notification_settings_, M);
  M->new_field ("notification_settings_");
}
struct TdUpdateScopeNotificationSettings *TdStackFetcherUpdateScopeNotificationSettings (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateScopeNotificationSettings ();
  res->ID = CODE_UpdateScopeNotificationSettings;
  res->refcnt = 1;
  M->get_field ("scope_");
  if (M->is_nil ()) {
    res->scope_ = nullptr;
  } else {
    res->scope_ = TdStackFetcherNotificationSettingsScope (M);
  }
  M->pop ();
  M->get_field ("notification_settings_");
  if (M->is_nil ()) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdStackFetcherScopeNotificationSettings (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateChatReplyMarkup *TdCreateObjectUpdateChatReplyMarkup (long long chat_id_, long long reply_markup_message_id_) {
  auto var = new struct TdUpdateChatReplyMarkup ();
  var->ID = CODE_UpdateChatReplyMarkup;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->reply_markup_message_id_ = reply_markup_message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatReplyMarkup> TdConvertToInternal (struct TdUpdateChatReplyMarkup *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->reply_markup_message_id_;
  return td::td_api::make_object<td::td_api::updateChatReplyMarkup>(std::move (v0), std::move (v100));
}
struct TdUpdateChatReplyMarkup *TdConvertFromInternal (const td::td_api::updateChatReplyMarkup &from) {
  auto res = new TdUpdateChatReplyMarkup ();
  res->ID = CODE_UpdateChatReplyMarkup;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->reply_markup_message_id_ = from.reply_markup_message_id_;
  return res;
}
char *TdSerializeUpdateChatReplyMarkup (struct TdUpdateChatReplyMarkup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatReplyMarkup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatReplyMarkup (struct TdUpdateChatReplyMarkup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatReplyMarkup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateChatReplyMarkup (struct TdUpdateChatReplyMarkup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatReplyMarkup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatReplyMarkup");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->reply_markup_message_id_);
  M->new_field ("reply_markup_message_id_");
}
struct TdUpdateChatReplyMarkup *TdStackFetcherUpdateChatReplyMarkup (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatReplyMarkup ();
  res->ID = CODE_UpdateChatReplyMarkup;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_message_id_");
  res->reply_markup_message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateChatDraftMessage *TdCreateObjectUpdateChatDraftMessage (long long chat_id_, struct TdDraftMessage *draft_message_, long long order_) {
  auto var = new struct TdUpdateChatDraftMessage ();
  var->ID = CODE_UpdateChatDraftMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->draft_message_ = draft_message_;
  var->order_ = order_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateChatDraftMessage> TdConvertToInternal (struct TdUpdateChatDraftMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::draftMessage> v100;
  v100 = TdConvertToInternal (var->draft_message_);
  std::int64_t v200;
  v200 = var->order_;
  return td::td_api::make_object<td::td_api::updateChatDraftMessage>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateChatDraftMessage *TdConvertFromInternal (const td::td_api::updateChatDraftMessage &from) {
  auto res = new TdUpdateChatDraftMessage ();
  res->ID = CODE_UpdateChatDraftMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.draft_message_) {
    res->draft_message_ = nullptr;
  } else {
    res->draft_message_ = TdConvertFromInternal (static_cast<const td::td_api::draftMessage &>(*from.draft_message_));
  }
  res->order_ = from.order_;
  return res;
}
char *TdSerializeUpdateChatDraftMessage (struct TdUpdateChatDraftMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateChatDraftMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateChatDraftMessage (struct TdUpdateChatDraftMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateChatDraftMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->draft_message_);
  delete var;
}
void TdStackStorerUpdateChatDraftMessage (struct TdUpdateChatDraftMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateChatDraftMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateChatDraftMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->draft_message_, M);
  M->new_field ("draft_message_");
  M->pack_long (var->order_);
  M->new_field ("order_");
}
struct TdUpdateChatDraftMessage *TdStackFetcherUpdateChatDraftMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateChatDraftMessage ();
  res->ID = CODE_UpdateChatDraftMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("draft_message_");
  if (M->is_nil ()) {
    res->draft_message_ = nullptr;
  } else {
    res->draft_message_ = TdStackFetcherDraftMessage (M);
  }
  M->pop ();
  M->get_field ("order_");
  res->order_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateDeleteMessages *TdCreateObjectUpdateDeleteMessages (long long chat_id_, struct TdVectorLong *message_ids_, int is_permanent_, int from_cache_) {
  auto var = new struct TdUpdateDeleteMessages ();
  var->ID = CODE_UpdateDeleteMessages;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_ids_ = message_ids_;
  var->is_permanent_ = is_permanent_;
  var->from_cache_ = from_cache_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateDeleteMessages> TdConvertToInternal (struct TdUpdateDeleteMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::vector<std::int64_t> v100;
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
    std::int64_t v101;
    v101 = var->message_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  bool v200;
  v200 = var->is_permanent_ != 0;
  bool v300;
  v300 = var->from_cache_ != 0;
  return td::td_api::make_object<td::td_api::updateDeleteMessages>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdUpdateDeleteMessages *TdConvertFromInternal (const td::td_api::updateDeleteMessages &from) {
  auto res = new TdUpdateDeleteMessages ();
  res->ID = CODE_UpdateDeleteMessages;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = (int)from.message_ids_.size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i100 = 0; i100 < res->message_ids_->len; i100++) {
    res->message_ids_->data[i100] = from.message_ids_[i100];
  }
  res->is_permanent_ = from.is_permanent_;
  res->from_cache_ = from.from_cache_;
  return res;
}
char *TdSerializeUpdateDeleteMessages (struct TdUpdateDeleteMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateDeleteMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateDeleteMessages (struct TdUpdateDeleteMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateDeleteMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
  }
  delete[] var->message_ids_->data;
  delete var->message_ids_;
  delete var;
}
void TdStackStorerUpdateDeleteMessages (struct TdUpdateDeleteMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateDeleteMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateDeleteMessages");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
    M->pack_long (var->message_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("message_ids_");
  M->pack_bool (var->is_permanent_);
  M->new_field ("is_permanent_");
  M->pack_bool (var->from_cache_);
  M->new_field ("from_cache_");
}
struct TdUpdateDeleteMessages *TdStackFetcherUpdateDeleteMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateDeleteMessages ();
  res->ID = CODE_UpdateDeleteMessages;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_ids_");
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = M->get_arr_size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i100 = 0; i100 < res->message_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->message_ids_->data[i100] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("is_permanent_");
  res->is_permanent_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("from_cache_");
  res->from_cache_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateUserChatAction *TdCreateObjectUpdateUserChatAction (long long chat_id_, int user_id_, struct TdChatAction *action_) {
  auto var = new struct TdUpdateUserChatAction ();
  var->ID = CODE_UpdateUserChatAction;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->user_id_ = user_id_;
  var->action_ = action_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateUserChatAction> TdConvertToInternal (struct TdUpdateUserChatAction *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->user_id_;
  td::td_api::object_ptr<td::td_api::ChatAction> v200;
  v200 = TdConvertToInternal (var->action_);
  return td::td_api::make_object<td::td_api::updateUserChatAction>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateUserChatAction *TdConvertFromInternal (const td::td_api::updateUserChatAction &from) {
  auto res = new TdUpdateUserChatAction ();
  res->ID = CODE_UpdateUserChatAction;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->user_id_ = from.user_id_;
  if (!from.action_) {
    res->action_ = nullptr;
  } else {
    res->action_ = TdConvertFromInternal (static_cast<const td::td_api::ChatAction &>(*from.action_));
  }
  return res;
}
char *TdSerializeUpdateUserChatAction (struct TdUpdateUserChatAction *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateUserChatAction *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateUserChatAction (struct TdUpdateUserChatAction *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateUserChatAction *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->action_);
  delete var;
}
void TdStackStorerUpdateUserChatAction (struct TdUpdateUserChatAction *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateUserChatAction *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateUserChatAction");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->action_, M);
  M->new_field ("action_");
}
struct TdUpdateUserChatAction *TdStackFetcherUpdateUserChatAction (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateUserChatAction ();
  res->ID = CODE_UpdateUserChatAction;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("action_");
  if (M->is_nil ()) {
    res->action_ = nullptr;
  } else {
    res->action_ = TdStackFetcherChatAction (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateUserStatus *TdCreateObjectUpdateUserStatus (int user_id_, struct TdUserStatus *status_) {
  auto var = new struct TdUpdateUserStatus ();
  var->ID = CODE_UpdateUserStatus;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->status_ = status_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateUserStatus> TdConvertToInternal (struct TdUpdateUserStatus *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  td::td_api::object_ptr<td::td_api::UserStatus> v100;
  v100 = TdConvertToInternal (var->status_);
  return td::td_api::make_object<td::td_api::updateUserStatus>(std::move (v0), std::move (v100));
}
struct TdUpdateUserStatus *TdConvertFromInternal (const td::td_api::updateUserStatus &from) {
  auto res = new TdUpdateUserStatus ();
  res->ID = CODE_UpdateUserStatus;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  if (!from.status_) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdConvertFromInternal (static_cast<const td::td_api::UserStatus &>(*from.status_));
  }
  return res;
}
char *TdSerializeUpdateUserStatus (struct TdUpdateUserStatus *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateUserStatus *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateUserStatus (struct TdUpdateUserStatus *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateUserStatus *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->status_);
  delete var;
}
void TdStackStorerUpdateUserStatus (struct TdUpdateUserStatus *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateUserStatus *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateUserStatus");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->status_, M);
  M->new_field ("status_");
}
struct TdUpdateUserStatus *TdStackFetcherUpdateUserStatus (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateUserStatus ();
  res->ID = CODE_UpdateUserStatus;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("status_");
  if (M->is_nil ()) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdStackFetcherUserStatus (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateUser *TdCreateObjectUpdateUser (struct TdUser *user_) {
  auto var = new struct TdUpdateUser ();
  var->ID = CODE_UpdateUser;
  var->refcnt = 1;
  var->user_ = user_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateUser> TdConvertToInternal (struct TdUpdateUser *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::user> v0;
  v0 = TdConvertToInternal (var->user_);
  return td::td_api::make_object<td::td_api::updateUser>(std::move (v0));
}
struct TdUpdateUser *TdConvertFromInternal (const td::td_api::updateUser &from) {
  auto res = new TdUpdateUser ();
  res->ID = CODE_UpdateUser;
  res->refcnt = 1;
  if (!from.user_) {
    res->user_ = nullptr;
  } else {
    res->user_ = TdConvertFromInternal (static_cast<const td::td_api::user &>(*from.user_));
  }
  return res;
}
char *TdSerializeUpdateUser (struct TdUpdateUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateUser (struct TdUpdateUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->user_);
  delete var;
}
void TdStackStorerUpdateUser (struct TdUpdateUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateUser");
  M->new_field ("ID");
  TdStackStorer (var->user_, M);
  M->new_field ("user_");
}
struct TdUpdateUser *TdStackFetcherUpdateUser (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateUser ();
  res->ID = CODE_UpdateUser;
  res->refcnt = 1;
  M->get_field ("user_");
  if (M->is_nil ()) {
    res->user_ = nullptr;
  } else {
    res->user_ = TdStackFetcherUser (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateBasicGroup *TdCreateObjectUpdateBasicGroup (struct TdBasicGroup *basic_group_) {
  auto var = new struct TdUpdateBasicGroup ();
  var->ID = CODE_UpdateBasicGroup;
  var->refcnt = 1;
  var->basic_group_ = basic_group_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateBasicGroup> TdConvertToInternal (struct TdUpdateBasicGroup *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::basicGroup> v0;
  v0 = TdConvertToInternal (var->basic_group_);
  return td::td_api::make_object<td::td_api::updateBasicGroup>(std::move (v0));
}
struct TdUpdateBasicGroup *TdConvertFromInternal (const td::td_api::updateBasicGroup &from) {
  auto res = new TdUpdateBasicGroup ();
  res->ID = CODE_UpdateBasicGroup;
  res->refcnt = 1;
  if (!from.basic_group_) {
    res->basic_group_ = nullptr;
  } else {
    res->basic_group_ = TdConvertFromInternal (static_cast<const td::td_api::basicGroup &>(*from.basic_group_));
  }
  return res;
}
char *TdSerializeUpdateBasicGroup (struct TdUpdateBasicGroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateBasicGroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateBasicGroup (struct TdUpdateBasicGroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateBasicGroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->basic_group_);
  delete var;
}
void TdStackStorerUpdateBasicGroup (struct TdUpdateBasicGroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateBasicGroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateBasicGroup");
  M->new_field ("ID");
  TdStackStorer (var->basic_group_, M);
  M->new_field ("basic_group_");
}
struct TdUpdateBasicGroup *TdStackFetcherUpdateBasicGroup (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateBasicGroup ();
  res->ID = CODE_UpdateBasicGroup;
  res->refcnt = 1;
  M->get_field ("basic_group_");
  if (M->is_nil ()) {
    res->basic_group_ = nullptr;
  } else {
    res->basic_group_ = TdStackFetcherBasicGroup (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateSupergroup *TdCreateObjectUpdateSupergroup (struct TdSupergroup *supergroup_) {
  auto var = new struct TdUpdateSupergroup ();
  var->ID = CODE_UpdateSupergroup;
  var->refcnt = 1;
  var->supergroup_ = supergroup_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateSupergroup> TdConvertToInternal (struct TdUpdateSupergroup *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::supergroup> v0;
  v0 = TdConvertToInternal (var->supergroup_);
  return td::td_api::make_object<td::td_api::updateSupergroup>(std::move (v0));
}
struct TdUpdateSupergroup *TdConvertFromInternal (const td::td_api::updateSupergroup &from) {
  auto res = new TdUpdateSupergroup ();
  res->ID = CODE_UpdateSupergroup;
  res->refcnt = 1;
  if (!from.supergroup_) {
    res->supergroup_ = nullptr;
  } else {
    res->supergroup_ = TdConvertFromInternal (static_cast<const td::td_api::supergroup &>(*from.supergroup_));
  }
  return res;
}
char *TdSerializeUpdateSupergroup (struct TdUpdateSupergroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateSupergroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateSupergroup (struct TdUpdateSupergroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateSupergroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->supergroup_);
  delete var;
}
void TdStackStorerUpdateSupergroup (struct TdUpdateSupergroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateSupergroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateSupergroup");
  M->new_field ("ID");
  TdStackStorer (var->supergroup_, M);
  M->new_field ("supergroup_");
}
struct TdUpdateSupergroup *TdStackFetcherUpdateSupergroup (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateSupergroup ();
  res->ID = CODE_UpdateSupergroup;
  res->refcnt = 1;
  M->get_field ("supergroup_");
  if (M->is_nil ()) {
    res->supergroup_ = nullptr;
  } else {
    res->supergroup_ = TdStackFetcherSupergroup (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateSecretChat *TdCreateObjectUpdateSecretChat (struct TdSecretChat *secret_chat_) {
  auto var = new struct TdUpdateSecretChat ();
  var->ID = CODE_UpdateSecretChat;
  var->refcnt = 1;
  var->secret_chat_ = secret_chat_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateSecretChat> TdConvertToInternal (struct TdUpdateSecretChat *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::secretChat> v0;
  v0 = TdConvertToInternal (var->secret_chat_);
  return td::td_api::make_object<td::td_api::updateSecretChat>(std::move (v0));
}
struct TdUpdateSecretChat *TdConvertFromInternal (const td::td_api::updateSecretChat &from) {
  auto res = new TdUpdateSecretChat ();
  res->ID = CODE_UpdateSecretChat;
  res->refcnt = 1;
  if (!from.secret_chat_) {
    res->secret_chat_ = nullptr;
  } else {
    res->secret_chat_ = TdConvertFromInternal (static_cast<const td::td_api::secretChat &>(*from.secret_chat_));
  }
  return res;
}
char *TdSerializeUpdateSecretChat (struct TdUpdateSecretChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateSecretChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateSecretChat (struct TdUpdateSecretChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateSecretChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->secret_chat_);
  delete var;
}
void TdStackStorerUpdateSecretChat (struct TdUpdateSecretChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateSecretChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateSecretChat");
  M->new_field ("ID");
  TdStackStorer (var->secret_chat_, M);
  M->new_field ("secret_chat_");
}
struct TdUpdateSecretChat *TdStackFetcherUpdateSecretChat (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateSecretChat ();
  res->ID = CODE_UpdateSecretChat;
  res->refcnt = 1;
  M->get_field ("secret_chat_");
  if (M->is_nil ()) {
    res->secret_chat_ = nullptr;
  } else {
    res->secret_chat_ = TdStackFetcherSecretChat (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateUserFullInfo *TdCreateObjectUpdateUserFullInfo (int user_id_, struct TdUserFullInfo *user_full_info_) {
  auto var = new struct TdUpdateUserFullInfo ();
  var->ID = CODE_UpdateUserFullInfo;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->user_full_info_ = user_full_info_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateUserFullInfo> TdConvertToInternal (struct TdUpdateUserFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  td::td_api::object_ptr<td::td_api::userFullInfo> v100;
  v100 = TdConvertToInternal (var->user_full_info_);
  return td::td_api::make_object<td::td_api::updateUserFullInfo>(std::move (v0), std::move (v100));
}
struct TdUpdateUserFullInfo *TdConvertFromInternal (const td::td_api::updateUserFullInfo &from) {
  auto res = new TdUpdateUserFullInfo ();
  res->ID = CODE_UpdateUserFullInfo;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  if (!from.user_full_info_) {
    res->user_full_info_ = nullptr;
  } else {
    res->user_full_info_ = TdConvertFromInternal (static_cast<const td::td_api::userFullInfo &>(*from.user_full_info_));
  }
  return res;
}
char *TdSerializeUpdateUserFullInfo (struct TdUpdateUserFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateUserFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateUserFullInfo (struct TdUpdateUserFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateUserFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->user_full_info_);
  delete var;
}
void TdStackStorerUpdateUserFullInfo (struct TdUpdateUserFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateUserFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateUserFullInfo");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->user_full_info_, M);
  M->new_field ("user_full_info_");
}
struct TdUpdateUserFullInfo *TdStackFetcherUpdateUserFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateUserFullInfo ();
  res->ID = CODE_UpdateUserFullInfo;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_full_info_");
  if (M->is_nil ()) {
    res->user_full_info_ = nullptr;
  } else {
    res->user_full_info_ = TdStackFetcherUserFullInfo (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateBasicGroupFullInfo *TdCreateObjectUpdateBasicGroupFullInfo (int basic_group_id_, struct TdBasicGroupFullInfo *basic_group_full_info_) {
  auto var = new struct TdUpdateBasicGroupFullInfo ();
  var->ID = CODE_UpdateBasicGroupFullInfo;
  var->refcnt = 1;
  var->basic_group_id_ = basic_group_id_;
  var->basic_group_full_info_ = basic_group_full_info_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateBasicGroupFullInfo> TdConvertToInternal (struct TdUpdateBasicGroupFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->basic_group_id_;
  td::td_api::object_ptr<td::td_api::basicGroupFullInfo> v100;
  v100 = TdConvertToInternal (var->basic_group_full_info_);
  return td::td_api::make_object<td::td_api::updateBasicGroupFullInfo>(std::move (v0), std::move (v100));
}
struct TdUpdateBasicGroupFullInfo *TdConvertFromInternal (const td::td_api::updateBasicGroupFullInfo &from) {
  auto res = new TdUpdateBasicGroupFullInfo ();
  res->ID = CODE_UpdateBasicGroupFullInfo;
  res->refcnt = 1;
  res->basic_group_id_ = from.basic_group_id_;
  if (!from.basic_group_full_info_) {
    res->basic_group_full_info_ = nullptr;
  } else {
    res->basic_group_full_info_ = TdConvertFromInternal (static_cast<const td::td_api::basicGroupFullInfo &>(*from.basic_group_full_info_));
  }
  return res;
}
char *TdSerializeUpdateBasicGroupFullInfo (struct TdUpdateBasicGroupFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateBasicGroupFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateBasicGroupFullInfo (struct TdUpdateBasicGroupFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateBasicGroupFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->basic_group_full_info_);
  delete var;
}
void TdStackStorerUpdateBasicGroupFullInfo (struct TdUpdateBasicGroupFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateBasicGroupFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateBasicGroupFullInfo");
  M->new_field ("ID");
  M->pack_long (var->basic_group_id_);
  M->new_field ("basic_group_id_");
  TdStackStorer (var->basic_group_full_info_, M);
  M->new_field ("basic_group_full_info_");
}
struct TdUpdateBasicGroupFullInfo *TdStackFetcherUpdateBasicGroupFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateBasicGroupFullInfo ();
  res->ID = CODE_UpdateBasicGroupFullInfo;
  res->refcnt = 1;
  M->get_field ("basic_group_id_");
  res->basic_group_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("basic_group_full_info_");
  if (M->is_nil ()) {
    res->basic_group_full_info_ = nullptr;
  } else {
    res->basic_group_full_info_ = TdStackFetcherBasicGroupFullInfo (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateSupergroupFullInfo *TdCreateObjectUpdateSupergroupFullInfo (int supergroup_id_, struct TdSupergroupFullInfo *supergroup_full_info_) {
  auto var = new struct TdUpdateSupergroupFullInfo ();
  var->ID = CODE_UpdateSupergroupFullInfo;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->supergroup_full_info_ = supergroup_full_info_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateSupergroupFullInfo> TdConvertToInternal (struct TdUpdateSupergroupFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  td::td_api::object_ptr<td::td_api::supergroupFullInfo> v100;
  v100 = TdConvertToInternal (var->supergroup_full_info_);
  return td::td_api::make_object<td::td_api::updateSupergroupFullInfo>(std::move (v0), std::move (v100));
}
struct TdUpdateSupergroupFullInfo *TdConvertFromInternal (const td::td_api::updateSupergroupFullInfo &from) {
  auto res = new TdUpdateSupergroupFullInfo ();
  res->ID = CODE_UpdateSupergroupFullInfo;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  if (!from.supergroup_full_info_) {
    res->supergroup_full_info_ = nullptr;
  } else {
    res->supergroup_full_info_ = TdConvertFromInternal (static_cast<const td::td_api::supergroupFullInfo &>(*from.supergroup_full_info_));
  }
  return res;
}
char *TdSerializeUpdateSupergroupFullInfo (struct TdUpdateSupergroupFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateSupergroupFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateSupergroupFullInfo (struct TdUpdateSupergroupFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateSupergroupFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->supergroup_full_info_);
  delete var;
}
void TdStackStorerUpdateSupergroupFullInfo (struct TdUpdateSupergroupFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateSupergroupFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateSupergroupFullInfo");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  TdStackStorer (var->supergroup_full_info_, M);
  M->new_field ("supergroup_full_info_");
}
struct TdUpdateSupergroupFullInfo *TdStackFetcherUpdateSupergroupFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateSupergroupFullInfo ();
  res->ID = CODE_UpdateSupergroupFullInfo;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("supergroup_full_info_");
  if (M->is_nil ()) {
    res->supergroup_full_info_ = nullptr;
  } else {
    res->supergroup_full_info_ = TdStackFetcherSupergroupFullInfo (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateServiceNotification *TdCreateObjectUpdateServiceNotification (char *type_, struct TdMessageContent *content_) {
  auto var = new struct TdUpdateServiceNotification ();
  var->ID = CODE_UpdateServiceNotification;
  var->refcnt = 1;
  var->type_ = (type_) ? td::str_dup (td::Slice (type_)) : nullptr;
  var->content_ = content_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateServiceNotification> TdConvertToInternal (struct TdUpdateServiceNotification *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->type_) ? var->type_: "";
  td::td_api::object_ptr<td::td_api::MessageContent> v100;
  v100 = TdConvertToInternal (var->content_);
  return td::td_api::make_object<td::td_api::updateServiceNotification>(std::move (v0), std::move (v100));
}
struct TdUpdateServiceNotification *TdConvertFromInternal (const td::td_api::updateServiceNotification &from) {
  auto res = new TdUpdateServiceNotification ();
  res->ID = CODE_UpdateServiceNotification;
  res->refcnt = 1;
  res->type_ = (from.type_.length ()) ? td::str_dup (from.type_) : nullptr;
  if (!from.content_) {
    res->content_ = nullptr;
  } else {
    res->content_ = TdConvertFromInternal (static_cast<const td::td_api::MessageContent &>(*from.content_));
  }
  return res;
}
char *TdSerializeUpdateServiceNotification (struct TdUpdateServiceNotification *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateServiceNotification *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateServiceNotification (struct TdUpdateServiceNotification *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateServiceNotification *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->type_);
  TdDestroyObject (var->content_);
  delete var;
}
void TdStackStorerUpdateServiceNotification (struct TdUpdateServiceNotification *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateServiceNotification *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateServiceNotification");
  M->new_field ("ID");
  M->pack_string (var->type_);
  M->new_field ("type_");
  TdStackStorer (var->content_, M);
  M->new_field ("content_");
}
struct TdUpdateServiceNotification *TdStackFetcherUpdateServiceNotification (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateServiceNotification ();
  res->ID = CODE_UpdateServiceNotification;
  res->refcnt = 1;
  M->get_field ("type_");
  res->type_ = M->get_string ();
  M->pop ();
  M->get_field ("content_");
  if (M->is_nil ()) {
    res->content_ = nullptr;
  } else {
    res->content_ = TdStackFetcherMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateFile *TdCreateObjectUpdateFile (struct TdFile *file_) {
  auto var = new struct TdUpdateFile ();
  var->ID = CODE_UpdateFile;
  var->refcnt = 1;
  var->file_ = file_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateFile> TdConvertToInternal (struct TdUpdateFile *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::file> v0;
  v0 = TdConvertToInternal (var->file_);
  return td::td_api::make_object<td::td_api::updateFile>(std::move (v0));
}
struct TdUpdateFile *TdConvertFromInternal (const td::td_api::updateFile &from) {
  auto res = new TdUpdateFile ();
  res->ID = CODE_UpdateFile;
  res->refcnt = 1;
  if (!from.file_) {
    res->file_ = nullptr;
  } else {
    res->file_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.file_));
  }
  return res;
}
char *TdSerializeUpdateFile (struct TdUpdateFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateFile (struct TdUpdateFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->file_);
  delete var;
}
void TdStackStorerUpdateFile (struct TdUpdateFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateFile");
  M->new_field ("ID");
  TdStackStorer (var->file_, M);
  M->new_field ("file_");
}
struct TdUpdateFile *TdStackFetcherUpdateFile (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateFile ();
  res->ID = CODE_UpdateFile;
  res->refcnt = 1;
  M->get_field ("file_");
  if (M->is_nil ()) {
    res->file_ = nullptr;
  } else {
    res->file_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateFileGenerationStart *TdCreateObjectUpdateFileGenerationStart (long long generation_id_, char *original_path_, char *destination_path_, char *conversion_) {
  auto var = new struct TdUpdateFileGenerationStart ();
  var->ID = CODE_UpdateFileGenerationStart;
  var->refcnt = 1;
  var->generation_id_ = generation_id_;
  var->original_path_ = (original_path_) ? td::str_dup (td::Slice (original_path_)) : nullptr;
  var->destination_path_ = (destination_path_) ? td::str_dup (td::Slice (destination_path_)) : nullptr;
  var->conversion_ = (conversion_) ? td::str_dup (td::Slice (conversion_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::updateFileGenerationStart> TdConvertToInternal (struct TdUpdateFileGenerationStart *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->generation_id_;
  std::string v100;
  v100 = (var->original_path_) ? var->original_path_: "";
  std::string v200;
  v200 = (var->destination_path_) ? var->destination_path_: "";
  std::string v300;
  v300 = (var->conversion_) ? var->conversion_: "";
  return td::td_api::make_object<td::td_api::updateFileGenerationStart>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdUpdateFileGenerationStart *TdConvertFromInternal (const td::td_api::updateFileGenerationStart &from) {
  auto res = new TdUpdateFileGenerationStart ();
  res->ID = CODE_UpdateFileGenerationStart;
  res->refcnt = 1;
  res->generation_id_ = from.generation_id_;
  res->original_path_ = (from.original_path_.length ()) ? td::str_dup (from.original_path_) : nullptr;
  res->destination_path_ = (from.destination_path_.length ()) ? td::str_dup (from.destination_path_) : nullptr;
  res->conversion_ = (from.conversion_.length ()) ? td::str_dup (from.conversion_) : nullptr;
  return res;
}
char *TdSerializeUpdateFileGenerationStart (struct TdUpdateFileGenerationStart *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateFileGenerationStart *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateFileGenerationStart (struct TdUpdateFileGenerationStart *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateFileGenerationStart *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->original_path_);
  free (var->destination_path_);
  free (var->conversion_);
  delete var;
}
void TdStackStorerUpdateFileGenerationStart (struct TdUpdateFileGenerationStart *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateFileGenerationStart *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateFileGenerationStart");
  M->new_field ("ID");
  M->pack_long (var->generation_id_);
  M->new_field ("generation_id_");
  M->pack_string (var->original_path_);
  M->new_field ("original_path_");
  M->pack_string (var->destination_path_);
  M->new_field ("destination_path_");
  M->pack_string (var->conversion_);
  M->new_field ("conversion_");
}
struct TdUpdateFileGenerationStart *TdStackFetcherUpdateFileGenerationStart (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateFileGenerationStart ();
  res->ID = CODE_UpdateFileGenerationStart;
  res->refcnt = 1;
  M->get_field ("generation_id_");
  res->generation_id_ = M->get_long ();
  M->pop ();
  M->get_field ("original_path_");
  res->original_path_ = M->get_string ();
  M->pop ();
  M->get_field ("destination_path_");
  res->destination_path_ = M->get_string ();
  M->pop ();
  M->get_field ("conversion_");
  res->conversion_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdUpdateFileGenerationStop *TdCreateObjectUpdateFileGenerationStop (long long generation_id_) {
  auto var = new struct TdUpdateFileGenerationStop ();
  var->ID = CODE_UpdateFileGenerationStop;
  var->refcnt = 1;
  var->generation_id_ = generation_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateFileGenerationStop> TdConvertToInternal (struct TdUpdateFileGenerationStop *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->generation_id_;
  return td::td_api::make_object<td::td_api::updateFileGenerationStop>(std::move (v0));
}
struct TdUpdateFileGenerationStop *TdConvertFromInternal (const td::td_api::updateFileGenerationStop &from) {
  auto res = new TdUpdateFileGenerationStop ();
  res->ID = CODE_UpdateFileGenerationStop;
  res->refcnt = 1;
  res->generation_id_ = from.generation_id_;
  return res;
}
char *TdSerializeUpdateFileGenerationStop (struct TdUpdateFileGenerationStop *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateFileGenerationStop *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateFileGenerationStop (struct TdUpdateFileGenerationStop *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateFileGenerationStop *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateFileGenerationStop (struct TdUpdateFileGenerationStop *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateFileGenerationStop *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateFileGenerationStop");
  M->new_field ("ID");
  M->pack_long (var->generation_id_);
  M->new_field ("generation_id_");
}
struct TdUpdateFileGenerationStop *TdStackFetcherUpdateFileGenerationStop (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateFileGenerationStop ();
  res->ID = CODE_UpdateFileGenerationStop;
  res->refcnt = 1;
  M->get_field ("generation_id_");
  res->generation_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateCall *TdCreateObjectUpdateCall (struct TdCall *call_) {
  auto var = new struct TdUpdateCall ();
  var->ID = CODE_UpdateCall;
  var->refcnt = 1;
  var->call_ = call_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateCall> TdConvertToInternal (struct TdUpdateCall *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::call> v0;
  v0 = TdConvertToInternal (var->call_);
  return td::td_api::make_object<td::td_api::updateCall>(std::move (v0));
}
struct TdUpdateCall *TdConvertFromInternal (const td::td_api::updateCall &from) {
  auto res = new TdUpdateCall ();
  res->ID = CODE_UpdateCall;
  res->refcnt = 1;
  if (!from.call_) {
    res->call_ = nullptr;
  } else {
    res->call_ = TdConvertFromInternal (static_cast<const td::td_api::call &>(*from.call_));
  }
  return res;
}
char *TdSerializeUpdateCall (struct TdUpdateCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateCall (struct TdUpdateCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->call_);
  delete var;
}
void TdStackStorerUpdateCall (struct TdUpdateCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateCall");
  M->new_field ("ID");
  TdStackStorer (var->call_, M);
  M->new_field ("call_");
}
struct TdUpdateCall *TdStackFetcherUpdateCall (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateCall ();
  res->ID = CODE_UpdateCall;
  res->refcnt = 1;
  M->get_field ("call_");
  if (M->is_nil ()) {
    res->call_ = nullptr;
  } else {
    res->call_ = TdStackFetcherCall (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateUserPrivacySettingRules *TdCreateObjectUpdateUserPrivacySettingRules (struct TdUserPrivacySetting *setting_, struct TdUserPrivacySettingRules *rules_) {
  auto var = new struct TdUpdateUserPrivacySettingRules ();
  var->ID = CODE_UpdateUserPrivacySettingRules;
  var->refcnt = 1;
  var->setting_ = setting_;
  var->rules_ = rules_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateUserPrivacySettingRules> TdConvertToInternal (struct TdUpdateUserPrivacySettingRules *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::UserPrivacySetting> v0;
  v0 = TdConvertToInternal (var->setting_);
  td::td_api::object_ptr<td::td_api::userPrivacySettingRules> v100;
  v100 = TdConvertToInternal (var->rules_);
  return td::td_api::make_object<td::td_api::updateUserPrivacySettingRules>(std::move (v0), std::move (v100));
}
struct TdUpdateUserPrivacySettingRules *TdConvertFromInternal (const td::td_api::updateUserPrivacySettingRules &from) {
  auto res = new TdUpdateUserPrivacySettingRules ();
  res->ID = CODE_UpdateUserPrivacySettingRules;
  res->refcnt = 1;
  if (!from.setting_) {
    res->setting_ = nullptr;
  } else {
    res->setting_ = TdConvertFromInternal (static_cast<const td::td_api::UserPrivacySetting &>(*from.setting_));
  }
  if (!from.rules_) {
    res->rules_ = nullptr;
  } else {
    res->rules_ = TdConvertFromInternal (static_cast<const td::td_api::userPrivacySettingRules &>(*from.rules_));
  }
  return res;
}
char *TdSerializeUpdateUserPrivacySettingRules (struct TdUpdateUserPrivacySettingRules *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateUserPrivacySettingRules *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateUserPrivacySettingRules (struct TdUpdateUserPrivacySettingRules *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateUserPrivacySettingRules *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->setting_);
  TdDestroyObject (var->rules_);
  delete var;
}
void TdStackStorerUpdateUserPrivacySettingRules (struct TdUpdateUserPrivacySettingRules *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateUserPrivacySettingRules *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateUserPrivacySettingRules");
  M->new_field ("ID");
  TdStackStorer (var->setting_, M);
  M->new_field ("setting_");
  TdStackStorer (var->rules_, M);
  M->new_field ("rules_");
}
struct TdUpdateUserPrivacySettingRules *TdStackFetcherUpdateUserPrivacySettingRules (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateUserPrivacySettingRules ();
  res->ID = CODE_UpdateUserPrivacySettingRules;
  res->refcnt = 1;
  M->get_field ("setting_");
  if (M->is_nil ()) {
    res->setting_ = nullptr;
  } else {
    res->setting_ = TdStackFetcherUserPrivacySetting (M);
  }
  M->pop ();
  M->get_field ("rules_");
  if (M->is_nil ()) {
    res->rules_ = nullptr;
  } else {
    res->rules_ = TdStackFetcherUserPrivacySettingRules (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateUnreadMessageCount *TdCreateObjectUpdateUnreadMessageCount (int unread_count_, int unread_unmuted_count_) {
  auto var = new struct TdUpdateUnreadMessageCount ();
  var->ID = CODE_UpdateUnreadMessageCount;
  var->refcnt = 1;
  var->unread_count_ = unread_count_;
  var->unread_unmuted_count_ = unread_unmuted_count_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateUnreadMessageCount> TdConvertToInternal (struct TdUpdateUnreadMessageCount *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->unread_count_;
  std::int32_t v100;
  v100 = var->unread_unmuted_count_;
  return td::td_api::make_object<td::td_api::updateUnreadMessageCount>(std::move (v0), std::move (v100));
}
struct TdUpdateUnreadMessageCount *TdConvertFromInternal (const td::td_api::updateUnreadMessageCount &from) {
  auto res = new TdUpdateUnreadMessageCount ();
  res->ID = CODE_UpdateUnreadMessageCount;
  res->refcnt = 1;
  res->unread_count_ = from.unread_count_;
  res->unread_unmuted_count_ = from.unread_unmuted_count_;
  return res;
}
char *TdSerializeUpdateUnreadMessageCount (struct TdUpdateUnreadMessageCount *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateUnreadMessageCount *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateUnreadMessageCount (struct TdUpdateUnreadMessageCount *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateUnreadMessageCount *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateUnreadMessageCount (struct TdUpdateUnreadMessageCount *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateUnreadMessageCount *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateUnreadMessageCount");
  M->new_field ("ID");
  M->pack_long (var->unread_count_);
  M->new_field ("unread_count_");
  M->pack_long (var->unread_unmuted_count_);
  M->new_field ("unread_unmuted_count_");
}
struct TdUpdateUnreadMessageCount *TdStackFetcherUpdateUnreadMessageCount (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateUnreadMessageCount ();
  res->ID = CODE_UpdateUnreadMessageCount;
  res->refcnt = 1;
  M->get_field ("unread_count_");
  res->unread_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("unread_unmuted_count_");
  res->unread_unmuted_count_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateUnreadChatCount *TdCreateObjectUpdateUnreadChatCount (int unread_count_, int unread_unmuted_count_, int marked_as_unread_count_, int marked_as_unread_unmuted_count_) {
  auto var = new struct TdUpdateUnreadChatCount ();
  var->ID = CODE_UpdateUnreadChatCount;
  var->refcnt = 1;
  var->unread_count_ = unread_count_;
  var->unread_unmuted_count_ = unread_unmuted_count_;
  var->marked_as_unread_count_ = marked_as_unread_count_;
  var->marked_as_unread_unmuted_count_ = marked_as_unread_unmuted_count_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateUnreadChatCount> TdConvertToInternal (struct TdUpdateUnreadChatCount *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->unread_count_;
  std::int32_t v100;
  v100 = var->unread_unmuted_count_;
  std::int32_t v200;
  v200 = var->marked_as_unread_count_;
  std::int32_t v300;
  v300 = var->marked_as_unread_unmuted_count_;
  return td::td_api::make_object<td::td_api::updateUnreadChatCount>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdUpdateUnreadChatCount *TdConvertFromInternal (const td::td_api::updateUnreadChatCount &from) {
  auto res = new TdUpdateUnreadChatCount ();
  res->ID = CODE_UpdateUnreadChatCount;
  res->refcnt = 1;
  res->unread_count_ = from.unread_count_;
  res->unread_unmuted_count_ = from.unread_unmuted_count_;
  res->marked_as_unread_count_ = from.marked_as_unread_count_;
  res->marked_as_unread_unmuted_count_ = from.marked_as_unread_unmuted_count_;
  return res;
}
char *TdSerializeUpdateUnreadChatCount (struct TdUpdateUnreadChatCount *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateUnreadChatCount *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateUnreadChatCount (struct TdUpdateUnreadChatCount *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateUnreadChatCount *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpdateUnreadChatCount (struct TdUpdateUnreadChatCount *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateUnreadChatCount *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateUnreadChatCount");
  M->new_field ("ID");
  M->pack_long (var->unread_count_);
  M->new_field ("unread_count_");
  M->pack_long (var->unread_unmuted_count_);
  M->new_field ("unread_unmuted_count_");
  M->pack_long (var->marked_as_unread_count_);
  M->new_field ("marked_as_unread_count_");
  M->pack_long (var->marked_as_unread_unmuted_count_);
  M->new_field ("marked_as_unread_unmuted_count_");
}
struct TdUpdateUnreadChatCount *TdStackFetcherUpdateUnreadChatCount (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateUnreadChatCount ();
  res->ID = CODE_UpdateUnreadChatCount;
  res->refcnt = 1;
  M->get_field ("unread_count_");
  res->unread_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("unread_unmuted_count_");
  res->unread_unmuted_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("marked_as_unread_count_");
  res->marked_as_unread_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("marked_as_unread_unmuted_count_");
  res->marked_as_unread_unmuted_count_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpdateOption *TdCreateObjectUpdateOption (char *name_, struct TdOptionValue *value_) {
  auto var = new struct TdUpdateOption ();
  var->ID = CODE_UpdateOption;
  var->refcnt = 1;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateOption> TdConvertToInternal (struct TdUpdateOption *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->name_) ? var->name_: "";
  td::td_api::object_ptr<td::td_api::OptionValue> v100;
  v100 = TdConvertToInternal (var->value_);
  return td::td_api::make_object<td::td_api::updateOption>(std::move (v0), std::move (v100));
}
struct TdUpdateOption *TdConvertFromInternal (const td::td_api::updateOption &from) {
  auto res = new TdUpdateOption ();
  res->ID = CODE_UpdateOption;
  res->refcnt = 1;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  if (!from.value_) {
    res->value_ = nullptr;
  } else {
    res->value_ = TdConvertFromInternal (static_cast<const td::td_api::OptionValue &>(*from.value_));
  }
  return res;
}
char *TdSerializeUpdateOption (struct TdUpdateOption *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateOption *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateOption (struct TdUpdateOption *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateOption *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->name_);
  TdDestroyObject (var->value_);
  delete var;
}
void TdStackStorerUpdateOption (struct TdUpdateOption *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateOption *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateOption");
  M->new_field ("ID");
  M->pack_string (var->name_);
  M->new_field ("name_");
  TdStackStorer (var->value_, M);
  M->new_field ("value_");
}
struct TdUpdateOption *TdStackFetcherUpdateOption (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateOption ();
  res->ID = CODE_UpdateOption;
  res->refcnt = 1;
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  M->get_field ("value_");
  if (M->is_nil ()) {
    res->value_ = nullptr;
  } else {
    res->value_ = TdStackFetcherOptionValue (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateInstalledStickerSets *TdCreateObjectUpdateInstalledStickerSets (int is_masks_, struct TdVectorLong *sticker_set_ids_) {
  auto var = new struct TdUpdateInstalledStickerSets ();
  var->ID = CODE_UpdateInstalledStickerSets;
  var->refcnt = 1;
  var->is_masks_ = is_masks_;
  var->sticker_set_ids_ = sticker_set_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateInstalledStickerSets> TdConvertToInternal (struct TdUpdateInstalledStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_masks_ != 0;
  std::vector<std::int64_t> v100;
  for (int i100 = 0; i100 < var->sticker_set_ids_->len; i100++) {
    std::int64_t v101;
    v101 = var->sticker_set_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::updateInstalledStickerSets>(std::move (v0), std::move (v100));
}
struct TdUpdateInstalledStickerSets *TdConvertFromInternal (const td::td_api::updateInstalledStickerSets &from) {
  auto res = new TdUpdateInstalledStickerSets ();
  res->ID = CODE_UpdateInstalledStickerSets;
  res->refcnt = 1;
  res->is_masks_ = from.is_masks_;
  res->sticker_set_ids_ = new TdVectorLong ();
  res->sticker_set_ids_->len = (int)from.sticker_set_ids_.size ();
  res->sticker_set_ids_->data = new long long  [res->sticker_set_ids_->len];
  for (int i100 = 0; i100 < res->sticker_set_ids_->len; i100++) {
    res->sticker_set_ids_->data[i100] = from.sticker_set_ids_[i100];
  }
  return res;
}
char *TdSerializeUpdateInstalledStickerSets (struct TdUpdateInstalledStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateInstalledStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateInstalledStickerSets (struct TdUpdateInstalledStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateInstalledStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->sticker_set_ids_->len; i100++) {
  }
  delete[] var->sticker_set_ids_->data;
  delete var->sticker_set_ids_;
  delete var;
}
void TdStackStorerUpdateInstalledStickerSets (struct TdUpdateInstalledStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateInstalledStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateInstalledStickerSets");
  M->new_field ("ID");
  M->pack_bool (var->is_masks_);
  M->new_field ("is_masks_");
  M->new_array ();
  for (int i100 = 0; i100 < var->sticker_set_ids_->len; i100++) {
    M->pack_long (var->sticker_set_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("sticker_set_ids_");
}
struct TdUpdateInstalledStickerSets *TdStackFetcherUpdateInstalledStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateInstalledStickerSets ();
  res->ID = CODE_UpdateInstalledStickerSets;
  res->refcnt = 1;
  M->get_field ("is_masks_");
  res->is_masks_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sticker_set_ids_");
  res->sticker_set_ids_ = new TdVectorLong ();
  res->sticker_set_ids_->len = M->get_arr_size ();
  res->sticker_set_ids_->data = new long long  [res->sticker_set_ids_->len];
  for (int i100 = 0; i100 < res->sticker_set_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->sticker_set_ids_->data[i100] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdUpdateTrendingStickerSets *TdCreateObjectUpdateTrendingStickerSets (struct TdStickerSets *sticker_sets_) {
  auto var = new struct TdUpdateTrendingStickerSets ();
  var->ID = CODE_UpdateTrendingStickerSets;
  var->refcnt = 1;
  var->sticker_sets_ = sticker_sets_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateTrendingStickerSets> TdConvertToInternal (struct TdUpdateTrendingStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::stickerSets> v0;
  v0 = TdConvertToInternal (var->sticker_sets_);
  return td::td_api::make_object<td::td_api::updateTrendingStickerSets>(std::move (v0));
}
struct TdUpdateTrendingStickerSets *TdConvertFromInternal (const td::td_api::updateTrendingStickerSets &from) {
  auto res = new TdUpdateTrendingStickerSets ();
  res->ID = CODE_UpdateTrendingStickerSets;
  res->refcnt = 1;
  if (!from.sticker_sets_) {
    res->sticker_sets_ = nullptr;
  } else {
    res->sticker_sets_ = TdConvertFromInternal (static_cast<const td::td_api::stickerSets &>(*from.sticker_sets_));
  }
  return res;
}
char *TdSerializeUpdateTrendingStickerSets (struct TdUpdateTrendingStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateTrendingStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateTrendingStickerSets (struct TdUpdateTrendingStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateTrendingStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_sets_);
  delete var;
}
void TdStackStorerUpdateTrendingStickerSets (struct TdUpdateTrendingStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateTrendingStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateTrendingStickerSets");
  M->new_field ("ID");
  TdStackStorer (var->sticker_sets_, M);
  M->new_field ("sticker_sets_");
}
struct TdUpdateTrendingStickerSets *TdStackFetcherUpdateTrendingStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateTrendingStickerSets ();
  res->ID = CODE_UpdateTrendingStickerSets;
  res->refcnt = 1;
  M->get_field ("sticker_sets_");
  if (M->is_nil ()) {
    res->sticker_sets_ = nullptr;
  } else {
    res->sticker_sets_ = TdStackFetcherStickerSets (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateRecentStickers *TdCreateObjectUpdateRecentStickers (int is_attached_, struct TdVectorInt *sticker_ids_) {
  auto var = new struct TdUpdateRecentStickers ();
  var->ID = CODE_UpdateRecentStickers;
  var->refcnt = 1;
  var->is_attached_ = is_attached_;
  var->sticker_ids_ = sticker_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateRecentStickers> TdConvertToInternal (struct TdUpdateRecentStickers *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_attached_ != 0;
  std::vector<std::int32_t> v100;
  for (int i100 = 0; i100 < var->sticker_ids_->len; i100++) {
    std::int32_t v101;
    v101 = var->sticker_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::updateRecentStickers>(std::move (v0), std::move (v100));
}
struct TdUpdateRecentStickers *TdConvertFromInternal (const td::td_api::updateRecentStickers &from) {
  auto res = new TdUpdateRecentStickers ();
  res->ID = CODE_UpdateRecentStickers;
  res->refcnt = 1;
  res->is_attached_ = from.is_attached_;
  res->sticker_ids_ = new TdVectorInt ();
  res->sticker_ids_->len = (int)from.sticker_ids_.size ();
  res->sticker_ids_->data = new int  [res->sticker_ids_->len];
  for (int i100 = 0; i100 < res->sticker_ids_->len; i100++) {
    res->sticker_ids_->data[i100] = from.sticker_ids_[i100];
  }
  return res;
}
char *TdSerializeUpdateRecentStickers (struct TdUpdateRecentStickers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateRecentStickers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateRecentStickers (struct TdUpdateRecentStickers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateRecentStickers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->sticker_ids_->len; i100++) {
  }
  delete[] var->sticker_ids_->data;
  delete var->sticker_ids_;
  delete var;
}
void TdStackStorerUpdateRecentStickers (struct TdUpdateRecentStickers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateRecentStickers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateRecentStickers");
  M->new_field ("ID");
  M->pack_bool (var->is_attached_);
  M->new_field ("is_attached_");
  M->new_array ();
  for (int i100 = 0; i100 < var->sticker_ids_->len; i100++) {
    M->pack_long (var->sticker_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("sticker_ids_");
}
struct TdUpdateRecentStickers *TdStackFetcherUpdateRecentStickers (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateRecentStickers ();
  res->ID = CODE_UpdateRecentStickers;
  res->refcnt = 1;
  M->get_field ("is_attached_");
  res->is_attached_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sticker_ids_");
  res->sticker_ids_ = new TdVectorInt ();
  res->sticker_ids_->len = M->get_arr_size ();
  res->sticker_ids_->data = new int  [res->sticker_ids_->len];
  for (int i100 = 0; i100 < res->sticker_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->sticker_ids_->data[i100] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdUpdateFavoriteStickers *TdCreateObjectUpdateFavoriteStickers (struct TdVectorInt *sticker_ids_) {
  auto var = new struct TdUpdateFavoriteStickers ();
  var->ID = CODE_UpdateFavoriteStickers;
  var->refcnt = 1;
  var->sticker_ids_ = sticker_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateFavoriteStickers> TdConvertToInternal (struct TdUpdateFavoriteStickers *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->sticker_ids_->len; i0++) {
    std::int32_t v1;
    v1 = var->sticker_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::updateFavoriteStickers>(std::move (v0));
}
struct TdUpdateFavoriteStickers *TdConvertFromInternal (const td::td_api::updateFavoriteStickers &from) {
  auto res = new TdUpdateFavoriteStickers ();
  res->ID = CODE_UpdateFavoriteStickers;
  res->refcnt = 1;
  res->sticker_ids_ = new TdVectorInt ();
  res->sticker_ids_->len = (int)from.sticker_ids_.size ();
  res->sticker_ids_->data = new int  [res->sticker_ids_->len];
  for (int i0 = 0; i0 < res->sticker_ids_->len; i0++) {
    res->sticker_ids_->data[i0] = from.sticker_ids_[i0];
  }
  return res;
}
char *TdSerializeUpdateFavoriteStickers (struct TdUpdateFavoriteStickers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateFavoriteStickers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateFavoriteStickers (struct TdUpdateFavoriteStickers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateFavoriteStickers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->sticker_ids_->len; i0++) {
  }
  delete[] var->sticker_ids_->data;
  delete var->sticker_ids_;
  delete var;
}
void TdStackStorerUpdateFavoriteStickers (struct TdUpdateFavoriteStickers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateFavoriteStickers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateFavoriteStickers");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->sticker_ids_->len; i0++) {
    M->pack_long (var->sticker_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("sticker_ids_");
}
struct TdUpdateFavoriteStickers *TdStackFetcherUpdateFavoriteStickers (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateFavoriteStickers ();
  res->ID = CODE_UpdateFavoriteStickers;
  res->refcnt = 1;
  M->get_field ("sticker_ids_");
  res->sticker_ids_ = new TdVectorInt ();
  res->sticker_ids_->len = M->get_arr_size ();
  res->sticker_ids_->data = new int  [res->sticker_ids_->len];
  for (int i0 = 0; i0 < res->sticker_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->sticker_ids_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdUpdateSavedAnimations *TdCreateObjectUpdateSavedAnimations (struct TdVectorInt *animation_ids_) {
  auto var = new struct TdUpdateSavedAnimations ();
  var->ID = CODE_UpdateSavedAnimations;
  var->refcnt = 1;
  var->animation_ids_ = animation_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateSavedAnimations> TdConvertToInternal (struct TdUpdateSavedAnimations *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->animation_ids_->len; i0++) {
    std::int32_t v1;
    v1 = var->animation_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::updateSavedAnimations>(std::move (v0));
}
struct TdUpdateSavedAnimations *TdConvertFromInternal (const td::td_api::updateSavedAnimations &from) {
  auto res = new TdUpdateSavedAnimations ();
  res->ID = CODE_UpdateSavedAnimations;
  res->refcnt = 1;
  res->animation_ids_ = new TdVectorInt ();
  res->animation_ids_->len = (int)from.animation_ids_.size ();
  res->animation_ids_->data = new int  [res->animation_ids_->len];
  for (int i0 = 0; i0 < res->animation_ids_->len; i0++) {
    res->animation_ids_->data[i0] = from.animation_ids_[i0];
  }
  return res;
}
char *TdSerializeUpdateSavedAnimations (struct TdUpdateSavedAnimations *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateSavedAnimations *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateSavedAnimations (struct TdUpdateSavedAnimations *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateSavedAnimations *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->animation_ids_->len; i0++) {
  }
  delete[] var->animation_ids_->data;
  delete var->animation_ids_;
  delete var;
}
void TdStackStorerUpdateSavedAnimations (struct TdUpdateSavedAnimations *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateSavedAnimations *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateSavedAnimations");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->animation_ids_->len; i0++) {
    M->pack_long (var->animation_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("animation_ids_");
}
struct TdUpdateSavedAnimations *TdStackFetcherUpdateSavedAnimations (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateSavedAnimations ();
  res->ID = CODE_UpdateSavedAnimations;
  res->refcnt = 1;
  M->get_field ("animation_ids_");
  res->animation_ids_ = new TdVectorInt ();
  res->animation_ids_->len = M->get_arr_size ();
  res->animation_ids_->data = new int  [res->animation_ids_->len];
  for (int i0 = 0; i0 < res->animation_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->animation_ids_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdUpdateLanguagePackStrings *TdCreateObjectUpdateLanguagePackStrings (char *localization_target_, char *language_pack_id_, struct TdVectorLanguagePackString *strings_) {
  auto var = new struct TdUpdateLanguagePackStrings ();
  var->ID = CODE_UpdateLanguagePackStrings;
  var->refcnt = 1;
  var->localization_target_ = (localization_target_) ? td::str_dup (td::Slice (localization_target_)) : nullptr;
  var->language_pack_id_ = (language_pack_id_) ? td::str_dup (td::Slice (language_pack_id_)) : nullptr;
  var->strings_ = strings_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateLanguagePackStrings> TdConvertToInternal (struct TdUpdateLanguagePackStrings *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->localization_target_) ? var->localization_target_: "";
  std::string v100;
  v100 = (var->language_pack_id_) ? var->language_pack_id_: "";
  std::vector<td::td_api::object_ptr<td::td_api::languagePackString>> v200;
  for (int i200 = 0; i200 < var->strings_->len; i200++) {
    td::td_api::object_ptr<td::td_api::languagePackString> v201;
    v201 = TdConvertToInternal (var->strings_->data[i200]);
    v200.push_back (std::move (v201));
  }
  return td::td_api::make_object<td::td_api::updateLanguagePackStrings>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateLanguagePackStrings *TdConvertFromInternal (const td::td_api::updateLanguagePackStrings &from) {
  auto res = new TdUpdateLanguagePackStrings ();
  res->ID = CODE_UpdateLanguagePackStrings;
  res->refcnt = 1;
  res->localization_target_ = (from.localization_target_.length ()) ? td::str_dup (from.localization_target_) : nullptr;
  res->language_pack_id_ = (from.language_pack_id_.length ()) ? td::str_dup (from.language_pack_id_) : nullptr;
  res->strings_ = new TdVectorLanguagePackString ();
  res->strings_->len = (int)from.strings_.size ();
  res->strings_->data = new struct TdLanguagePackString * [res->strings_->len];
  for (int i200 = 0; i200 < res->strings_->len; i200++) {
    if (!from.strings_[i200]) {
      res->strings_->data[i200] = nullptr;
    } else {
      res->strings_->data[i200] = TdConvertFromInternal (static_cast<const td::td_api::languagePackString &>(*from.strings_[i200]));
    }
  }
  return res;
}
char *TdSerializeUpdateLanguagePackStrings (struct TdUpdateLanguagePackStrings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateLanguagePackStrings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateLanguagePackStrings (struct TdUpdateLanguagePackStrings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateLanguagePackStrings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->localization_target_);
  free (var->language_pack_id_);
  for (int i200 = 0; i200 < var->strings_->len; i200++) {
    TdDestroyObject (var->strings_->data[i200]);
  }
  delete[] var->strings_->data;
  delete var->strings_;
  delete var;
}
void TdStackStorerUpdateLanguagePackStrings (struct TdUpdateLanguagePackStrings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateLanguagePackStrings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateLanguagePackStrings");
  M->new_field ("ID");
  M->pack_string (var->localization_target_);
  M->new_field ("localization_target_");
  M->pack_string (var->language_pack_id_);
  M->new_field ("language_pack_id_");
  M->new_array ();
  for (int i200 = 0; i200 < var->strings_->len; i200++) {
    TdStackStorer (var->strings_->data[i200], M);
    M->new_arr_field (i200);
  }
  M->new_field ("strings_");
}
struct TdUpdateLanguagePackStrings *TdStackFetcherUpdateLanguagePackStrings (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateLanguagePackStrings ();
  res->ID = CODE_UpdateLanguagePackStrings;
  res->refcnt = 1;
  M->get_field ("localization_target_");
  res->localization_target_ = M->get_string ();
  M->pop ();
  M->get_field ("language_pack_id_");
  res->language_pack_id_ = M->get_string ();
  M->pop ();
  M->get_field ("strings_");
  res->strings_ = new TdVectorLanguagePackString ();
  res->strings_->len = M->get_arr_size ();
  res->strings_->data = new struct TdLanguagePackString * [res->strings_->len];
  for (int i200 = 0; i200 < res->strings_->len; i200++) {
    M->get_arr_field (i200);
    if (M->is_nil ()) {
      res->strings_->data[i200] = nullptr;
    } else {
      res->strings_->data[i200] = TdStackFetcherLanguagePackString (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdUpdateConnectionState *TdCreateObjectUpdateConnectionState (struct TdConnectionState *state_) {
  auto var = new struct TdUpdateConnectionState ();
  var->ID = CODE_UpdateConnectionState;
  var->refcnt = 1;
  var->state_ = state_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateConnectionState> TdConvertToInternal (struct TdUpdateConnectionState *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::ConnectionState> v0;
  v0 = TdConvertToInternal (var->state_);
  return td::td_api::make_object<td::td_api::updateConnectionState>(std::move (v0));
}
struct TdUpdateConnectionState *TdConvertFromInternal (const td::td_api::updateConnectionState &from) {
  auto res = new TdUpdateConnectionState ();
  res->ID = CODE_UpdateConnectionState;
  res->refcnt = 1;
  if (!from.state_) {
    res->state_ = nullptr;
  } else {
    res->state_ = TdConvertFromInternal (static_cast<const td::td_api::ConnectionState &>(*from.state_));
  }
  return res;
}
char *TdSerializeUpdateConnectionState (struct TdUpdateConnectionState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateConnectionState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateConnectionState (struct TdUpdateConnectionState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateConnectionState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->state_);
  delete var;
}
void TdStackStorerUpdateConnectionState (struct TdUpdateConnectionState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateConnectionState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateConnectionState");
  M->new_field ("ID");
  TdStackStorer (var->state_, M);
  M->new_field ("state_");
}
struct TdUpdateConnectionState *TdStackFetcherUpdateConnectionState (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateConnectionState ();
  res->ID = CODE_UpdateConnectionState;
  res->refcnt = 1;
  M->get_field ("state_");
  if (M->is_nil ()) {
    res->state_ = nullptr;
  } else {
    res->state_ = TdStackFetcherConnectionState (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateTermsOfService *TdCreateObjectUpdateTermsOfService (char *terms_of_service_id_, struct TdTermsOfService *terms_of_service_) {
  auto var = new struct TdUpdateTermsOfService ();
  var->ID = CODE_UpdateTermsOfService;
  var->refcnt = 1;
  var->terms_of_service_id_ = (terms_of_service_id_) ? td::str_dup (td::Slice (terms_of_service_id_)) : nullptr;
  var->terms_of_service_ = terms_of_service_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateTermsOfService> TdConvertToInternal (struct TdUpdateTermsOfService *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->terms_of_service_id_) ? var->terms_of_service_id_: "";
  td::td_api::object_ptr<td::td_api::termsOfService> v100;
  v100 = TdConvertToInternal (var->terms_of_service_);
  return td::td_api::make_object<td::td_api::updateTermsOfService>(std::move (v0), std::move (v100));
}
struct TdUpdateTermsOfService *TdConvertFromInternal (const td::td_api::updateTermsOfService &from) {
  auto res = new TdUpdateTermsOfService ();
  res->ID = CODE_UpdateTermsOfService;
  res->refcnt = 1;
  res->terms_of_service_id_ = (from.terms_of_service_id_.length ()) ? td::str_dup (from.terms_of_service_id_) : nullptr;
  if (!from.terms_of_service_) {
    res->terms_of_service_ = nullptr;
  } else {
    res->terms_of_service_ = TdConvertFromInternal (static_cast<const td::td_api::termsOfService &>(*from.terms_of_service_));
  }
  return res;
}
char *TdSerializeUpdateTermsOfService (struct TdUpdateTermsOfService *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateTermsOfService *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateTermsOfService (struct TdUpdateTermsOfService *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateTermsOfService *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->terms_of_service_id_);
  TdDestroyObject (var->terms_of_service_);
  delete var;
}
void TdStackStorerUpdateTermsOfService (struct TdUpdateTermsOfService *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateTermsOfService *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateTermsOfService");
  M->new_field ("ID");
  M->pack_string (var->terms_of_service_id_);
  M->new_field ("terms_of_service_id_");
  TdStackStorer (var->terms_of_service_, M);
  M->new_field ("terms_of_service_");
}
struct TdUpdateTermsOfService *TdStackFetcherUpdateTermsOfService (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateTermsOfService ();
  res->ID = CODE_UpdateTermsOfService;
  res->refcnt = 1;
  M->get_field ("terms_of_service_id_");
  res->terms_of_service_id_ = M->get_string ();
  M->pop ();
  M->get_field ("terms_of_service_");
  if (M->is_nil ()) {
    res->terms_of_service_ = nullptr;
  } else {
    res->terms_of_service_ = TdStackFetcherTermsOfService (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateNewInlineQuery *TdCreateObjectUpdateNewInlineQuery (long long id_, int sender_user_id_, struct TdLocation *user_location_, char *query_, char *offset_) {
  auto var = new struct TdUpdateNewInlineQuery ();
  var->ID = CODE_UpdateNewInlineQuery;
  var->refcnt = 1;
  var->id_ = id_;
  var->sender_user_id_ = sender_user_id_;
  var->user_location_ = user_location_;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->offset_ = (offset_) ? td::str_dup (td::Slice (offset_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewInlineQuery> TdConvertToInternal (struct TdUpdateNewInlineQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->sender_user_id_;
  td::td_api::object_ptr<td::td_api::location> v200;
  v200 = TdConvertToInternal (var->user_location_);
  std::string v300;
  v300 = (var->query_) ? var->query_: "";
  std::string v400;
  v400 = (var->offset_) ? var->offset_: "";
  return td::td_api::make_object<td::td_api::updateNewInlineQuery>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdUpdateNewInlineQuery *TdConvertFromInternal (const td::td_api::updateNewInlineQuery &from) {
  auto res = new TdUpdateNewInlineQuery ();
  res->ID = CODE_UpdateNewInlineQuery;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->sender_user_id_ = from.sender_user_id_;
  if (!from.user_location_) {
    res->user_location_ = nullptr;
  } else {
    res->user_location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.user_location_));
  }
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->offset_ = (from.offset_.length ()) ? td::str_dup (from.offset_) : nullptr;
  return res;
}
char *TdSerializeUpdateNewInlineQuery (struct TdUpdateNewInlineQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewInlineQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewInlineQuery (struct TdUpdateNewInlineQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewInlineQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->user_location_);
  free (var->query_);
  free (var->offset_);
  delete var;
}
void TdStackStorerUpdateNewInlineQuery (struct TdUpdateNewInlineQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewInlineQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewInlineQuery");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  TdStackStorer (var->user_location_, M);
  M->new_field ("user_location_");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_string (var->offset_);
  M->new_field ("offset_");
}
struct TdUpdateNewInlineQuery *TdStackFetcherUpdateNewInlineQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewInlineQuery ();
  res->ID = CODE_UpdateNewInlineQuery;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_location_");
  if (M->is_nil ()) {
    res->user_location_ = nullptr;
  } else {
    res->user_location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("offset_");
  res->offset_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdUpdateNewChosenInlineResult *TdCreateObjectUpdateNewChosenInlineResult (int sender_user_id_, struct TdLocation *user_location_, char *query_, char *result_id_, char *inline_message_id_) {
  auto var = new struct TdUpdateNewChosenInlineResult ();
  var->ID = CODE_UpdateNewChosenInlineResult;
  var->refcnt = 1;
  var->sender_user_id_ = sender_user_id_;
  var->user_location_ = user_location_;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->result_id_ = (result_id_) ? td::str_dup (td::Slice (result_id_)) : nullptr;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewChosenInlineResult> TdConvertToInternal (struct TdUpdateNewChosenInlineResult *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->sender_user_id_;
  td::td_api::object_ptr<td::td_api::location> v100;
  v100 = TdConvertToInternal (var->user_location_);
  std::string v200;
  v200 = (var->query_) ? var->query_: "";
  std::string v300;
  v300 = (var->result_id_) ? var->result_id_: "";
  std::string v400;
  v400 = (var->inline_message_id_) ? var->inline_message_id_: "";
  return td::td_api::make_object<td::td_api::updateNewChosenInlineResult>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdUpdateNewChosenInlineResult *TdConvertFromInternal (const td::td_api::updateNewChosenInlineResult &from) {
  auto res = new TdUpdateNewChosenInlineResult ();
  res->ID = CODE_UpdateNewChosenInlineResult;
  res->refcnt = 1;
  res->sender_user_id_ = from.sender_user_id_;
  if (!from.user_location_) {
    res->user_location_ = nullptr;
  } else {
    res->user_location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.user_location_));
  }
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->result_id_ = (from.result_id_.length ()) ? td::str_dup (from.result_id_) : nullptr;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  return res;
}
char *TdSerializeUpdateNewChosenInlineResult (struct TdUpdateNewChosenInlineResult *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewChosenInlineResult *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewChosenInlineResult (struct TdUpdateNewChosenInlineResult *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewChosenInlineResult *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->user_location_);
  free (var->query_);
  free (var->result_id_);
  free (var->inline_message_id_);
  delete var;
}
void TdStackStorerUpdateNewChosenInlineResult (struct TdUpdateNewChosenInlineResult *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewChosenInlineResult *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewChosenInlineResult");
  M->new_field ("ID");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  TdStackStorer (var->user_location_, M);
  M->new_field ("user_location_");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_string (var->result_id_);
  M->new_field ("result_id_");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
}
struct TdUpdateNewChosenInlineResult *TdStackFetcherUpdateNewChosenInlineResult (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewChosenInlineResult ();
  res->ID = CODE_UpdateNewChosenInlineResult;
  res->refcnt = 1;
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_location_");
  if (M->is_nil ()) {
    res->user_location_ = nullptr;
  } else {
    res->user_location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("result_id_");
  res->result_id_ = M->get_string ();
  M->pop ();
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdUpdateNewCallbackQuery *TdCreateObjectUpdateNewCallbackQuery (long long id_, int sender_user_id_, long long chat_id_, long long message_id_, long long chat_instance_, struct TdCallbackQueryPayload *payload_) {
  auto var = new struct TdUpdateNewCallbackQuery ();
  var->ID = CODE_UpdateNewCallbackQuery;
  var->refcnt = 1;
  var->id_ = id_;
  var->sender_user_id_ = sender_user_id_;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->chat_instance_ = chat_instance_;
  var->payload_ = payload_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewCallbackQuery> TdConvertToInternal (struct TdUpdateNewCallbackQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->sender_user_id_;
  std::int64_t v200;
  v200 = var->chat_id_;
  std::int64_t v300;
  v300 = var->message_id_;
  std::int64_t v400;
  v400 = var->chat_instance_;
  td::td_api::object_ptr<td::td_api::CallbackQueryPayload> v500;
  v500 = TdConvertToInternal (var->payload_);
  return td::td_api::make_object<td::td_api::updateNewCallbackQuery>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdUpdateNewCallbackQuery *TdConvertFromInternal (const td::td_api::updateNewCallbackQuery &from) {
  auto res = new TdUpdateNewCallbackQuery ();
  res->ID = CODE_UpdateNewCallbackQuery;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->sender_user_id_ = from.sender_user_id_;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  res->chat_instance_ = from.chat_instance_;
  if (!from.payload_) {
    res->payload_ = nullptr;
  } else {
    res->payload_ = TdConvertFromInternal (static_cast<const td::td_api::CallbackQueryPayload &>(*from.payload_));
  }
  return res;
}
char *TdSerializeUpdateNewCallbackQuery (struct TdUpdateNewCallbackQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewCallbackQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewCallbackQuery (struct TdUpdateNewCallbackQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewCallbackQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->payload_);
  delete var;
}
void TdStackStorerUpdateNewCallbackQuery (struct TdUpdateNewCallbackQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewCallbackQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewCallbackQuery");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_long (var->chat_instance_);
  M->new_field ("chat_instance_");
  TdStackStorer (var->payload_, M);
  M->new_field ("payload_");
}
struct TdUpdateNewCallbackQuery *TdStackFetcherUpdateNewCallbackQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewCallbackQuery ();
  res->ID = CODE_UpdateNewCallbackQuery;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("chat_instance_");
  res->chat_instance_ = M->get_long ();
  M->pop ();
  M->get_field ("payload_");
  if (M->is_nil ()) {
    res->payload_ = nullptr;
  } else {
    res->payload_ = TdStackFetcherCallbackQueryPayload (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateNewInlineCallbackQuery *TdCreateObjectUpdateNewInlineCallbackQuery (long long id_, int sender_user_id_, char *inline_message_id_, long long chat_instance_, struct TdCallbackQueryPayload *payload_) {
  auto var = new struct TdUpdateNewInlineCallbackQuery ();
  var->ID = CODE_UpdateNewInlineCallbackQuery;
  var->refcnt = 1;
  var->id_ = id_;
  var->sender_user_id_ = sender_user_id_;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  var->chat_instance_ = chat_instance_;
  var->payload_ = payload_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewInlineCallbackQuery> TdConvertToInternal (struct TdUpdateNewInlineCallbackQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->sender_user_id_;
  std::string v200;
  v200 = (var->inline_message_id_) ? var->inline_message_id_: "";
  std::int64_t v300;
  v300 = var->chat_instance_;
  td::td_api::object_ptr<td::td_api::CallbackQueryPayload> v400;
  v400 = TdConvertToInternal (var->payload_);
  return td::td_api::make_object<td::td_api::updateNewInlineCallbackQuery>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdUpdateNewInlineCallbackQuery *TdConvertFromInternal (const td::td_api::updateNewInlineCallbackQuery &from) {
  auto res = new TdUpdateNewInlineCallbackQuery ();
  res->ID = CODE_UpdateNewInlineCallbackQuery;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->sender_user_id_ = from.sender_user_id_;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  res->chat_instance_ = from.chat_instance_;
  if (!from.payload_) {
    res->payload_ = nullptr;
  } else {
    res->payload_ = TdConvertFromInternal (static_cast<const td::td_api::CallbackQueryPayload &>(*from.payload_));
  }
  return res;
}
char *TdSerializeUpdateNewInlineCallbackQuery (struct TdUpdateNewInlineCallbackQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewInlineCallbackQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewInlineCallbackQuery (struct TdUpdateNewInlineCallbackQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewInlineCallbackQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_message_id_);
  TdDestroyObject (var->payload_);
  delete var;
}
void TdStackStorerUpdateNewInlineCallbackQuery (struct TdUpdateNewInlineCallbackQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewInlineCallbackQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewInlineCallbackQuery");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
  M->pack_long (var->chat_instance_);
  M->new_field ("chat_instance_");
  TdStackStorer (var->payload_, M);
  M->new_field ("payload_");
}
struct TdUpdateNewInlineCallbackQuery *TdStackFetcherUpdateNewInlineCallbackQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewInlineCallbackQuery ();
  res->ID = CODE_UpdateNewInlineCallbackQuery;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  M->get_field ("chat_instance_");
  res->chat_instance_ = M->get_long ();
  M->pop ();
  M->get_field ("payload_");
  if (M->is_nil ()) {
    res->payload_ = nullptr;
  } else {
    res->payload_ = TdStackFetcherCallbackQueryPayload (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateNewShippingQuery *TdCreateObjectUpdateNewShippingQuery (long long id_, int sender_user_id_, char *invoice_payload_, struct TdAddress *shipping_address_) {
  auto var = new struct TdUpdateNewShippingQuery ();
  var->ID = CODE_UpdateNewShippingQuery;
  var->refcnt = 1;
  var->id_ = id_;
  var->sender_user_id_ = sender_user_id_;
  var->invoice_payload_ = (invoice_payload_) ? td::str_dup (td::Slice (invoice_payload_)) : nullptr;
  var->shipping_address_ = shipping_address_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewShippingQuery> TdConvertToInternal (struct TdUpdateNewShippingQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->sender_user_id_;
  std::string v200;
  v200 = (var->invoice_payload_) ? var->invoice_payload_: "";
  td::td_api::object_ptr<td::td_api::address> v300;
  v300 = TdConvertToInternal (var->shipping_address_);
  return td::td_api::make_object<td::td_api::updateNewShippingQuery>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdUpdateNewShippingQuery *TdConvertFromInternal (const td::td_api::updateNewShippingQuery &from) {
  auto res = new TdUpdateNewShippingQuery ();
  res->ID = CODE_UpdateNewShippingQuery;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->sender_user_id_ = from.sender_user_id_;
  res->invoice_payload_ = (from.invoice_payload_.length ()) ? td::str_dup (from.invoice_payload_) : nullptr;
  if (!from.shipping_address_) {
    res->shipping_address_ = nullptr;
  } else {
    res->shipping_address_ = TdConvertFromInternal (static_cast<const td::td_api::address &>(*from.shipping_address_));
  }
  return res;
}
char *TdSerializeUpdateNewShippingQuery (struct TdUpdateNewShippingQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewShippingQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewShippingQuery (struct TdUpdateNewShippingQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewShippingQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->invoice_payload_);
  TdDestroyObject (var->shipping_address_);
  delete var;
}
void TdStackStorerUpdateNewShippingQuery (struct TdUpdateNewShippingQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewShippingQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewShippingQuery");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  M->pack_string (var->invoice_payload_);
  M->new_field ("invoice_payload_");
  TdStackStorer (var->shipping_address_, M);
  M->new_field ("shipping_address_");
}
struct TdUpdateNewShippingQuery *TdStackFetcherUpdateNewShippingQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewShippingQuery ();
  res->ID = CODE_UpdateNewShippingQuery;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("invoice_payload_");
  res->invoice_payload_ = M->get_string ();
  M->pop ();
  M->get_field ("shipping_address_");
  if (M->is_nil ()) {
    res->shipping_address_ = nullptr;
  } else {
    res->shipping_address_ = TdStackFetcherAddress (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateNewPreCheckoutQuery *TdCreateObjectUpdateNewPreCheckoutQuery (long long id_, int sender_user_id_, char *currency_, long long total_amount_, struct TdBytes invoice_payload_, char *shipping_option_id_, struct TdOrderInfo *order_info_) {
  auto var = new struct TdUpdateNewPreCheckoutQuery ();
  var->ID = CODE_UpdateNewPreCheckoutQuery;
  var->refcnt = 1;
  var->id_ = id_;
  var->sender_user_id_ = sender_user_id_;
  var->currency_ = (currency_) ? td::str_dup (td::Slice (currency_)) : nullptr;
  var->total_amount_ = total_amount_;
  var->invoice_payload_ = invoice_payload_;
  var->shipping_option_id_ = (shipping_option_id_) ? td::str_dup (td::Slice (shipping_option_id_)) : nullptr;
  var->order_info_ = order_info_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewPreCheckoutQuery> TdConvertToInternal (struct TdUpdateNewPreCheckoutQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::int32_t v100;
  v100 = var->sender_user_id_;
  std::string v200;
  v200 = (var->currency_) ? var->currency_: "";
  std::int64_t v300;
  v300 = var->total_amount_;
  std::string v400;
  v400 = std::string ((char *)var->invoice_payload_.data, var->invoice_payload_.len);
  std::string v500;
  v500 = (var->shipping_option_id_) ? var->shipping_option_id_: "";
  td::td_api::object_ptr<td::td_api::orderInfo> v600;
  v600 = TdConvertToInternal (var->order_info_);
  return td::td_api::make_object<td::td_api::updateNewPreCheckoutQuery>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdUpdateNewPreCheckoutQuery *TdConvertFromInternal (const td::td_api::updateNewPreCheckoutQuery &from) {
  auto res = new TdUpdateNewPreCheckoutQuery ();
  res->ID = CODE_UpdateNewPreCheckoutQuery;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->sender_user_id_ = from.sender_user_id_;
  res->currency_ = (from.currency_.length ()) ? td::str_dup (from.currency_) : nullptr;
  res->total_amount_ = from.total_amount_;
  res->invoice_payload_.len = (int)from.invoice_payload_.length ();
  if (res->invoice_payload_.len) {
    res->invoice_payload_.data = new unsigned char[res->invoice_payload_.len];
    memcpy (res->invoice_payload_.data, from.invoice_payload_.c_str (), res->invoice_payload_.len);
  } else {
    res->invoice_payload_.data = nullptr;
  }
  res->shipping_option_id_ = (from.shipping_option_id_.length ()) ? td::str_dup (from.shipping_option_id_) : nullptr;
  if (!from.order_info_) {
    res->order_info_ = nullptr;
  } else {
    res->order_info_ = TdConvertFromInternal (static_cast<const td::td_api::orderInfo &>(*from.order_info_));
  }
  return res;
}
char *TdSerializeUpdateNewPreCheckoutQuery (struct TdUpdateNewPreCheckoutQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewPreCheckoutQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewPreCheckoutQuery (struct TdUpdateNewPreCheckoutQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewPreCheckoutQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->currency_);
  delete[]var->invoice_payload_.data;
  free (var->shipping_option_id_);
  TdDestroyObject (var->order_info_);
  delete var;
}
void TdStackStorerUpdateNewPreCheckoutQuery (struct TdUpdateNewPreCheckoutQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewPreCheckoutQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewPreCheckoutQuery");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  M->pack_string (var->currency_);
  M->new_field ("currency_");
  M->pack_long (var->total_amount_);
  M->new_field ("total_amount_");
  M->pack_bytes (var->invoice_payload_.data, var->invoice_payload_.len);
  M->new_field ("invoice_payload_");
  M->pack_string (var->shipping_option_id_);
  M->new_field ("shipping_option_id_");
  TdStackStorer (var->order_info_, M);
  M->new_field ("order_info_");
}
struct TdUpdateNewPreCheckoutQuery *TdStackFetcherUpdateNewPreCheckoutQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewPreCheckoutQuery ();
  res->ID = CODE_UpdateNewPreCheckoutQuery;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("currency_");
  res->currency_ = M->get_string ();
  M->pop ();
  M->get_field ("total_amount_");
  res->total_amount_ = M->get_long ();
  M->pop ();
  M->get_field ("invoice_payload_");
  res->invoice_payload_.data = M->get_bytes (&res->invoice_payload_.len);
  M->pop ();
  M->get_field ("shipping_option_id_");
  res->shipping_option_id_ = M->get_string ();
  M->pop ();
  M->get_field ("order_info_");
  if (M->is_nil ()) {
    res->order_info_ = nullptr;
  } else {
    res->order_info_ = TdStackFetcherOrderInfo (M);
  }
  M->pop ();
  return res;
}
struct TdUpdateNewCustomEvent *TdCreateObjectUpdateNewCustomEvent (char *event_) {
  auto var = new struct TdUpdateNewCustomEvent ();
  var->ID = CODE_UpdateNewCustomEvent;
  var->refcnt = 1;
  var->event_ = (event_) ? td::str_dup (td::Slice (event_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewCustomEvent> TdConvertToInternal (struct TdUpdateNewCustomEvent *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->event_) ? var->event_: "";
  return td::td_api::make_object<td::td_api::updateNewCustomEvent>(std::move (v0));
}
struct TdUpdateNewCustomEvent *TdConvertFromInternal (const td::td_api::updateNewCustomEvent &from) {
  auto res = new TdUpdateNewCustomEvent ();
  res->ID = CODE_UpdateNewCustomEvent;
  res->refcnt = 1;
  res->event_ = (from.event_.length ()) ? td::str_dup (from.event_) : nullptr;
  return res;
}
char *TdSerializeUpdateNewCustomEvent (struct TdUpdateNewCustomEvent *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewCustomEvent *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewCustomEvent (struct TdUpdateNewCustomEvent *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewCustomEvent *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->event_);
  delete var;
}
void TdStackStorerUpdateNewCustomEvent (struct TdUpdateNewCustomEvent *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewCustomEvent *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewCustomEvent");
  M->new_field ("ID");
  M->pack_string (var->event_);
  M->new_field ("event_");
}
struct TdUpdateNewCustomEvent *TdStackFetcherUpdateNewCustomEvent (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewCustomEvent ();
  res->ID = CODE_UpdateNewCustomEvent;
  res->refcnt = 1;
  M->get_field ("event_");
  res->event_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdUpdateNewCustomQuery *TdCreateObjectUpdateNewCustomQuery (long long id_, char *data_, int timeout_) {
  auto var = new struct TdUpdateNewCustomQuery ();
  var->ID = CODE_UpdateNewCustomQuery;
  var->refcnt = 1;
  var->id_ = id_;
  var->data_ = (data_) ? td::str_dup (td::Slice (data_)) : nullptr;
  var->timeout_ = timeout_;
  return var;
}
td::td_api::object_ptr<td::td_api::updateNewCustomQuery> TdConvertToInternal (struct TdUpdateNewCustomQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->data_) ? var->data_: "";
  std::int32_t v200;
  v200 = var->timeout_;
  return td::td_api::make_object<td::td_api::updateNewCustomQuery>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUpdateNewCustomQuery *TdConvertFromInternal (const td::td_api::updateNewCustomQuery &from) {
  auto res = new TdUpdateNewCustomQuery ();
  res->ID = CODE_UpdateNewCustomQuery;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->data_ = (from.data_.length ()) ? td::str_dup (from.data_) : nullptr;
  res->timeout_ = from.timeout_;
  return res;
}
char *TdSerializeUpdateNewCustomQuery (struct TdUpdateNewCustomQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpdateNewCustomQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpdateNewCustomQuery (struct TdUpdateNewCustomQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpdateNewCustomQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->data_);
  delete var;
}
void TdStackStorerUpdateNewCustomQuery (struct TdUpdateNewCustomQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpdateNewCustomQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpdateNewCustomQuery");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->data_);
  M->new_field ("data_");
  M->pack_long (var->timeout_);
  M->new_field ("timeout_");
}
struct TdUpdateNewCustomQuery *TdStackFetcherUpdateNewCustomQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdUpdateNewCustomQuery ();
  res->ID = CODE_UpdateNewCustomQuery;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = M->get_long ();
  M->pop ();
  M->get_field ("data_");
  res->data_ = M->get_string ();
  M->pop ();
  M->get_field ("timeout_");
  res->timeout_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUser *TdCreateObjectUser (int id_, char *first_name_, char *last_name_, char *username_, char *phone_number_, struct TdUserStatus *status_, struct TdProfilePhoto *profile_photo_, struct TdLinkState *outgoing_link_, struct TdLinkState *incoming_link_, int is_verified_, char *restriction_reason_, int have_access_, struct TdUserType *type_, char *language_code_) {
  auto var = new struct TdUser ();
  var->ID = CODE_User;
  var->refcnt = 1;
  var->id_ = id_;
  var->first_name_ = (first_name_) ? td::str_dup (td::Slice (first_name_)) : nullptr;
  var->last_name_ = (last_name_) ? td::str_dup (td::Slice (last_name_)) : nullptr;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  var->status_ = status_;
  var->profile_photo_ = profile_photo_;
  var->outgoing_link_ = outgoing_link_;
  var->incoming_link_ = incoming_link_;
  var->is_verified_ = is_verified_;
  var->restriction_reason_ = (restriction_reason_) ? td::str_dup (td::Slice (restriction_reason_)) : nullptr;
  var->have_access_ = have_access_;
  var->type_ = type_;
  var->language_code_ = (language_code_) ? td::str_dup (td::Slice (language_code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::user> TdConvertToInternal (struct TdUser *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::string v100;
  v100 = (var->first_name_) ? var->first_name_: "";
  std::string v200;
  v200 = (var->last_name_) ? var->last_name_: "";
  std::string v300;
  v300 = (var->username_) ? var->username_: "";
  std::string v400;
  v400 = (var->phone_number_) ? var->phone_number_: "";
  td::td_api::object_ptr<td::td_api::UserStatus> v500;
  v500 = TdConvertToInternal (var->status_);
  td::td_api::object_ptr<td::td_api::profilePhoto> v600;
  v600 = TdConvertToInternal (var->profile_photo_);
  td::td_api::object_ptr<td::td_api::LinkState> v700;
  v700 = TdConvertToInternal (var->outgoing_link_);
  td::td_api::object_ptr<td::td_api::LinkState> v800;
  v800 = TdConvertToInternal (var->incoming_link_);
  bool v900;
  v900 = var->is_verified_ != 0;
  std::string v1000;
  v1000 = (var->restriction_reason_) ? var->restriction_reason_: "";
  bool v1100;
  v1100 = var->have_access_ != 0;
  td::td_api::object_ptr<td::td_api::UserType> v1200;
  v1200 = TdConvertToInternal (var->type_);
  std::string v1300;
  v1300 = (var->language_code_) ? var->language_code_: "";
  return td::td_api::make_object<td::td_api::user>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000), std::move (v1100), std::move (v1200), std::move (v1300));
}
struct TdUser *TdConvertFromInternal (const td::td_api::user &from) {
  auto res = new TdUser ();
  res->ID = CODE_User;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->first_name_ = (from.first_name_.length ()) ? td::str_dup (from.first_name_) : nullptr;
  res->last_name_ = (from.last_name_.length ()) ? td::str_dup (from.last_name_) : nullptr;
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  if (!from.status_) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdConvertFromInternal (static_cast<const td::td_api::UserStatus &>(*from.status_));
  }
  if (!from.profile_photo_) {
    res->profile_photo_ = nullptr;
  } else {
    res->profile_photo_ = TdConvertFromInternal (static_cast<const td::td_api::profilePhoto &>(*from.profile_photo_));
  }
  if (!from.outgoing_link_) {
    res->outgoing_link_ = nullptr;
  } else {
    res->outgoing_link_ = TdConvertFromInternal (static_cast<const td::td_api::LinkState &>(*from.outgoing_link_));
  }
  if (!from.incoming_link_) {
    res->incoming_link_ = nullptr;
  } else {
    res->incoming_link_ = TdConvertFromInternal (static_cast<const td::td_api::LinkState &>(*from.incoming_link_));
  }
  res->is_verified_ = from.is_verified_;
  res->restriction_reason_ = (from.restriction_reason_.length ()) ? td::str_dup (from.restriction_reason_) : nullptr;
  res->have_access_ = from.have_access_;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::UserType &>(*from.type_));
  }
  res->language_code_ = (from.language_code_.length ()) ? td::str_dup (from.language_code_) : nullptr;
  return res;
}
char *TdSerializeUser (struct TdUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUser (struct TdUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->first_name_);
  free (var->last_name_);
  free (var->username_);
  free (var->phone_number_);
  TdDestroyObject (var->status_);
  TdDestroyObject (var->profile_photo_);
  TdDestroyObject (var->outgoing_link_);
  TdDestroyObject (var->incoming_link_);
  free (var->restriction_reason_);
  TdDestroyObject (var->type_);
  free (var->language_code_);
  delete var;
}
void TdStackStorerUser (struct TdUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("User");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->pack_string (var->first_name_);
  M->new_field ("first_name_");
  M->pack_string (var->last_name_);
  M->new_field ("last_name_");
  M->pack_string (var->username_);
  M->new_field ("username_");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
  TdStackStorer (var->status_, M);
  M->new_field ("status_");
  TdStackStorer (var->profile_photo_, M);
  M->new_field ("profile_photo_");
  TdStackStorer (var->outgoing_link_, M);
  M->new_field ("outgoing_link_");
  TdStackStorer (var->incoming_link_, M);
  M->new_field ("incoming_link_");
  M->pack_bool (var->is_verified_);
  M->new_field ("is_verified_");
  M->pack_string (var->restriction_reason_);
  M->new_field ("restriction_reason_");
  M->pack_bool (var->have_access_);
  M->new_field ("have_access_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  M->pack_string (var->language_code_);
  M->new_field ("language_code_");
}
struct TdUser *TdStackFetcherUser (struct TdStackFetcherMethods *M) {
  auto res = new TdUser ();
  res->ID = CODE_User;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("first_name_");
  res->first_name_ = M->get_string ();
  M->pop ();
  M->get_field ("last_name_");
  res->last_name_ = M->get_string ();
  M->pop ();
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  M->get_field ("status_");
  if (M->is_nil ()) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdStackFetcherUserStatus (M);
  }
  M->pop ();
  M->get_field ("profile_photo_");
  if (M->is_nil ()) {
    res->profile_photo_ = nullptr;
  } else {
    res->profile_photo_ = TdStackFetcherProfilePhoto (M);
  }
  M->pop ();
  M->get_field ("outgoing_link_");
  if (M->is_nil ()) {
    res->outgoing_link_ = nullptr;
  } else {
    res->outgoing_link_ = TdStackFetcherLinkState (M);
  }
  M->pop ();
  M->get_field ("incoming_link_");
  if (M->is_nil ()) {
    res->incoming_link_ = nullptr;
  } else {
    res->incoming_link_ = TdStackFetcherLinkState (M);
  }
  M->pop ();
  M->get_field ("is_verified_");
  res->is_verified_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("restriction_reason_");
  res->restriction_reason_ = M->get_string ();
  M->pop ();
  M->get_field ("have_access_");
  res->have_access_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherUserType (M);
  }
  M->pop ();
  M->get_field ("language_code_");
  res->language_code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdUserFullInfo *TdCreateObjectUserFullInfo (int is_blocked_, int can_be_called_, int has_private_calls_, char *bio_, char *share_text_, int group_in_common_count_, struct TdBotInfo *bot_info_) {
  auto var = new struct TdUserFullInfo ();
  var->ID = CODE_UserFullInfo;
  var->refcnt = 1;
  var->is_blocked_ = is_blocked_;
  var->can_be_called_ = can_be_called_;
  var->has_private_calls_ = has_private_calls_;
  var->bio_ = (bio_) ? td::str_dup (td::Slice (bio_)) : nullptr;
  var->share_text_ = (share_text_) ? td::str_dup (td::Slice (share_text_)) : nullptr;
  var->group_in_common_count_ = group_in_common_count_;
  var->bot_info_ = bot_info_;
  return var;
}
td::td_api::object_ptr<td::td_api::userFullInfo> TdConvertToInternal (struct TdUserFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_blocked_ != 0;
  bool v100;
  v100 = var->can_be_called_ != 0;
  bool v200;
  v200 = var->has_private_calls_ != 0;
  std::string v300;
  v300 = (var->bio_) ? var->bio_: "";
  std::string v400;
  v400 = (var->share_text_) ? var->share_text_: "";
  std::int32_t v500;
  v500 = var->group_in_common_count_;
  td::td_api::object_ptr<td::td_api::botInfo> v600;
  v600 = TdConvertToInternal (var->bot_info_);
  return td::td_api::make_object<td::td_api::userFullInfo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdUserFullInfo *TdConvertFromInternal (const td::td_api::userFullInfo &from) {
  auto res = new TdUserFullInfo ();
  res->ID = CODE_UserFullInfo;
  res->refcnt = 1;
  res->is_blocked_ = from.is_blocked_;
  res->can_be_called_ = from.can_be_called_;
  res->has_private_calls_ = from.has_private_calls_;
  res->bio_ = (from.bio_.length ()) ? td::str_dup (from.bio_) : nullptr;
  res->share_text_ = (from.share_text_.length ()) ? td::str_dup (from.share_text_) : nullptr;
  res->group_in_common_count_ = from.group_in_common_count_;
  if (!from.bot_info_) {
    res->bot_info_ = nullptr;
  } else {
    res->bot_info_ = TdConvertFromInternal (static_cast<const td::td_api::botInfo &>(*from.bot_info_));
  }
  return res;
}
char *TdSerializeUserFullInfo (struct TdUserFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserFullInfo (struct TdUserFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->bio_);
  free (var->share_text_);
  TdDestroyObject (var->bot_info_);
  delete var;
}
void TdStackStorerUserFullInfo (struct TdUserFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserFullInfo");
  M->new_field ("ID");
  M->pack_bool (var->is_blocked_);
  M->new_field ("is_blocked_");
  M->pack_bool (var->can_be_called_);
  M->new_field ("can_be_called_");
  M->pack_bool (var->has_private_calls_);
  M->new_field ("has_private_calls_");
  M->pack_string (var->bio_);
  M->new_field ("bio_");
  M->pack_string (var->share_text_);
  M->new_field ("share_text_");
  M->pack_long (var->group_in_common_count_);
  M->new_field ("group_in_common_count_");
  TdStackStorer (var->bot_info_, M);
  M->new_field ("bot_info_");
}
struct TdUserFullInfo *TdStackFetcherUserFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdUserFullInfo ();
  res->ID = CODE_UserFullInfo;
  res->refcnt = 1;
  M->get_field ("is_blocked_");
  res->is_blocked_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_be_called_");
  res->can_be_called_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("has_private_calls_");
  res->has_private_calls_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("bio_");
  res->bio_ = M->get_string ();
  M->pop ();
  M->get_field ("share_text_");
  res->share_text_ = M->get_string ();
  M->pop ();
  M->get_field ("group_in_common_count_");
  res->group_in_common_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("bot_info_");
  if (M->is_nil ()) {
    res->bot_info_ = nullptr;
  } else {
    res->bot_info_ = TdStackFetcherBotInfo (M);
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::UserPrivacySetting> TdConvertToInternal (struct TdUserPrivacySetting *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserPrivacySettingShowStatus: return TdConvertToInternal ((struct TdUserPrivacySettingShowStatus *)var);
    case CODE_UserPrivacySettingAllowChatInvites: return TdConvertToInternal ((struct TdUserPrivacySettingAllowChatInvites *)var);
    case CODE_UserPrivacySettingAllowCalls: return TdConvertToInternal ((struct TdUserPrivacySettingAllowCalls *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdUserPrivacySetting *TdConvertFromInternal (const td::td_api::UserPrivacySetting &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_UserPrivacySettingShowStatus: return (struct TdUserPrivacySetting *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingShowStatus &>(from));
    case CODE_UserPrivacySettingAllowChatInvites: return (struct TdUserPrivacySetting *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingAllowChatInvites &>(from));
    case CODE_UserPrivacySettingAllowCalls: return (struct TdUserPrivacySetting *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingAllowCalls &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeUserPrivacySetting (struct TdUserPrivacySetting *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySetting *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySetting (struct TdUserPrivacySetting *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySetting *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserPrivacySettingShowStatus: return TdDestroyObject ((struct TdUserPrivacySettingShowStatus *)var);
    case CODE_UserPrivacySettingAllowChatInvites: return TdDestroyObject ((struct TdUserPrivacySettingAllowChatInvites *)var);
    case CODE_UserPrivacySettingAllowCalls: return TdDestroyObject ((struct TdUserPrivacySettingAllowCalls *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerUserPrivacySetting (struct TdUserPrivacySetting *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySetting *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserPrivacySettingShowStatus: return TdStackStorer ((struct TdUserPrivacySettingShowStatus *)var, M);
    case CODE_UserPrivacySettingAllowChatInvites: return TdStackStorer ((struct TdUserPrivacySettingAllowChatInvites *)var, M);
    case CODE_UserPrivacySettingAllowCalls: return TdStackStorer ((struct TdUserPrivacySettingAllowCalls *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdUserPrivacySetting *TdStackFetcherUserPrivacySetting (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "UserPrivacySettingShowStatus") {
    return (struct TdUserPrivacySetting *)TdStackFetcherUserPrivacySettingShowStatus (M);
  }
  if (constructor == "UserPrivacySettingAllowChatInvites") {
    return (struct TdUserPrivacySetting *)TdStackFetcherUserPrivacySettingAllowChatInvites (M);
  }
  if (constructor == "UserPrivacySettingAllowCalls") {
    return (struct TdUserPrivacySetting *)TdStackFetcherUserPrivacySettingAllowCalls (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdUserPrivacySettingShowStatus *TdCreateObjectUserPrivacySettingShowStatus (void) {
  auto var = new struct TdUserPrivacySettingShowStatus ();
  var->ID = CODE_UserPrivacySettingShowStatus;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingShowStatus> TdConvertToInternal (struct TdUserPrivacySettingShowStatus *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingShowStatus>();
}
struct TdUserPrivacySettingShowStatus *TdConvertFromInternal (const td::td_api::userPrivacySettingShowStatus &from) {
  auto res = new TdUserPrivacySettingShowStatus ();
  res->ID = CODE_UserPrivacySettingShowStatus;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserPrivacySettingShowStatus (struct TdUserPrivacySettingShowStatus *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingShowStatus *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingShowStatus (struct TdUserPrivacySettingShowStatus *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingShowStatus *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserPrivacySettingShowStatus (struct TdUserPrivacySettingShowStatus *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingShowStatus *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingShowStatus");
  M->new_field ("ID");
}
struct TdUserPrivacySettingShowStatus *TdStackFetcherUserPrivacySettingShowStatus (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingShowStatus ();
  res->ID = CODE_UserPrivacySettingShowStatus;
  res->refcnt = 1;
  return res;
}
struct TdUserPrivacySettingAllowChatInvites *TdCreateObjectUserPrivacySettingAllowChatInvites (void) {
  auto var = new struct TdUserPrivacySettingAllowChatInvites ();
  var->ID = CODE_UserPrivacySettingAllowChatInvites;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingAllowChatInvites> TdConvertToInternal (struct TdUserPrivacySettingAllowChatInvites *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingAllowChatInvites>();
}
struct TdUserPrivacySettingAllowChatInvites *TdConvertFromInternal (const td::td_api::userPrivacySettingAllowChatInvites &from) {
  auto res = new TdUserPrivacySettingAllowChatInvites ();
  res->ID = CODE_UserPrivacySettingAllowChatInvites;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserPrivacySettingAllowChatInvites (struct TdUserPrivacySettingAllowChatInvites *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingAllowChatInvites *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingAllowChatInvites (struct TdUserPrivacySettingAllowChatInvites *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingAllowChatInvites *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserPrivacySettingAllowChatInvites (struct TdUserPrivacySettingAllowChatInvites *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingAllowChatInvites *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingAllowChatInvites");
  M->new_field ("ID");
}
struct TdUserPrivacySettingAllowChatInvites *TdStackFetcherUserPrivacySettingAllowChatInvites (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingAllowChatInvites ();
  res->ID = CODE_UserPrivacySettingAllowChatInvites;
  res->refcnt = 1;
  return res;
}
struct TdUserPrivacySettingAllowCalls *TdCreateObjectUserPrivacySettingAllowCalls (void) {
  auto var = new struct TdUserPrivacySettingAllowCalls ();
  var->ID = CODE_UserPrivacySettingAllowCalls;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingAllowCalls> TdConvertToInternal (struct TdUserPrivacySettingAllowCalls *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingAllowCalls>();
}
struct TdUserPrivacySettingAllowCalls *TdConvertFromInternal (const td::td_api::userPrivacySettingAllowCalls &from) {
  auto res = new TdUserPrivacySettingAllowCalls ();
  res->ID = CODE_UserPrivacySettingAllowCalls;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserPrivacySettingAllowCalls (struct TdUserPrivacySettingAllowCalls *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingAllowCalls *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingAllowCalls (struct TdUserPrivacySettingAllowCalls *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingAllowCalls *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserPrivacySettingAllowCalls (struct TdUserPrivacySettingAllowCalls *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingAllowCalls *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingAllowCalls");
  M->new_field ("ID");
}
struct TdUserPrivacySettingAllowCalls *TdStackFetcherUserPrivacySettingAllowCalls (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingAllowCalls ();
  res->ID = CODE_UserPrivacySettingAllowCalls;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::UserPrivacySettingRule> TdConvertToInternal (struct TdUserPrivacySettingRule *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserPrivacySettingRuleAllowAll: return TdConvertToInternal ((struct TdUserPrivacySettingRuleAllowAll *)var);
    case CODE_UserPrivacySettingRuleAllowContacts: return TdConvertToInternal ((struct TdUserPrivacySettingRuleAllowContacts *)var);
    case CODE_UserPrivacySettingRuleAllowUsers: return TdConvertToInternal ((struct TdUserPrivacySettingRuleAllowUsers *)var);
    case CODE_UserPrivacySettingRuleRestrictAll: return TdConvertToInternal ((struct TdUserPrivacySettingRuleRestrictAll *)var);
    case CODE_UserPrivacySettingRuleRestrictContacts: return TdConvertToInternal ((struct TdUserPrivacySettingRuleRestrictContacts *)var);
    case CODE_UserPrivacySettingRuleRestrictUsers: return TdConvertToInternal ((struct TdUserPrivacySettingRuleRestrictUsers *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdUserPrivacySettingRule *TdConvertFromInternal (const td::td_api::UserPrivacySettingRule &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_UserPrivacySettingRuleAllowAll: return (struct TdUserPrivacySettingRule *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleAllowAll &>(from));
    case CODE_UserPrivacySettingRuleAllowContacts: return (struct TdUserPrivacySettingRule *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleAllowContacts &>(from));
    case CODE_UserPrivacySettingRuleAllowUsers: return (struct TdUserPrivacySettingRule *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleAllowUsers &>(from));
    case CODE_UserPrivacySettingRuleRestrictAll: return (struct TdUserPrivacySettingRule *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleRestrictAll &>(from));
    case CODE_UserPrivacySettingRuleRestrictContacts: return (struct TdUserPrivacySettingRule *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleRestrictContacts &>(from));
    case CODE_UserPrivacySettingRuleRestrictUsers: return (struct TdUserPrivacySettingRule *)TdConvertFromInternal(static_cast<const td::td_api::userPrivacySettingRuleRestrictUsers &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeUserPrivacySettingRule (struct TdUserPrivacySettingRule *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingRule *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingRule (struct TdUserPrivacySettingRule *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingRule *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserPrivacySettingRuleAllowAll: return TdDestroyObject ((struct TdUserPrivacySettingRuleAllowAll *)var);
    case CODE_UserPrivacySettingRuleAllowContacts: return TdDestroyObject ((struct TdUserPrivacySettingRuleAllowContacts *)var);
    case CODE_UserPrivacySettingRuleAllowUsers: return TdDestroyObject ((struct TdUserPrivacySettingRuleAllowUsers *)var);
    case CODE_UserPrivacySettingRuleRestrictAll: return TdDestroyObject ((struct TdUserPrivacySettingRuleRestrictAll *)var);
    case CODE_UserPrivacySettingRuleRestrictContacts: return TdDestroyObject ((struct TdUserPrivacySettingRuleRestrictContacts *)var);
    case CODE_UserPrivacySettingRuleRestrictUsers: return TdDestroyObject ((struct TdUserPrivacySettingRuleRestrictUsers *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerUserPrivacySettingRule (struct TdUserPrivacySettingRule *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingRule *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserPrivacySettingRuleAllowAll: return TdStackStorer ((struct TdUserPrivacySettingRuleAllowAll *)var, M);
    case CODE_UserPrivacySettingRuleAllowContacts: return TdStackStorer ((struct TdUserPrivacySettingRuleAllowContacts *)var, M);
    case CODE_UserPrivacySettingRuleAllowUsers: return TdStackStorer ((struct TdUserPrivacySettingRuleAllowUsers *)var, M);
    case CODE_UserPrivacySettingRuleRestrictAll: return TdStackStorer ((struct TdUserPrivacySettingRuleRestrictAll *)var, M);
    case CODE_UserPrivacySettingRuleRestrictContacts: return TdStackStorer ((struct TdUserPrivacySettingRuleRestrictContacts *)var, M);
    case CODE_UserPrivacySettingRuleRestrictUsers: return TdStackStorer ((struct TdUserPrivacySettingRuleRestrictUsers *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdUserPrivacySettingRule *TdStackFetcherUserPrivacySettingRule (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "UserPrivacySettingRuleAllowAll") {
    return (struct TdUserPrivacySettingRule *)TdStackFetcherUserPrivacySettingRuleAllowAll (M);
  }
  if (constructor == "UserPrivacySettingRuleAllowContacts") {
    return (struct TdUserPrivacySettingRule *)TdStackFetcherUserPrivacySettingRuleAllowContacts (M);
  }
  if (constructor == "UserPrivacySettingRuleAllowUsers") {
    return (struct TdUserPrivacySettingRule *)TdStackFetcherUserPrivacySettingRuleAllowUsers (M);
  }
  if (constructor == "UserPrivacySettingRuleRestrictAll") {
    return (struct TdUserPrivacySettingRule *)TdStackFetcherUserPrivacySettingRuleRestrictAll (M);
  }
  if (constructor == "UserPrivacySettingRuleRestrictContacts") {
    return (struct TdUserPrivacySettingRule *)TdStackFetcherUserPrivacySettingRuleRestrictContacts (M);
  }
  if (constructor == "UserPrivacySettingRuleRestrictUsers") {
    return (struct TdUserPrivacySettingRule *)TdStackFetcherUserPrivacySettingRuleRestrictUsers (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdUserPrivacySettingRuleAllowAll *TdCreateObjectUserPrivacySettingRuleAllowAll (void) {
  auto var = new struct TdUserPrivacySettingRuleAllowAll ();
  var->ID = CODE_UserPrivacySettingRuleAllowAll;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingRuleAllowAll> TdConvertToInternal (struct TdUserPrivacySettingRuleAllowAll *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingRuleAllowAll>();
}
struct TdUserPrivacySettingRuleAllowAll *TdConvertFromInternal (const td::td_api::userPrivacySettingRuleAllowAll &from) {
  auto res = new TdUserPrivacySettingRuleAllowAll ();
  res->ID = CODE_UserPrivacySettingRuleAllowAll;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserPrivacySettingRuleAllowAll (struct TdUserPrivacySettingRuleAllowAll *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingRuleAllowAll *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingRuleAllowAll (struct TdUserPrivacySettingRuleAllowAll *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingRuleAllowAll *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserPrivacySettingRuleAllowAll (struct TdUserPrivacySettingRuleAllowAll *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingRuleAllowAll *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingRuleAllowAll");
  M->new_field ("ID");
}
struct TdUserPrivacySettingRuleAllowAll *TdStackFetcherUserPrivacySettingRuleAllowAll (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingRuleAllowAll ();
  res->ID = CODE_UserPrivacySettingRuleAllowAll;
  res->refcnt = 1;
  return res;
}
struct TdUserPrivacySettingRuleAllowContacts *TdCreateObjectUserPrivacySettingRuleAllowContacts (void) {
  auto var = new struct TdUserPrivacySettingRuleAllowContacts ();
  var->ID = CODE_UserPrivacySettingRuleAllowContacts;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingRuleAllowContacts> TdConvertToInternal (struct TdUserPrivacySettingRuleAllowContacts *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingRuleAllowContacts>();
}
struct TdUserPrivacySettingRuleAllowContacts *TdConvertFromInternal (const td::td_api::userPrivacySettingRuleAllowContacts &from) {
  auto res = new TdUserPrivacySettingRuleAllowContacts ();
  res->ID = CODE_UserPrivacySettingRuleAllowContacts;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserPrivacySettingRuleAllowContacts (struct TdUserPrivacySettingRuleAllowContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingRuleAllowContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingRuleAllowContacts (struct TdUserPrivacySettingRuleAllowContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingRuleAllowContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserPrivacySettingRuleAllowContacts (struct TdUserPrivacySettingRuleAllowContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingRuleAllowContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingRuleAllowContacts");
  M->new_field ("ID");
}
struct TdUserPrivacySettingRuleAllowContacts *TdStackFetcherUserPrivacySettingRuleAllowContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingRuleAllowContacts ();
  res->ID = CODE_UserPrivacySettingRuleAllowContacts;
  res->refcnt = 1;
  return res;
}
struct TdUserPrivacySettingRuleAllowUsers *TdCreateObjectUserPrivacySettingRuleAllowUsers (struct TdVectorInt *user_ids_) {
  auto var = new struct TdUserPrivacySettingRuleAllowUsers ();
  var->ID = CODE_UserPrivacySettingRuleAllowUsers;
  var->refcnt = 1;
  var->user_ids_ = user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingRuleAllowUsers> TdConvertToInternal (struct TdUserPrivacySettingRuleAllowUsers *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    std::int32_t v1;
    v1 = var->user_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingRuleAllowUsers>(std::move (v0));
}
struct TdUserPrivacySettingRuleAllowUsers *TdConvertFromInternal (const td::td_api::userPrivacySettingRuleAllowUsers &from) {
  auto res = new TdUserPrivacySettingRuleAllowUsers ();
  res->ID = CODE_UserPrivacySettingRuleAllowUsers;
  res->refcnt = 1;
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = (int)from.user_ids_.size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    res->user_ids_->data[i0] = from.user_ids_[i0];
  }
  return res;
}
char *TdSerializeUserPrivacySettingRuleAllowUsers (struct TdUserPrivacySettingRuleAllowUsers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingRuleAllowUsers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingRuleAllowUsers (struct TdUserPrivacySettingRuleAllowUsers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingRuleAllowUsers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
  }
  delete[] var->user_ids_->data;
  delete var->user_ids_;
  delete var;
}
void TdStackStorerUserPrivacySettingRuleAllowUsers (struct TdUserPrivacySettingRuleAllowUsers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingRuleAllowUsers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingRuleAllowUsers");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    M->pack_long (var->user_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("user_ids_");
}
struct TdUserPrivacySettingRuleAllowUsers *TdStackFetcherUserPrivacySettingRuleAllowUsers (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingRuleAllowUsers ();
  res->ID = CODE_UserPrivacySettingRuleAllowUsers;
  res->refcnt = 1;
  M->get_field ("user_ids_");
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = M->get_arr_size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->user_ids_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdUserPrivacySettingRuleRestrictAll *TdCreateObjectUserPrivacySettingRuleRestrictAll (void) {
  auto var = new struct TdUserPrivacySettingRuleRestrictAll ();
  var->ID = CODE_UserPrivacySettingRuleRestrictAll;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingRuleRestrictAll> TdConvertToInternal (struct TdUserPrivacySettingRuleRestrictAll *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingRuleRestrictAll>();
}
struct TdUserPrivacySettingRuleRestrictAll *TdConvertFromInternal (const td::td_api::userPrivacySettingRuleRestrictAll &from) {
  auto res = new TdUserPrivacySettingRuleRestrictAll ();
  res->ID = CODE_UserPrivacySettingRuleRestrictAll;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserPrivacySettingRuleRestrictAll (struct TdUserPrivacySettingRuleRestrictAll *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingRuleRestrictAll *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingRuleRestrictAll (struct TdUserPrivacySettingRuleRestrictAll *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingRuleRestrictAll *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserPrivacySettingRuleRestrictAll (struct TdUserPrivacySettingRuleRestrictAll *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingRuleRestrictAll *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingRuleRestrictAll");
  M->new_field ("ID");
}
struct TdUserPrivacySettingRuleRestrictAll *TdStackFetcherUserPrivacySettingRuleRestrictAll (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingRuleRestrictAll ();
  res->ID = CODE_UserPrivacySettingRuleRestrictAll;
  res->refcnt = 1;
  return res;
}
struct TdUserPrivacySettingRuleRestrictContacts *TdCreateObjectUserPrivacySettingRuleRestrictContacts (void) {
  auto var = new struct TdUserPrivacySettingRuleRestrictContacts ();
  var->ID = CODE_UserPrivacySettingRuleRestrictContacts;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingRuleRestrictContacts> TdConvertToInternal (struct TdUserPrivacySettingRuleRestrictContacts *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingRuleRestrictContacts>();
}
struct TdUserPrivacySettingRuleRestrictContacts *TdConvertFromInternal (const td::td_api::userPrivacySettingRuleRestrictContacts &from) {
  auto res = new TdUserPrivacySettingRuleRestrictContacts ();
  res->ID = CODE_UserPrivacySettingRuleRestrictContacts;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserPrivacySettingRuleRestrictContacts (struct TdUserPrivacySettingRuleRestrictContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingRuleRestrictContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingRuleRestrictContacts (struct TdUserPrivacySettingRuleRestrictContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingRuleRestrictContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserPrivacySettingRuleRestrictContacts (struct TdUserPrivacySettingRuleRestrictContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingRuleRestrictContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingRuleRestrictContacts");
  M->new_field ("ID");
}
struct TdUserPrivacySettingRuleRestrictContacts *TdStackFetcherUserPrivacySettingRuleRestrictContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingRuleRestrictContacts ();
  res->ID = CODE_UserPrivacySettingRuleRestrictContacts;
  res->refcnt = 1;
  return res;
}
struct TdUserPrivacySettingRuleRestrictUsers *TdCreateObjectUserPrivacySettingRuleRestrictUsers (struct TdVectorInt *user_ids_) {
  auto var = new struct TdUserPrivacySettingRuleRestrictUsers ();
  var->ID = CODE_UserPrivacySettingRuleRestrictUsers;
  var->refcnt = 1;
  var->user_ids_ = user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingRuleRestrictUsers> TdConvertToInternal (struct TdUserPrivacySettingRuleRestrictUsers *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    std::int32_t v1;
    v1 = var->user_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingRuleRestrictUsers>(std::move (v0));
}
struct TdUserPrivacySettingRuleRestrictUsers *TdConvertFromInternal (const td::td_api::userPrivacySettingRuleRestrictUsers &from) {
  auto res = new TdUserPrivacySettingRuleRestrictUsers ();
  res->ID = CODE_UserPrivacySettingRuleRestrictUsers;
  res->refcnt = 1;
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = (int)from.user_ids_.size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    res->user_ids_->data[i0] = from.user_ids_[i0];
  }
  return res;
}
char *TdSerializeUserPrivacySettingRuleRestrictUsers (struct TdUserPrivacySettingRuleRestrictUsers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingRuleRestrictUsers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingRuleRestrictUsers (struct TdUserPrivacySettingRuleRestrictUsers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingRuleRestrictUsers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
  }
  delete[] var->user_ids_->data;
  delete var->user_ids_;
  delete var;
}
void TdStackStorerUserPrivacySettingRuleRestrictUsers (struct TdUserPrivacySettingRuleRestrictUsers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingRuleRestrictUsers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingRuleRestrictUsers");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    M->pack_long (var->user_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("user_ids_");
}
struct TdUserPrivacySettingRuleRestrictUsers *TdStackFetcherUserPrivacySettingRuleRestrictUsers (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingRuleRestrictUsers ();
  res->ID = CODE_UserPrivacySettingRuleRestrictUsers;
  res->refcnt = 1;
  M->get_field ("user_ids_");
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = M->get_arr_size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->user_ids_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdUserPrivacySettingRules *TdCreateObjectUserPrivacySettingRules (struct TdVectorUserPrivacySettingRule *rules_) {
  auto var = new struct TdUserPrivacySettingRules ();
  var->ID = CODE_UserPrivacySettingRules;
  var->refcnt = 1;
  var->rules_ = rules_;
  return var;
}
td::td_api::object_ptr<td::td_api::userPrivacySettingRules> TdConvertToInternal (struct TdUserPrivacySettingRules *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::UserPrivacySettingRule>> v0;
  for (int i0 = 0; i0 < var->rules_->len; i0++) {
    td::td_api::object_ptr<td::td_api::UserPrivacySettingRule> v1;
    v1 = TdConvertToInternal (var->rules_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::userPrivacySettingRules>(std::move (v0));
}
struct TdUserPrivacySettingRules *TdConvertFromInternal (const td::td_api::userPrivacySettingRules &from) {
  auto res = new TdUserPrivacySettingRules ();
  res->ID = CODE_UserPrivacySettingRules;
  res->refcnt = 1;
  res->rules_ = new TdVectorUserPrivacySettingRule ();
  res->rules_->len = (int)from.rules_.size ();
  res->rules_->data = new struct TdUserPrivacySettingRule * [res->rules_->len];
  for (int i0 = 0; i0 < res->rules_->len; i0++) {
    if (!from.rules_[i0]) {
      res->rules_->data[i0] = nullptr;
    } else {
      res->rules_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::UserPrivacySettingRule &>(*from.rules_[i0]));
    }
  }
  return res;
}
char *TdSerializeUserPrivacySettingRules (struct TdUserPrivacySettingRules *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserPrivacySettingRules *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserPrivacySettingRules (struct TdUserPrivacySettingRules *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserPrivacySettingRules *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->rules_->len; i0++) {
    TdDestroyObject (var->rules_->data[i0]);
  }
  delete[] var->rules_->data;
  delete var->rules_;
  delete var;
}
void TdStackStorerUserPrivacySettingRules (struct TdUserPrivacySettingRules *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserPrivacySettingRules *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserPrivacySettingRules");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->rules_->len; i0++) {
    TdStackStorer (var->rules_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("rules_");
}
struct TdUserPrivacySettingRules *TdStackFetcherUserPrivacySettingRules (struct TdStackFetcherMethods *M) {
  auto res = new TdUserPrivacySettingRules ();
  res->ID = CODE_UserPrivacySettingRules;
  res->refcnt = 1;
  M->get_field ("rules_");
  res->rules_ = new TdVectorUserPrivacySettingRule ();
  res->rules_->len = M->get_arr_size ();
  res->rules_->data = new struct TdUserPrivacySettingRule * [res->rules_->len];
  for (int i0 = 0; i0 < res->rules_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->rules_->data[i0] = nullptr;
    } else {
      res->rules_->data[i0] = TdStackFetcherUserPrivacySettingRule (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdUserProfilePhotos *TdCreateObjectUserProfilePhotos (int total_count_, struct TdVectorPhoto *photos_) {
  auto var = new struct TdUserProfilePhotos ();
  var->ID = CODE_UserProfilePhotos;
  var->refcnt = 1;
  var->total_count_ = total_count_;
  var->photos_ = photos_;
  return var;
}
td::td_api::object_ptr<td::td_api::userProfilePhotos> TdConvertToInternal (struct TdUserProfilePhotos *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->total_count_;
  std::vector<td::td_api::object_ptr<td::td_api::photo>> v100;
  for (int i100 = 0; i100 < var->photos_->len; i100++) {
    td::td_api::object_ptr<td::td_api::photo> v101;
    v101 = TdConvertToInternal (var->photos_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::userProfilePhotos>(std::move (v0), std::move (v100));
}
struct TdUserProfilePhotos *TdConvertFromInternal (const td::td_api::userProfilePhotos &from) {
  auto res = new TdUserProfilePhotos ();
  res->ID = CODE_UserProfilePhotos;
  res->refcnt = 1;
  res->total_count_ = from.total_count_;
  res->photos_ = new TdVectorPhoto ();
  res->photos_->len = (int)from.photos_.size ();
  res->photos_->data = new struct TdPhoto * [res->photos_->len];
  for (int i100 = 0; i100 < res->photos_->len; i100++) {
    if (!from.photos_[i100]) {
      res->photos_->data[i100] = nullptr;
    } else {
      res->photos_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.photos_[i100]));
    }
  }
  return res;
}
char *TdSerializeUserProfilePhotos (struct TdUserProfilePhotos *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserProfilePhotos *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserProfilePhotos (struct TdUserProfilePhotos *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserProfilePhotos *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->photos_->len; i100++) {
    TdDestroyObject (var->photos_->data[i100]);
  }
  delete[] var->photos_->data;
  delete var->photos_;
  delete var;
}
void TdStackStorerUserProfilePhotos (struct TdUserProfilePhotos *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserProfilePhotos *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserProfilePhotos");
  M->new_field ("ID");
  M->pack_long (var->total_count_);
  M->new_field ("total_count_");
  M->new_array ();
  for (int i100 = 0; i100 < var->photos_->len; i100++) {
    TdStackStorer (var->photos_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("photos_");
}
struct TdUserProfilePhotos *TdStackFetcherUserProfilePhotos (struct TdStackFetcherMethods *M) {
  auto res = new TdUserProfilePhotos ();
  res->ID = CODE_UserProfilePhotos;
  res->refcnt = 1;
  M->get_field ("total_count_");
  res->total_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("photos_");
  res->photos_ = new TdVectorPhoto ();
  res->photos_->len = M->get_arr_size ();
  res->photos_->data = new struct TdPhoto * [res->photos_->len];
  for (int i100 = 0; i100 < res->photos_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->photos_->data[i100] = nullptr;
    } else {
      res->photos_->data[i100] = TdStackFetcherPhoto (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
td::td_api::object_ptr<td::td_api::UserStatus> TdConvertToInternal (struct TdUserStatus *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserStatusEmpty: return TdConvertToInternal ((struct TdUserStatusEmpty *)var);
    case CODE_UserStatusOnline: return TdConvertToInternal ((struct TdUserStatusOnline *)var);
    case CODE_UserStatusOffline: return TdConvertToInternal ((struct TdUserStatusOffline *)var);
    case CODE_UserStatusRecently: return TdConvertToInternal ((struct TdUserStatusRecently *)var);
    case CODE_UserStatusLastWeek: return TdConvertToInternal ((struct TdUserStatusLastWeek *)var);
    case CODE_UserStatusLastMonth: return TdConvertToInternal ((struct TdUserStatusLastMonth *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdUserStatus *TdConvertFromInternal (const td::td_api::UserStatus &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_UserStatusEmpty: return (struct TdUserStatus *)TdConvertFromInternal(static_cast<const td::td_api::userStatusEmpty &>(from));
    case CODE_UserStatusOnline: return (struct TdUserStatus *)TdConvertFromInternal(static_cast<const td::td_api::userStatusOnline &>(from));
    case CODE_UserStatusOffline: return (struct TdUserStatus *)TdConvertFromInternal(static_cast<const td::td_api::userStatusOffline &>(from));
    case CODE_UserStatusRecently: return (struct TdUserStatus *)TdConvertFromInternal(static_cast<const td::td_api::userStatusRecently &>(from));
    case CODE_UserStatusLastWeek: return (struct TdUserStatus *)TdConvertFromInternal(static_cast<const td::td_api::userStatusLastWeek &>(from));
    case CODE_UserStatusLastMonth: return (struct TdUserStatus *)TdConvertFromInternal(static_cast<const td::td_api::userStatusLastMonth &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeUserStatus (struct TdUserStatus *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserStatus *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserStatus (struct TdUserStatus *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserStatus *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserStatusEmpty: return TdDestroyObject ((struct TdUserStatusEmpty *)var);
    case CODE_UserStatusOnline: return TdDestroyObject ((struct TdUserStatusOnline *)var);
    case CODE_UserStatusOffline: return TdDestroyObject ((struct TdUserStatusOffline *)var);
    case CODE_UserStatusRecently: return TdDestroyObject ((struct TdUserStatusRecently *)var);
    case CODE_UserStatusLastWeek: return TdDestroyObject ((struct TdUserStatusLastWeek *)var);
    case CODE_UserStatusLastMonth: return TdDestroyObject ((struct TdUserStatusLastMonth *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerUserStatus (struct TdUserStatus *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserStatus *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserStatusEmpty: return TdStackStorer ((struct TdUserStatusEmpty *)var, M);
    case CODE_UserStatusOnline: return TdStackStorer ((struct TdUserStatusOnline *)var, M);
    case CODE_UserStatusOffline: return TdStackStorer ((struct TdUserStatusOffline *)var, M);
    case CODE_UserStatusRecently: return TdStackStorer ((struct TdUserStatusRecently *)var, M);
    case CODE_UserStatusLastWeek: return TdStackStorer ((struct TdUserStatusLastWeek *)var, M);
    case CODE_UserStatusLastMonth: return TdStackStorer ((struct TdUserStatusLastMonth *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdUserStatus *TdStackFetcherUserStatus (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "UserStatusEmpty") {
    return (struct TdUserStatus *)TdStackFetcherUserStatusEmpty (M);
  }
  if (constructor == "UserStatusOnline") {
    return (struct TdUserStatus *)TdStackFetcherUserStatusOnline (M);
  }
  if (constructor == "UserStatusOffline") {
    return (struct TdUserStatus *)TdStackFetcherUserStatusOffline (M);
  }
  if (constructor == "UserStatusRecently") {
    return (struct TdUserStatus *)TdStackFetcherUserStatusRecently (M);
  }
  if (constructor == "UserStatusLastWeek") {
    return (struct TdUserStatus *)TdStackFetcherUserStatusLastWeek (M);
  }
  if (constructor == "UserStatusLastMonth") {
    return (struct TdUserStatus *)TdStackFetcherUserStatusLastMonth (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdUserStatusEmpty *TdCreateObjectUserStatusEmpty (void) {
  auto var = new struct TdUserStatusEmpty ();
  var->ID = CODE_UserStatusEmpty;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userStatusEmpty> TdConvertToInternal (struct TdUserStatusEmpty *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userStatusEmpty>();
}
struct TdUserStatusEmpty *TdConvertFromInternal (const td::td_api::userStatusEmpty &from) {
  auto res = new TdUserStatusEmpty ();
  res->ID = CODE_UserStatusEmpty;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserStatusEmpty (struct TdUserStatusEmpty *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserStatusEmpty *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserStatusEmpty (struct TdUserStatusEmpty *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserStatusEmpty *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserStatusEmpty (struct TdUserStatusEmpty *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserStatusEmpty *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserStatusEmpty");
  M->new_field ("ID");
}
struct TdUserStatusEmpty *TdStackFetcherUserStatusEmpty (struct TdStackFetcherMethods *M) {
  auto res = new TdUserStatusEmpty ();
  res->ID = CODE_UserStatusEmpty;
  res->refcnt = 1;
  return res;
}
struct TdUserStatusOnline *TdCreateObjectUserStatusOnline (int expires_) {
  auto var = new struct TdUserStatusOnline ();
  var->ID = CODE_UserStatusOnline;
  var->refcnt = 1;
  var->expires_ = expires_;
  return var;
}
td::td_api::object_ptr<td::td_api::userStatusOnline> TdConvertToInternal (struct TdUserStatusOnline *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->expires_;
  return td::td_api::make_object<td::td_api::userStatusOnline>(std::move (v0));
}
struct TdUserStatusOnline *TdConvertFromInternal (const td::td_api::userStatusOnline &from) {
  auto res = new TdUserStatusOnline ();
  res->ID = CODE_UserStatusOnline;
  res->refcnt = 1;
  res->expires_ = from.expires_;
  return res;
}
char *TdSerializeUserStatusOnline (struct TdUserStatusOnline *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserStatusOnline *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserStatusOnline (struct TdUserStatusOnline *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserStatusOnline *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserStatusOnline (struct TdUserStatusOnline *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserStatusOnline *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserStatusOnline");
  M->new_field ("ID");
  M->pack_long (var->expires_);
  M->new_field ("expires_");
}
struct TdUserStatusOnline *TdStackFetcherUserStatusOnline (struct TdStackFetcherMethods *M) {
  auto res = new TdUserStatusOnline ();
  res->ID = CODE_UserStatusOnline;
  res->refcnt = 1;
  M->get_field ("expires_");
  res->expires_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUserStatusOffline *TdCreateObjectUserStatusOffline (int was_online_) {
  auto var = new struct TdUserStatusOffline ();
  var->ID = CODE_UserStatusOffline;
  var->refcnt = 1;
  var->was_online_ = was_online_;
  return var;
}
td::td_api::object_ptr<td::td_api::userStatusOffline> TdConvertToInternal (struct TdUserStatusOffline *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->was_online_;
  return td::td_api::make_object<td::td_api::userStatusOffline>(std::move (v0));
}
struct TdUserStatusOffline *TdConvertFromInternal (const td::td_api::userStatusOffline &from) {
  auto res = new TdUserStatusOffline ();
  res->ID = CODE_UserStatusOffline;
  res->refcnt = 1;
  res->was_online_ = from.was_online_;
  return res;
}
char *TdSerializeUserStatusOffline (struct TdUserStatusOffline *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserStatusOffline *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserStatusOffline (struct TdUserStatusOffline *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserStatusOffline *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserStatusOffline (struct TdUserStatusOffline *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserStatusOffline *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserStatusOffline");
  M->new_field ("ID");
  M->pack_long (var->was_online_);
  M->new_field ("was_online_");
}
struct TdUserStatusOffline *TdStackFetcherUserStatusOffline (struct TdStackFetcherMethods *M) {
  auto res = new TdUserStatusOffline ();
  res->ID = CODE_UserStatusOffline;
  res->refcnt = 1;
  M->get_field ("was_online_");
  res->was_online_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUserStatusRecently *TdCreateObjectUserStatusRecently (void) {
  auto var = new struct TdUserStatusRecently ();
  var->ID = CODE_UserStatusRecently;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userStatusRecently> TdConvertToInternal (struct TdUserStatusRecently *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userStatusRecently>();
}
struct TdUserStatusRecently *TdConvertFromInternal (const td::td_api::userStatusRecently &from) {
  auto res = new TdUserStatusRecently ();
  res->ID = CODE_UserStatusRecently;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserStatusRecently (struct TdUserStatusRecently *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserStatusRecently *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserStatusRecently (struct TdUserStatusRecently *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserStatusRecently *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserStatusRecently (struct TdUserStatusRecently *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserStatusRecently *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserStatusRecently");
  M->new_field ("ID");
}
struct TdUserStatusRecently *TdStackFetcherUserStatusRecently (struct TdStackFetcherMethods *M) {
  auto res = new TdUserStatusRecently ();
  res->ID = CODE_UserStatusRecently;
  res->refcnt = 1;
  return res;
}
struct TdUserStatusLastWeek *TdCreateObjectUserStatusLastWeek (void) {
  auto var = new struct TdUserStatusLastWeek ();
  var->ID = CODE_UserStatusLastWeek;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userStatusLastWeek> TdConvertToInternal (struct TdUserStatusLastWeek *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userStatusLastWeek>();
}
struct TdUserStatusLastWeek *TdConvertFromInternal (const td::td_api::userStatusLastWeek &from) {
  auto res = new TdUserStatusLastWeek ();
  res->ID = CODE_UserStatusLastWeek;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserStatusLastWeek (struct TdUserStatusLastWeek *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserStatusLastWeek *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserStatusLastWeek (struct TdUserStatusLastWeek *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserStatusLastWeek *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserStatusLastWeek (struct TdUserStatusLastWeek *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserStatusLastWeek *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserStatusLastWeek");
  M->new_field ("ID");
}
struct TdUserStatusLastWeek *TdStackFetcherUserStatusLastWeek (struct TdStackFetcherMethods *M) {
  auto res = new TdUserStatusLastWeek ();
  res->ID = CODE_UserStatusLastWeek;
  res->refcnt = 1;
  return res;
}
struct TdUserStatusLastMonth *TdCreateObjectUserStatusLastMonth (void) {
  auto var = new struct TdUserStatusLastMonth ();
  var->ID = CODE_UserStatusLastMonth;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userStatusLastMonth> TdConvertToInternal (struct TdUserStatusLastMonth *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userStatusLastMonth>();
}
struct TdUserStatusLastMonth *TdConvertFromInternal (const td::td_api::userStatusLastMonth &from) {
  auto res = new TdUserStatusLastMonth ();
  res->ID = CODE_UserStatusLastMonth;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserStatusLastMonth (struct TdUserStatusLastMonth *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserStatusLastMonth *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserStatusLastMonth (struct TdUserStatusLastMonth *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserStatusLastMonth *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserStatusLastMonth (struct TdUserStatusLastMonth *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserStatusLastMonth *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserStatusLastMonth");
  M->new_field ("ID");
}
struct TdUserStatusLastMonth *TdStackFetcherUserStatusLastMonth (struct TdStackFetcherMethods *M) {
  auto res = new TdUserStatusLastMonth ();
  res->ID = CODE_UserStatusLastMonth;
  res->refcnt = 1;
  return res;
}
td::td_api::object_ptr<td::td_api::UserType> TdConvertToInternal (struct TdUserType *var) {
  if (!var) { return nullptr; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserTypeRegular: return TdConvertToInternal ((struct TdUserTypeRegular *)var);
    case CODE_UserTypeDeleted: return TdConvertToInternal ((struct TdUserTypeDeleted *)var);
    case CODE_UserTypeBot: return TdConvertToInternal ((struct TdUserTypeBot *)var);
    case CODE_UserTypeUnknown: return TdConvertToInternal ((struct TdUserTypeUnknown *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
struct TdUserType *TdConvertFromInternal (const td::td_api::UserType &from) {
  int constructor = from.get_id ();
  switch (constructor) {
    case CODE_UserTypeRegular: return (struct TdUserType *)TdConvertFromInternal(static_cast<const td::td_api::userTypeRegular &>(from));
    case CODE_UserTypeDeleted: return (struct TdUserType *)TdConvertFromInternal(static_cast<const td::td_api::userTypeDeleted &>(from));
    case CODE_UserTypeBot: return (struct TdUserType *)TdConvertFromInternal(static_cast<const td::td_api::userTypeBot &>(from));
    case CODE_UserTypeUnknown: return (struct TdUserType *)TdConvertFromInternal(static_cast<const td::td_api::userTypeUnknown &>(from));
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return nullptr;
  }
}
char *TdSerializeUserType (struct TdUserType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserType (struct TdUserType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserType *var) {
  if (!var) { return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserTypeRegular: return TdDestroyObject ((struct TdUserTypeRegular *)var);
    case CODE_UserTypeDeleted: return TdDestroyObject ((struct TdUserTypeDeleted *)var);
    case CODE_UserTypeBot: return TdDestroyObject ((struct TdUserTypeBot *)var);
    case CODE_UserTypeUnknown: return TdDestroyObject ((struct TdUserTypeUnknown *)var);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
void TdStackStorerUserType (struct TdUserType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserType *var, struct TdStackStorerMethods *M) {
  if (!var) { M->pack_bool (0); return; }
  int constructor = var->ID;
  switch (constructor) {
    case CODE_UserTypeRegular: return TdStackStorer ((struct TdUserTypeRegular *)var, M);
    case CODE_UserTypeDeleted: return TdStackStorer ((struct TdUserTypeDeleted *)var, M);
    case CODE_UserTypeBot: return TdStackStorer ((struct TdUserTypeBot *)var, M);
    case CODE_UserTypeUnknown: return TdStackStorer ((struct TdUserTypeUnknown *)var, M);
    default:
      LOG(FATAL) << "Unknown constructor found " << td::format::as_hex(constructor);
      return ;
  }
}
struct TdUserType *TdStackFetcherUserType (struct TdStackFetcherMethods *M) {
  M->get_field ("ID");
  char *constructor_old = M->get_string ();
  M->pop ();
  std::string constructor = constructor_old;
  free (constructor_old);
  if (constructor == "UserTypeRegular") {
    return (struct TdUserType *)TdStackFetcherUserTypeRegular (M);
  }
  if (constructor == "UserTypeDeleted") {
    return (struct TdUserType *)TdStackFetcherUserTypeDeleted (M);
  }
  if (constructor == "UserTypeBot") {
    return (struct TdUserType *)TdStackFetcherUserTypeBot (M);
  }
  if (constructor == "UserTypeUnknown") {
    return (struct TdUserType *)TdStackFetcherUserTypeUnknown (M);
  }
  {
    LOG(FATAL) << "Unknown constructor found " << constructor;
    return nullptr;
  }
}
struct TdUserTypeRegular *TdCreateObjectUserTypeRegular (void) {
  auto var = new struct TdUserTypeRegular ();
  var->ID = CODE_UserTypeRegular;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userTypeRegular> TdConvertToInternal (struct TdUserTypeRegular *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userTypeRegular>();
}
struct TdUserTypeRegular *TdConvertFromInternal (const td::td_api::userTypeRegular &from) {
  auto res = new TdUserTypeRegular ();
  res->ID = CODE_UserTypeRegular;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserTypeRegular (struct TdUserTypeRegular *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserTypeRegular *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserTypeRegular (struct TdUserTypeRegular *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserTypeRegular *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserTypeRegular (struct TdUserTypeRegular *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserTypeRegular *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserTypeRegular");
  M->new_field ("ID");
}
struct TdUserTypeRegular *TdStackFetcherUserTypeRegular (struct TdStackFetcherMethods *M) {
  auto res = new TdUserTypeRegular ();
  res->ID = CODE_UserTypeRegular;
  res->refcnt = 1;
  return res;
}
struct TdUserTypeDeleted *TdCreateObjectUserTypeDeleted (void) {
  auto var = new struct TdUserTypeDeleted ();
  var->ID = CODE_UserTypeDeleted;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userTypeDeleted> TdConvertToInternal (struct TdUserTypeDeleted *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userTypeDeleted>();
}
struct TdUserTypeDeleted *TdConvertFromInternal (const td::td_api::userTypeDeleted &from) {
  auto res = new TdUserTypeDeleted ();
  res->ID = CODE_UserTypeDeleted;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserTypeDeleted (struct TdUserTypeDeleted *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserTypeDeleted *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserTypeDeleted (struct TdUserTypeDeleted *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserTypeDeleted *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserTypeDeleted (struct TdUserTypeDeleted *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserTypeDeleted *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserTypeDeleted");
  M->new_field ("ID");
}
struct TdUserTypeDeleted *TdStackFetcherUserTypeDeleted (struct TdStackFetcherMethods *M) {
  auto res = new TdUserTypeDeleted ();
  res->ID = CODE_UserTypeDeleted;
  res->refcnt = 1;
  return res;
}
struct TdUserTypeBot *TdCreateObjectUserTypeBot (int can_join_groups_, int can_read_all_group_messages_, int is_inline_, char *inline_query_placeholder_, int need_location_) {
  auto var = new struct TdUserTypeBot ();
  var->ID = CODE_UserTypeBot;
  var->refcnt = 1;
  var->can_join_groups_ = can_join_groups_;
  var->can_read_all_group_messages_ = can_read_all_group_messages_;
  var->is_inline_ = is_inline_;
  var->inline_query_placeholder_ = (inline_query_placeholder_) ? td::str_dup (td::Slice (inline_query_placeholder_)) : nullptr;
  var->need_location_ = need_location_;
  return var;
}
td::td_api::object_ptr<td::td_api::userTypeBot> TdConvertToInternal (struct TdUserTypeBot *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->can_join_groups_ != 0;
  bool v100;
  v100 = var->can_read_all_group_messages_ != 0;
  bool v200;
  v200 = var->is_inline_ != 0;
  std::string v300;
  v300 = (var->inline_query_placeholder_) ? var->inline_query_placeholder_: "";
  bool v400;
  v400 = var->need_location_ != 0;
  return td::td_api::make_object<td::td_api::userTypeBot>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdUserTypeBot *TdConvertFromInternal (const td::td_api::userTypeBot &from) {
  auto res = new TdUserTypeBot ();
  res->ID = CODE_UserTypeBot;
  res->refcnt = 1;
  res->can_join_groups_ = from.can_join_groups_;
  res->can_read_all_group_messages_ = from.can_read_all_group_messages_;
  res->is_inline_ = from.is_inline_;
  res->inline_query_placeholder_ = (from.inline_query_placeholder_.length ()) ? td::str_dup (from.inline_query_placeholder_) : nullptr;
  res->need_location_ = from.need_location_;
  return res;
}
char *TdSerializeUserTypeBot (struct TdUserTypeBot *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserTypeBot *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserTypeBot (struct TdUserTypeBot *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserTypeBot *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_query_placeholder_);
  delete var;
}
void TdStackStorerUserTypeBot (struct TdUserTypeBot *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserTypeBot *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserTypeBot");
  M->new_field ("ID");
  M->pack_bool (var->can_join_groups_);
  M->new_field ("can_join_groups_");
  M->pack_bool (var->can_read_all_group_messages_);
  M->new_field ("can_read_all_group_messages_");
  M->pack_bool (var->is_inline_);
  M->new_field ("is_inline_");
  M->pack_string (var->inline_query_placeholder_);
  M->new_field ("inline_query_placeholder_");
  M->pack_bool (var->need_location_);
  M->new_field ("need_location_");
}
struct TdUserTypeBot *TdStackFetcherUserTypeBot (struct TdStackFetcherMethods *M) {
  auto res = new TdUserTypeBot ();
  res->ID = CODE_UserTypeBot;
  res->refcnt = 1;
  M->get_field ("can_join_groups_");
  res->can_join_groups_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("can_read_all_group_messages_");
  res->can_read_all_group_messages_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_inline_");
  res->is_inline_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("inline_query_placeholder_");
  res->inline_query_placeholder_ = M->get_string ();
  M->pop ();
  M->get_field ("need_location_");
  res->need_location_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUserTypeUnknown *TdCreateObjectUserTypeUnknown (void) {
  auto var = new struct TdUserTypeUnknown ();
  var->ID = CODE_UserTypeUnknown;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::userTypeUnknown> TdConvertToInternal (struct TdUserTypeUnknown *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::userTypeUnknown>();
}
struct TdUserTypeUnknown *TdConvertFromInternal (const td::td_api::userTypeUnknown &from) {
  auto res = new TdUserTypeUnknown ();
  res->ID = CODE_UserTypeUnknown;
  res->refcnt = 1;
  return res;
}
char *TdSerializeUserTypeUnknown (struct TdUserTypeUnknown *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUserTypeUnknown *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUserTypeUnknown (struct TdUserTypeUnknown *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUserTypeUnknown *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUserTypeUnknown (struct TdUserTypeUnknown *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUserTypeUnknown *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UserTypeUnknown");
  M->new_field ("ID");
}
struct TdUserTypeUnknown *TdStackFetcherUserTypeUnknown (struct TdStackFetcherMethods *M) {
  auto res = new TdUserTypeUnknown ();
  res->ID = CODE_UserTypeUnknown;
  res->refcnt = 1;
  return res;
}
struct TdUsers *TdCreateObjectUsers (int total_count_, struct TdVectorInt *user_ids_) {
  auto var = new struct TdUsers ();
  var->ID = CODE_Users;
  var->refcnt = 1;
  var->total_count_ = total_count_;
  var->user_ids_ = user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::users> TdConvertToInternal (struct TdUsers *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->total_count_;
  std::vector<std::int32_t> v100;
  for (int i100 = 0; i100 < var->user_ids_->len; i100++) {
    std::int32_t v101;
    v101 = var->user_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::users>(std::move (v0), std::move (v100));
}
struct TdUsers *TdConvertFromInternal (const td::td_api::users &from) {
  auto res = new TdUsers ();
  res->ID = CODE_Users;
  res->refcnt = 1;
  res->total_count_ = from.total_count_;
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = (int)from.user_ids_.size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i100 = 0; i100 < res->user_ids_->len; i100++) {
    res->user_ids_->data[i100] = from.user_ids_[i100];
  }
  return res;
}
char *TdSerializeUsers (struct TdUsers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUsers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUsers (struct TdUsers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUsers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->user_ids_->len; i100++) {
  }
  delete[] var->user_ids_->data;
  delete var->user_ids_;
  delete var;
}
void TdStackStorerUsers (struct TdUsers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUsers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Users");
  M->new_field ("ID");
  M->pack_long (var->total_count_);
  M->new_field ("total_count_");
  M->new_array ();
  for (int i100 = 0; i100 < var->user_ids_->len; i100++) {
    M->pack_long (var->user_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("user_ids_");
}
struct TdUsers *TdStackFetcherUsers (struct TdStackFetcherMethods *M) {
  auto res = new TdUsers ();
  res->ID = CODE_Users;
  res->refcnt = 1;
  M->get_field ("total_count_");
  res->total_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_ids_");
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = M->get_arr_size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i100 = 0; i100 < res->user_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->user_ids_->data[i100] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdValidatedOrderInfo *TdCreateObjectValidatedOrderInfo (char *order_info_id_, struct TdVectorShippingOption *shipping_options_) {
  auto var = new struct TdValidatedOrderInfo ();
  var->ID = CODE_ValidatedOrderInfo;
  var->refcnt = 1;
  var->order_info_id_ = (order_info_id_) ? td::str_dup (td::Slice (order_info_id_)) : nullptr;
  var->shipping_options_ = shipping_options_;
  return var;
}
td::td_api::object_ptr<td::td_api::validatedOrderInfo> TdConvertToInternal (struct TdValidatedOrderInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->order_info_id_) ? var->order_info_id_: "";
  std::vector<td::td_api::object_ptr<td::td_api::shippingOption>> v100;
  for (int i100 = 0; i100 < var->shipping_options_->len; i100++) {
    td::td_api::object_ptr<td::td_api::shippingOption> v101;
    v101 = TdConvertToInternal (var->shipping_options_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::validatedOrderInfo>(std::move (v0), std::move (v100));
}
struct TdValidatedOrderInfo *TdConvertFromInternal (const td::td_api::validatedOrderInfo &from) {
  auto res = new TdValidatedOrderInfo ();
  res->ID = CODE_ValidatedOrderInfo;
  res->refcnt = 1;
  res->order_info_id_ = (from.order_info_id_.length ()) ? td::str_dup (from.order_info_id_) : nullptr;
  res->shipping_options_ = new TdVectorShippingOption ();
  res->shipping_options_->len = (int)from.shipping_options_.size ();
  res->shipping_options_->data = new struct TdShippingOption * [res->shipping_options_->len];
  for (int i100 = 0; i100 < res->shipping_options_->len; i100++) {
    if (!from.shipping_options_[i100]) {
      res->shipping_options_->data[i100] = nullptr;
    } else {
      res->shipping_options_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::shippingOption &>(*from.shipping_options_[i100]));
    }
  }
  return res;
}
char *TdSerializeValidatedOrderInfo (struct TdValidatedOrderInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdValidatedOrderInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectValidatedOrderInfo (struct TdValidatedOrderInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdValidatedOrderInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->order_info_id_);
  for (int i100 = 0; i100 < var->shipping_options_->len; i100++) {
    TdDestroyObject (var->shipping_options_->data[i100]);
  }
  delete[] var->shipping_options_->data;
  delete var->shipping_options_;
  delete var;
}
void TdStackStorerValidatedOrderInfo (struct TdValidatedOrderInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdValidatedOrderInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ValidatedOrderInfo");
  M->new_field ("ID");
  M->pack_string (var->order_info_id_);
  M->new_field ("order_info_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->shipping_options_->len; i100++) {
    TdStackStorer (var->shipping_options_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("shipping_options_");
}
struct TdValidatedOrderInfo *TdStackFetcherValidatedOrderInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdValidatedOrderInfo ();
  res->ID = CODE_ValidatedOrderInfo;
  res->refcnt = 1;
  M->get_field ("order_info_id_");
  res->order_info_id_ = M->get_string ();
  M->pop ();
  M->get_field ("shipping_options_");
  res->shipping_options_ = new TdVectorShippingOption ();
  res->shipping_options_->len = M->get_arr_size ();
  res->shipping_options_->data = new struct TdShippingOption * [res->shipping_options_->len];
  for (int i100 = 0; i100 < res->shipping_options_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->shipping_options_->data[i100] = nullptr;
    } else {
      res->shipping_options_->data[i100] = TdStackFetcherShippingOption (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdVenue *TdCreateObjectVenue (struct TdLocation *location_, char *title_, char *address_, char *provider_, char *id_, char *type_) {
  auto var = new struct TdVenue ();
  var->ID = CODE_Venue;
  var->refcnt = 1;
  var->location_ = location_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->address_ = (address_) ? td::str_dup (td::Slice (address_)) : nullptr;
  var->provider_ = (provider_) ? td::str_dup (td::Slice (provider_)) : nullptr;
  var->id_ = (id_) ? td::str_dup (td::Slice (id_)) : nullptr;
  var->type_ = (type_) ? td::str_dup (td::Slice (type_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::venue> TdConvertToInternal (struct TdVenue *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::location> v0;
  v0 = TdConvertToInternal (var->location_);
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->address_) ? var->address_: "";
  std::string v300;
  v300 = (var->provider_) ? var->provider_: "";
  std::string v400;
  v400 = (var->id_) ? var->id_: "";
  std::string v500;
  v500 = (var->type_) ? var->type_: "";
  return td::td_api::make_object<td::td_api::venue>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdVenue *TdConvertFromInternal (const td::td_api::venue &from) {
  auto res = new TdVenue ();
  res->ID = CODE_Venue;
  res->refcnt = 1;
  if (!from.location_) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.location_));
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->address_ = (from.address_.length ()) ? td::str_dup (from.address_) : nullptr;
  res->provider_ = (from.provider_.length ()) ? td::str_dup (from.provider_) : nullptr;
  res->id_ = (from.id_.length ()) ? td::str_dup (from.id_) : nullptr;
  res->type_ = (from.type_.length ()) ? td::str_dup (from.type_) : nullptr;
  return res;
}
char *TdSerializeVenue (struct TdVenue *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdVenue *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectVenue (struct TdVenue *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdVenue *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->location_);
  free (var->title_);
  free (var->address_);
  free (var->provider_);
  free (var->id_);
  free (var->type_);
  delete var;
}
void TdStackStorerVenue (struct TdVenue *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdVenue *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Venue");
  M->new_field ("ID");
  TdStackStorer (var->location_, M);
  M->new_field ("location_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->address_);
  M->new_field ("address_");
  M->pack_string (var->provider_);
  M->new_field ("provider_");
  M->pack_string (var->id_);
  M->new_field ("id_");
  M->pack_string (var->type_);
  M->new_field ("type_");
}
struct TdVenue *TdStackFetcherVenue (struct TdStackFetcherMethods *M) {
  auto res = new TdVenue ();
  res->ID = CODE_Venue;
  res->refcnt = 1;
  M->get_field ("location_");
  if (M->is_nil ()) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("address_");
  res->address_ = M->get_string ();
  M->pop ();
  M->get_field ("provider_");
  res->provider_ = M->get_string ();
  M->pop ();
  M->get_field ("id_");
  res->id_ = M->get_string ();
  M->pop ();
  M->get_field ("type_");
  res->type_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdVideo *TdCreateObjectVideo (int duration_, int width_, int height_, char *file_name_, char *mime_type_, int has_stickers_, int supports_streaming_, struct TdPhotoSize *thumbnail_, struct TdFile *video_) {
  auto var = new struct TdVideo ();
  var->ID = CODE_Video;
  var->refcnt = 1;
  var->duration_ = duration_;
  var->width_ = width_;
  var->height_ = height_;
  var->file_name_ = (file_name_) ? td::str_dup (td::Slice (file_name_)) : nullptr;
  var->mime_type_ = (mime_type_) ? td::str_dup (td::Slice (mime_type_)) : nullptr;
  var->has_stickers_ = has_stickers_;
  var->supports_streaming_ = supports_streaming_;
  var->thumbnail_ = thumbnail_;
  var->video_ = video_;
  return var;
}
td::td_api::object_ptr<td::td_api::video> TdConvertToInternal (struct TdVideo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->duration_;
  std::int32_t v100;
  v100 = var->width_;
  std::int32_t v200;
  v200 = var->height_;
  std::string v300;
  v300 = (var->file_name_) ? var->file_name_: "";
  std::string v400;
  v400 = (var->mime_type_) ? var->mime_type_: "";
  bool v500;
  v500 = var->has_stickers_ != 0;
  bool v600;
  v600 = var->supports_streaming_ != 0;
  td::td_api::object_ptr<td::td_api::photoSize> v700;
  v700 = TdConvertToInternal (var->thumbnail_);
  td::td_api::object_ptr<td::td_api::file> v800;
  v800 = TdConvertToInternal (var->video_);
  return td::td_api::make_object<td::td_api::video>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800));
}
struct TdVideo *TdConvertFromInternal (const td::td_api::video &from) {
  auto res = new TdVideo ();
  res->ID = CODE_Video;
  res->refcnt = 1;
  res->duration_ = from.duration_;
  res->width_ = from.width_;
  res->height_ = from.height_;
  res->file_name_ = (from.file_name_.length ()) ? td::str_dup (from.file_name_) : nullptr;
  res->mime_type_ = (from.mime_type_.length ()) ? td::str_dup (from.mime_type_) : nullptr;
  res->has_stickers_ = from.has_stickers_;
  res->supports_streaming_ = from.supports_streaming_;
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  if (!from.video_) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.video_));
  }
  return res;
}
char *TdSerializeVideo (struct TdVideo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdVideo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectVideo (struct TdVideo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdVideo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->file_name_);
  free (var->mime_type_);
  TdDestroyObject (var->thumbnail_);
  TdDestroyObject (var->video_);
  delete var;
}
void TdStackStorerVideo (struct TdVideo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdVideo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Video");
  M->new_field ("ID");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
  M->pack_string (var->file_name_);
  M->new_field ("file_name_");
  M->pack_string (var->mime_type_);
  M->new_field ("mime_type_");
  M->pack_bool (var->has_stickers_);
  M->new_field ("has_stickers_");
  M->pack_bool (var->supports_streaming_);
  M->new_field ("supports_streaming_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  TdStackStorer (var->video_, M);
  M->new_field ("video_");
}
struct TdVideo *TdStackFetcherVideo (struct TdStackFetcherMethods *M) {
  auto res = new TdVideo ();
  res->ID = CODE_Video;
  res->refcnt = 1;
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("file_name_");
  res->file_name_ = M->get_string ();
  M->pop ();
  M->get_field ("mime_type_");
  res->mime_type_ = M->get_string ();
  M->pop ();
  M->get_field ("has_stickers_");
  res->has_stickers_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("supports_streaming_");
  res->supports_streaming_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  M->get_field ("video_");
  if (M->is_nil ()) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdVideoNote *TdCreateObjectVideoNote (int duration_, int length_, struct TdPhotoSize *thumbnail_, struct TdFile *video_) {
  auto var = new struct TdVideoNote ();
  var->ID = CODE_VideoNote;
  var->refcnt = 1;
  var->duration_ = duration_;
  var->length_ = length_;
  var->thumbnail_ = thumbnail_;
  var->video_ = video_;
  return var;
}
td::td_api::object_ptr<td::td_api::videoNote> TdConvertToInternal (struct TdVideoNote *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->duration_;
  std::int32_t v100;
  v100 = var->length_;
  td::td_api::object_ptr<td::td_api::photoSize> v200;
  v200 = TdConvertToInternal (var->thumbnail_);
  td::td_api::object_ptr<td::td_api::file> v300;
  v300 = TdConvertToInternal (var->video_);
  return td::td_api::make_object<td::td_api::videoNote>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdVideoNote *TdConvertFromInternal (const td::td_api::videoNote &from) {
  auto res = new TdVideoNote ();
  res->ID = CODE_VideoNote;
  res->refcnt = 1;
  res->duration_ = from.duration_;
  res->length_ = from.length_;
  if (!from.thumbnail_) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.thumbnail_));
  }
  if (!from.video_) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.video_));
  }
  return res;
}
char *TdSerializeVideoNote (struct TdVideoNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdVideoNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectVideoNote (struct TdVideoNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdVideoNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->thumbnail_);
  TdDestroyObject (var->video_);
  delete var;
}
void TdStackStorerVideoNote (struct TdVideoNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdVideoNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("VideoNote");
  M->new_field ("ID");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_long (var->length_);
  M->new_field ("length_");
  TdStackStorer (var->thumbnail_, M);
  M->new_field ("thumbnail_");
  TdStackStorer (var->video_, M);
  M->new_field ("video_");
}
struct TdVideoNote *TdStackFetcherVideoNote (struct TdStackFetcherMethods *M) {
  auto res = new TdVideoNote ();
  res->ID = CODE_VideoNote;
  res->refcnt = 1;
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("length_");
  res->length_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("thumbnail_");
  if (M->is_nil ()) {
    res->thumbnail_ = nullptr;
  } else {
    res->thumbnail_ = TdStackFetcherPhotoSize (M);
  }
  M->pop ();
  M->get_field ("video_");
  if (M->is_nil ()) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdVoiceNote *TdCreateObjectVoiceNote (int duration_, struct TdBytes waveform_, char *mime_type_, struct TdFile *voice_) {
  auto var = new struct TdVoiceNote ();
  var->ID = CODE_VoiceNote;
  var->refcnt = 1;
  var->duration_ = duration_;
  var->waveform_ = waveform_;
  var->mime_type_ = (mime_type_) ? td::str_dup (td::Slice (mime_type_)) : nullptr;
  var->voice_ = voice_;
  return var;
}
td::td_api::object_ptr<td::td_api::voiceNote> TdConvertToInternal (struct TdVoiceNote *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->duration_;
  std::string v100;
  v100 = std::string ((char *)var->waveform_.data, var->waveform_.len);
  std::string v200;
  v200 = (var->mime_type_) ? var->mime_type_: "";
  td::td_api::object_ptr<td::td_api::file> v300;
  v300 = TdConvertToInternal (var->voice_);
  return td::td_api::make_object<td::td_api::voiceNote>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdVoiceNote *TdConvertFromInternal (const td::td_api::voiceNote &from) {
  auto res = new TdVoiceNote ();
  res->ID = CODE_VoiceNote;
  res->refcnt = 1;
  res->duration_ = from.duration_;
  res->waveform_.len = (int)from.waveform_.length ();
  if (res->waveform_.len) {
    res->waveform_.data = new unsigned char[res->waveform_.len];
    memcpy (res->waveform_.data, from.waveform_.c_str (), res->waveform_.len);
  } else {
    res->waveform_.data = nullptr;
  }
  res->mime_type_ = (from.mime_type_.length ()) ? td::str_dup (from.mime_type_) : nullptr;
  if (!from.voice_) {
    res->voice_ = nullptr;
  } else {
    res->voice_ = TdConvertFromInternal (static_cast<const td::td_api::file &>(*from.voice_));
  }
  return res;
}
char *TdSerializeVoiceNote (struct TdVoiceNote *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdVoiceNote *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectVoiceNote (struct TdVoiceNote *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdVoiceNote *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->waveform_.data;
  free (var->mime_type_);
  TdDestroyObject (var->voice_);
  delete var;
}
void TdStackStorerVoiceNote (struct TdVoiceNote *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdVoiceNote *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("VoiceNote");
  M->new_field ("ID");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_bytes (var->waveform_.data, var->waveform_.len);
  M->new_field ("waveform_");
  M->pack_string (var->mime_type_);
  M->new_field ("mime_type_");
  TdStackStorer (var->voice_, M);
  M->new_field ("voice_");
}
struct TdVoiceNote *TdStackFetcherVoiceNote (struct TdStackFetcherMethods *M) {
  auto res = new TdVoiceNote ();
  res->ID = CODE_VoiceNote;
  res->refcnt = 1;
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("waveform_");
  res->waveform_.data = M->get_bytes (&res->waveform_.len);
  M->pop ();
  M->get_field ("mime_type_");
  res->mime_type_ = M->get_string ();
  M->pop ();
  M->get_field ("voice_");
  if (M->is_nil ()) {
    res->voice_ = nullptr;
  } else {
    res->voice_ = TdStackFetcherFile (M);
  }
  M->pop ();
  return res;
}
struct TdWallpaper *TdCreateObjectWallpaper (int id_, struct TdVectorPhotoSize *sizes_, int color_) {
  auto var = new struct TdWallpaper ();
  var->ID = CODE_Wallpaper;
  var->refcnt = 1;
  var->id_ = id_;
  var->sizes_ = sizes_;
  var->color_ = color_;
  return var;
}
td::td_api::object_ptr<td::td_api::wallpaper> TdConvertToInternal (struct TdWallpaper *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->id_;
  std::vector<td::td_api::object_ptr<td::td_api::photoSize>> v100;
  for (int i100 = 0; i100 < var->sizes_->len; i100++) {
    td::td_api::object_ptr<td::td_api::photoSize> v101;
    v101 = TdConvertToInternal (var->sizes_->data[i100]);
    v100.push_back (std::move (v101));
  }
  std::int32_t v200;
  v200 = var->color_;
  return td::td_api::make_object<td::td_api::wallpaper>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdWallpaper *TdConvertFromInternal (const td::td_api::wallpaper &from) {
  auto res = new TdWallpaper ();
  res->ID = CODE_Wallpaper;
  res->refcnt = 1;
  res->id_ = from.id_;
  res->sizes_ = new TdVectorPhotoSize ();
  res->sizes_->len = (int)from.sizes_.size ();
  res->sizes_->data = new struct TdPhotoSize * [res->sizes_->len];
  for (int i100 = 0; i100 < res->sizes_->len; i100++) {
    if (!from.sizes_[i100]) {
      res->sizes_->data[i100] = nullptr;
    } else {
      res->sizes_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::photoSize &>(*from.sizes_[i100]));
    }
  }
  res->color_ = from.color_;
  return res;
}
char *TdSerializeWallpaper (struct TdWallpaper *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdWallpaper *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectWallpaper (struct TdWallpaper *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdWallpaper *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->sizes_->len; i100++) {
    TdDestroyObject (var->sizes_->data[i100]);
  }
  delete[] var->sizes_->data;
  delete var->sizes_;
  delete var;
}
void TdStackStorerWallpaper (struct TdWallpaper *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdWallpaper *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Wallpaper");
  M->new_field ("ID");
  M->pack_long (var->id_);
  M->new_field ("id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->sizes_->len; i100++) {
    TdStackStorer (var->sizes_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("sizes_");
  M->pack_long (var->color_);
  M->new_field ("color_");
}
struct TdWallpaper *TdStackFetcherWallpaper (struct TdStackFetcherMethods *M) {
  auto res = new TdWallpaper ();
  res->ID = CODE_Wallpaper;
  res->refcnt = 1;
  M->get_field ("id_");
  res->id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sizes_");
  res->sizes_ = new TdVectorPhotoSize ();
  res->sizes_->len = M->get_arr_size ();
  res->sizes_->data = new struct TdPhotoSize * [res->sizes_->len];
  for (int i100 = 0; i100 < res->sizes_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->sizes_->data[i100] = nullptr;
    } else {
      res->sizes_->data[i100] = TdStackFetcherPhotoSize (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("color_");
  res->color_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdWallpapers *TdCreateObjectWallpapers (struct TdVectorWallpaper *wallpapers_) {
  auto var = new struct TdWallpapers ();
  var->ID = CODE_Wallpapers;
  var->refcnt = 1;
  var->wallpapers_ = wallpapers_;
  return var;
}
td::td_api::object_ptr<td::td_api::wallpapers> TdConvertToInternal (struct TdWallpapers *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::wallpaper>> v0;
  for (int i0 = 0; i0 < var->wallpapers_->len; i0++) {
    td::td_api::object_ptr<td::td_api::wallpaper> v1;
    v1 = TdConvertToInternal (var->wallpapers_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::wallpapers>(std::move (v0));
}
struct TdWallpapers *TdConvertFromInternal (const td::td_api::wallpapers &from) {
  auto res = new TdWallpapers ();
  res->ID = CODE_Wallpapers;
  res->refcnt = 1;
  res->wallpapers_ = new TdVectorWallpaper ();
  res->wallpapers_->len = (int)from.wallpapers_.size ();
  res->wallpapers_->data = new struct TdWallpaper * [res->wallpapers_->len];
  for (int i0 = 0; i0 < res->wallpapers_->len; i0++) {
    if (!from.wallpapers_[i0]) {
      res->wallpapers_->data[i0] = nullptr;
    } else {
      res->wallpapers_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::wallpaper &>(*from.wallpapers_[i0]));
    }
  }
  return res;
}
char *TdSerializeWallpapers (struct TdWallpapers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdWallpapers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectWallpapers (struct TdWallpapers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdWallpapers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->wallpapers_->len; i0++) {
    TdDestroyObject (var->wallpapers_->data[i0]);
  }
  delete[] var->wallpapers_->data;
  delete var->wallpapers_;
  delete var;
}
void TdStackStorerWallpapers (struct TdWallpapers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdWallpapers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Wallpapers");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->wallpapers_->len; i0++) {
    TdStackStorer (var->wallpapers_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("wallpapers_");
}
struct TdWallpapers *TdStackFetcherWallpapers (struct TdStackFetcherMethods *M) {
  auto res = new TdWallpapers ();
  res->ID = CODE_Wallpapers;
  res->refcnt = 1;
  M->get_field ("wallpapers_");
  res->wallpapers_ = new TdVectorWallpaper ();
  res->wallpapers_->len = M->get_arr_size ();
  res->wallpapers_->data = new struct TdWallpaper * [res->wallpapers_->len];
  for (int i0 = 0; i0 < res->wallpapers_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->wallpapers_->data[i0] = nullptr;
    } else {
      res->wallpapers_->data[i0] = TdStackFetcherWallpaper (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdWebPage *TdCreateObjectWebPage (char *url_, char *display_url_, char *type_, char *site_name_, char *title_, char *description_, struct TdPhoto *photo_, char *embed_url_, char *embed_type_, int embed_width_, int embed_height_, int duration_, char *author_, struct TdAnimation *animation_, struct TdAudio *audio_, struct TdDocument *document_, struct TdSticker *sticker_, struct TdVideo *video_, struct TdVideoNote *video_note_, struct TdVoiceNote *voice_note_, int has_instant_view_) {
  auto var = new struct TdWebPage ();
  var->ID = CODE_WebPage;
  var->refcnt = 1;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->display_url_ = (display_url_) ? td::str_dup (td::Slice (display_url_)) : nullptr;
  var->type_ = (type_) ? td::str_dup (td::Slice (type_)) : nullptr;
  var->site_name_ = (site_name_) ? td::str_dup (td::Slice (site_name_)) : nullptr;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  var->photo_ = photo_;
  var->embed_url_ = (embed_url_) ? td::str_dup (td::Slice (embed_url_)) : nullptr;
  var->embed_type_ = (embed_type_) ? td::str_dup (td::Slice (embed_type_)) : nullptr;
  var->embed_width_ = embed_width_;
  var->embed_height_ = embed_height_;
  var->duration_ = duration_;
  var->author_ = (author_) ? td::str_dup (td::Slice (author_)) : nullptr;
  var->animation_ = animation_;
  var->audio_ = audio_;
  var->document_ = document_;
  var->sticker_ = sticker_;
  var->video_ = video_;
  var->video_note_ = video_note_;
  var->voice_note_ = voice_note_;
  var->has_instant_view_ = has_instant_view_;
  return var;
}
td::td_api::object_ptr<td::td_api::webPage> TdConvertToInternal (struct TdWebPage *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->url_) ? var->url_: "";
  std::string v100;
  v100 = (var->display_url_) ? var->display_url_: "";
  std::string v200;
  v200 = (var->type_) ? var->type_: "";
  std::string v300;
  v300 = (var->site_name_) ? var->site_name_: "";
  std::string v400;
  v400 = (var->title_) ? var->title_: "";
  std::string v500;
  v500 = (var->description_) ? var->description_: "";
  td::td_api::object_ptr<td::td_api::photo> v600;
  v600 = TdConvertToInternal (var->photo_);
  std::string v700;
  v700 = (var->embed_url_) ? var->embed_url_: "";
  std::string v800;
  v800 = (var->embed_type_) ? var->embed_type_: "";
  std::int32_t v900;
  v900 = var->embed_width_;
  std::int32_t v1000;
  v1000 = var->embed_height_;
  std::int32_t v1100;
  v1100 = var->duration_;
  std::string v1200;
  v1200 = (var->author_) ? var->author_: "";
  td::td_api::object_ptr<td::td_api::animation> v1300;
  v1300 = TdConvertToInternal (var->animation_);
  td::td_api::object_ptr<td::td_api::audio> v1400;
  v1400 = TdConvertToInternal (var->audio_);
  td::td_api::object_ptr<td::td_api::document> v1500;
  v1500 = TdConvertToInternal (var->document_);
  td::td_api::object_ptr<td::td_api::sticker> v1600;
  v1600 = TdConvertToInternal (var->sticker_);
  td::td_api::object_ptr<td::td_api::video> v1700;
  v1700 = TdConvertToInternal (var->video_);
  td::td_api::object_ptr<td::td_api::videoNote> v1800;
  v1800 = TdConvertToInternal (var->video_note_);
  td::td_api::object_ptr<td::td_api::voiceNote> v1900;
  v1900 = TdConvertToInternal (var->voice_note_);
  bool v2000;
  v2000 = var->has_instant_view_ != 0;
  return td::td_api::make_object<td::td_api::webPage>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700), std::move (v800), std::move (v900), std::move (v1000), std::move (v1100), std::move (v1200), std::move (v1300), std::move (v1400), std::move (v1500), std::move (v1600), std::move (v1700), std::move (v1800), std::move (v1900), std::move (v2000));
}
struct TdWebPage *TdConvertFromInternal (const td::td_api::webPage &from) {
  auto res = new TdWebPage ();
  res->ID = CODE_WebPage;
  res->refcnt = 1;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  res->display_url_ = (from.display_url_.length ()) ? td::str_dup (from.display_url_) : nullptr;
  res->type_ = (from.type_.length ()) ? td::str_dup (from.type_) : nullptr;
  res->site_name_ = (from.site_name_.length ()) ? td::str_dup (from.site_name_) : nullptr;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::photo &>(*from.photo_));
  }
  res->embed_url_ = (from.embed_url_.length ()) ? td::str_dup (from.embed_url_) : nullptr;
  res->embed_type_ = (from.embed_type_.length ()) ? td::str_dup (from.embed_type_) : nullptr;
  res->embed_width_ = from.embed_width_;
  res->embed_height_ = from.embed_height_;
  res->duration_ = from.duration_;
  res->author_ = (from.author_.length ()) ? td::str_dup (from.author_) : nullptr;
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::animation &>(*from.animation_));
  }
  if (!from.audio_) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdConvertFromInternal (static_cast<const td::td_api::audio &>(*from.audio_));
  }
  if (!from.document_) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdConvertFromInternal (static_cast<const td::td_api::document &>(*from.document_));
  }
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::sticker &>(*from.sticker_));
  }
  if (!from.video_) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdConvertFromInternal (static_cast<const td::td_api::video &>(*from.video_));
  }
  if (!from.video_note_) {
    res->video_note_ = nullptr;
  } else {
    res->video_note_ = TdConvertFromInternal (static_cast<const td::td_api::videoNote &>(*from.video_note_));
  }
  if (!from.voice_note_) {
    res->voice_note_ = nullptr;
  } else {
    res->voice_note_ = TdConvertFromInternal (static_cast<const td::td_api::voiceNote &>(*from.voice_note_));
  }
  res->has_instant_view_ = from.has_instant_view_;
  return res;
}
char *TdSerializeWebPage (struct TdWebPage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdWebPage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectWebPage (struct TdWebPage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdWebPage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->url_);
  free (var->display_url_);
  free (var->type_);
  free (var->site_name_);
  free (var->title_);
  free (var->description_);
  TdDestroyObject (var->photo_);
  free (var->embed_url_);
  free (var->embed_type_);
  free (var->author_);
  TdDestroyObject (var->animation_);
  TdDestroyObject (var->audio_);
  TdDestroyObject (var->document_);
  TdDestroyObject (var->sticker_);
  TdDestroyObject (var->video_);
  TdDestroyObject (var->video_note_);
  TdDestroyObject (var->voice_note_);
  delete var;
}
void TdStackStorerWebPage (struct TdWebPage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdWebPage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("WebPage");
  M->new_field ("ID");
  M->pack_string (var->url_);
  M->new_field ("url_");
  M->pack_string (var->display_url_);
  M->new_field ("display_url_");
  M->pack_string (var->type_);
  M->new_field ("type_");
  M->pack_string (var->site_name_);
  M->new_field ("site_name_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->description_);
  M->new_field ("description_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
  M->pack_string (var->embed_url_);
  M->new_field ("embed_url_");
  M->pack_string (var->embed_type_);
  M->new_field ("embed_type_");
  M->pack_long (var->embed_width_);
  M->new_field ("embed_width_");
  M->pack_long (var->embed_height_);
  M->new_field ("embed_height_");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_string (var->author_);
  M->new_field ("author_");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
  TdStackStorer (var->audio_, M);
  M->new_field ("audio_");
  TdStackStorer (var->document_, M);
  M->new_field ("document_");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
  TdStackStorer (var->video_, M);
  M->new_field ("video_");
  TdStackStorer (var->video_note_, M);
  M->new_field ("video_note_");
  TdStackStorer (var->voice_note_, M);
  M->new_field ("voice_note_");
  M->pack_bool (var->has_instant_view_);
  M->new_field ("has_instant_view_");
}
struct TdWebPage *TdStackFetcherWebPage (struct TdStackFetcherMethods *M) {
  auto res = new TdWebPage ();
  res->ID = CODE_WebPage;
  res->refcnt = 1;
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("display_url_");
  res->display_url_ = M->get_string ();
  M->pop ();
  M->get_field ("type_");
  res->type_ = M->get_string ();
  M->pop ();
  M->get_field ("site_name_");
  res->site_name_ = M->get_string ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherPhoto (M);
  }
  M->pop ();
  M->get_field ("embed_url_");
  res->embed_url_ = M->get_string ();
  M->pop ();
  M->get_field ("embed_type_");
  res->embed_type_ = M->get_string ();
  M->pop ();
  M->get_field ("embed_width_");
  res->embed_width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("embed_height_");
  res->embed_height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("author_");
  res->author_ = M->get_string ();
  M->pop ();
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherAnimation (M);
  }
  M->pop ();
  M->get_field ("audio_");
  if (M->is_nil ()) {
    res->audio_ = nullptr;
  } else {
    res->audio_ = TdStackFetcherAudio (M);
  }
  M->pop ();
  M->get_field ("document_");
  if (M->is_nil ()) {
    res->document_ = nullptr;
  } else {
    res->document_ = TdStackFetcherDocument (M);
  }
  M->pop ();
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherSticker (M);
  }
  M->pop ();
  M->get_field ("video_");
  if (M->is_nil ()) {
    res->video_ = nullptr;
  } else {
    res->video_ = TdStackFetcherVideo (M);
  }
  M->pop ();
  M->get_field ("video_note_");
  if (M->is_nil ()) {
    res->video_note_ = nullptr;
  } else {
    res->video_note_ = TdStackFetcherVideoNote (M);
  }
  M->pop ();
  M->get_field ("voice_note_");
  if (M->is_nil ()) {
    res->voice_note_ = nullptr;
  } else {
    res->voice_note_ = TdStackFetcherVoiceNote (M);
  }
  M->pop ();
  M->get_field ("has_instant_view_");
  res->has_instant_view_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdWebPageInstantView *TdCreateObjectWebPageInstantView (struct TdVectorPageBlock *page_blocks_, int is_full_) {
  auto var = new struct TdWebPageInstantView ();
  var->ID = CODE_WebPageInstantView;
  var->refcnt = 1;
  var->page_blocks_ = page_blocks_;
  var->is_full_ = is_full_;
  return var;
}
td::td_api::object_ptr<td::td_api::webPageInstantView> TdConvertToInternal (struct TdWebPageInstantView *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::PageBlock>> v0;
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    td::td_api::object_ptr<td::td_api::PageBlock> v1;
    v1 = TdConvertToInternal (var->page_blocks_->data[i0]);
    v0.push_back (std::move (v1));
  }
  bool v100;
  v100 = var->is_full_ != 0;
  return td::td_api::make_object<td::td_api::webPageInstantView>(std::move (v0), std::move (v100));
}
struct TdWebPageInstantView *TdConvertFromInternal (const td::td_api::webPageInstantView &from) {
  auto res = new TdWebPageInstantView ();
  res->ID = CODE_WebPageInstantView;
  res->refcnt = 1;
  res->page_blocks_ = new TdVectorPageBlock ();
  res->page_blocks_->len = (int)from.page_blocks_.size ();
  res->page_blocks_->data = new struct TdPageBlock * [res->page_blocks_->len];
  for (int i0 = 0; i0 < res->page_blocks_->len; i0++) {
    if (!from.page_blocks_[i0]) {
      res->page_blocks_->data[i0] = nullptr;
    } else {
      res->page_blocks_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::PageBlock &>(*from.page_blocks_[i0]));
    }
  }
  res->is_full_ = from.is_full_;
  return res;
}
char *TdSerializeWebPageInstantView (struct TdWebPageInstantView *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdWebPageInstantView *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectWebPageInstantView (struct TdWebPageInstantView *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdWebPageInstantView *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    TdDestroyObject (var->page_blocks_->data[i0]);
  }
  delete[] var->page_blocks_->data;
  delete var->page_blocks_;
  delete var;
}
void TdStackStorerWebPageInstantView (struct TdWebPageInstantView *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdWebPageInstantView *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("WebPageInstantView");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->page_blocks_->len; i0++) {
    TdStackStorer (var->page_blocks_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("page_blocks_");
  M->pack_bool (var->is_full_);
  M->new_field ("is_full_");
}
struct TdWebPageInstantView *TdStackFetcherWebPageInstantView (struct TdStackFetcherMethods *M) {
  auto res = new TdWebPageInstantView ();
  res->ID = CODE_WebPageInstantView;
  res->refcnt = 1;
  M->get_field ("page_blocks_");
  res->page_blocks_ = new TdVectorPageBlock ();
  res->page_blocks_->len = M->get_arr_size ();
  res->page_blocks_->data = new struct TdPageBlock * [res->page_blocks_->len];
  for (int i0 = 0; i0 < res->page_blocks_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->page_blocks_->data[i0] = nullptr;
    } else {
      res->page_blocks_->data[i0] = TdStackFetcherPageBlock (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("is_full_");
  res->is_full_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdAcceptCall *TdCreateObjectAcceptCall (int call_id_, struct TdCallProtocol *protocol_) {
  auto var = new struct TdAcceptCall ();
  var->ID = CODE_AcceptCall;
  var->refcnt = 1;
  var->call_id_ = call_id_;
  var->protocol_ = protocol_;
  return var;
}
td::td_api::object_ptr<td::td_api::acceptCall> TdConvertToInternal (struct TdAcceptCall *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->call_id_;
  td::td_api::object_ptr<td::td_api::callProtocol> v100;
  v100 = TdConvertToInternal (var->protocol_);
  return td::td_api::make_object<td::td_api::acceptCall>(std::move (v0), std::move (v100));
}
struct TdAcceptCall *TdConvertFromInternal (const td::td_api::acceptCall &from) {
  auto res = new TdAcceptCall ();
  res->ID = CODE_AcceptCall;
  res->refcnt = 1;
  res->call_id_ = from.call_id_;
  if (!from.protocol_) {
    res->protocol_ = nullptr;
  } else {
    res->protocol_ = TdConvertFromInternal (static_cast<const td::td_api::callProtocol &>(*from.protocol_));
  }
  return res;
}
char *TdSerializeAcceptCall (struct TdAcceptCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAcceptCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAcceptCall (struct TdAcceptCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAcceptCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->protocol_);
  delete var;
}
void TdStackStorerAcceptCall (struct TdAcceptCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAcceptCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AcceptCall");
  M->new_field ("ID");
  M->pack_long (var->call_id_);
  M->new_field ("call_id_");
  TdStackStorer (var->protocol_, M);
  M->new_field ("protocol_");
}
struct TdAcceptCall *TdStackFetcherAcceptCall (struct TdStackFetcherMethods *M) {
  auto res = new TdAcceptCall ();
  res->ID = CODE_AcceptCall;
  res->refcnt = 1;
  M->get_field ("call_id_");
  res->call_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("protocol_");
  if (M->is_nil ()) {
    res->protocol_ = nullptr;
  } else {
    res->protocol_ = TdStackFetcherCallProtocol (M);
  }
  M->pop ();
  return res;
}
struct TdAcceptTermsOfService *TdCreateObjectAcceptTermsOfService (char *terms_of_service_id_) {
  auto var = new struct TdAcceptTermsOfService ();
  var->ID = CODE_AcceptTermsOfService;
  var->refcnt = 1;
  var->terms_of_service_id_ = (terms_of_service_id_) ? td::str_dup (td::Slice (terms_of_service_id_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::acceptTermsOfService> TdConvertToInternal (struct TdAcceptTermsOfService *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->terms_of_service_id_) ? var->terms_of_service_id_: "";
  return td::td_api::make_object<td::td_api::acceptTermsOfService>(std::move (v0));
}
struct TdAcceptTermsOfService *TdConvertFromInternal (const td::td_api::acceptTermsOfService &from) {
  auto res = new TdAcceptTermsOfService ();
  res->ID = CODE_AcceptTermsOfService;
  res->refcnt = 1;
  res->terms_of_service_id_ = (from.terms_of_service_id_.length ()) ? td::str_dup (from.terms_of_service_id_) : nullptr;
  return res;
}
char *TdSerializeAcceptTermsOfService (struct TdAcceptTermsOfService *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAcceptTermsOfService *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAcceptTermsOfService (struct TdAcceptTermsOfService *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAcceptTermsOfService *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->terms_of_service_id_);
  delete var;
}
void TdStackStorerAcceptTermsOfService (struct TdAcceptTermsOfService *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAcceptTermsOfService *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AcceptTermsOfService");
  M->new_field ("ID");
  M->pack_string (var->terms_of_service_id_);
  M->new_field ("terms_of_service_id_");
}
struct TdAcceptTermsOfService *TdStackFetcherAcceptTermsOfService (struct TdStackFetcherMethods *M) {
  auto res = new TdAcceptTermsOfService ();
  res->ID = CODE_AcceptTermsOfService;
  res->refcnt = 1;
  M->get_field ("terms_of_service_id_");
  res->terms_of_service_id_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdAddChatMember *TdCreateObjectAddChatMember (long long chat_id_, int user_id_, int forward_limit_) {
  auto var = new struct TdAddChatMember ();
  var->ID = CODE_AddChatMember;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->user_id_ = user_id_;
  var->forward_limit_ = forward_limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::addChatMember> TdConvertToInternal (struct TdAddChatMember *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->user_id_;
  std::int32_t v200;
  v200 = var->forward_limit_;
  return td::td_api::make_object<td::td_api::addChatMember>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdAddChatMember *TdConvertFromInternal (const td::td_api::addChatMember &from) {
  auto res = new TdAddChatMember ();
  res->ID = CODE_AddChatMember;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->user_id_ = from.user_id_;
  res->forward_limit_ = from.forward_limit_;
  return res;
}
char *TdSerializeAddChatMember (struct TdAddChatMember *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddChatMember *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddChatMember (struct TdAddChatMember *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddChatMember *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAddChatMember (struct TdAddChatMember *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddChatMember *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddChatMember");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_long (var->forward_limit_);
  M->new_field ("forward_limit_");
}
struct TdAddChatMember *TdStackFetcherAddChatMember (struct TdStackFetcherMethods *M) {
  auto res = new TdAddChatMember ();
  res->ID = CODE_AddChatMember;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("forward_limit_");
  res->forward_limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdAddChatMembers *TdCreateObjectAddChatMembers (long long chat_id_, struct TdVectorInt *user_ids_) {
  auto var = new struct TdAddChatMembers ();
  var->ID = CODE_AddChatMembers;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->user_ids_ = user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::addChatMembers> TdConvertToInternal (struct TdAddChatMembers *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::vector<std::int32_t> v100;
  for (int i100 = 0; i100 < var->user_ids_->len; i100++) {
    std::int32_t v101;
    v101 = var->user_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::addChatMembers>(std::move (v0), std::move (v100));
}
struct TdAddChatMembers *TdConvertFromInternal (const td::td_api::addChatMembers &from) {
  auto res = new TdAddChatMembers ();
  res->ID = CODE_AddChatMembers;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = (int)from.user_ids_.size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i100 = 0; i100 < res->user_ids_->len; i100++) {
    res->user_ids_->data[i100] = from.user_ids_[i100];
  }
  return res;
}
char *TdSerializeAddChatMembers (struct TdAddChatMembers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddChatMembers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddChatMembers (struct TdAddChatMembers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddChatMembers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->user_ids_->len; i100++) {
  }
  delete[] var->user_ids_->data;
  delete var->user_ids_;
  delete var;
}
void TdStackStorerAddChatMembers (struct TdAddChatMembers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddChatMembers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddChatMembers");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->user_ids_->len; i100++) {
    M->pack_long (var->user_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("user_ids_");
}
struct TdAddChatMembers *TdStackFetcherAddChatMembers (struct TdStackFetcherMethods *M) {
  auto res = new TdAddChatMembers ();
  res->ID = CODE_AddChatMembers;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("user_ids_");
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = M->get_arr_size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i100 = 0; i100 < res->user_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->user_ids_->data[i100] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdAddFavoriteSticker *TdCreateObjectAddFavoriteSticker (struct TdInputFile *sticker_) {
  auto var = new struct TdAddFavoriteSticker ();
  var->ID = CODE_AddFavoriteSticker;
  var->refcnt = 1;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::addFavoriteSticker> TdConvertToInternal (struct TdAddFavoriteSticker *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::addFavoriteSticker>(std::move (v0));
}
struct TdAddFavoriteSticker *TdConvertFromInternal (const td::td_api::addFavoriteSticker &from) {
  auto res = new TdAddFavoriteSticker ();
  res->ID = CODE_AddFavoriteSticker;
  res->refcnt = 1;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeAddFavoriteSticker (struct TdAddFavoriteSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddFavoriteSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddFavoriteSticker (struct TdAddFavoriteSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddFavoriteSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerAddFavoriteSticker (struct TdAddFavoriteSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddFavoriteSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddFavoriteSticker");
  M->new_field ("ID");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdAddFavoriteSticker *TdStackFetcherAddFavoriteSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdAddFavoriteSticker ();
  res->ID = CODE_AddFavoriteSticker;
  res->refcnt = 1;
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdAddLocalMessage *TdCreateObjectAddLocalMessage (long long chat_id_, int sender_user_id_, long long reply_to_message_id_, int disable_notification_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdAddLocalMessage ();
  var->ID = CODE_AddLocalMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->sender_user_id_ = sender_user_id_;
  var->reply_to_message_id_ = reply_to_message_id_;
  var->disable_notification_ = disable_notification_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::addLocalMessage> TdConvertToInternal (struct TdAddLocalMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->sender_user_id_;
  std::int64_t v200;
  v200 = var->reply_to_message_id_;
  bool v300;
  v300 = var->disable_notification_ != 0;
  td::td_api::object_ptr<td::td_api::InputMessageContent> v400;
  v400 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::addLocalMessage>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdAddLocalMessage *TdConvertFromInternal (const td::td_api::addLocalMessage &from) {
  auto res = new TdAddLocalMessage ();
  res->ID = CODE_AddLocalMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->sender_user_id_ = from.sender_user_id_;
  res->reply_to_message_id_ = from.reply_to_message_id_;
  res->disable_notification_ = from.disable_notification_;
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeAddLocalMessage (struct TdAddLocalMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddLocalMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddLocalMessage (struct TdAddLocalMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddLocalMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerAddLocalMessage (struct TdAddLocalMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddLocalMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddLocalMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  M->pack_long (var->reply_to_message_id_);
  M->new_field ("reply_to_message_id_");
  M->pack_bool (var->disable_notification_);
  M->new_field ("disable_notification_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdAddLocalMessage *TdStackFetcherAddLocalMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdAddLocalMessage ();
  res->ID = CODE_AddLocalMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_to_message_id_");
  res->reply_to_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("disable_notification_");
  res->disable_notification_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdAddNetworkStatistics *TdCreateObjectAddNetworkStatistics (struct TdNetworkStatisticsEntry *entry_) {
  auto var = new struct TdAddNetworkStatistics ();
  var->ID = CODE_AddNetworkStatistics;
  var->refcnt = 1;
  var->entry_ = entry_;
  return var;
}
td::td_api::object_ptr<td::td_api::addNetworkStatistics> TdConvertToInternal (struct TdAddNetworkStatistics *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::NetworkStatisticsEntry> v0;
  v0 = TdConvertToInternal (var->entry_);
  return td::td_api::make_object<td::td_api::addNetworkStatistics>(std::move (v0));
}
struct TdAddNetworkStatistics *TdConvertFromInternal (const td::td_api::addNetworkStatistics &from) {
  auto res = new TdAddNetworkStatistics ();
  res->ID = CODE_AddNetworkStatistics;
  res->refcnt = 1;
  if (!from.entry_) {
    res->entry_ = nullptr;
  } else {
    res->entry_ = TdConvertFromInternal (static_cast<const td::td_api::NetworkStatisticsEntry &>(*from.entry_));
  }
  return res;
}
char *TdSerializeAddNetworkStatistics (struct TdAddNetworkStatistics *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddNetworkStatistics *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddNetworkStatistics (struct TdAddNetworkStatistics *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddNetworkStatistics *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->entry_);
  delete var;
}
void TdStackStorerAddNetworkStatistics (struct TdAddNetworkStatistics *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddNetworkStatistics *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddNetworkStatistics");
  M->new_field ("ID");
  TdStackStorer (var->entry_, M);
  M->new_field ("entry_");
}
struct TdAddNetworkStatistics *TdStackFetcherAddNetworkStatistics (struct TdStackFetcherMethods *M) {
  auto res = new TdAddNetworkStatistics ();
  res->ID = CODE_AddNetworkStatistics;
  res->refcnt = 1;
  M->get_field ("entry_");
  if (M->is_nil ()) {
    res->entry_ = nullptr;
  } else {
    res->entry_ = TdStackFetcherNetworkStatisticsEntry (M);
  }
  M->pop ();
  return res;
}
struct TdAddProxy *TdCreateObjectAddProxy (char *server_, int port_, int enable_, struct TdProxyType *type_) {
  auto var = new struct TdAddProxy ();
  var->ID = CODE_AddProxy;
  var->refcnt = 1;
  var->server_ = (server_) ? td::str_dup (td::Slice (server_)) : nullptr;
  var->port_ = port_;
  var->enable_ = enable_;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::addProxy> TdConvertToInternal (struct TdAddProxy *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->server_) ? var->server_: "";
  std::int32_t v100;
  v100 = var->port_;
  bool v200;
  v200 = var->enable_ != 0;
  td::td_api::object_ptr<td::td_api::ProxyType> v300;
  v300 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::addProxy>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdAddProxy *TdConvertFromInternal (const td::td_api::addProxy &from) {
  auto res = new TdAddProxy ();
  res->ID = CODE_AddProxy;
  res->refcnt = 1;
  res->server_ = (from.server_.length ()) ? td::str_dup (from.server_) : nullptr;
  res->port_ = from.port_;
  res->enable_ = from.enable_;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::ProxyType &>(*from.type_));
  }
  return res;
}
char *TdSerializeAddProxy (struct TdAddProxy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddProxy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddProxy (struct TdAddProxy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddProxy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->server_);
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerAddProxy (struct TdAddProxy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddProxy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddProxy");
  M->new_field ("ID");
  M->pack_string (var->server_);
  M->new_field ("server_");
  M->pack_long (var->port_);
  M->new_field ("port_");
  M->pack_bool (var->enable_);
  M->new_field ("enable_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdAddProxy *TdStackFetcherAddProxy (struct TdStackFetcherMethods *M) {
  auto res = new TdAddProxy ();
  res->ID = CODE_AddProxy;
  res->refcnt = 1;
  M->get_field ("server_");
  res->server_ = M->get_string ();
  M->pop ();
  M->get_field ("port_");
  res->port_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("enable_");
  res->enable_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherProxyType (M);
  }
  M->pop ();
  return res;
}
struct TdAddRecentSticker *TdCreateObjectAddRecentSticker (int is_attached_, struct TdInputFile *sticker_) {
  auto var = new struct TdAddRecentSticker ();
  var->ID = CODE_AddRecentSticker;
  var->refcnt = 1;
  var->is_attached_ = is_attached_;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::addRecentSticker> TdConvertToInternal (struct TdAddRecentSticker *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_attached_ != 0;
  td::td_api::object_ptr<td::td_api::InputFile> v100;
  v100 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::addRecentSticker>(std::move (v0), std::move (v100));
}
struct TdAddRecentSticker *TdConvertFromInternal (const td::td_api::addRecentSticker &from) {
  auto res = new TdAddRecentSticker ();
  res->ID = CODE_AddRecentSticker;
  res->refcnt = 1;
  res->is_attached_ = from.is_attached_;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeAddRecentSticker (struct TdAddRecentSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddRecentSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddRecentSticker (struct TdAddRecentSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddRecentSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerAddRecentSticker (struct TdAddRecentSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddRecentSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddRecentSticker");
  M->new_field ("ID");
  M->pack_bool (var->is_attached_);
  M->new_field ("is_attached_");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdAddRecentSticker *TdStackFetcherAddRecentSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdAddRecentSticker ();
  res->ID = CODE_AddRecentSticker;
  res->refcnt = 1;
  M->get_field ("is_attached_");
  res->is_attached_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdAddRecentlyFoundChat *TdCreateObjectAddRecentlyFoundChat (long long chat_id_) {
  auto var = new struct TdAddRecentlyFoundChat ();
  var->ID = CODE_AddRecentlyFoundChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::addRecentlyFoundChat> TdConvertToInternal (struct TdAddRecentlyFoundChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::addRecentlyFoundChat>(std::move (v0));
}
struct TdAddRecentlyFoundChat *TdConvertFromInternal (const td::td_api::addRecentlyFoundChat &from) {
  auto res = new TdAddRecentlyFoundChat ();
  res->ID = CODE_AddRecentlyFoundChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeAddRecentlyFoundChat (struct TdAddRecentlyFoundChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddRecentlyFoundChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddRecentlyFoundChat (struct TdAddRecentlyFoundChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddRecentlyFoundChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerAddRecentlyFoundChat (struct TdAddRecentlyFoundChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddRecentlyFoundChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddRecentlyFoundChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdAddRecentlyFoundChat *TdStackFetcherAddRecentlyFoundChat (struct TdStackFetcherMethods *M) {
  auto res = new TdAddRecentlyFoundChat ();
  res->ID = CODE_AddRecentlyFoundChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdAddSavedAnimation *TdCreateObjectAddSavedAnimation (struct TdInputFile *animation_) {
  auto var = new struct TdAddSavedAnimation ();
  var->ID = CODE_AddSavedAnimation;
  var->refcnt = 1;
  var->animation_ = animation_;
  return var;
}
td::td_api::object_ptr<td::td_api::addSavedAnimation> TdConvertToInternal (struct TdAddSavedAnimation *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->animation_);
  return td::td_api::make_object<td::td_api::addSavedAnimation>(std::move (v0));
}
struct TdAddSavedAnimation *TdConvertFromInternal (const td::td_api::addSavedAnimation &from) {
  auto res = new TdAddSavedAnimation ();
  res->ID = CODE_AddSavedAnimation;
  res->refcnt = 1;
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.animation_));
  }
  return res;
}
char *TdSerializeAddSavedAnimation (struct TdAddSavedAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddSavedAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddSavedAnimation (struct TdAddSavedAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddSavedAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->animation_);
  delete var;
}
void TdStackStorerAddSavedAnimation (struct TdAddSavedAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddSavedAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddSavedAnimation");
  M->new_field ("ID");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
}
struct TdAddSavedAnimation *TdStackFetcherAddSavedAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdAddSavedAnimation ();
  res->ID = CODE_AddSavedAnimation;
  res->refcnt = 1;
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdAddStickerToSet *TdCreateObjectAddStickerToSet (int user_id_, char *name_, struct TdInputSticker *sticker_) {
  auto var = new struct TdAddStickerToSet ();
  var->ID = CODE_AddStickerToSet;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::addStickerToSet> TdConvertToInternal (struct TdAddStickerToSet *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  std::string v100;
  v100 = (var->name_) ? var->name_: "";
  td::td_api::object_ptr<td::td_api::inputSticker> v200;
  v200 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::addStickerToSet>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdAddStickerToSet *TdConvertFromInternal (const td::td_api::addStickerToSet &from) {
  auto res = new TdAddStickerToSet ();
  res->ID = CODE_AddStickerToSet;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::inputSticker &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeAddStickerToSet (struct TdAddStickerToSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAddStickerToSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAddStickerToSet (struct TdAddStickerToSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAddStickerToSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->name_);
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerAddStickerToSet (struct TdAddStickerToSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAddStickerToSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AddStickerToSet");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_string (var->name_);
  M->new_field ("name_");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdAddStickerToSet *TdStackFetcherAddStickerToSet (struct TdStackFetcherMethods *M) {
  auto res = new TdAddStickerToSet ();
  res->ID = CODE_AddStickerToSet;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputSticker (M);
  }
  M->pop ();
  return res;
}
struct TdAnswerCallbackQuery *TdCreateObjectAnswerCallbackQuery (long long callback_query_id_, char *text_, int show_alert_, char *url_, int cache_time_) {
  auto var = new struct TdAnswerCallbackQuery ();
  var->ID = CODE_AnswerCallbackQuery;
  var->refcnt = 1;
  var->callback_query_id_ = callback_query_id_;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  var->show_alert_ = show_alert_;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->cache_time_ = cache_time_;
  return var;
}
td::td_api::object_ptr<td::td_api::answerCallbackQuery> TdConvertToInternal (struct TdAnswerCallbackQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->callback_query_id_;
  std::string v100;
  v100 = (var->text_) ? var->text_: "";
  bool v200;
  v200 = var->show_alert_ != 0;
  std::string v300;
  v300 = (var->url_) ? var->url_: "";
  std::int32_t v400;
  v400 = var->cache_time_;
  return td::td_api::make_object<td::td_api::answerCallbackQuery>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdAnswerCallbackQuery *TdConvertFromInternal (const td::td_api::answerCallbackQuery &from) {
  auto res = new TdAnswerCallbackQuery ();
  res->ID = CODE_AnswerCallbackQuery;
  res->refcnt = 1;
  res->callback_query_id_ = from.callback_query_id_;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  res->show_alert_ = from.show_alert_;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  res->cache_time_ = from.cache_time_;
  return res;
}
char *TdSerializeAnswerCallbackQuery (struct TdAnswerCallbackQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAnswerCallbackQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAnswerCallbackQuery (struct TdAnswerCallbackQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAnswerCallbackQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  free (var->url_);
  delete var;
}
void TdStackStorerAnswerCallbackQuery (struct TdAnswerCallbackQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAnswerCallbackQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AnswerCallbackQuery");
  M->new_field ("ID");
  M->pack_long (var->callback_query_id_);
  M->new_field ("callback_query_id_");
  M->pack_string (var->text_);
  M->new_field ("text_");
  M->pack_bool (var->show_alert_);
  M->new_field ("show_alert_");
  M->pack_string (var->url_);
  M->new_field ("url_");
  M->pack_long (var->cache_time_);
  M->new_field ("cache_time_");
}
struct TdAnswerCallbackQuery *TdStackFetcherAnswerCallbackQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdAnswerCallbackQuery ();
  res->ID = CODE_AnswerCallbackQuery;
  res->refcnt = 1;
  M->get_field ("callback_query_id_");
  res->callback_query_id_ = M->get_long ();
  M->pop ();
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  M->get_field ("show_alert_");
  res->show_alert_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("cache_time_");
  res->cache_time_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdAnswerCustomQuery *TdCreateObjectAnswerCustomQuery (long long custom_query_id_, char *data_) {
  auto var = new struct TdAnswerCustomQuery ();
  var->ID = CODE_AnswerCustomQuery;
  var->refcnt = 1;
  var->custom_query_id_ = custom_query_id_;
  var->data_ = (data_) ? td::str_dup (td::Slice (data_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::answerCustomQuery> TdConvertToInternal (struct TdAnswerCustomQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->custom_query_id_;
  std::string v100;
  v100 = (var->data_) ? var->data_: "";
  return td::td_api::make_object<td::td_api::answerCustomQuery>(std::move (v0), std::move (v100));
}
struct TdAnswerCustomQuery *TdConvertFromInternal (const td::td_api::answerCustomQuery &from) {
  auto res = new TdAnswerCustomQuery ();
  res->ID = CODE_AnswerCustomQuery;
  res->refcnt = 1;
  res->custom_query_id_ = from.custom_query_id_;
  res->data_ = (from.data_.length ()) ? td::str_dup (from.data_) : nullptr;
  return res;
}
char *TdSerializeAnswerCustomQuery (struct TdAnswerCustomQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAnswerCustomQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAnswerCustomQuery (struct TdAnswerCustomQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAnswerCustomQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->data_);
  delete var;
}
void TdStackStorerAnswerCustomQuery (struct TdAnswerCustomQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAnswerCustomQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AnswerCustomQuery");
  M->new_field ("ID");
  M->pack_long (var->custom_query_id_);
  M->new_field ("custom_query_id_");
  M->pack_string (var->data_);
  M->new_field ("data_");
}
struct TdAnswerCustomQuery *TdStackFetcherAnswerCustomQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdAnswerCustomQuery ();
  res->ID = CODE_AnswerCustomQuery;
  res->refcnt = 1;
  M->get_field ("custom_query_id_");
  res->custom_query_id_ = M->get_long ();
  M->pop ();
  M->get_field ("data_");
  res->data_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdAnswerInlineQuery *TdCreateObjectAnswerInlineQuery (long long inline_query_id_, int is_personal_, struct TdVectorInputInlineQueryResult *results_, int cache_time_, char *next_offset_, char *switch_pm_text_, char *switch_pm_parameter_) {
  auto var = new struct TdAnswerInlineQuery ();
  var->ID = CODE_AnswerInlineQuery;
  var->refcnt = 1;
  var->inline_query_id_ = inline_query_id_;
  var->is_personal_ = is_personal_;
  var->results_ = results_;
  var->cache_time_ = cache_time_;
  var->next_offset_ = (next_offset_) ? td::str_dup (td::Slice (next_offset_)) : nullptr;
  var->switch_pm_text_ = (switch_pm_text_) ? td::str_dup (td::Slice (switch_pm_text_)) : nullptr;
  var->switch_pm_parameter_ = (switch_pm_parameter_) ? td::str_dup (td::Slice (switch_pm_parameter_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::answerInlineQuery> TdConvertToInternal (struct TdAnswerInlineQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->inline_query_id_;
  bool v100;
  v100 = var->is_personal_ != 0;
  std::vector<td::td_api::object_ptr<td::td_api::InputInlineQueryResult>> v200;
  for (int i200 = 0; i200 < var->results_->len; i200++) {
    td::td_api::object_ptr<td::td_api::InputInlineQueryResult> v201;
    v201 = TdConvertToInternal (var->results_->data[i200]);
    v200.push_back (std::move (v201));
  }
  std::int32_t v300;
  v300 = var->cache_time_;
  std::string v400;
  v400 = (var->next_offset_) ? var->next_offset_: "";
  std::string v500;
  v500 = (var->switch_pm_text_) ? var->switch_pm_text_: "";
  std::string v600;
  v600 = (var->switch_pm_parameter_) ? var->switch_pm_parameter_: "";
  return td::td_api::make_object<td::td_api::answerInlineQuery>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdAnswerInlineQuery *TdConvertFromInternal (const td::td_api::answerInlineQuery &from) {
  auto res = new TdAnswerInlineQuery ();
  res->ID = CODE_AnswerInlineQuery;
  res->refcnt = 1;
  res->inline_query_id_ = from.inline_query_id_;
  res->is_personal_ = from.is_personal_;
  res->results_ = new TdVectorInputInlineQueryResult ();
  res->results_->len = (int)from.results_.size ();
  res->results_->data = new struct TdInputInlineQueryResult * [res->results_->len];
  for (int i200 = 0; i200 < res->results_->len; i200++) {
    if (!from.results_[i200]) {
      res->results_->data[i200] = nullptr;
    } else {
      res->results_->data[i200] = TdConvertFromInternal (static_cast<const td::td_api::InputInlineQueryResult &>(*from.results_[i200]));
    }
  }
  res->cache_time_ = from.cache_time_;
  res->next_offset_ = (from.next_offset_.length ()) ? td::str_dup (from.next_offset_) : nullptr;
  res->switch_pm_text_ = (from.switch_pm_text_.length ()) ? td::str_dup (from.switch_pm_text_) : nullptr;
  res->switch_pm_parameter_ = (from.switch_pm_parameter_.length ()) ? td::str_dup (from.switch_pm_parameter_) : nullptr;
  return res;
}
char *TdSerializeAnswerInlineQuery (struct TdAnswerInlineQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAnswerInlineQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAnswerInlineQuery (struct TdAnswerInlineQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAnswerInlineQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i200 = 0; i200 < var->results_->len; i200++) {
    TdDestroyObject (var->results_->data[i200]);
  }
  delete[] var->results_->data;
  delete var->results_;
  free (var->next_offset_);
  free (var->switch_pm_text_);
  free (var->switch_pm_parameter_);
  delete var;
}
void TdStackStorerAnswerInlineQuery (struct TdAnswerInlineQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAnswerInlineQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AnswerInlineQuery");
  M->new_field ("ID");
  M->pack_long (var->inline_query_id_);
  M->new_field ("inline_query_id_");
  M->pack_bool (var->is_personal_);
  M->new_field ("is_personal_");
  M->new_array ();
  for (int i200 = 0; i200 < var->results_->len; i200++) {
    TdStackStorer (var->results_->data[i200], M);
    M->new_arr_field (i200);
  }
  M->new_field ("results_");
  M->pack_long (var->cache_time_);
  M->new_field ("cache_time_");
  M->pack_string (var->next_offset_);
  M->new_field ("next_offset_");
  M->pack_string (var->switch_pm_text_);
  M->new_field ("switch_pm_text_");
  M->pack_string (var->switch_pm_parameter_);
  M->new_field ("switch_pm_parameter_");
}
struct TdAnswerInlineQuery *TdStackFetcherAnswerInlineQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdAnswerInlineQuery ();
  res->ID = CODE_AnswerInlineQuery;
  res->refcnt = 1;
  M->get_field ("inline_query_id_");
  res->inline_query_id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_personal_");
  res->is_personal_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("results_");
  res->results_ = new TdVectorInputInlineQueryResult ();
  res->results_->len = M->get_arr_size ();
  res->results_->data = new struct TdInputInlineQueryResult * [res->results_->len];
  for (int i200 = 0; i200 < res->results_->len; i200++) {
    M->get_arr_field (i200);
    if (M->is_nil ()) {
      res->results_->data[i200] = nullptr;
    } else {
      res->results_->data[i200] = TdStackFetcherInputInlineQueryResult (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("cache_time_");
  res->cache_time_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("next_offset_");
  res->next_offset_ = M->get_string ();
  M->pop ();
  M->get_field ("switch_pm_text_");
  res->switch_pm_text_ = M->get_string ();
  M->pop ();
  M->get_field ("switch_pm_parameter_");
  res->switch_pm_parameter_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdAnswerPreCheckoutQuery *TdCreateObjectAnswerPreCheckoutQuery (long long pre_checkout_query_id_, char *error_message_) {
  auto var = new struct TdAnswerPreCheckoutQuery ();
  var->ID = CODE_AnswerPreCheckoutQuery;
  var->refcnt = 1;
  var->pre_checkout_query_id_ = pre_checkout_query_id_;
  var->error_message_ = (error_message_) ? td::str_dup (td::Slice (error_message_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::answerPreCheckoutQuery> TdConvertToInternal (struct TdAnswerPreCheckoutQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->pre_checkout_query_id_;
  std::string v100;
  v100 = (var->error_message_) ? var->error_message_: "";
  return td::td_api::make_object<td::td_api::answerPreCheckoutQuery>(std::move (v0), std::move (v100));
}
struct TdAnswerPreCheckoutQuery *TdConvertFromInternal (const td::td_api::answerPreCheckoutQuery &from) {
  auto res = new TdAnswerPreCheckoutQuery ();
  res->ID = CODE_AnswerPreCheckoutQuery;
  res->refcnt = 1;
  res->pre_checkout_query_id_ = from.pre_checkout_query_id_;
  res->error_message_ = (from.error_message_.length ()) ? td::str_dup (from.error_message_) : nullptr;
  return res;
}
char *TdSerializeAnswerPreCheckoutQuery (struct TdAnswerPreCheckoutQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAnswerPreCheckoutQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAnswerPreCheckoutQuery (struct TdAnswerPreCheckoutQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAnswerPreCheckoutQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->error_message_);
  delete var;
}
void TdStackStorerAnswerPreCheckoutQuery (struct TdAnswerPreCheckoutQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAnswerPreCheckoutQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AnswerPreCheckoutQuery");
  M->new_field ("ID");
  M->pack_long (var->pre_checkout_query_id_);
  M->new_field ("pre_checkout_query_id_");
  M->pack_string (var->error_message_);
  M->new_field ("error_message_");
}
struct TdAnswerPreCheckoutQuery *TdStackFetcherAnswerPreCheckoutQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdAnswerPreCheckoutQuery ();
  res->ID = CODE_AnswerPreCheckoutQuery;
  res->refcnt = 1;
  M->get_field ("pre_checkout_query_id_");
  res->pre_checkout_query_id_ = M->get_long ();
  M->pop ();
  M->get_field ("error_message_");
  res->error_message_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdAnswerShippingQuery *TdCreateObjectAnswerShippingQuery (long long shipping_query_id_, struct TdVectorShippingOption *shipping_options_, char *error_message_) {
  auto var = new struct TdAnswerShippingQuery ();
  var->ID = CODE_AnswerShippingQuery;
  var->refcnt = 1;
  var->shipping_query_id_ = shipping_query_id_;
  var->shipping_options_ = shipping_options_;
  var->error_message_ = (error_message_) ? td::str_dup (td::Slice (error_message_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::answerShippingQuery> TdConvertToInternal (struct TdAnswerShippingQuery *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->shipping_query_id_;
  std::vector<td::td_api::object_ptr<td::td_api::shippingOption>> v100;
  for (int i100 = 0; i100 < var->shipping_options_->len; i100++) {
    td::td_api::object_ptr<td::td_api::shippingOption> v101;
    v101 = TdConvertToInternal (var->shipping_options_->data[i100]);
    v100.push_back (std::move (v101));
  }
  std::string v200;
  v200 = (var->error_message_) ? var->error_message_: "";
  return td::td_api::make_object<td::td_api::answerShippingQuery>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdAnswerShippingQuery *TdConvertFromInternal (const td::td_api::answerShippingQuery &from) {
  auto res = new TdAnswerShippingQuery ();
  res->ID = CODE_AnswerShippingQuery;
  res->refcnt = 1;
  res->shipping_query_id_ = from.shipping_query_id_;
  res->shipping_options_ = new TdVectorShippingOption ();
  res->shipping_options_->len = (int)from.shipping_options_.size ();
  res->shipping_options_->data = new struct TdShippingOption * [res->shipping_options_->len];
  for (int i100 = 0; i100 < res->shipping_options_->len; i100++) {
    if (!from.shipping_options_[i100]) {
      res->shipping_options_->data[i100] = nullptr;
    } else {
      res->shipping_options_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::shippingOption &>(*from.shipping_options_[i100]));
    }
  }
  res->error_message_ = (from.error_message_.length ()) ? td::str_dup (from.error_message_) : nullptr;
  return res;
}
char *TdSerializeAnswerShippingQuery (struct TdAnswerShippingQuery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdAnswerShippingQuery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectAnswerShippingQuery (struct TdAnswerShippingQuery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdAnswerShippingQuery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->shipping_options_->len; i100++) {
    TdDestroyObject (var->shipping_options_->data[i100]);
  }
  delete[] var->shipping_options_->data;
  delete var->shipping_options_;
  free (var->error_message_);
  delete var;
}
void TdStackStorerAnswerShippingQuery (struct TdAnswerShippingQuery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdAnswerShippingQuery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("AnswerShippingQuery");
  M->new_field ("ID");
  M->pack_long (var->shipping_query_id_);
  M->new_field ("shipping_query_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->shipping_options_->len; i100++) {
    TdStackStorer (var->shipping_options_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("shipping_options_");
  M->pack_string (var->error_message_);
  M->new_field ("error_message_");
}
struct TdAnswerShippingQuery *TdStackFetcherAnswerShippingQuery (struct TdStackFetcherMethods *M) {
  auto res = new TdAnswerShippingQuery ();
  res->ID = CODE_AnswerShippingQuery;
  res->refcnt = 1;
  M->get_field ("shipping_query_id_");
  res->shipping_query_id_ = M->get_long ();
  M->pop ();
  M->get_field ("shipping_options_");
  res->shipping_options_ = new TdVectorShippingOption ();
  res->shipping_options_->len = M->get_arr_size ();
  res->shipping_options_->data = new struct TdShippingOption * [res->shipping_options_->len];
  for (int i100 = 0; i100 < res->shipping_options_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->shipping_options_->data[i100] = nullptr;
    } else {
      res->shipping_options_->data[i100] = TdStackFetcherShippingOption (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("error_message_");
  res->error_message_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdBlockUser *TdCreateObjectBlockUser (int user_id_) {
  auto var = new struct TdBlockUser ();
  var->ID = CODE_BlockUser;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::blockUser> TdConvertToInternal (struct TdBlockUser *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::blockUser>(std::move (v0));
}
struct TdBlockUser *TdConvertFromInternal (const td::td_api::blockUser &from) {
  auto res = new TdBlockUser ();
  res->ID = CODE_BlockUser;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeBlockUser (struct TdBlockUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdBlockUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectBlockUser (struct TdBlockUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdBlockUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerBlockUser (struct TdBlockUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdBlockUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("BlockUser");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdBlockUser *TdStackFetcherBlockUser (struct TdStackFetcherMethods *M) {
  auto res = new TdBlockUser ();
  res->ID = CODE_BlockUser;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCancelDownloadFile *TdCreateObjectCancelDownloadFile (int file_id_, int only_if_pending_) {
  auto var = new struct TdCancelDownloadFile ();
  var->ID = CODE_CancelDownloadFile;
  var->refcnt = 1;
  var->file_id_ = file_id_;
  var->only_if_pending_ = only_if_pending_;
  return var;
}
td::td_api::object_ptr<td::td_api::cancelDownloadFile> TdConvertToInternal (struct TdCancelDownloadFile *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->file_id_;
  bool v100;
  v100 = var->only_if_pending_ != 0;
  return td::td_api::make_object<td::td_api::cancelDownloadFile>(std::move (v0), std::move (v100));
}
struct TdCancelDownloadFile *TdConvertFromInternal (const td::td_api::cancelDownloadFile &from) {
  auto res = new TdCancelDownloadFile ();
  res->ID = CODE_CancelDownloadFile;
  res->refcnt = 1;
  res->file_id_ = from.file_id_;
  res->only_if_pending_ = from.only_if_pending_;
  return res;
}
char *TdSerializeCancelDownloadFile (struct TdCancelDownloadFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCancelDownloadFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCancelDownloadFile (struct TdCancelDownloadFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCancelDownloadFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCancelDownloadFile (struct TdCancelDownloadFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCancelDownloadFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CancelDownloadFile");
  M->new_field ("ID");
  M->pack_long (var->file_id_);
  M->new_field ("file_id_");
  M->pack_bool (var->only_if_pending_);
  M->new_field ("only_if_pending_");
}
struct TdCancelDownloadFile *TdStackFetcherCancelDownloadFile (struct TdStackFetcherMethods *M) {
  auto res = new TdCancelDownloadFile ();
  res->ID = CODE_CancelDownloadFile;
  res->refcnt = 1;
  M->get_field ("file_id_");
  res->file_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("only_if_pending_");
  res->only_if_pending_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCancelUploadFile *TdCreateObjectCancelUploadFile (int file_id_) {
  auto var = new struct TdCancelUploadFile ();
  var->ID = CODE_CancelUploadFile;
  var->refcnt = 1;
  var->file_id_ = file_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::cancelUploadFile> TdConvertToInternal (struct TdCancelUploadFile *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->file_id_;
  return td::td_api::make_object<td::td_api::cancelUploadFile>(std::move (v0));
}
struct TdCancelUploadFile *TdConvertFromInternal (const td::td_api::cancelUploadFile &from) {
  auto res = new TdCancelUploadFile ();
  res->ID = CODE_CancelUploadFile;
  res->refcnt = 1;
  res->file_id_ = from.file_id_;
  return res;
}
char *TdSerializeCancelUploadFile (struct TdCancelUploadFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCancelUploadFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCancelUploadFile (struct TdCancelUploadFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCancelUploadFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCancelUploadFile (struct TdCancelUploadFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCancelUploadFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CancelUploadFile");
  M->new_field ("ID");
  M->pack_long (var->file_id_);
  M->new_field ("file_id_");
}
struct TdCancelUploadFile *TdStackFetcherCancelUploadFile (struct TdStackFetcherMethods *M) {
  auto res = new TdCancelUploadFile ();
  res->ID = CODE_CancelUploadFile;
  res->refcnt = 1;
  M->get_field ("file_id_");
  res->file_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChangeChatReportSpamState *TdCreateObjectChangeChatReportSpamState (long long chat_id_, int is_spam_chat_) {
  auto var = new struct TdChangeChatReportSpamState ();
  var->ID = CODE_ChangeChatReportSpamState;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->is_spam_chat_ = is_spam_chat_;
  return var;
}
td::td_api::object_ptr<td::td_api::changeChatReportSpamState> TdConvertToInternal (struct TdChangeChatReportSpamState *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->is_spam_chat_ != 0;
  return td::td_api::make_object<td::td_api::changeChatReportSpamState>(std::move (v0), std::move (v100));
}
struct TdChangeChatReportSpamState *TdConvertFromInternal (const td::td_api::changeChatReportSpamState &from) {
  auto res = new TdChangeChatReportSpamState ();
  res->ID = CODE_ChangeChatReportSpamState;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->is_spam_chat_ = from.is_spam_chat_;
  return res;
}
char *TdSerializeChangeChatReportSpamState (struct TdChangeChatReportSpamState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChangeChatReportSpamState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChangeChatReportSpamState (struct TdChangeChatReportSpamState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChangeChatReportSpamState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChangeChatReportSpamState (struct TdChangeChatReportSpamState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChangeChatReportSpamState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChangeChatReportSpamState");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->is_spam_chat_);
  M->new_field ("is_spam_chat_");
}
struct TdChangeChatReportSpamState *TdStackFetcherChangeChatReportSpamState (struct TdStackFetcherMethods *M) {
  auto res = new TdChangeChatReportSpamState ();
  res->ID = CODE_ChangeChatReportSpamState;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_spam_chat_");
  res->is_spam_chat_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChangeImportedContacts *TdCreateObjectChangeImportedContacts (struct TdVectorContact *contacts_) {
  auto var = new struct TdChangeImportedContacts ();
  var->ID = CODE_ChangeImportedContacts;
  var->refcnt = 1;
  var->contacts_ = contacts_;
  return var;
}
td::td_api::object_ptr<td::td_api::changeImportedContacts> TdConvertToInternal (struct TdChangeImportedContacts *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::contact>> v0;
  for (int i0 = 0; i0 < var->contacts_->len; i0++) {
    td::td_api::object_ptr<td::td_api::contact> v1;
    v1 = TdConvertToInternal (var->contacts_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::changeImportedContacts>(std::move (v0));
}
struct TdChangeImportedContacts *TdConvertFromInternal (const td::td_api::changeImportedContacts &from) {
  auto res = new TdChangeImportedContacts ();
  res->ID = CODE_ChangeImportedContacts;
  res->refcnt = 1;
  res->contacts_ = new TdVectorContact ();
  res->contacts_->len = (int)from.contacts_.size ();
  res->contacts_->data = new struct TdContact * [res->contacts_->len];
  for (int i0 = 0; i0 < res->contacts_->len; i0++) {
    if (!from.contacts_[i0]) {
      res->contacts_->data[i0] = nullptr;
    } else {
      res->contacts_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::contact &>(*from.contacts_[i0]));
    }
  }
  return res;
}
char *TdSerializeChangeImportedContacts (struct TdChangeImportedContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChangeImportedContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChangeImportedContacts (struct TdChangeImportedContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChangeImportedContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->contacts_->len; i0++) {
    TdDestroyObject (var->contacts_->data[i0]);
  }
  delete[] var->contacts_->data;
  delete var->contacts_;
  delete var;
}
void TdStackStorerChangeImportedContacts (struct TdChangeImportedContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChangeImportedContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChangeImportedContacts");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->contacts_->len; i0++) {
    TdStackStorer (var->contacts_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("contacts_");
}
struct TdChangeImportedContacts *TdStackFetcherChangeImportedContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdChangeImportedContacts ();
  res->ID = CODE_ChangeImportedContacts;
  res->refcnt = 1;
  M->get_field ("contacts_");
  res->contacts_ = new TdVectorContact ();
  res->contacts_->len = M->get_arr_size ();
  res->contacts_->data = new struct TdContact * [res->contacts_->len];
  for (int i0 = 0; i0 < res->contacts_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->contacts_->data[i0] = nullptr;
    } else {
      res->contacts_->data[i0] = TdStackFetcherContact (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdChangePhoneNumber *TdCreateObjectChangePhoneNumber (char *phone_number_, int allow_flash_call_, int is_current_phone_number_) {
  auto var = new struct TdChangePhoneNumber ();
  var->ID = CODE_ChangePhoneNumber;
  var->refcnt = 1;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  var->allow_flash_call_ = allow_flash_call_;
  var->is_current_phone_number_ = is_current_phone_number_;
  return var;
}
td::td_api::object_ptr<td::td_api::changePhoneNumber> TdConvertToInternal (struct TdChangePhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->phone_number_) ? var->phone_number_: "";
  bool v100;
  v100 = var->allow_flash_call_ != 0;
  bool v200;
  v200 = var->is_current_phone_number_ != 0;
  return td::td_api::make_object<td::td_api::changePhoneNumber>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdChangePhoneNumber *TdConvertFromInternal (const td::td_api::changePhoneNumber &from) {
  auto res = new TdChangePhoneNumber ();
  res->ID = CODE_ChangePhoneNumber;
  res->refcnt = 1;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  res->allow_flash_call_ = from.allow_flash_call_;
  res->is_current_phone_number_ = from.is_current_phone_number_;
  return res;
}
char *TdSerializeChangePhoneNumber (struct TdChangePhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChangePhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChangePhoneNumber (struct TdChangePhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChangePhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->phone_number_);
  delete var;
}
void TdStackStorerChangePhoneNumber (struct TdChangePhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChangePhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChangePhoneNumber");
  M->new_field ("ID");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
  M->pack_bool (var->allow_flash_call_);
  M->new_field ("allow_flash_call_");
  M->pack_bool (var->is_current_phone_number_);
  M->new_field ("is_current_phone_number_");
}
struct TdChangePhoneNumber *TdStackFetcherChangePhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdChangePhoneNumber ();
  res->ID = CODE_ChangePhoneNumber;
  res->refcnt = 1;
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  M->get_field ("allow_flash_call_");
  res->allow_flash_call_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_current_phone_number_");
  res->is_current_phone_number_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdChangeStickerSet *TdCreateObjectChangeStickerSet (long long set_id_, int is_installed_, int is_archived_) {
  auto var = new struct TdChangeStickerSet ();
  var->ID = CODE_ChangeStickerSet;
  var->refcnt = 1;
  var->set_id_ = set_id_;
  var->is_installed_ = is_installed_;
  var->is_archived_ = is_archived_;
  return var;
}
td::td_api::object_ptr<td::td_api::changeStickerSet> TdConvertToInternal (struct TdChangeStickerSet *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->set_id_;
  bool v100;
  v100 = var->is_installed_ != 0;
  bool v200;
  v200 = var->is_archived_ != 0;
  return td::td_api::make_object<td::td_api::changeStickerSet>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdChangeStickerSet *TdConvertFromInternal (const td::td_api::changeStickerSet &from) {
  auto res = new TdChangeStickerSet ();
  res->ID = CODE_ChangeStickerSet;
  res->refcnt = 1;
  res->set_id_ = from.set_id_;
  res->is_installed_ = from.is_installed_;
  res->is_archived_ = from.is_archived_;
  return res;
}
char *TdSerializeChangeStickerSet (struct TdChangeStickerSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdChangeStickerSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectChangeStickerSet (struct TdChangeStickerSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdChangeStickerSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerChangeStickerSet (struct TdChangeStickerSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdChangeStickerSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ChangeStickerSet");
  M->new_field ("ID");
  M->pack_long (var->set_id_);
  M->new_field ("set_id_");
  M->pack_bool (var->is_installed_);
  M->new_field ("is_installed_");
  M->pack_bool (var->is_archived_);
  M->new_field ("is_archived_");
}
struct TdChangeStickerSet *TdStackFetcherChangeStickerSet (struct TdStackFetcherMethods *M) {
  auto res = new TdChangeStickerSet ();
  res->ID = CODE_ChangeStickerSet;
  res->refcnt = 1;
  M->get_field ("set_id_");
  res->set_id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_installed_");
  res->is_installed_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_archived_");
  res->is_archived_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCheckAuthenticationBotToken *TdCreateObjectCheckAuthenticationBotToken (char *token_) {
  auto var = new struct TdCheckAuthenticationBotToken ();
  var->ID = CODE_CheckAuthenticationBotToken;
  var->refcnt = 1;
  var->token_ = (token_) ? td::str_dup (td::Slice (token_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkAuthenticationBotToken> TdConvertToInternal (struct TdCheckAuthenticationBotToken *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->token_) ? var->token_: "";
  return td::td_api::make_object<td::td_api::checkAuthenticationBotToken>(std::move (v0));
}
struct TdCheckAuthenticationBotToken *TdConvertFromInternal (const td::td_api::checkAuthenticationBotToken &from) {
  auto res = new TdCheckAuthenticationBotToken ();
  res->ID = CODE_CheckAuthenticationBotToken;
  res->refcnt = 1;
  res->token_ = (from.token_.length ()) ? td::str_dup (from.token_) : nullptr;
  return res;
}
char *TdSerializeCheckAuthenticationBotToken (struct TdCheckAuthenticationBotToken *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckAuthenticationBotToken *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckAuthenticationBotToken (struct TdCheckAuthenticationBotToken *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckAuthenticationBotToken *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->token_);
  delete var;
}
void TdStackStorerCheckAuthenticationBotToken (struct TdCheckAuthenticationBotToken *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckAuthenticationBotToken *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckAuthenticationBotToken");
  M->new_field ("ID");
  M->pack_string (var->token_);
  M->new_field ("token_");
}
struct TdCheckAuthenticationBotToken *TdStackFetcherCheckAuthenticationBotToken (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckAuthenticationBotToken ();
  res->ID = CODE_CheckAuthenticationBotToken;
  res->refcnt = 1;
  M->get_field ("token_");
  res->token_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCheckAuthenticationCode *TdCreateObjectCheckAuthenticationCode (char *code_, char *first_name_, char *last_name_) {
  auto var = new struct TdCheckAuthenticationCode ();
  var->ID = CODE_CheckAuthenticationCode;
  var->refcnt = 1;
  var->code_ = (code_) ? td::str_dup (td::Slice (code_)) : nullptr;
  var->first_name_ = (first_name_) ? td::str_dup (td::Slice (first_name_)) : nullptr;
  var->last_name_ = (last_name_) ? td::str_dup (td::Slice (last_name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkAuthenticationCode> TdConvertToInternal (struct TdCheckAuthenticationCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->code_) ? var->code_: "";
  std::string v100;
  v100 = (var->first_name_) ? var->first_name_: "";
  std::string v200;
  v200 = (var->last_name_) ? var->last_name_: "";
  return td::td_api::make_object<td::td_api::checkAuthenticationCode>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdCheckAuthenticationCode *TdConvertFromInternal (const td::td_api::checkAuthenticationCode &from) {
  auto res = new TdCheckAuthenticationCode ();
  res->ID = CODE_CheckAuthenticationCode;
  res->refcnt = 1;
  res->code_ = (from.code_.length ()) ? td::str_dup (from.code_) : nullptr;
  res->first_name_ = (from.first_name_.length ()) ? td::str_dup (from.first_name_) : nullptr;
  res->last_name_ = (from.last_name_.length ()) ? td::str_dup (from.last_name_) : nullptr;
  return res;
}
char *TdSerializeCheckAuthenticationCode (struct TdCheckAuthenticationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckAuthenticationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckAuthenticationCode (struct TdCheckAuthenticationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckAuthenticationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->code_);
  free (var->first_name_);
  free (var->last_name_);
  delete var;
}
void TdStackStorerCheckAuthenticationCode (struct TdCheckAuthenticationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckAuthenticationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckAuthenticationCode");
  M->new_field ("ID");
  M->pack_string (var->code_);
  M->new_field ("code_");
  M->pack_string (var->first_name_);
  M->new_field ("first_name_");
  M->pack_string (var->last_name_);
  M->new_field ("last_name_");
}
struct TdCheckAuthenticationCode *TdStackFetcherCheckAuthenticationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckAuthenticationCode ();
  res->ID = CODE_CheckAuthenticationCode;
  res->refcnt = 1;
  M->get_field ("code_");
  res->code_ = M->get_string ();
  M->pop ();
  M->get_field ("first_name_");
  res->first_name_ = M->get_string ();
  M->pop ();
  M->get_field ("last_name_");
  res->last_name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCheckAuthenticationPassword *TdCreateObjectCheckAuthenticationPassword (char *password_) {
  auto var = new struct TdCheckAuthenticationPassword ();
  var->ID = CODE_CheckAuthenticationPassword;
  var->refcnt = 1;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkAuthenticationPassword> TdConvertToInternal (struct TdCheckAuthenticationPassword *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->password_) ? var->password_: "";
  return td::td_api::make_object<td::td_api::checkAuthenticationPassword>(std::move (v0));
}
struct TdCheckAuthenticationPassword *TdConvertFromInternal (const td::td_api::checkAuthenticationPassword &from) {
  auto res = new TdCheckAuthenticationPassword ();
  res->ID = CODE_CheckAuthenticationPassword;
  res->refcnt = 1;
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  return res;
}
char *TdSerializeCheckAuthenticationPassword (struct TdCheckAuthenticationPassword *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckAuthenticationPassword *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckAuthenticationPassword (struct TdCheckAuthenticationPassword *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckAuthenticationPassword *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->password_);
  delete var;
}
void TdStackStorerCheckAuthenticationPassword (struct TdCheckAuthenticationPassword *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckAuthenticationPassword *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckAuthenticationPassword");
  M->new_field ("ID");
  M->pack_string (var->password_);
  M->new_field ("password_");
}
struct TdCheckAuthenticationPassword *TdStackFetcherCheckAuthenticationPassword (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckAuthenticationPassword ();
  res->ID = CODE_CheckAuthenticationPassword;
  res->refcnt = 1;
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCheckChangePhoneNumberCode *TdCreateObjectCheckChangePhoneNumberCode (char *code_) {
  auto var = new struct TdCheckChangePhoneNumberCode ();
  var->ID = CODE_CheckChangePhoneNumberCode;
  var->refcnt = 1;
  var->code_ = (code_) ? td::str_dup (td::Slice (code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkChangePhoneNumberCode> TdConvertToInternal (struct TdCheckChangePhoneNumberCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->code_) ? var->code_: "";
  return td::td_api::make_object<td::td_api::checkChangePhoneNumberCode>(std::move (v0));
}
struct TdCheckChangePhoneNumberCode *TdConvertFromInternal (const td::td_api::checkChangePhoneNumberCode &from) {
  auto res = new TdCheckChangePhoneNumberCode ();
  res->ID = CODE_CheckChangePhoneNumberCode;
  res->refcnt = 1;
  res->code_ = (from.code_.length ()) ? td::str_dup (from.code_) : nullptr;
  return res;
}
char *TdSerializeCheckChangePhoneNumberCode (struct TdCheckChangePhoneNumberCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChangePhoneNumberCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChangePhoneNumberCode (struct TdCheckChangePhoneNumberCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChangePhoneNumberCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->code_);
  delete var;
}
void TdStackStorerCheckChangePhoneNumberCode (struct TdCheckChangePhoneNumberCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChangePhoneNumberCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckChangePhoneNumberCode");
  M->new_field ("ID");
  M->pack_string (var->code_);
  M->new_field ("code_");
}
struct TdCheckChangePhoneNumberCode *TdStackFetcherCheckChangePhoneNumberCode (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckChangePhoneNumberCode ();
  res->ID = CODE_CheckChangePhoneNumberCode;
  res->refcnt = 1;
  M->get_field ("code_");
  res->code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCheckChatInviteLink *TdCreateObjectCheckChatInviteLink (char *invite_link_) {
  auto var = new struct TdCheckChatInviteLink ();
  var->ID = CODE_CheckChatInviteLink;
  var->refcnt = 1;
  var->invite_link_ = (invite_link_) ? td::str_dup (td::Slice (invite_link_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkChatInviteLink> TdConvertToInternal (struct TdCheckChatInviteLink *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->invite_link_) ? var->invite_link_: "";
  return td::td_api::make_object<td::td_api::checkChatInviteLink>(std::move (v0));
}
struct TdCheckChatInviteLink *TdConvertFromInternal (const td::td_api::checkChatInviteLink &from) {
  auto res = new TdCheckChatInviteLink ();
  res->ID = CODE_CheckChatInviteLink;
  res->refcnt = 1;
  res->invite_link_ = (from.invite_link_.length ()) ? td::str_dup (from.invite_link_) : nullptr;
  return res;
}
char *TdSerializeCheckChatInviteLink (struct TdCheckChatInviteLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChatInviteLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChatInviteLink (struct TdCheckChatInviteLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChatInviteLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->invite_link_);
  delete var;
}
void TdStackStorerCheckChatInviteLink (struct TdCheckChatInviteLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChatInviteLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckChatInviteLink");
  M->new_field ("ID");
  M->pack_string (var->invite_link_);
  M->new_field ("invite_link_");
}
struct TdCheckChatInviteLink *TdStackFetcherCheckChatInviteLink (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckChatInviteLink ();
  res->ID = CODE_CheckChatInviteLink;
  res->refcnt = 1;
  M->get_field ("invite_link_");
  res->invite_link_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCheckChatUsername *TdCreateObjectCheckChatUsername (long long chat_id_, char *username_) {
  auto var = new struct TdCheckChatUsername ();
  var->ID = CODE_CheckChatUsername;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkChatUsername> TdConvertToInternal (struct TdCheckChatUsername *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->username_) ? var->username_: "";
  return td::td_api::make_object<td::td_api::checkChatUsername>(std::move (v0), std::move (v100));
}
struct TdCheckChatUsername *TdConvertFromInternal (const td::td_api::checkChatUsername &from) {
  auto res = new TdCheckChatUsername ();
  res->ID = CODE_CheckChatUsername;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  return res;
}
char *TdSerializeCheckChatUsername (struct TdCheckChatUsername *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckChatUsername *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckChatUsername (struct TdCheckChatUsername *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckChatUsername *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->username_);
  delete var;
}
void TdStackStorerCheckChatUsername (struct TdCheckChatUsername *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckChatUsername *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckChatUsername");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->username_);
  M->new_field ("username_");
}
struct TdCheckChatUsername *TdStackFetcherCheckChatUsername (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckChatUsername ();
  res->ID = CODE_CheckChatUsername;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCheckDatabaseEncryptionKey *TdCreateObjectCheckDatabaseEncryptionKey (struct TdBytes encryption_key_) {
  auto var = new struct TdCheckDatabaseEncryptionKey ();
  var->ID = CODE_CheckDatabaseEncryptionKey;
  var->refcnt = 1;
  var->encryption_key_ = encryption_key_;
  return var;
}
td::td_api::object_ptr<td::td_api::checkDatabaseEncryptionKey> TdConvertToInternal (struct TdCheckDatabaseEncryptionKey *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->encryption_key_.data, var->encryption_key_.len);
  return td::td_api::make_object<td::td_api::checkDatabaseEncryptionKey>(std::move (v0));
}
struct TdCheckDatabaseEncryptionKey *TdConvertFromInternal (const td::td_api::checkDatabaseEncryptionKey &from) {
  auto res = new TdCheckDatabaseEncryptionKey ();
  res->ID = CODE_CheckDatabaseEncryptionKey;
  res->refcnt = 1;
  res->encryption_key_.len = (int)from.encryption_key_.length ();
  if (res->encryption_key_.len) {
    res->encryption_key_.data = new unsigned char[res->encryption_key_.len];
    memcpy (res->encryption_key_.data, from.encryption_key_.c_str (), res->encryption_key_.len);
  } else {
    res->encryption_key_.data = nullptr;
  }
  return res;
}
char *TdSerializeCheckDatabaseEncryptionKey (struct TdCheckDatabaseEncryptionKey *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckDatabaseEncryptionKey *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckDatabaseEncryptionKey (struct TdCheckDatabaseEncryptionKey *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckDatabaseEncryptionKey *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->encryption_key_.data;
  delete var;
}
void TdStackStorerCheckDatabaseEncryptionKey (struct TdCheckDatabaseEncryptionKey *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckDatabaseEncryptionKey *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckDatabaseEncryptionKey");
  M->new_field ("ID");
  M->pack_bytes (var->encryption_key_.data, var->encryption_key_.len);
  M->new_field ("encryption_key_");
}
struct TdCheckDatabaseEncryptionKey *TdStackFetcherCheckDatabaseEncryptionKey (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckDatabaseEncryptionKey ();
  res->ID = CODE_CheckDatabaseEncryptionKey;
  res->refcnt = 1;
  M->get_field ("encryption_key_");
  res->encryption_key_.data = M->get_bytes (&res->encryption_key_.len);
  M->pop ();
  return res;
}
struct TdCheckEmailAddressVerificationCode *TdCreateObjectCheckEmailAddressVerificationCode (char *code_) {
  auto var = new struct TdCheckEmailAddressVerificationCode ();
  var->ID = CODE_CheckEmailAddressVerificationCode;
  var->refcnt = 1;
  var->code_ = (code_) ? td::str_dup (td::Slice (code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkEmailAddressVerificationCode> TdConvertToInternal (struct TdCheckEmailAddressVerificationCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->code_) ? var->code_: "";
  return td::td_api::make_object<td::td_api::checkEmailAddressVerificationCode>(std::move (v0));
}
struct TdCheckEmailAddressVerificationCode *TdConvertFromInternal (const td::td_api::checkEmailAddressVerificationCode &from) {
  auto res = new TdCheckEmailAddressVerificationCode ();
  res->ID = CODE_CheckEmailAddressVerificationCode;
  res->refcnt = 1;
  res->code_ = (from.code_.length ()) ? td::str_dup (from.code_) : nullptr;
  return res;
}
char *TdSerializeCheckEmailAddressVerificationCode (struct TdCheckEmailAddressVerificationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckEmailAddressVerificationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckEmailAddressVerificationCode (struct TdCheckEmailAddressVerificationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckEmailAddressVerificationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->code_);
  delete var;
}
void TdStackStorerCheckEmailAddressVerificationCode (struct TdCheckEmailAddressVerificationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckEmailAddressVerificationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckEmailAddressVerificationCode");
  M->new_field ("ID");
  M->pack_string (var->code_);
  M->new_field ("code_");
}
struct TdCheckEmailAddressVerificationCode *TdStackFetcherCheckEmailAddressVerificationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckEmailAddressVerificationCode ();
  res->ID = CODE_CheckEmailAddressVerificationCode;
  res->refcnt = 1;
  M->get_field ("code_");
  res->code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCheckPhoneNumberConfirmationCode *TdCreateObjectCheckPhoneNumberConfirmationCode (char *code_) {
  auto var = new struct TdCheckPhoneNumberConfirmationCode ();
  var->ID = CODE_CheckPhoneNumberConfirmationCode;
  var->refcnt = 1;
  var->code_ = (code_) ? td::str_dup (td::Slice (code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkPhoneNumberConfirmationCode> TdConvertToInternal (struct TdCheckPhoneNumberConfirmationCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->code_) ? var->code_: "";
  return td::td_api::make_object<td::td_api::checkPhoneNumberConfirmationCode>(std::move (v0));
}
struct TdCheckPhoneNumberConfirmationCode *TdConvertFromInternal (const td::td_api::checkPhoneNumberConfirmationCode &from) {
  auto res = new TdCheckPhoneNumberConfirmationCode ();
  res->ID = CODE_CheckPhoneNumberConfirmationCode;
  res->refcnt = 1;
  res->code_ = (from.code_.length ()) ? td::str_dup (from.code_) : nullptr;
  return res;
}
char *TdSerializeCheckPhoneNumberConfirmationCode (struct TdCheckPhoneNumberConfirmationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckPhoneNumberConfirmationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckPhoneNumberConfirmationCode (struct TdCheckPhoneNumberConfirmationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckPhoneNumberConfirmationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->code_);
  delete var;
}
void TdStackStorerCheckPhoneNumberConfirmationCode (struct TdCheckPhoneNumberConfirmationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckPhoneNumberConfirmationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckPhoneNumberConfirmationCode");
  M->new_field ("ID");
  M->pack_string (var->code_);
  M->new_field ("code_");
}
struct TdCheckPhoneNumberConfirmationCode *TdStackFetcherCheckPhoneNumberConfirmationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckPhoneNumberConfirmationCode ();
  res->ID = CODE_CheckPhoneNumberConfirmationCode;
  res->refcnt = 1;
  M->get_field ("code_");
  res->code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCheckPhoneNumberVerificationCode *TdCreateObjectCheckPhoneNumberVerificationCode (char *code_) {
  auto var = new struct TdCheckPhoneNumberVerificationCode ();
  var->ID = CODE_CheckPhoneNumberVerificationCode;
  var->refcnt = 1;
  var->code_ = (code_) ? td::str_dup (td::Slice (code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::checkPhoneNumberVerificationCode> TdConvertToInternal (struct TdCheckPhoneNumberVerificationCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->code_) ? var->code_: "";
  return td::td_api::make_object<td::td_api::checkPhoneNumberVerificationCode>(std::move (v0));
}
struct TdCheckPhoneNumberVerificationCode *TdConvertFromInternal (const td::td_api::checkPhoneNumberVerificationCode &from) {
  auto res = new TdCheckPhoneNumberVerificationCode ();
  res->ID = CODE_CheckPhoneNumberVerificationCode;
  res->refcnt = 1;
  res->code_ = (from.code_.length ()) ? td::str_dup (from.code_) : nullptr;
  return res;
}
char *TdSerializeCheckPhoneNumberVerificationCode (struct TdCheckPhoneNumberVerificationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCheckPhoneNumberVerificationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCheckPhoneNumberVerificationCode (struct TdCheckPhoneNumberVerificationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCheckPhoneNumberVerificationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->code_);
  delete var;
}
void TdStackStorerCheckPhoneNumberVerificationCode (struct TdCheckPhoneNumberVerificationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCheckPhoneNumberVerificationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CheckPhoneNumberVerificationCode");
  M->new_field ("ID");
  M->pack_string (var->code_);
  M->new_field ("code_");
}
struct TdCheckPhoneNumberVerificationCode *TdStackFetcherCheckPhoneNumberVerificationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdCheckPhoneNumberVerificationCode ();
  res->ID = CODE_CheckPhoneNumberVerificationCode;
  res->refcnt = 1;
  M->get_field ("code_");
  res->code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCleanFileName *TdCreateObjectCleanFileName (char *file_name_) {
  auto var = new struct TdCleanFileName ();
  var->ID = CODE_CleanFileName;
  var->refcnt = 1;
  var->file_name_ = (file_name_) ? td::str_dup (td::Slice (file_name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::cleanFileName> TdConvertToInternal (struct TdCleanFileName *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->file_name_) ? var->file_name_: "";
  return td::td_api::make_object<td::td_api::cleanFileName>(std::move (v0));
}
struct TdCleanFileName *TdConvertFromInternal (const td::td_api::cleanFileName &from) {
  auto res = new TdCleanFileName ();
  res->ID = CODE_CleanFileName;
  res->refcnt = 1;
  res->file_name_ = (from.file_name_.length ()) ? td::str_dup (from.file_name_) : nullptr;
  return res;
}
char *TdSerializeCleanFileName (struct TdCleanFileName *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCleanFileName *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCleanFileName (struct TdCleanFileName *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCleanFileName *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->file_name_);
  delete var;
}
void TdStackStorerCleanFileName (struct TdCleanFileName *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCleanFileName *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CleanFileName");
  M->new_field ("ID");
  M->pack_string (var->file_name_);
  M->new_field ("file_name_");
}
struct TdCleanFileName *TdStackFetcherCleanFileName (struct TdStackFetcherMethods *M) {
  auto res = new TdCleanFileName ();
  res->ID = CODE_CleanFileName;
  res->refcnt = 1;
  M->get_field ("file_name_");
  res->file_name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdClearAllDraftMessages *TdCreateObjectClearAllDraftMessages (int exclude_secret_chats_) {
  auto var = new struct TdClearAllDraftMessages ();
  var->ID = CODE_ClearAllDraftMessages;
  var->refcnt = 1;
  var->exclude_secret_chats_ = exclude_secret_chats_;
  return var;
}
td::td_api::object_ptr<td::td_api::clearAllDraftMessages> TdConvertToInternal (struct TdClearAllDraftMessages *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->exclude_secret_chats_ != 0;
  return td::td_api::make_object<td::td_api::clearAllDraftMessages>(std::move (v0));
}
struct TdClearAllDraftMessages *TdConvertFromInternal (const td::td_api::clearAllDraftMessages &from) {
  auto res = new TdClearAllDraftMessages ();
  res->ID = CODE_ClearAllDraftMessages;
  res->refcnt = 1;
  res->exclude_secret_chats_ = from.exclude_secret_chats_;
  return res;
}
char *TdSerializeClearAllDraftMessages (struct TdClearAllDraftMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdClearAllDraftMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectClearAllDraftMessages (struct TdClearAllDraftMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdClearAllDraftMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerClearAllDraftMessages (struct TdClearAllDraftMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdClearAllDraftMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ClearAllDraftMessages");
  M->new_field ("ID");
  M->pack_bool (var->exclude_secret_chats_);
  M->new_field ("exclude_secret_chats_");
}
struct TdClearAllDraftMessages *TdStackFetcherClearAllDraftMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdClearAllDraftMessages ();
  res->ID = CODE_ClearAllDraftMessages;
  res->refcnt = 1;
  M->get_field ("exclude_secret_chats_");
  res->exclude_secret_chats_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdClearImportedContacts *TdCreateObjectClearImportedContacts (void) {
  auto var = new struct TdClearImportedContacts ();
  var->ID = CODE_ClearImportedContacts;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::clearImportedContacts> TdConvertToInternal (struct TdClearImportedContacts *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::clearImportedContacts>();
}
struct TdClearImportedContacts *TdConvertFromInternal (const td::td_api::clearImportedContacts &from) {
  auto res = new TdClearImportedContacts ();
  res->ID = CODE_ClearImportedContacts;
  res->refcnt = 1;
  return res;
}
char *TdSerializeClearImportedContacts (struct TdClearImportedContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdClearImportedContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectClearImportedContacts (struct TdClearImportedContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdClearImportedContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerClearImportedContacts (struct TdClearImportedContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdClearImportedContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ClearImportedContacts");
  M->new_field ("ID");
}
struct TdClearImportedContacts *TdStackFetcherClearImportedContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdClearImportedContacts ();
  res->ID = CODE_ClearImportedContacts;
  res->refcnt = 1;
  return res;
}
struct TdClearRecentStickers *TdCreateObjectClearRecentStickers (int is_attached_) {
  auto var = new struct TdClearRecentStickers ();
  var->ID = CODE_ClearRecentStickers;
  var->refcnt = 1;
  var->is_attached_ = is_attached_;
  return var;
}
td::td_api::object_ptr<td::td_api::clearRecentStickers> TdConvertToInternal (struct TdClearRecentStickers *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_attached_ != 0;
  return td::td_api::make_object<td::td_api::clearRecentStickers>(std::move (v0));
}
struct TdClearRecentStickers *TdConvertFromInternal (const td::td_api::clearRecentStickers &from) {
  auto res = new TdClearRecentStickers ();
  res->ID = CODE_ClearRecentStickers;
  res->refcnt = 1;
  res->is_attached_ = from.is_attached_;
  return res;
}
char *TdSerializeClearRecentStickers (struct TdClearRecentStickers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdClearRecentStickers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectClearRecentStickers (struct TdClearRecentStickers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdClearRecentStickers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerClearRecentStickers (struct TdClearRecentStickers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdClearRecentStickers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ClearRecentStickers");
  M->new_field ("ID");
  M->pack_bool (var->is_attached_);
  M->new_field ("is_attached_");
}
struct TdClearRecentStickers *TdStackFetcherClearRecentStickers (struct TdStackFetcherMethods *M) {
  auto res = new TdClearRecentStickers ();
  res->ID = CODE_ClearRecentStickers;
  res->refcnt = 1;
  M->get_field ("is_attached_");
  res->is_attached_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdClearRecentlyFoundChats *TdCreateObjectClearRecentlyFoundChats (void) {
  auto var = new struct TdClearRecentlyFoundChats ();
  var->ID = CODE_ClearRecentlyFoundChats;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::clearRecentlyFoundChats> TdConvertToInternal (struct TdClearRecentlyFoundChats *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::clearRecentlyFoundChats>();
}
struct TdClearRecentlyFoundChats *TdConvertFromInternal (const td::td_api::clearRecentlyFoundChats &from) {
  auto res = new TdClearRecentlyFoundChats ();
  res->ID = CODE_ClearRecentlyFoundChats;
  res->refcnt = 1;
  return res;
}
char *TdSerializeClearRecentlyFoundChats (struct TdClearRecentlyFoundChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdClearRecentlyFoundChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectClearRecentlyFoundChats (struct TdClearRecentlyFoundChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdClearRecentlyFoundChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerClearRecentlyFoundChats (struct TdClearRecentlyFoundChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdClearRecentlyFoundChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ClearRecentlyFoundChats");
  M->new_field ("ID");
}
struct TdClearRecentlyFoundChats *TdStackFetcherClearRecentlyFoundChats (struct TdStackFetcherMethods *M) {
  auto res = new TdClearRecentlyFoundChats ();
  res->ID = CODE_ClearRecentlyFoundChats;
  res->refcnt = 1;
  return res;
}
struct TdClose *TdCreateObjectClose (void) {
  auto var = new struct TdClose ();
  var->ID = CODE_Close;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::close> TdConvertToInternal (struct TdClose *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::close>();
}
struct TdClose *TdConvertFromInternal (const td::td_api::close &from) {
  auto res = new TdClose ();
  res->ID = CODE_Close;
  res->refcnt = 1;
  return res;
}
char *TdSerializeClose (struct TdClose *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdClose *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectClose (struct TdClose *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdClose *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerClose (struct TdClose *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdClose *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Close");
  M->new_field ("ID");
}
struct TdClose *TdStackFetcherClose (struct TdStackFetcherMethods *M) {
  auto res = new TdClose ();
  res->ID = CODE_Close;
  res->refcnt = 1;
  return res;
}
struct TdCloseChat *TdCreateObjectCloseChat (long long chat_id_) {
  auto var = new struct TdCloseChat ();
  var->ID = CODE_CloseChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::closeChat> TdConvertToInternal (struct TdCloseChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::closeChat>(std::move (v0));
}
struct TdCloseChat *TdConvertFromInternal (const td::td_api::closeChat &from) {
  auto res = new TdCloseChat ();
  res->ID = CODE_CloseChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeCloseChat (struct TdCloseChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCloseChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCloseChat (struct TdCloseChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCloseChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCloseChat (struct TdCloseChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCloseChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CloseChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdCloseChat *TdStackFetcherCloseChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCloseChat ();
  res->ID = CODE_CloseChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdCloseSecretChat *TdCreateObjectCloseSecretChat (int secret_chat_id_) {
  auto var = new struct TdCloseSecretChat ();
  var->ID = CODE_CloseSecretChat;
  var->refcnt = 1;
  var->secret_chat_id_ = secret_chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::closeSecretChat> TdConvertToInternal (struct TdCloseSecretChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->secret_chat_id_;
  return td::td_api::make_object<td::td_api::closeSecretChat>(std::move (v0));
}
struct TdCloseSecretChat *TdConvertFromInternal (const td::td_api::closeSecretChat &from) {
  auto res = new TdCloseSecretChat ();
  res->ID = CODE_CloseSecretChat;
  res->refcnt = 1;
  res->secret_chat_id_ = from.secret_chat_id_;
  return res;
}
char *TdSerializeCloseSecretChat (struct TdCloseSecretChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCloseSecretChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCloseSecretChat (struct TdCloseSecretChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCloseSecretChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCloseSecretChat (struct TdCloseSecretChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCloseSecretChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CloseSecretChat");
  M->new_field ("ID");
  M->pack_long (var->secret_chat_id_);
  M->new_field ("secret_chat_id_");
}
struct TdCloseSecretChat *TdStackFetcherCloseSecretChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCloseSecretChat ();
  res->ID = CODE_CloseSecretChat;
  res->refcnt = 1;
  M->get_field ("secret_chat_id_");
  res->secret_chat_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCreateBasicGroupChat *TdCreateObjectCreateBasicGroupChat (int basic_group_id_, int force_) {
  auto var = new struct TdCreateBasicGroupChat ();
  var->ID = CODE_CreateBasicGroupChat;
  var->refcnt = 1;
  var->basic_group_id_ = basic_group_id_;
  var->force_ = force_;
  return var;
}
td::td_api::object_ptr<td::td_api::createBasicGroupChat> TdConvertToInternal (struct TdCreateBasicGroupChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->basic_group_id_;
  bool v100;
  v100 = var->force_ != 0;
  return td::td_api::make_object<td::td_api::createBasicGroupChat>(std::move (v0), std::move (v100));
}
struct TdCreateBasicGroupChat *TdConvertFromInternal (const td::td_api::createBasicGroupChat &from) {
  auto res = new TdCreateBasicGroupChat ();
  res->ID = CODE_CreateBasicGroupChat;
  res->refcnt = 1;
  res->basic_group_id_ = from.basic_group_id_;
  res->force_ = from.force_;
  return res;
}
char *TdSerializeCreateBasicGroupChat (struct TdCreateBasicGroupChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateBasicGroupChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateBasicGroupChat (struct TdCreateBasicGroupChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateBasicGroupChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCreateBasicGroupChat (struct TdCreateBasicGroupChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateBasicGroupChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateBasicGroupChat");
  M->new_field ("ID");
  M->pack_long (var->basic_group_id_);
  M->new_field ("basic_group_id_");
  M->pack_bool (var->force_);
  M->new_field ("force_");
}
struct TdCreateBasicGroupChat *TdStackFetcherCreateBasicGroupChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateBasicGroupChat ();
  res->ID = CODE_CreateBasicGroupChat;
  res->refcnt = 1;
  M->get_field ("basic_group_id_");
  res->basic_group_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("force_");
  res->force_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCreateCall *TdCreateObjectCreateCall (int user_id_, struct TdCallProtocol *protocol_) {
  auto var = new struct TdCreateCall ();
  var->ID = CODE_CreateCall;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->protocol_ = protocol_;
  return var;
}
td::td_api::object_ptr<td::td_api::createCall> TdConvertToInternal (struct TdCreateCall *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  td::td_api::object_ptr<td::td_api::callProtocol> v100;
  v100 = TdConvertToInternal (var->protocol_);
  return td::td_api::make_object<td::td_api::createCall>(std::move (v0), std::move (v100));
}
struct TdCreateCall *TdConvertFromInternal (const td::td_api::createCall &from) {
  auto res = new TdCreateCall ();
  res->ID = CODE_CreateCall;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  if (!from.protocol_) {
    res->protocol_ = nullptr;
  } else {
    res->protocol_ = TdConvertFromInternal (static_cast<const td::td_api::callProtocol &>(*from.protocol_));
  }
  return res;
}
char *TdSerializeCreateCall (struct TdCreateCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateCall (struct TdCreateCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->protocol_);
  delete var;
}
void TdStackStorerCreateCall (struct TdCreateCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateCall");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->protocol_, M);
  M->new_field ("protocol_");
}
struct TdCreateCall *TdStackFetcherCreateCall (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateCall ();
  res->ID = CODE_CreateCall;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("protocol_");
  if (M->is_nil ()) {
    res->protocol_ = nullptr;
  } else {
    res->protocol_ = TdStackFetcherCallProtocol (M);
  }
  M->pop ();
  return res;
}
struct TdCreateNewBasicGroupChat *TdCreateObjectCreateNewBasicGroupChat (struct TdVectorInt *user_ids_, char *title_) {
  auto var = new struct TdCreateNewBasicGroupChat ();
  var->ID = CODE_CreateNewBasicGroupChat;
  var->refcnt = 1;
  var->user_ids_ = user_ids_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::createNewBasicGroupChat> TdConvertToInternal (struct TdCreateNewBasicGroupChat *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    std::int32_t v1;
    v1 = var->user_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  return td::td_api::make_object<td::td_api::createNewBasicGroupChat>(std::move (v0), std::move (v100));
}
struct TdCreateNewBasicGroupChat *TdConvertFromInternal (const td::td_api::createNewBasicGroupChat &from) {
  auto res = new TdCreateNewBasicGroupChat ();
  res->ID = CODE_CreateNewBasicGroupChat;
  res->refcnt = 1;
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = (int)from.user_ids_.size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    res->user_ids_->data[i0] = from.user_ids_[i0];
  }
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  return res;
}
char *TdSerializeCreateNewBasicGroupChat (struct TdCreateNewBasicGroupChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateNewBasicGroupChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateNewBasicGroupChat (struct TdCreateNewBasicGroupChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateNewBasicGroupChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
  }
  delete[] var->user_ids_->data;
  delete var->user_ids_;
  free (var->title_);
  delete var;
}
void TdStackStorerCreateNewBasicGroupChat (struct TdCreateNewBasicGroupChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateNewBasicGroupChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateNewBasicGroupChat");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    M->pack_long (var->user_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("user_ids_");
  M->pack_string (var->title_);
  M->new_field ("title_");
}
struct TdCreateNewBasicGroupChat *TdStackFetcherCreateNewBasicGroupChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateNewBasicGroupChat ();
  res->ID = CODE_CreateNewBasicGroupChat;
  res->refcnt = 1;
  M->get_field ("user_ids_");
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = M->get_arr_size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->user_ids_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCreateNewSecretChat *TdCreateObjectCreateNewSecretChat (int user_id_) {
  auto var = new struct TdCreateNewSecretChat ();
  var->ID = CODE_CreateNewSecretChat;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::createNewSecretChat> TdConvertToInternal (struct TdCreateNewSecretChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::createNewSecretChat>(std::move (v0));
}
struct TdCreateNewSecretChat *TdConvertFromInternal (const td::td_api::createNewSecretChat &from) {
  auto res = new TdCreateNewSecretChat ();
  res->ID = CODE_CreateNewSecretChat;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeCreateNewSecretChat (struct TdCreateNewSecretChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateNewSecretChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateNewSecretChat (struct TdCreateNewSecretChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateNewSecretChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCreateNewSecretChat (struct TdCreateNewSecretChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateNewSecretChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateNewSecretChat");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdCreateNewSecretChat *TdStackFetcherCreateNewSecretChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateNewSecretChat ();
  res->ID = CODE_CreateNewSecretChat;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCreateNewStickerSet *TdCreateObjectCreateNewStickerSet (int user_id_, char *title_, char *name_, int is_masks_, struct TdVectorInputSticker *stickers_) {
  auto var = new struct TdCreateNewStickerSet ();
  var->ID = CODE_CreateNewStickerSet;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  var->is_masks_ = is_masks_;
  var->stickers_ = stickers_;
  return var;
}
td::td_api::object_ptr<td::td_api::createNewStickerSet> TdConvertToInternal (struct TdCreateNewStickerSet *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  std::string v200;
  v200 = (var->name_) ? var->name_: "";
  bool v300;
  v300 = var->is_masks_ != 0;
  std::vector<td::td_api::object_ptr<td::td_api::inputSticker>> v400;
  for (int i400 = 0; i400 < var->stickers_->len; i400++) {
    td::td_api::object_ptr<td::td_api::inputSticker> v401;
    v401 = TdConvertToInternal (var->stickers_->data[i400]);
    v400.push_back (std::move (v401));
  }
  return td::td_api::make_object<td::td_api::createNewStickerSet>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdCreateNewStickerSet *TdConvertFromInternal (const td::td_api::createNewStickerSet &from) {
  auto res = new TdCreateNewStickerSet ();
  res->ID = CODE_CreateNewStickerSet;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  res->is_masks_ = from.is_masks_;
  res->stickers_ = new TdVectorInputSticker ();
  res->stickers_->len = (int)from.stickers_.size ();
  res->stickers_->data = new struct TdInputSticker * [res->stickers_->len];
  for (int i400 = 0; i400 < res->stickers_->len; i400++) {
    if (!from.stickers_[i400]) {
      res->stickers_->data[i400] = nullptr;
    } else {
      res->stickers_->data[i400] = TdConvertFromInternal (static_cast<const td::td_api::inputSticker &>(*from.stickers_[i400]));
    }
  }
  return res;
}
char *TdSerializeCreateNewStickerSet (struct TdCreateNewStickerSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateNewStickerSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateNewStickerSet (struct TdCreateNewStickerSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateNewStickerSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  free (var->name_);
  for (int i400 = 0; i400 < var->stickers_->len; i400++) {
    TdDestroyObject (var->stickers_->data[i400]);
  }
  delete[] var->stickers_->data;
  delete var->stickers_;
  delete var;
}
void TdStackStorerCreateNewStickerSet (struct TdCreateNewStickerSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateNewStickerSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateNewStickerSet");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_string (var->name_);
  M->new_field ("name_");
  M->pack_bool (var->is_masks_);
  M->new_field ("is_masks_");
  M->new_array ();
  for (int i400 = 0; i400 < var->stickers_->len; i400++) {
    TdStackStorer (var->stickers_->data[i400], M);
    M->new_arr_field (i400);
  }
  M->new_field ("stickers_");
}
struct TdCreateNewStickerSet *TdStackFetcherCreateNewStickerSet (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateNewStickerSet ();
  res->ID = CODE_CreateNewStickerSet;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  M->get_field ("is_masks_");
  res->is_masks_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("stickers_");
  res->stickers_ = new TdVectorInputSticker ();
  res->stickers_->len = M->get_arr_size ();
  res->stickers_->data = new struct TdInputSticker * [res->stickers_->len];
  for (int i400 = 0; i400 < res->stickers_->len; i400++) {
    M->get_arr_field (i400);
    if (M->is_nil ()) {
      res->stickers_->data[i400] = nullptr;
    } else {
      res->stickers_->data[i400] = TdStackFetcherInputSticker (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdCreateNewSupergroupChat *TdCreateObjectCreateNewSupergroupChat (char *title_, int is_channel_, char *description_) {
  auto var = new struct TdCreateNewSupergroupChat ();
  var->ID = CODE_CreateNewSupergroupChat;
  var->refcnt = 1;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  var->is_channel_ = is_channel_;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::createNewSupergroupChat> TdConvertToInternal (struct TdCreateNewSupergroupChat *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->title_) ? var->title_: "";
  bool v100;
  v100 = var->is_channel_ != 0;
  std::string v200;
  v200 = (var->description_) ? var->description_: "";
  return td::td_api::make_object<td::td_api::createNewSupergroupChat>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdCreateNewSupergroupChat *TdConvertFromInternal (const td::td_api::createNewSupergroupChat &from) {
  auto res = new TdCreateNewSupergroupChat ();
  res->ID = CODE_CreateNewSupergroupChat;
  res->refcnt = 1;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  res->is_channel_ = from.is_channel_;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  return res;
}
char *TdSerializeCreateNewSupergroupChat (struct TdCreateNewSupergroupChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateNewSupergroupChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateNewSupergroupChat (struct TdCreateNewSupergroupChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateNewSupergroupChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  free (var->description_);
  delete var;
}
void TdStackStorerCreateNewSupergroupChat (struct TdCreateNewSupergroupChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateNewSupergroupChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateNewSupergroupChat");
  M->new_field ("ID");
  M->pack_string (var->title_);
  M->new_field ("title_");
  M->pack_bool (var->is_channel_);
  M->new_field ("is_channel_");
  M->pack_string (var->description_);
  M->new_field ("description_");
}
struct TdCreateNewSupergroupChat *TdStackFetcherCreateNewSupergroupChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateNewSupergroupChat ();
  res->ID = CODE_CreateNewSupergroupChat;
  res->refcnt = 1;
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  M->get_field ("is_channel_");
  res->is_channel_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdCreatePrivateChat *TdCreateObjectCreatePrivateChat (int user_id_, int force_) {
  auto var = new struct TdCreatePrivateChat ();
  var->ID = CODE_CreatePrivateChat;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->force_ = force_;
  return var;
}
td::td_api::object_ptr<td::td_api::createPrivateChat> TdConvertToInternal (struct TdCreatePrivateChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  bool v100;
  v100 = var->force_ != 0;
  return td::td_api::make_object<td::td_api::createPrivateChat>(std::move (v0), std::move (v100));
}
struct TdCreatePrivateChat *TdConvertFromInternal (const td::td_api::createPrivateChat &from) {
  auto res = new TdCreatePrivateChat ();
  res->ID = CODE_CreatePrivateChat;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  res->force_ = from.force_;
  return res;
}
char *TdSerializeCreatePrivateChat (struct TdCreatePrivateChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreatePrivateChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreatePrivateChat (struct TdCreatePrivateChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreatePrivateChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCreatePrivateChat (struct TdCreatePrivateChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreatePrivateChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreatePrivateChat");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_bool (var->force_);
  M->new_field ("force_");
}
struct TdCreatePrivateChat *TdStackFetcherCreatePrivateChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCreatePrivateChat ();
  res->ID = CODE_CreatePrivateChat;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("force_");
  res->force_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCreateSecretChat *TdCreateObjectCreateSecretChat (int secret_chat_id_) {
  auto var = new struct TdCreateSecretChat ();
  var->ID = CODE_CreateSecretChat;
  var->refcnt = 1;
  var->secret_chat_id_ = secret_chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::createSecretChat> TdConvertToInternal (struct TdCreateSecretChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->secret_chat_id_;
  return td::td_api::make_object<td::td_api::createSecretChat>(std::move (v0));
}
struct TdCreateSecretChat *TdConvertFromInternal (const td::td_api::createSecretChat &from) {
  auto res = new TdCreateSecretChat ();
  res->ID = CODE_CreateSecretChat;
  res->refcnt = 1;
  res->secret_chat_id_ = from.secret_chat_id_;
  return res;
}
char *TdSerializeCreateSecretChat (struct TdCreateSecretChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateSecretChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateSecretChat (struct TdCreateSecretChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateSecretChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCreateSecretChat (struct TdCreateSecretChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateSecretChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateSecretChat");
  M->new_field ("ID");
  M->pack_long (var->secret_chat_id_);
  M->new_field ("secret_chat_id_");
}
struct TdCreateSecretChat *TdStackFetcherCreateSecretChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateSecretChat ();
  res->ID = CODE_CreateSecretChat;
  res->refcnt = 1;
  M->get_field ("secret_chat_id_");
  res->secret_chat_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCreateSupergroupChat *TdCreateObjectCreateSupergroupChat (int supergroup_id_, int force_) {
  auto var = new struct TdCreateSupergroupChat ();
  var->ID = CODE_CreateSupergroupChat;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->force_ = force_;
  return var;
}
td::td_api::object_ptr<td::td_api::createSupergroupChat> TdConvertToInternal (struct TdCreateSupergroupChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  bool v100;
  v100 = var->force_ != 0;
  return td::td_api::make_object<td::td_api::createSupergroupChat>(std::move (v0), std::move (v100));
}
struct TdCreateSupergroupChat *TdConvertFromInternal (const td::td_api::createSupergroupChat &from) {
  auto res = new TdCreateSupergroupChat ();
  res->ID = CODE_CreateSupergroupChat;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->force_ = from.force_;
  return res;
}
char *TdSerializeCreateSupergroupChat (struct TdCreateSupergroupChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateSupergroupChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateSupergroupChat (struct TdCreateSupergroupChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateSupergroupChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerCreateSupergroupChat (struct TdCreateSupergroupChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateSupergroupChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateSupergroupChat");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_bool (var->force_);
  M->new_field ("force_");
}
struct TdCreateSupergroupChat *TdStackFetcherCreateSupergroupChat (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateSupergroupChat ();
  res->ID = CODE_CreateSupergroupChat;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("force_");
  res->force_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdCreateTemporaryPassword *TdCreateObjectCreateTemporaryPassword (char *password_, int valid_for_) {
  auto var = new struct TdCreateTemporaryPassword ();
  var->ID = CODE_CreateTemporaryPassword;
  var->refcnt = 1;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  var->valid_for_ = valid_for_;
  return var;
}
td::td_api::object_ptr<td::td_api::createTemporaryPassword> TdConvertToInternal (struct TdCreateTemporaryPassword *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->password_) ? var->password_: "";
  std::int32_t v100;
  v100 = var->valid_for_;
  return td::td_api::make_object<td::td_api::createTemporaryPassword>(std::move (v0), std::move (v100));
}
struct TdCreateTemporaryPassword *TdConvertFromInternal (const td::td_api::createTemporaryPassword &from) {
  auto res = new TdCreateTemporaryPassword ();
  res->ID = CODE_CreateTemporaryPassword;
  res->refcnt = 1;
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  res->valid_for_ = from.valid_for_;
  return res;
}
char *TdSerializeCreateTemporaryPassword (struct TdCreateTemporaryPassword *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdCreateTemporaryPassword *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectCreateTemporaryPassword (struct TdCreateTemporaryPassword *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdCreateTemporaryPassword *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->password_);
  delete var;
}
void TdStackStorerCreateTemporaryPassword (struct TdCreateTemporaryPassword *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdCreateTemporaryPassword *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("CreateTemporaryPassword");
  M->new_field ("ID");
  M->pack_string (var->password_);
  M->new_field ("password_");
  M->pack_long (var->valid_for_);
  M->new_field ("valid_for_");
}
struct TdCreateTemporaryPassword *TdStackFetcherCreateTemporaryPassword (struct TdStackFetcherMethods *M) {
  auto res = new TdCreateTemporaryPassword ();
  res->ID = CODE_CreateTemporaryPassword;
  res->refcnt = 1;
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  M->get_field ("valid_for_");
  res->valid_for_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDeleteAccount *TdCreateObjectDeleteAccount (char *reason_) {
  auto var = new struct TdDeleteAccount ();
  var->ID = CODE_DeleteAccount;
  var->refcnt = 1;
  var->reason_ = (reason_) ? td::str_dup (td::Slice (reason_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteAccount> TdConvertToInternal (struct TdDeleteAccount *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->reason_) ? var->reason_: "";
  return td::td_api::make_object<td::td_api::deleteAccount>(std::move (v0));
}
struct TdDeleteAccount *TdConvertFromInternal (const td::td_api::deleteAccount &from) {
  auto res = new TdDeleteAccount ();
  res->ID = CODE_DeleteAccount;
  res->refcnt = 1;
  res->reason_ = (from.reason_.length ()) ? td::str_dup (from.reason_) : nullptr;
  return res;
}
char *TdSerializeDeleteAccount (struct TdDeleteAccount *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteAccount *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteAccount (struct TdDeleteAccount *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteAccount *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->reason_);
  delete var;
}
void TdStackStorerDeleteAccount (struct TdDeleteAccount *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteAccount *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteAccount");
  M->new_field ("ID");
  M->pack_string (var->reason_);
  M->new_field ("reason_");
}
struct TdDeleteAccount *TdStackFetcherDeleteAccount (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteAccount ();
  res->ID = CODE_DeleteAccount;
  res->refcnt = 1;
  M->get_field ("reason_");
  res->reason_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeleteChatHistory *TdCreateObjectDeleteChatHistory (long long chat_id_, int remove_from_chat_list_) {
  auto var = new struct TdDeleteChatHistory ();
  var->ID = CODE_DeleteChatHistory;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->remove_from_chat_list_ = remove_from_chat_list_;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteChatHistory> TdConvertToInternal (struct TdDeleteChatHistory *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->remove_from_chat_list_ != 0;
  return td::td_api::make_object<td::td_api::deleteChatHistory>(std::move (v0), std::move (v100));
}
struct TdDeleteChatHistory *TdConvertFromInternal (const td::td_api::deleteChatHistory &from) {
  auto res = new TdDeleteChatHistory ();
  res->ID = CODE_DeleteChatHistory;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->remove_from_chat_list_ = from.remove_from_chat_list_;
  return res;
}
char *TdSerializeDeleteChatHistory (struct TdDeleteChatHistory *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteChatHistory *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteChatHistory (struct TdDeleteChatHistory *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteChatHistory *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDeleteChatHistory (struct TdDeleteChatHistory *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteChatHistory *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteChatHistory");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->remove_from_chat_list_);
  M->new_field ("remove_from_chat_list_");
}
struct TdDeleteChatHistory *TdStackFetcherDeleteChatHistory (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteChatHistory ();
  res->ID = CODE_DeleteChatHistory;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("remove_from_chat_list_");
  res->remove_from_chat_list_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDeleteChatMessagesFromUser *TdCreateObjectDeleteChatMessagesFromUser (long long chat_id_, int user_id_) {
  auto var = new struct TdDeleteChatMessagesFromUser ();
  var->ID = CODE_DeleteChatMessagesFromUser;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteChatMessagesFromUser> TdConvertToInternal (struct TdDeleteChatMessagesFromUser *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->user_id_;
  return td::td_api::make_object<td::td_api::deleteChatMessagesFromUser>(std::move (v0), std::move (v100));
}
struct TdDeleteChatMessagesFromUser *TdConvertFromInternal (const td::td_api::deleteChatMessagesFromUser &from) {
  auto res = new TdDeleteChatMessagesFromUser ();
  res->ID = CODE_DeleteChatMessagesFromUser;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeDeleteChatMessagesFromUser (struct TdDeleteChatMessagesFromUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteChatMessagesFromUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteChatMessagesFromUser (struct TdDeleteChatMessagesFromUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteChatMessagesFromUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDeleteChatMessagesFromUser (struct TdDeleteChatMessagesFromUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteChatMessagesFromUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteChatMessagesFromUser");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdDeleteChatMessagesFromUser *TdStackFetcherDeleteChatMessagesFromUser (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteChatMessagesFromUser ();
  res->ID = CODE_DeleteChatMessagesFromUser;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDeleteChatReplyMarkup *TdCreateObjectDeleteChatReplyMarkup (long long chat_id_, long long message_id_) {
  auto var = new struct TdDeleteChatReplyMarkup ();
  var->ID = CODE_DeleteChatReplyMarkup;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteChatReplyMarkup> TdConvertToInternal (struct TdDeleteChatReplyMarkup *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  return td::td_api::make_object<td::td_api::deleteChatReplyMarkup>(std::move (v0), std::move (v100));
}
struct TdDeleteChatReplyMarkup *TdConvertFromInternal (const td::td_api::deleteChatReplyMarkup &from) {
  auto res = new TdDeleteChatReplyMarkup ();
  res->ID = CODE_DeleteChatReplyMarkup;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeDeleteChatReplyMarkup (struct TdDeleteChatReplyMarkup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteChatReplyMarkup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteChatReplyMarkup (struct TdDeleteChatReplyMarkup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteChatReplyMarkup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDeleteChatReplyMarkup (struct TdDeleteChatReplyMarkup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteChatReplyMarkup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteChatReplyMarkup");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdDeleteChatReplyMarkup *TdStackFetcherDeleteChatReplyMarkup (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteChatReplyMarkup ();
  res->ID = CODE_DeleteChatReplyMarkup;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdDeleteFile *TdCreateObjectDeleteFile (int file_id_) {
  auto var = new struct TdDeleteFile ();
  var->ID = CODE_DeleteFile;
  var->refcnt = 1;
  var->file_id_ = file_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteFile> TdConvertToInternal (struct TdDeleteFile *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->file_id_;
  return td::td_api::make_object<td::td_api::deleteFile>(std::move (v0));
}
struct TdDeleteFile *TdConvertFromInternal (const td::td_api::deleteFile &from) {
  auto res = new TdDeleteFile ();
  res->ID = CODE_DeleteFile;
  res->refcnt = 1;
  res->file_id_ = from.file_id_;
  return res;
}
char *TdSerializeDeleteFile (struct TdDeleteFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteFile (struct TdDeleteFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDeleteFile (struct TdDeleteFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteFile");
  M->new_field ("ID");
  M->pack_long (var->file_id_);
  M->new_field ("file_id_");
}
struct TdDeleteFile *TdStackFetcherDeleteFile (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteFile ();
  res->ID = CODE_DeleteFile;
  res->refcnt = 1;
  M->get_field ("file_id_");
  res->file_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDeleteLanguagePack *TdCreateObjectDeleteLanguagePack (char *language_pack_id_) {
  auto var = new struct TdDeleteLanguagePack ();
  var->ID = CODE_DeleteLanguagePack;
  var->refcnt = 1;
  var->language_pack_id_ = (language_pack_id_) ? td::str_dup (td::Slice (language_pack_id_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteLanguagePack> TdConvertToInternal (struct TdDeleteLanguagePack *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->language_pack_id_) ? var->language_pack_id_: "";
  return td::td_api::make_object<td::td_api::deleteLanguagePack>(std::move (v0));
}
struct TdDeleteLanguagePack *TdConvertFromInternal (const td::td_api::deleteLanguagePack &from) {
  auto res = new TdDeleteLanguagePack ();
  res->ID = CODE_DeleteLanguagePack;
  res->refcnt = 1;
  res->language_pack_id_ = (from.language_pack_id_.length ()) ? td::str_dup (from.language_pack_id_) : nullptr;
  return res;
}
char *TdSerializeDeleteLanguagePack (struct TdDeleteLanguagePack *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteLanguagePack *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteLanguagePack (struct TdDeleteLanguagePack *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteLanguagePack *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->language_pack_id_);
  delete var;
}
void TdStackStorerDeleteLanguagePack (struct TdDeleteLanguagePack *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteLanguagePack *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteLanguagePack");
  M->new_field ("ID");
  M->pack_string (var->language_pack_id_);
  M->new_field ("language_pack_id_");
}
struct TdDeleteLanguagePack *TdStackFetcherDeleteLanguagePack (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteLanguagePack ();
  res->ID = CODE_DeleteLanguagePack;
  res->refcnt = 1;
  M->get_field ("language_pack_id_");
  res->language_pack_id_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdDeleteMessages *TdCreateObjectDeleteMessages (long long chat_id_, struct TdVectorLong *message_ids_, int revoke_) {
  auto var = new struct TdDeleteMessages ();
  var->ID = CODE_DeleteMessages;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_ids_ = message_ids_;
  var->revoke_ = revoke_;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteMessages> TdConvertToInternal (struct TdDeleteMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::vector<std::int64_t> v100;
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
    std::int64_t v101;
    v101 = var->message_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  bool v200;
  v200 = var->revoke_ != 0;
  return td::td_api::make_object<td::td_api::deleteMessages>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdDeleteMessages *TdConvertFromInternal (const td::td_api::deleteMessages &from) {
  auto res = new TdDeleteMessages ();
  res->ID = CODE_DeleteMessages;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = (int)from.message_ids_.size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i100 = 0; i100 < res->message_ids_->len; i100++) {
    res->message_ids_->data[i100] = from.message_ids_[i100];
  }
  res->revoke_ = from.revoke_;
  return res;
}
char *TdSerializeDeleteMessages (struct TdDeleteMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteMessages (struct TdDeleteMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
  }
  delete[] var->message_ids_->data;
  delete var->message_ids_;
  delete var;
}
void TdStackStorerDeleteMessages (struct TdDeleteMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteMessages");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
    M->pack_long (var->message_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("message_ids_");
  M->pack_bool (var->revoke_);
  M->new_field ("revoke_");
}
struct TdDeleteMessages *TdStackFetcherDeleteMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteMessages ();
  res->ID = CODE_DeleteMessages;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_ids_");
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = M->get_arr_size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i100 = 0; i100 < res->message_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->message_ids_->data[i100] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("revoke_");
  res->revoke_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDeletePassportElement *TdCreateObjectDeletePassportElement (struct TdPassportElementType *type_) {
  auto var = new struct TdDeletePassportElement ();
  var->ID = CODE_DeletePassportElement;
  var->refcnt = 1;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::deletePassportElement> TdConvertToInternal (struct TdDeletePassportElement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::PassportElementType> v0;
  v0 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::deletePassportElement>(std::move (v0));
}
struct TdDeletePassportElement *TdConvertFromInternal (const td::td_api::deletePassportElement &from) {
  auto res = new TdDeletePassportElement ();
  res->ID = CODE_DeletePassportElement;
  res->refcnt = 1;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::PassportElementType &>(*from.type_));
  }
  return res;
}
char *TdSerializeDeletePassportElement (struct TdDeletePassportElement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeletePassportElement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeletePassportElement (struct TdDeletePassportElement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeletePassportElement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerDeletePassportElement (struct TdDeletePassportElement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeletePassportElement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeletePassportElement");
  M->new_field ("ID");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdDeletePassportElement *TdStackFetcherDeletePassportElement (struct TdStackFetcherMethods *M) {
  auto res = new TdDeletePassportElement ();
  res->ID = CODE_DeletePassportElement;
  res->refcnt = 1;
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherPassportElementType (M);
  }
  M->pop ();
  return res;
}
struct TdDeleteProfilePhoto *TdCreateObjectDeleteProfilePhoto (long long profile_photo_id_) {
  auto var = new struct TdDeleteProfilePhoto ();
  var->ID = CODE_DeleteProfilePhoto;
  var->refcnt = 1;
  var->profile_photo_id_ = profile_photo_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteProfilePhoto> TdConvertToInternal (struct TdDeleteProfilePhoto *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->profile_photo_id_;
  return td::td_api::make_object<td::td_api::deleteProfilePhoto>(std::move (v0));
}
struct TdDeleteProfilePhoto *TdConvertFromInternal (const td::td_api::deleteProfilePhoto &from) {
  auto res = new TdDeleteProfilePhoto ();
  res->ID = CODE_DeleteProfilePhoto;
  res->refcnt = 1;
  res->profile_photo_id_ = from.profile_photo_id_;
  return res;
}
char *TdSerializeDeleteProfilePhoto (struct TdDeleteProfilePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteProfilePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteProfilePhoto (struct TdDeleteProfilePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteProfilePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDeleteProfilePhoto (struct TdDeleteProfilePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteProfilePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteProfilePhoto");
  M->new_field ("ID");
  M->pack_long (var->profile_photo_id_);
  M->new_field ("profile_photo_id_");
}
struct TdDeleteProfilePhoto *TdStackFetcherDeleteProfilePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteProfilePhoto ();
  res->ID = CODE_DeleteProfilePhoto;
  res->refcnt = 1;
  M->get_field ("profile_photo_id_");
  res->profile_photo_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdDeleteSavedCredentials *TdCreateObjectDeleteSavedCredentials (void) {
  auto var = new struct TdDeleteSavedCredentials ();
  var->ID = CODE_DeleteSavedCredentials;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteSavedCredentials> TdConvertToInternal (struct TdDeleteSavedCredentials *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::deleteSavedCredentials>();
}
struct TdDeleteSavedCredentials *TdConvertFromInternal (const td::td_api::deleteSavedCredentials &from) {
  auto res = new TdDeleteSavedCredentials ();
  res->ID = CODE_DeleteSavedCredentials;
  res->refcnt = 1;
  return res;
}
char *TdSerializeDeleteSavedCredentials (struct TdDeleteSavedCredentials *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteSavedCredentials *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteSavedCredentials (struct TdDeleteSavedCredentials *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteSavedCredentials *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDeleteSavedCredentials (struct TdDeleteSavedCredentials *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteSavedCredentials *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteSavedCredentials");
  M->new_field ("ID");
}
struct TdDeleteSavedCredentials *TdStackFetcherDeleteSavedCredentials (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteSavedCredentials ();
  res->ID = CODE_DeleteSavedCredentials;
  res->refcnt = 1;
  return res;
}
struct TdDeleteSavedOrderInfo *TdCreateObjectDeleteSavedOrderInfo (void) {
  auto var = new struct TdDeleteSavedOrderInfo ();
  var->ID = CODE_DeleteSavedOrderInfo;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteSavedOrderInfo> TdConvertToInternal (struct TdDeleteSavedOrderInfo *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::deleteSavedOrderInfo>();
}
struct TdDeleteSavedOrderInfo *TdConvertFromInternal (const td::td_api::deleteSavedOrderInfo &from) {
  auto res = new TdDeleteSavedOrderInfo ();
  res->ID = CODE_DeleteSavedOrderInfo;
  res->refcnt = 1;
  return res;
}
char *TdSerializeDeleteSavedOrderInfo (struct TdDeleteSavedOrderInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteSavedOrderInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteSavedOrderInfo (struct TdDeleteSavedOrderInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteSavedOrderInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDeleteSavedOrderInfo (struct TdDeleteSavedOrderInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteSavedOrderInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteSavedOrderInfo");
  M->new_field ("ID");
}
struct TdDeleteSavedOrderInfo *TdStackFetcherDeleteSavedOrderInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteSavedOrderInfo ();
  res->ID = CODE_DeleteSavedOrderInfo;
  res->refcnt = 1;
  return res;
}
struct TdDeleteSupergroup *TdCreateObjectDeleteSupergroup (int supergroup_id_) {
  auto var = new struct TdDeleteSupergroup ();
  var->ID = CODE_DeleteSupergroup;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::deleteSupergroup> TdConvertToInternal (struct TdDeleteSupergroup *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  return td::td_api::make_object<td::td_api::deleteSupergroup>(std::move (v0));
}
struct TdDeleteSupergroup *TdConvertFromInternal (const td::td_api::deleteSupergroup &from) {
  auto res = new TdDeleteSupergroup ();
  res->ID = CODE_DeleteSupergroup;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  return res;
}
char *TdSerializeDeleteSupergroup (struct TdDeleteSupergroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDeleteSupergroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDeleteSupergroup (struct TdDeleteSupergroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDeleteSupergroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDeleteSupergroup (struct TdDeleteSupergroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDeleteSupergroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DeleteSupergroup");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
}
struct TdDeleteSupergroup *TdStackFetcherDeleteSupergroup (struct TdStackFetcherMethods *M) {
  auto res = new TdDeleteSupergroup ();
  res->ID = CODE_DeleteSupergroup;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdDestroy *TdCreateObjectDestroy (void) {
  auto var = new struct TdDestroy ();
  var->ID = CODE_Destroy;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::destroy> TdConvertToInternal (struct TdDestroy *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::destroy>();
}
struct TdDestroy *TdConvertFromInternal (const td::td_api::destroy &from) {
  auto res = new TdDestroy ();
  res->ID = CODE_Destroy;
  res->refcnt = 1;
  return res;
}
char *TdSerializeDestroy (struct TdDestroy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDestroy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDestroy (struct TdDestroy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDestroy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDestroy (struct TdDestroy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDestroy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("Destroy");
  M->new_field ("ID");
}
struct TdDestroy *TdStackFetcherDestroy (struct TdStackFetcherMethods *M) {
  auto res = new TdDestroy ();
  res->ID = CODE_Destroy;
  res->refcnt = 1;
  return res;
}
struct TdDisableProxy *TdCreateObjectDisableProxy (void) {
  auto var = new struct TdDisableProxy ();
  var->ID = CODE_DisableProxy;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::disableProxy> TdConvertToInternal (struct TdDisableProxy *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::disableProxy>();
}
struct TdDisableProxy *TdConvertFromInternal (const td::td_api::disableProxy &from) {
  auto res = new TdDisableProxy ();
  res->ID = CODE_DisableProxy;
  res->refcnt = 1;
  return res;
}
char *TdSerializeDisableProxy (struct TdDisableProxy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDisableProxy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDisableProxy (struct TdDisableProxy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDisableProxy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDisableProxy (struct TdDisableProxy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDisableProxy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DisableProxy");
  M->new_field ("ID");
}
struct TdDisableProxy *TdStackFetcherDisableProxy (struct TdStackFetcherMethods *M) {
  auto res = new TdDisableProxy ();
  res->ID = CODE_DisableProxy;
  res->refcnt = 1;
  return res;
}
struct TdDiscardCall *TdCreateObjectDiscardCall (int call_id_, int is_disconnected_, int duration_, long long connection_id_) {
  auto var = new struct TdDiscardCall ();
  var->ID = CODE_DiscardCall;
  var->refcnt = 1;
  var->call_id_ = call_id_;
  var->is_disconnected_ = is_disconnected_;
  var->duration_ = duration_;
  var->connection_id_ = connection_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::discardCall> TdConvertToInternal (struct TdDiscardCall *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->call_id_;
  bool v100;
  v100 = var->is_disconnected_ != 0;
  std::int32_t v200;
  v200 = var->duration_;
  std::int64_t v300;
  v300 = var->connection_id_;
  return td::td_api::make_object<td::td_api::discardCall>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdDiscardCall *TdConvertFromInternal (const td::td_api::discardCall &from) {
  auto res = new TdDiscardCall ();
  res->ID = CODE_DiscardCall;
  res->refcnt = 1;
  res->call_id_ = from.call_id_;
  res->is_disconnected_ = from.is_disconnected_;
  res->duration_ = from.duration_;
  res->connection_id_ = from.connection_id_;
  return res;
}
char *TdSerializeDiscardCall (struct TdDiscardCall *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDiscardCall *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDiscardCall (struct TdDiscardCall *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDiscardCall *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDiscardCall (struct TdDiscardCall *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDiscardCall *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DiscardCall");
  M->new_field ("ID");
  M->pack_long (var->call_id_);
  M->new_field ("call_id_");
  M->pack_bool (var->is_disconnected_);
  M->new_field ("is_disconnected_");
  M->pack_long (var->duration_);
  M->new_field ("duration_");
  M->pack_long (var->connection_id_);
  M->new_field ("connection_id_");
}
struct TdDiscardCall *TdStackFetcherDiscardCall (struct TdStackFetcherMethods *M) {
  auto res = new TdDiscardCall ();
  res->ID = CODE_DiscardCall;
  res->refcnt = 1;
  M->get_field ("call_id_");
  res->call_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_disconnected_");
  res->is_disconnected_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("duration_");
  res->duration_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("connection_id_");
  res->connection_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdDisconnectAllWebsites *TdCreateObjectDisconnectAllWebsites (void) {
  auto var = new struct TdDisconnectAllWebsites ();
  var->ID = CODE_DisconnectAllWebsites;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::disconnectAllWebsites> TdConvertToInternal (struct TdDisconnectAllWebsites *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::disconnectAllWebsites>();
}
struct TdDisconnectAllWebsites *TdConvertFromInternal (const td::td_api::disconnectAllWebsites &from) {
  auto res = new TdDisconnectAllWebsites ();
  res->ID = CODE_DisconnectAllWebsites;
  res->refcnt = 1;
  return res;
}
char *TdSerializeDisconnectAllWebsites (struct TdDisconnectAllWebsites *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDisconnectAllWebsites *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDisconnectAllWebsites (struct TdDisconnectAllWebsites *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDisconnectAllWebsites *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDisconnectAllWebsites (struct TdDisconnectAllWebsites *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDisconnectAllWebsites *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DisconnectAllWebsites");
  M->new_field ("ID");
}
struct TdDisconnectAllWebsites *TdStackFetcherDisconnectAllWebsites (struct TdStackFetcherMethods *M) {
  auto res = new TdDisconnectAllWebsites ();
  res->ID = CODE_DisconnectAllWebsites;
  res->refcnt = 1;
  return res;
}
struct TdDisconnectWebsite *TdCreateObjectDisconnectWebsite (long long website_id_) {
  auto var = new struct TdDisconnectWebsite ();
  var->ID = CODE_DisconnectWebsite;
  var->refcnt = 1;
  var->website_id_ = website_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::disconnectWebsite> TdConvertToInternal (struct TdDisconnectWebsite *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->website_id_;
  return td::td_api::make_object<td::td_api::disconnectWebsite>(std::move (v0));
}
struct TdDisconnectWebsite *TdConvertFromInternal (const td::td_api::disconnectWebsite &from) {
  auto res = new TdDisconnectWebsite ();
  res->ID = CODE_DisconnectWebsite;
  res->refcnt = 1;
  res->website_id_ = from.website_id_;
  return res;
}
char *TdSerializeDisconnectWebsite (struct TdDisconnectWebsite *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDisconnectWebsite *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDisconnectWebsite (struct TdDisconnectWebsite *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDisconnectWebsite *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDisconnectWebsite (struct TdDisconnectWebsite *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDisconnectWebsite *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DisconnectWebsite");
  M->new_field ("ID");
  M->pack_long (var->website_id_);
  M->new_field ("website_id_");
}
struct TdDisconnectWebsite *TdStackFetcherDisconnectWebsite (struct TdStackFetcherMethods *M) {
  auto res = new TdDisconnectWebsite ();
  res->ID = CODE_DisconnectWebsite;
  res->refcnt = 1;
  M->get_field ("website_id_");
  res->website_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdDownloadFile *TdCreateObjectDownloadFile (int file_id_, int priority_) {
  auto var = new struct TdDownloadFile ();
  var->ID = CODE_DownloadFile;
  var->refcnt = 1;
  var->file_id_ = file_id_;
  var->priority_ = priority_;
  return var;
}
td::td_api::object_ptr<td::td_api::downloadFile> TdConvertToInternal (struct TdDownloadFile *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->file_id_;
  std::int32_t v100;
  v100 = var->priority_;
  return td::td_api::make_object<td::td_api::downloadFile>(std::move (v0), std::move (v100));
}
struct TdDownloadFile *TdConvertFromInternal (const td::td_api::downloadFile &from) {
  auto res = new TdDownloadFile ();
  res->ID = CODE_DownloadFile;
  res->refcnt = 1;
  res->file_id_ = from.file_id_;
  res->priority_ = from.priority_;
  return res;
}
char *TdSerializeDownloadFile (struct TdDownloadFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdDownloadFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectDownloadFile (struct TdDownloadFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdDownloadFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerDownloadFile (struct TdDownloadFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdDownloadFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("DownloadFile");
  M->new_field ("ID");
  M->pack_long (var->file_id_);
  M->new_field ("file_id_");
  M->pack_long (var->priority_);
  M->new_field ("priority_");
}
struct TdDownloadFile *TdStackFetcherDownloadFile (struct TdStackFetcherMethods *M) {
  auto res = new TdDownloadFile ();
  res->ID = CODE_DownloadFile;
  res->refcnt = 1;
  M->get_field ("file_id_");
  res->file_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("priority_");
  res->priority_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdEditCustomLanguagePackInfo *TdCreateObjectEditCustomLanguagePackInfo (struct TdLanguagePackInfo *info_) {
  auto var = new struct TdEditCustomLanguagePackInfo ();
  var->ID = CODE_EditCustomLanguagePackInfo;
  var->refcnt = 1;
  var->info_ = info_;
  return var;
}
td::td_api::object_ptr<td::td_api::editCustomLanguagePackInfo> TdConvertToInternal (struct TdEditCustomLanguagePackInfo *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::languagePackInfo> v0;
  v0 = TdConvertToInternal (var->info_);
  return td::td_api::make_object<td::td_api::editCustomLanguagePackInfo>(std::move (v0));
}
struct TdEditCustomLanguagePackInfo *TdConvertFromInternal (const td::td_api::editCustomLanguagePackInfo &from) {
  auto res = new TdEditCustomLanguagePackInfo ();
  res->ID = CODE_EditCustomLanguagePackInfo;
  res->refcnt = 1;
  if (!from.info_) {
    res->info_ = nullptr;
  } else {
    res->info_ = TdConvertFromInternal (static_cast<const td::td_api::languagePackInfo &>(*from.info_));
  }
  return res;
}
char *TdSerializeEditCustomLanguagePackInfo (struct TdEditCustomLanguagePackInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditCustomLanguagePackInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditCustomLanguagePackInfo (struct TdEditCustomLanguagePackInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditCustomLanguagePackInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->info_);
  delete var;
}
void TdStackStorerEditCustomLanguagePackInfo (struct TdEditCustomLanguagePackInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditCustomLanguagePackInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditCustomLanguagePackInfo");
  M->new_field ("ID");
  TdStackStorer (var->info_, M);
  M->new_field ("info_");
}
struct TdEditCustomLanguagePackInfo *TdStackFetcherEditCustomLanguagePackInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdEditCustomLanguagePackInfo ();
  res->ID = CODE_EditCustomLanguagePackInfo;
  res->refcnt = 1;
  M->get_field ("info_");
  if (M->is_nil ()) {
    res->info_ = nullptr;
  } else {
    res->info_ = TdStackFetcherLanguagePackInfo (M);
  }
  M->pop ();
  return res;
}
struct TdEditInlineMessageCaption *TdCreateObjectEditInlineMessageCaption (char *inline_message_id_, struct TdReplyMarkup *reply_markup_, struct TdFormattedText *caption_) {
  auto var = new struct TdEditInlineMessageCaption ();
  var->ID = CODE_EditInlineMessageCaption;
  var->refcnt = 1;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  var->reply_markup_ = reply_markup_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::editInlineMessageCaption> TdConvertToInternal (struct TdEditInlineMessageCaption *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->inline_message_id_) ? var->inline_message_id_: "";
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v100;
  v100 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::formattedText> v200;
  v200 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::editInlineMessageCaption>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdEditInlineMessageCaption *TdConvertFromInternal (const td::td_api::editInlineMessageCaption &from) {
  auto res = new TdEditInlineMessageCaption ();
  res->ID = CODE_EditInlineMessageCaption;
  res->refcnt = 1;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  return res;
}
char *TdSerializeEditInlineMessageCaption (struct TdEditInlineMessageCaption *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditInlineMessageCaption *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditInlineMessageCaption (struct TdEditInlineMessageCaption *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditInlineMessageCaption *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_message_id_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerEditInlineMessageCaption (struct TdEditInlineMessageCaption *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditInlineMessageCaption *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditInlineMessageCaption");
  M->new_field ("ID");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdEditInlineMessageCaption *TdStackFetcherEditInlineMessageCaption (struct TdStackFetcherMethods *M) {
  auto res = new TdEditInlineMessageCaption ();
  res->ID = CODE_EditInlineMessageCaption;
  res->refcnt = 1;
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdEditInlineMessageLiveLocation *TdCreateObjectEditInlineMessageLiveLocation (char *inline_message_id_, struct TdReplyMarkup *reply_markup_, struct TdLocation *location_) {
  auto var = new struct TdEditInlineMessageLiveLocation ();
  var->ID = CODE_EditInlineMessageLiveLocation;
  var->refcnt = 1;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  var->reply_markup_ = reply_markup_;
  var->location_ = location_;
  return var;
}
td::td_api::object_ptr<td::td_api::editInlineMessageLiveLocation> TdConvertToInternal (struct TdEditInlineMessageLiveLocation *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->inline_message_id_) ? var->inline_message_id_: "";
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v100;
  v100 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::location> v200;
  v200 = TdConvertToInternal (var->location_);
  return td::td_api::make_object<td::td_api::editInlineMessageLiveLocation>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdEditInlineMessageLiveLocation *TdConvertFromInternal (const td::td_api::editInlineMessageLiveLocation &from) {
  auto res = new TdEditInlineMessageLiveLocation ();
  res->ID = CODE_EditInlineMessageLiveLocation;
  res->refcnt = 1;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.location_) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.location_));
  }
  return res;
}
char *TdSerializeEditInlineMessageLiveLocation (struct TdEditInlineMessageLiveLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditInlineMessageLiveLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditInlineMessageLiveLocation (struct TdEditInlineMessageLiveLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditInlineMessageLiveLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_message_id_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->location_);
  delete var;
}
void TdStackStorerEditInlineMessageLiveLocation (struct TdEditInlineMessageLiveLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditInlineMessageLiveLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditInlineMessageLiveLocation");
  M->new_field ("ID");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->location_, M);
  M->new_field ("location_");
}
struct TdEditInlineMessageLiveLocation *TdStackFetcherEditInlineMessageLiveLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdEditInlineMessageLiveLocation ();
  res->ID = CODE_EditInlineMessageLiveLocation;
  res->refcnt = 1;
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("location_");
  if (M->is_nil ()) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  return res;
}
struct TdEditInlineMessageMedia *TdCreateObjectEditInlineMessageMedia (char *inline_message_id_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdEditInlineMessageMedia ();
  var->ID = CODE_EditInlineMessageMedia;
  var->refcnt = 1;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::editInlineMessageMedia> TdConvertToInternal (struct TdEditInlineMessageMedia *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->inline_message_id_) ? var->inline_message_id_: "";
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v100;
  v100 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v200;
  v200 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::editInlineMessageMedia>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdEditInlineMessageMedia *TdConvertFromInternal (const td::td_api::editInlineMessageMedia &from) {
  auto res = new TdEditInlineMessageMedia ();
  res->ID = CODE_EditInlineMessageMedia;
  res->refcnt = 1;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeEditInlineMessageMedia (struct TdEditInlineMessageMedia *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditInlineMessageMedia *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditInlineMessageMedia (struct TdEditInlineMessageMedia *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditInlineMessageMedia *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_message_id_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerEditInlineMessageMedia (struct TdEditInlineMessageMedia *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditInlineMessageMedia *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditInlineMessageMedia");
  M->new_field ("ID");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdEditInlineMessageMedia *TdStackFetcherEditInlineMessageMedia (struct TdStackFetcherMethods *M) {
  auto res = new TdEditInlineMessageMedia ();
  res->ID = CODE_EditInlineMessageMedia;
  res->refcnt = 1;
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdEditInlineMessageReplyMarkup *TdCreateObjectEditInlineMessageReplyMarkup (char *inline_message_id_, struct TdReplyMarkup *reply_markup_) {
  auto var = new struct TdEditInlineMessageReplyMarkup ();
  var->ID = CODE_EditInlineMessageReplyMarkup;
  var->refcnt = 1;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  var->reply_markup_ = reply_markup_;
  return var;
}
td::td_api::object_ptr<td::td_api::editInlineMessageReplyMarkup> TdConvertToInternal (struct TdEditInlineMessageReplyMarkup *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->inline_message_id_) ? var->inline_message_id_: "";
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v100;
  v100 = TdConvertToInternal (var->reply_markup_);
  return td::td_api::make_object<td::td_api::editInlineMessageReplyMarkup>(std::move (v0), std::move (v100));
}
struct TdEditInlineMessageReplyMarkup *TdConvertFromInternal (const td::td_api::editInlineMessageReplyMarkup &from) {
  auto res = new TdEditInlineMessageReplyMarkup ();
  res->ID = CODE_EditInlineMessageReplyMarkup;
  res->refcnt = 1;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  return res;
}
char *TdSerializeEditInlineMessageReplyMarkup (struct TdEditInlineMessageReplyMarkup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditInlineMessageReplyMarkup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditInlineMessageReplyMarkup (struct TdEditInlineMessageReplyMarkup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditInlineMessageReplyMarkup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_message_id_);
  TdDestroyObject (var->reply_markup_);
  delete var;
}
void TdStackStorerEditInlineMessageReplyMarkup (struct TdEditInlineMessageReplyMarkup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditInlineMessageReplyMarkup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditInlineMessageReplyMarkup");
  M->new_field ("ID");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
}
struct TdEditInlineMessageReplyMarkup *TdStackFetcherEditInlineMessageReplyMarkup (struct TdStackFetcherMethods *M) {
  auto res = new TdEditInlineMessageReplyMarkup ();
  res->ID = CODE_EditInlineMessageReplyMarkup;
  res->refcnt = 1;
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  return res;
}
struct TdEditInlineMessageText *TdCreateObjectEditInlineMessageText (char *inline_message_id_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdEditInlineMessageText ();
  var->ID = CODE_EditInlineMessageText;
  var->refcnt = 1;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::editInlineMessageText> TdConvertToInternal (struct TdEditInlineMessageText *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->inline_message_id_) ? var->inline_message_id_: "";
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v100;
  v100 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v200;
  v200 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::editInlineMessageText>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdEditInlineMessageText *TdConvertFromInternal (const td::td_api::editInlineMessageText &from) {
  auto res = new TdEditInlineMessageText ();
  res->ID = CODE_EditInlineMessageText;
  res->refcnt = 1;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeEditInlineMessageText (struct TdEditInlineMessageText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditInlineMessageText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditInlineMessageText (struct TdEditInlineMessageText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditInlineMessageText *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_message_id_);
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerEditInlineMessageText (struct TdEditInlineMessageText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditInlineMessageText *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditInlineMessageText");
  M->new_field ("ID");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdEditInlineMessageText *TdStackFetcherEditInlineMessageText (struct TdStackFetcherMethods *M) {
  auto res = new TdEditInlineMessageText ();
  res->ID = CODE_EditInlineMessageText;
  res->refcnt = 1;
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdEditMessageCaption *TdCreateObjectEditMessageCaption (long long chat_id_, long long message_id_, struct TdReplyMarkup *reply_markup_, struct TdFormattedText *caption_) {
  auto var = new struct TdEditMessageCaption ();
  var->ID = CODE_EditMessageCaption;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->reply_markup_ = reply_markup_;
  var->caption_ = caption_;
  return var;
}
td::td_api::object_ptr<td::td_api::editMessageCaption> TdConvertToInternal (struct TdEditMessageCaption *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v200;
  v200 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::formattedText> v300;
  v300 = TdConvertToInternal (var->caption_);
  return td::td_api::make_object<td::td_api::editMessageCaption>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdEditMessageCaption *TdConvertFromInternal (const td::td_api::editMessageCaption &from) {
  auto res = new TdEditMessageCaption ();
  res->ID = CODE_EditMessageCaption;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.caption_) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.caption_));
  }
  return res;
}
char *TdSerializeEditMessageCaption (struct TdEditMessageCaption *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditMessageCaption *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditMessageCaption (struct TdEditMessageCaption *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditMessageCaption *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->caption_);
  delete var;
}
void TdStackStorerEditMessageCaption (struct TdEditMessageCaption *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditMessageCaption *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditMessageCaption");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->caption_, M);
  M->new_field ("caption_");
}
struct TdEditMessageCaption *TdStackFetcherEditMessageCaption (struct TdStackFetcherMethods *M) {
  auto res = new TdEditMessageCaption ();
  res->ID = CODE_EditMessageCaption;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("caption_");
  if (M->is_nil ()) {
    res->caption_ = nullptr;
  } else {
    res->caption_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdEditMessageLiveLocation *TdCreateObjectEditMessageLiveLocation (long long chat_id_, long long message_id_, struct TdReplyMarkup *reply_markup_, struct TdLocation *location_) {
  auto var = new struct TdEditMessageLiveLocation ();
  var->ID = CODE_EditMessageLiveLocation;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->reply_markup_ = reply_markup_;
  var->location_ = location_;
  return var;
}
td::td_api::object_ptr<td::td_api::editMessageLiveLocation> TdConvertToInternal (struct TdEditMessageLiveLocation *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v200;
  v200 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::location> v300;
  v300 = TdConvertToInternal (var->location_);
  return td::td_api::make_object<td::td_api::editMessageLiveLocation>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdEditMessageLiveLocation *TdConvertFromInternal (const td::td_api::editMessageLiveLocation &from) {
  auto res = new TdEditMessageLiveLocation ();
  res->ID = CODE_EditMessageLiveLocation;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.location_) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.location_));
  }
  return res;
}
char *TdSerializeEditMessageLiveLocation (struct TdEditMessageLiveLocation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditMessageLiveLocation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditMessageLiveLocation (struct TdEditMessageLiveLocation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditMessageLiveLocation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->location_);
  delete var;
}
void TdStackStorerEditMessageLiveLocation (struct TdEditMessageLiveLocation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditMessageLiveLocation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditMessageLiveLocation");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->location_, M);
  M->new_field ("location_");
}
struct TdEditMessageLiveLocation *TdStackFetcherEditMessageLiveLocation (struct TdStackFetcherMethods *M) {
  auto res = new TdEditMessageLiveLocation ();
  res->ID = CODE_EditMessageLiveLocation;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("location_");
  if (M->is_nil ()) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  return res;
}
struct TdEditMessageMedia *TdCreateObjectEditMessageMedia (long long chat_id_, long long message_id_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdEditMessageMedia ();
  var->ID = CODE_EditMessageMedia;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::editMessageMedia> TdConvertToInternal (struct TdEditMessageMedia *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v200;
  v200 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v300;
  v300 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::editMessageMedia>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdEditMessageMedia *TdConvertFromInternal (const td::td_api::editMessageMedia &from) {
  auto res = new TdEditMessageMedia ();
  res->ID = CODE_EditMessageMedia;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeEditMessageMedia (struct TdEditMessageMedia *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditMessageMedia *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditMessageMedia (struct TdEditMessageMedia *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditMessageMedia *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerEditMessageMedia (struct TdEditMessageMedia *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditMessageMedia *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditMessageMedia");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdEditMessageMedia *TdStackFetcherEditMessageMedia (struct TdStackFetcherMethods *M) {
  auto res = new TdEditMessageMedia ();
  res->ID = CODE_EditMessageMedia;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdEditMessageReplyMarkup *TdCreateObjectEditMessageReplyMarkup (long long chat_id_, long long message_id_, struct TdReplyMarkup *reply_markup_) {
  auto var = new struct TdEditMessageReplyMarkup ();
  var->ID = CODE_EditMessageReplyMarkup;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->reply_markup_ = reply_markup_;
  return var;
}
td::td_api::object_ptr<td::td_api::editMessageReplyMarkup> TdConvertToInternal (struct TdEditMessageReplyMarkup *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v200;
  v200 = TdConvertToInternal (var->reply_markup_);
  return td::td_api::make_object<td::td_api::editMessageReplyMarkup>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdEditMessageReplyMarkup *TdConvertFromInternal (const td::td_api::editMessageReplyMarkup &from) {
  auto res = new TdEditMessageReplyMarkup ();
  res->ID = CODE_EditMessageReplyMarkup;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  return res;
}
char *TdSerializeEditMessageReplyMarkup (struct TdEditMessageReplyMarkup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditMessageReplyMarkup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditMessageReplyMarkup (struct TdEditMessageReplyMarkup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditMessageReplyMarkup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reply_markup_);
  delete var;
}
void TdStackStorerEditMessageReplyMarkup (struct TdEditMessageReplyMarkup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditMessageReplyMarkup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditMessageReplyMarkup");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
}
struct TdEditMessageReplyMarkup *TdStackFetcherEditMessageReplyMarkup (struct TdStackFetcherMethods *M) {
  auto res = new TdEditMessageReplyMarkup ();
  res->ID = CODE_EditMessageReplyMarkup;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  return res;
}
struct TdEditMessageText *TdCreateObjectEditMessageText (long long chat_id_, long long message_id_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdEditMessageText ();
  var->ID = CODE_EditMessageText;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::editMessageText> TdConvertToInternal (struct TdEditMessageText *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v200;
  v200 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v300;
  v300 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::editMessageText>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdEditMessageText *TdConvertFromInternal (const td::td_api::editMessageText &from) {
  auto res = new TdEditMessageText ();
  res->ID = CODE_EditMessageText;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeEditMessageText (struct TdEditMessageText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditMessageText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditMessageText (struct TdEditMessageText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditMessageText *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerEditMessageText (struct TdEditMessageText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditMessageText *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditMessageText");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdEditMessageText *TdStackFetcherEditMessageText (struct TdStackFetcherMethods *M) {
  auto res = new TdEditMessageText ();
  res->ID = CODE_EditMessageText;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdEditProxy *TdCreateObjectEditProxy (int proxy_id_, char *server_, int port_, int enable_, struct TdProxyType *type_) {
  auto var = new struct TdEditProxy ();
  var->ID = CODE_EditProxy;
  var->refcnt = 1;
  var->proxy_id_ = proxy_id_;
  var->server_ = (server_) ? td::str_dup (td::Slice (server_)) : nullptr;
  var->port_ = port_;
  var->enable_ = enable_;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::editProxy> TdConvertToInternal (struct TdEditProxy *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->proxy_id_;
  std::string v100;
  v100 = (var->server_) ? var->server_: "";
  std::int32_t v200;
  v200 = var->port_;
  bool v300;
  v300 = var->enable_ != 0;
  td::td_api::object_ptr<td::td_api::ProxyType> v400;
  v400 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::editProxy>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdEditProxy *TdConvertFromInternal (const td::td_api::editProxy &from) {
  auto res = new TdEditProxy ();
  res->ID = CODE_EditProxy;
  res->refcnt = 1;
  res->proxy_id_ = from.proxy_id_;
  res->server_ = (from.server_.length ()) ? td::str_dup (from.server_) : nullptr;
  res->port_ = from.port_;
  res->enable_ = from.enable_;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::ProxyType &>(*from.type_));
  }
  return res;
}
char *TdSerializeEditProxy (struct TdEditProxy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEditProxy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEditProxy (struct TdEditProxy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEditProxy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->server_);
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerEditProxy (struct TdEditProxy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEditProxy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EditProxy");
  M->new_field ("ID");
  M->pack_long (var->proxy_id_);
  M->new_field ("proxy_id_");
  M->pack_string (var->server_);
  M->new_field ("server_");
  M->pack_long (var->port_);
  M->new_field ("port_");
  M->pack_bool (var->enable_);
  M->new_field ("enable_");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdEditProxy *TdStackFetcherEditProxy (struct TdStackFetcherMethods *M) {
  auto res = new TdEditProxy ();
  res->ID = CODE_EditProxy;
  res->refcnt = 1;
  M->get_field ("proxy_id_");
  res->proxy_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("server_");
  res->server_ = M->get_string ();
  M->pop ();
  M->get_field ("port_");
  res->port_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("enable_");
  res->enable_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherProxyType (M);
  }
  M->pop ();
  return res;
}
struct TdEnableProxy *TdCreateObjectEnableProxy (int proxy_id_) {
  auto var = new struct TdEnableProxy ();
  var->ID = CODE_EnableProxy;
  var->refcnt = 1;
  var->proxy_id_ = proxy_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::enableProxy> TdConvertToInternal (struct TdEnableProxy *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->proxy_id_;
  return td::td_api::make_object<td::td_api::enableProxy>(std::move (v0));
}
struct TdEnableProxy *TdConvertFromInternal (const td::td_api::enableProxy &from) {
  auto res = new TdEnableProxy ();
  res->ID = CODE_EnableProxy;
  res->refcnt = 1;
  res->proxy_id_ = from.proxy_id_;
  return res;
}
char *TdSerializeEnableProxy (struct TdEnableProxy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdEnableProxy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectEnableProxy (struct TdEnableProxy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdEnableProxy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerEnableProxy (struct TdEnableProxy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdEnableProxy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("EnableProxy");
  M->new_field ("ID");
  M->pack_long (var->proxy_id_);
  M->new_field ("proxy_id_");
}
struct TdEnableProxy *TdStackFetcherEnableProxy (struct TdStackFetcherMethods *M) {
  auto res = new TdEnableProxy ();
  res->ID = CODE_EnableProxy;
  res->refcnt = 1;
  M->get_field ("proxy_id_");
  res->proxy_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdFinishFileGeneration *TdCreateObjectFinishFileGeneration (long long generation_id_, struct TdError *error_) {
  auto var = new struct TdFinishFileGeneration ();
  var->ID = CODE_FinishFileGeneration;
  var->refcnt = 1;
  var->generation_id_ = generation_id_;
  var->error_ = error_;
  return var;
}
td::td_api::object_ptr<td::td_api::finishFileGeneration> TdConvertToInternal (struct TdFinishFileGeneration *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->generation_id_;
  td::td_api::object_ptr<td::td_api::error> v100;
  v100 = TdConvertToInternal (var->error_);
  return td::td_api::make_object<td::td_api::finishFileGeneration>(std::move (v0), std::move (v100));
}
struct TdFinishFileGeneration *TdConvertFromInternal (const td::td_api::finishFileGeneration &from) {
  auto res = new TdFinishFileGeneration ();
  res->ID = CODE_FinishFileGeneration;
  res->refcnt = 1;
  res->generation_id_ = from.generation_id_;
  if (!from.error_) {
    res->error_ = nullptr;
  } else {
    res->error_ = TdConvertFromInternal (static_cast<const td::td_api::error &>(*from.error_));
  }
  return res;
}
char *TdSerializeFinishFileGeneration (struct TdFinishFileGeneration *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdFinishFileGeneration *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectFinishFileGeneration (struct TdFinishFileGeneration *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdFinishFileGeneration *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->error_);
  delete var;
}
void TdStackStorerFinishFileGeneration (struct TdFinishFileGeneration *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdFinishFileGeneration *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("FinishFileGeneration");
  M->new_field ("ID");
  M->pack_long (var->generation_id_);
  M->new_field ("generation_id_");
  TdStackStorer (var->error_, M);
  M->new_field ("error_");
}
struct TdFinishFileGeneration *TdStackFetcherFinishFileGeneration (struct TdStackFetcherMethods *M) {
  auto res = new TdFinishFileGeneration ();
  res->ID = CODE_FinishFileGeneration;
  res->refcnt = 1;
  M->get_field ("generation_id_");
  res->generation_id_ = M->get_long ();
  M->pop ();
  M->get_field ("error_");
  if (M->is_nil ()) {
    res->error_ = nullptr;
  } else {
    res->error_ = TdStackFetcherError (M);
  }
  M->pop ();
  return res;
}
struct TdForwardMessages *TdCreateObjectForwardMessages (long long chat_id_, long long from_chat_id_, struct TdVectorLong *message_ids_, int disable_notification_, int from_background_, int as_album_) {
  auto var = new struct TdForwardMessages ();
  var->ID = CODE_ForwardMessages;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->from_chat_id_ = from_chat_id_;
  var->message_ids_ = message_ids_;
  var->disable_notification_ = disable_notification_;
  var->from_background_ = from_background_;
  var->as_album_ = as_album_;
  return var;
}
td::td_api::object_ptr<td::td_api::forwardMessages> TdConvertToInternal (struct TdForwardMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->from_chat_id_;
  std::vector<std::int64_t> v200;
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
    std::int64_t v201;
    v201 = var->message_ids_->data[i200];
    v200.push_back (std::move (v201));
  }
  bool v300;
  v300 = var->disable_notification_ != 0;
  bool v400;
  v400 = var->from_background_ != 0;
  bool v500;
  v500 = var->as_album_ != 0;
  return td::td_api::make_object<td::td_api::forwardMessages>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdForwardMessages *TdConvertFromInternal (const td::td_api::forwardMessages &from) {
  auto res = new TdForwardMessages ();
  res->ID = CODE_ForwardMessages;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->from_chat_id_ = from.from_chat_id_;
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = (int)from.message_ids_.size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i200 = 0; i200 < res->message_ids_->len; i200++) {
    res->message_ids_->data[i200] = from.message_ids_[i200];
  }
  res->disable_notification_ = from.disable_notification_;
  res->from_background_ = from.from_background_;
  res->as_album_ = from.as_album_;
  return res;
}
char *TdSerializeForwardMessages (struct TdForwardMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdForwardMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectForwardMessages (struct TdForwardMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdForwardMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
  }
  delete[] var->message_ids_->data;
  delete var->message_ids_;
  delete var;
}
void TdStackStorerForwardMessages (struct TdForwardMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdForwardMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ForwardMessages");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->from_chat_id_);
  M->new_field ("from_chat_id_");
  M->new_array ();
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
    M->pack_long (var->message_ids_->data[i200]);
    M->new_arr_field (i200);
  }
  M->new_field ("message_ids_");
  M->pack_bool (var->disable_notification_);
  M->new_field ("disable_notification_");
  M->pack_bool (var->from_background_);
  M->new_field ("from_background_");
  M->pack_bool (var->as_album_);
  M->new_field ("as_album_");
}
struct TdForwardMessages *TdStackFetcherForwardMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdForwardMessages ();
  res->ID = CODE_ForwardMessages;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("from_chat_id_");
  res->from_chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_ids_");
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = M->get_arr_size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i200 = 0; i200 < res->message_ids_->len; i200++) {
    M->get_arr_field (i200);
    res->message_ids_->data[i200] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("disable_notification_");
  res->disable_notification_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("from_background_");
  res->from_background_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("as_album_");
  res->as_album_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGenerateChatInviteLink *TdCreateObjectGenerateChatInviteLink (long long chat_id_) {
  auto var = new struct TdGenerateChatInviteLink ();
  var->ID = CODE_GenerateChatInviteLink;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::generateChatInviteLink> TdConvertToInternal (struct TdGenerateChatInviteLink *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::generateChatInviteLink>(std::move (v0));
}
struct TdGenerateChatInviteLink *TdConvertFromInternal (const td::td_api::generateChatInviteLink &from) {
  auto res = new TdGenerateChatInviteLink ();
  res->ID = CODE_GenerateChatInviteLink;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeGenerateChatInviteLink (struct TdGenerateChatInviteLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGenerateChatInviteLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGenerateChatInviteLink (struct TdGenerateChatInviteLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGenerateChatInviteLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGenerateChatInviteLink (struct TdGenerateChatInviteLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGenerateChatInviteLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GenerateChatInviteLink");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdGenerateChatInviteLink *TdStackFetcherGenerateChatInviteLink (struct TdStackFetcherMethods *M) {
  auto res = new TdGenerateChatInviteLink ();
  res->ID = CODE_GenerateChatInviteLink;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetAccountTtl *TdCreateObjectGetAccountTtl (void) {
  auto var = new struct TdGetAccountTtl ();
  var->ID = CODE_GetAccountTtl;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getAccountTtl> TdConvertToInternal (struct TdGetAccountTtl *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getAccountTtl>();
}
struct TdGetAccountTtl *TdConvertFromInternal (const td::td_api::getAccountTtl &from) {
  auto res = new TdGetAccountTtl ();
  res->ID = CODE_GetAccountTtl;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetAccountTtl (struct TdGetAccountTtl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetAccountTtl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetAccountTtl (struct TdGetAccountTtl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetAccountTtl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetAccountTtl (struct TdGetAccountTtl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetAccountTtl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetAccountTtl");
  M->new_field ("ID");
}
struct TdGetAccountTtl *TdStackFetcherGetAccountTtl (struct TdStackFetcherMethods *M) {
  auto res = new TdGetAccountTtl ();
  res->ID = CODE_GetAccountTtl;
  res->refcnt = 1;
  return res;
}
struct TdGetActiveLiveLocationMessages *TdCreateObjectGetActiveLiveLocationMessages (void) {
  auto var = new struct TdGetActiveLiveLocationMessages ();
  var->ID = CODE_GetActiveLiveLocationMessages;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getActiveLiveLocationMessages> TdConvertToInternal (struct TdGetActiveLiveLocationMessages *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getActiveLiveLocationMessages>();
}
struct TdGetActiveLiveLocationMessages *TdConvertFromInternal (const td::td_api::getActiveLiveLocationMessages &from) {
  auto res = new TdGetActiveLiveLocationMessages ();
  res->ID = CODE_GetActiveLiveLocationMessages;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetActiveLiveLocationMessages (struct TdGetActiveLiveLocationMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetActiveLiveLocationMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetActiveLiveLocationMessages (struct TdGetActiveLiveLocationMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetActiveLiveLocationMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetActiveLiveLocationMessages (struct TdGetActiveLiveLocationMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetActiveLiveLocationMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetActiveLiveLocationMessages");
  M->new_field ("ID");
}
struct TdGetActiveLiveLocationMessages *TdStackFetcherGetActiveLiveLocationMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdGetActiveLiveLocationMessages ();
  res->ID = CODE_GetActiveLiveLocationMessages;
  res->refcnt = 1;
  return res;
}
struct TdGetActiveSessions *TdCreateObjectGetActiveSessions (void) {
  auto var = new struct TdGetActiveSessions ();
  var->ID = CODE_GetActiveSessions;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getActiveSessions> TdConvertToInternal (struct TdGetActiveSessions *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getActiveSessions>();
}
struct TdGetActiveSessions *TdConvertFromInternal (const td::td_api::getActiveSessions &from) {
  auto res = new TdGetActiveSessions ();
  res->ID = CODE_GetActiveSessions;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetActiveSessions (struct TdGetActiveSessions *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetActiveSessions *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetActiveSessions (struct TdGetActiveSessions *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetActiveSessions *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetActiveSessions (struct TdGetActiveSessions *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetActiveSessions *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetActiveSessions");
  M->new_field ("ID");
}
struct TdGetActiveSessions *TdStackFetcherGetActiveSessions (struct TdStackFetcherMethods *M) {
  auto res = new TdGetActiveSessions ();
  res->ID = CODE_GetActiveSessions;
  res->refcnt = 1;
  return res;
}
struct TdGetAllPassportElements *TdCreateObjectGetAllPassportElements (char *password_) {
  auto var = new struct TdGetAllPassportElements ();
  var->ID = CODE_GetAllPassportElements;
  var->refcnt = 1;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getAllPassportElements> TdConvertToInternal (struct TdGetAllPassportElements *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->password_) ? var->password_: "";
  return td::td_api::make_object<td::td_api::getAllPassportElements>(std::move (v0));
}
struct TdGetAllPassportElements *TdConvertFromInternal (const td::td_api::getAllPassportElements &from) {
  auto res = new TdGetAllPassportElements ();
  res->ID = CODE_GetAllPassportElements;
  res->refcnt = 1;
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  return res;
}
char *TdSerializeGetAllPassportElements (struct TdGetAllPassportElements *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetAllPassportElements *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetAllPassportElements (struct TdGetAllPassportElements *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetAllPassportElements *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->password_);
  delete var;
}
void TdStackStorerGetAllPassportElements (struct TdGetAllPassportElements *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetAllPassportElements *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetAllPassportElements");
  M->new_field ("ID");
  M->pack_string (var->password_);
  M->new_field ("password_");
}
struct TdGetAllPassportElements *TdStackFetcherGetAllPassportElements (struct TdStackFetcherMethods *M) {
  auto res = new TdGetAllPassportElements ();
  res->ID = CODE_GetAllPassportElements;
  res->refcnt = 1;
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetArchivedStickerSets *TdCreateObjectGetArchivedStickerSets (int is_masks_, long long offset_sticker_set_id_, int limit_) {
  auto var = new struct TdGetArchivedStickerSets ();
  var->ID = CODE_GetArchivedStickerSets;
  var->refcnt = 1;
  var->is_masks_ = is_masks_;
  var->offset_sticker_set_id_ = offset_sticker_set_id_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getArchivedStickerSets> TdConvertToInternal (struct TdGetArchivedStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_masks_ != 0;
  std::int64_t v100;
  v100 = var->offset_sticker_set_id_;
  std::int32_t v200;
  v200 = var->limit_;
  return td::td_api::make_object<td::td_api::getArchivedStickerSets>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGetArchivedStickerSets *TdConvertFromInternal (const td::td_api::getArchivedStickerSets &from) {
  auto res = new TdGetArchivedStickerSets ();
  res->ID = CODE_GetArchivedStickerSets;
  res->refcnt = 1;
  res->is_masks_ = from.is_masks_;
  res->offset_sticker_set_id_ = from.offset_sticker_set_id_;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeGetArchivedStickerSets (struct TdGetArchivedStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetArchivedStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetArchivedStickerSets (struct TdGetArchivedStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetArchivedStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetArchivedStickerSets (struct TdGetArchivedStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetArchivedStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetArchivedStickerSets");
  M->new_field ("ID");
  M->pack_bool (var->is_masks_);
  M->new_field ("is_masks_");
  M->pack_long (var->offset_sticker_set_id_);
  M->new_field ("offset_sticker_set_id_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdGetArchivedStickerSets *TdStackFetcherGetArchivedStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdGetArchivedStickerSets ();
  res->ID = CODE_GetArchivedStickerSets;
  res->refcnt = 1;
  M->get_field ("is_masks_");
  res->is_masks_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("offset_sticker_set_id_");
  res->offset_sticker_set_id_ = M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetAttachedStickerSets *TdCreateObjectGetAttachedStickerSets (int file_id_) {
  auto var = new struct TdGetAttachedStickerSets ();
  var->ID = CODE_GetAttachedStickerSets;
  var->refcnt = 1;
  var->file_id_ = file_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getAttachedStickerSets> TdConvertToInternal (struct TdGetAttachedStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->file_id_;
  return td::td_api::make_object<td::td_api::getAttachedStickerSets>(std::move (v0));
}
struct TdGetAttachedStickerSets *TdConvertFromInternal (const td::td_api::getAttachedStickerSets &from) {
  auto res = new TdGetAttachedStickerSets ();
  res->ID = CODE_GetAttachedStickerSets;
  res->refcnt = 1;
  res->file_id_ = from.file_id_;
  return res;
}
char *TdSerializeGetAttachedStickerSets (struct TdGetAttachedStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetAttachedStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetAttachedStickerSets (struct TdGetAttachedStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetAttachedStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetAttachedStickerSets (struct TdGetAttachedStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetAttachedStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetAttachedStickerSets");
  M->new_field ("ID");
  M->pack_long (var->file_id_);
  M->new_field ("file_id_");
}
struct TdGetAttachedStickerSets *TdStackFetcherGetAttachedStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdGetAttachedStickerSets ();
  res->ID = CODE_GetAttachedStickerSets;
  res->refcnt = 1;
  M->get_field ("file_id_");
  res->file_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetAuthorizationState *TdCreateObjectGetAuthorizationState (void) {
  auto var = new struct TdGetAuthorizationState ();
  var->ID = CODE_GetAuthorizationState;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getAuthorizationState> TdConvertToInternal (struct TdGetAuthorizationState *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getAuthorizationState>();
}
struct TdGetAuthorizationState *TdConvertFromInternal (const td::td_api::getAuthorizationState &from) {
  auto res = new TdGetAuthorizationState ();
  res->ID = CODE_GetAuthorizationState;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetAuthorizationState (struct TdGetAuthorizationState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetAuthorizationState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetAuthorizationState (struct TdGetAuthorizationState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetAuthorizationState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetAuthorizationState (struct TdGetAuthorizationState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetAuthorizationState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetAuthorizationState");
  M->new_field ("ID");
}
struct TdGetAuthorizationState *TdStackFetcherGetAuthorizationState (struct TdStackFetcherMethods *M) {
  auto res = new TdGetAuthorizationState ();
  res->ID = CODE_GetAuthorizationState;
  res->refcnt = 1;
  return res;
}
struct TdGetBasicGroup *TdCreateObjectGetBasicGroup (int basic_group_id_) {
  auto var = new struct TdGetBasicGroup ();
  var->ID = CODE_GetBasicGroup;
  var->refcnt = 1;
  var->basic_group_id_ = basic_group_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getBasicGroup> TdConvertToInternal (struct TdGetBasicGroup *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->basic_group_id_;
  return td::td_api::make_object<td::td_api::getBasicGroup>(std::move (v0));
}
struct TdGetBasicGroup *TdConvertFromInternal (const td::td_api::getBasicGroup &from) {
  auto res = new TdGetBasicGroup ();
  res->ID = CODE_GetBasicGroup;
  res->refcnt = 1;
  res->basic_group_id_ = from.basic_group_id_;
  return res;
}
char *TdSerializeGetBasicGroup (struct TdGetBasicGroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetBasicGroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetBasicGroup (struct TdGetBasicGroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetBasicGroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetBasicGroup (struct TdGetBasicGroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetBasicGroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetBasicGroup");
  M->new_field ("ID");
  M->pack_long (var->basic_group_id_);
  M->new_field ("basic_group_id_");
}
struct TdGetBasicGroup *TdStackFetcherGetBasicGroup (struct TdStackFetcherMethods *M) {
  auto res = new TdGetBasicGroup ();
  res->ID = CODE_GetBasicGroup;
  res->refcnt = 1;
  M->get_field ("basic_group_id_");
  res->basic_group_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetBasicGroupFullInfo *TdCreateObjectGetBasicGroupFullInfo (int basic_group_id_) {
  auto var = new struct TdGetBasicGroupFullInfo ();
  var->ID = CODE_GetBasicGroupFullInfo;
  var->refcnt = 1;
  var->basic_group_id_ = basic_group_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getBasicGroupFullInfo> TdConvertToInternal (struct TdGetBasicGroupFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->basic_group_id_;
  return td::td_api::make_object<td::td_api::getBasicGroupFullInfo>(std::move (v0));
}
struct TdGetBasicGroupFullInfo *TdConvertFromInternal (const td::td_api::getBasicGroupFullInfo &from) {
  auto res = new TdGetBasicGroupFullInfo ();
  res->ID = CODE_GetBasicGroupFullInfo;
  res->refcnt = 1;
  res->basic_group_id_ = from.basic_group_id_;
  return res;
}
char *TdSerializeGetBasicGroupFullInfo (struct TdGetBasicGroupFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetBasicGroupFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetBasicGroupFullInfo (struct TdGetBasicGroupFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetBasicGroupFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetBasicGroupFullInfo (struct TdGetBasicGroupFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetBasicGroupFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetBasicGroupFullInfo");
  M->new_field ("ID");
  M->pack_long (var->basic_group_id_);
  M->new_field ("basic_group_id_");
}
struct TdGetBasicGroupFullInfo *TdStackFetcherGetBasicGroupFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdGetBasicGroupFullInfo ();
  res->ID = CODE_GetBasicGroupFullInfo;
  res->refcnt = 1;
  M->get_field ("basic_group_id_");
  res->basic_group_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetBlockedUsers *TdCreateObjectGetBlockedUsers (int offset_, int limit_) {
  auto var = new struct TdGetBlockedUsers ();
  var->ID = CODE_GetBlockedUsers;
  var->refcnt = 1;
  var->offset_ = offset_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getBlockedUsers> TdConvertToInternal (struct TdGetBlockedUsers *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->offset_;
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::getBlockedUsers>(std::move (v0), std::move (v100));
}
struct TdGetBlockedUsers *TdConvertFromInternal (const td::td_api::getBlockedUsers &from) {
  auto res = new TdGetBlockedUsers ();
  res->ID = CODE_GetBlockedUsers;
  res->refcnt = 1;
  res->offset_ = from.offset_;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeGetBlockedUsers (struct TdGetBlockedUsers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetBlockedUsers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetBlockedUsers (struct TdGetBlockedUsers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetBlockedUsers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetBlockedUsers (struct TdGetBlockedUsers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetBlockedUsers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetBlockedUsers");
  M->new_field ("ID");
  M->pack_long (var->offset_);
  M->new_field ("offset_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdGetBlockedUsers *TdStackFetcherGetBlockedUsers (struct TdStackFetcherMethods *M) {
  auto res = new TdGetBlockedUsers ();
  res->ID = CODE_GetBlockedUsers;
  res->refcnt = 1;
  M->get_field ("offset_");
  res->offset_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetCallbackQueryAnswer *TdCreateObjectGetCallbackQueryAnswer (long long chat_id_, long long message_id_, struct TdCallbackQueryPayload *payload_) {
  auto var = new struct TdGetCallbackQueryAnswer ();
  var->ID = CODE_GetCallbackQueryAnswer;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->payload_ = payload_;
  return var;
}
td::td_api::object_ptr<td::td_api::getCallbackQueryAnswer> TdConvertToInternal (struct TdGetCallbackQueryAnswer *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  td::td_api::object_ptr<td::td_api::CallbackQueryPayload> v200;
  v200 = TdConvertToInternal (var->payload_);
  return td::td_api::make_object<td::td_api::getCallbackQueryAnswer>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGetCallbackQueryAnswer *TdConvertFromInternal (const td::td_api::getCallbackQueryAnswer &from) {
  auto res = new TdGetCallbackQueryAnswer ();
  res->ID = CODE_GetCallbackQueryAnswer;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  if (!from.payload_) {
    res->payload_ = nullptr;
  } else {
    res->payload_ = TdConvertFromInternal (static_cast<const td::td_api::CallbackQueryPayload &>(*from.payload_));
  }
  return res;
}
char *TdSerializeGetCallbackQueryAnswer (struct TdGetCallbackQueryAnswer *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetCallbackQueryAnswer *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetCallbackQueryAnswer (struct TdGetCallbackQueryAnswer *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetCallbackQueryAnswer *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->payload_);
  delete var;
}
void TdStackStorerGetCallbackQueryAnswer (struct TdGetCallbackQueryAnswer *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetCallbackQueryAnswer *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetCallbackQueryAnswer");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  TdStackStorer (var->payload_, M);
  M->new_field ("payload_");
}
struct TdGetCallbackQueryAnswer *TdStackFetcherGetCallbackQueryAnswer (struct TdStackFetcherMethods *M) {
  auto res = new TdGetCallbackQueryAnswer ();
  res->ID = CODE_GetCallbackQueryAnswer;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("payload_");
  if (M->is_nil ()) {
    res->payload_ = nullptr;
  } else {
    res->payload_ = TdStackFetcherCallbackQueryPayload (M);
  }
  M->pop ();
  return res;
}
struct TdGetChat *TdCreateObjectGetChat (long long chat_id_) {
  auto var = new struct TdGetChat ();
  var->ID = CODE_GetChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChat> TdConvertToInternal (struct TdGetChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::getChat>(std::move (v0));
}
struct TdGetChat *TdConvertFromInternal (const td::td_api::getChat &from) {
  auto res = new TdGetChat ();
  res->ID = CODE_GetChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeGetChat (struct TdGetChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChat (struct TdGetChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetChat (struct TdGetChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdGetChat *TdStackFetcherGetChat (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChat ();
  res->ID = CODE_GetChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetChatAdministrators *TdCreateObjectGetChatAdministrators (long long chat_id_) {
  auto var = new struct TdGetChatAdministrators ();
  var->ID = CODE_GetChatAdministrators;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChatAdministrators> TdConvertToInternal (struct TdGetChatAdministrators *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::getChatAdministrators>(std::move (v0));
}
struct TdGetChatAdministrators *TdConvertFromInternal (const td::td_api::getChatAdministrators &from) {
  auto res = new TdGetChatAdministrators ();
  res->ID = CODE_GetChatAdministrators;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeGetChatAdministrators (struct TdGetChatAdministrators *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChatAdministrators *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChatAdministrators (struct TdGetChatAdministrators *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChatAdministrators *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetChatAdministrators (struct TdGetChatAdministrators *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChatAdministrators *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChatAdministrators");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdGetChatAdministrators *TdStackFetcherGetChatAdministrators (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChatAdministrators ();
  res->ID = CODE_GetChatAdministrators;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetChatEventLog *TdCreateObjectGetChatEventLog (long long chat_id_, char *query_, long long from_event_id_, int limit_, struct TdChatEventLogFilters *filters_, struct TdVectorInt *user_ids_) {
  auto var = new struct TdGetChatEventLog ();
  var->ID = CODE_GetChatEventLog;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->from_event_id_ = from_event_id_;
  var->limit_ = limit_;
  var->filters_ = filters_;
  var->user_ids_ = user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChatEventLog> TdConvertToInternal (struct TdGetChatEventLog *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->query_) ? var->query_: "";
  std::int64_t v200;
  v200 = var->from_event_id_;
  std::int32_t v300;
  v300 = var->limit_;
  td::td_api::object_ptr<td::td_api::chatEventLogFilters> v400;
  v400 = TdConvertToInternal (var->filters_);
  std::vector<std::int32_t> v500;
  for (int i500 = 0; i500 < var->user_ids_->len; i500++) {
    std::int32_t v501;
    v501 = var->user_ids_->data[i500];
    v500.push_back (std::move (v501));
  }
  return td::td_api::make_object<td::td_api::getChatEventLog>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdGetChatEventLog *TdConvertFromInternal (const td::td_api::getChatEventLog &from) {
  auto res = new TdGetChatEventLog ();
  res->ID = CODE_GetChatEventLog;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->from_event_id_ = from.from_event_id_;
  res->limit_ = from.limit_;
  if (!from.filters_) {
    res->filters_ = nullptr;
  } else {
    res->filters_ = TdConvertFromInternal (static_cast<const td::td_api::chatEventLogFilters &>(*from.filters_));
  }
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = (int)from.user_ids_.size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i500 = 0; i500 < res->user_ids_->len; i500++) {
    res->user_ids_->data[i500] = from.user_ids_[i500];
  }
  return res;
}
char *TdSerializeGetChatEventLog (struct TdGetChatEventLog *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChatEventLog *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChatEventLog (struct TdGetChatEventLog *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChatEventLog *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  TdDestroyObject (var->filters_);
  for (int i500 = 0; i500 < var->user_ids_->len; i500++) {
  }
  delete[] var->user_ids_->data;
  delete var->user_ids_;
  delete var;
}
void TdStackStorerGetChatEventLog (struct TdGetChatEventLog *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChatEventLog *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChatEventLog");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->from_event_id_);
  M->new_field ("from_event_id_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
  TdStackStorer (var->filters_, M);
  M->new_field ("filters_");
  M->new_array ();
  for (int i500 = 0; i500 < var->user_ids_->len; i500++) {
    M->pack_long (var->user_ids_->data[i500]);
    M->new_arr_field (i500);
  }
  M->new_field ("user_ids_");
}
struct TdGetChatEventLog *TdStackFetcherGetChatEventLog (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChatEventLog ();
  res->ID = CODE_GetChatEventLog;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("from_event_id_");
  res->from_event_id_ = M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("filters_");
  if (M->is_nil ()) {
    res->filters_ = nullptr;
  } else {
    res->filters_ = TdStackFetcherChatEventLogFilters (M);
  }
  M->pop ();
  M->get_field ("user_ids_");
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = M->get_arr_size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i500 = 0; i500 < res->user_ids_->len; i500++) {
    M->get_arr_field (i500);
    res->user_ids_->data[i500] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdGetChatHistory *TdCreateObjectGetChatHistory (long long chat_id_, long long from_message_id_, int offset_, int limit_, int only_local_) {
  auto var = new struct TdGetChatHistory ();
  var->ID = CODE_GetChatHistory;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->from_message_id_ = from_message_id_;
  var->offset_ = offset_;
  var->limit_ = limit_;
  var->only_local_ = only_local_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChatHistory> TdConvertToInternal (struct TdGetChatHistory *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->from_message_id_;
  std::int32_t v200;
  v200 = var->offset_;
  std::int32_t v300;
  v300 = var->limit_;
  bool v400;
  v400 = var->only_local_ != 0;
  return td::td_api::make_object<td::td_api::getChatHistory>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdGetChatHistory *TdConvertFromInternal (const td::td_api::getChatHistory &from) {
  auto res = new TdGetChatHistory ();
  res->ID = CODE_GetChatHistory;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->from_message_id_ = from.from_message_id_;
  res->offset_ = from.offset_;
  res->limit_ = from.limit_;
  res->only_local_ = from.only_local_;
  return res;
}
char *TdSerializeGetChatHistory (struct TdGetChatHistory *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChatHistory *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChatHistory (struct TdGetChatHistory *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChatHistory *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetChatHistory (struct TdGetChatHistory *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChatHistory *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChatHistory");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->from_message_id_);
  M->new_field ("from_message_id_");
  M->pack_long (var->offset_);
  M->new_field ("offset_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
  M->pack_bool (var->only_local_);
  M->new_field ("only_local_");
}
struct TdGetChatHistory *TdStackFetcherGetChatHistory (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChatHistory ();
  res->ID = CODE_GetChatHistory;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("from_message_id_");
  res->from_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("offset_");
  res->offset_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("only_local_");
  res->only_local_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetChatMember *TdCreateObjectGetChatMember (long long chat_id_, int user_id_) {
  auto var = new struct TdGetChatMember ();
  var->ID = CODE_GetChatMember;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChatMember> TdConvertToInternal (struct TdGetChatMember *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->user_id_;
  return td::td_api::make_object<td::td_api::getChatMember>(std::move (v0), std::move (v100));
}
struct TdGetChatMember *TdConvertFromInternal (const td::td_api::getChatMember &from) {
  auto res = new TdGetChatMember ();
  res->ID = CODE_GetChatMember;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeGetChatMember (struct TdGetChatMember *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChatMember *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChatMember (struct TdGetChatMember *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChatMember *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetChatMember (struct TdGetChatMember *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChatMember *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChatMember");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdGetChatMember *TdStackFetcherGetChatMember (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChatMember ();
  res->ID = CODE_GetChatMember;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetChatMessageByDate *TdCreateObjectGetChatMessageByDate (long long chat_id_, int date_) {
  auto var = new struct TdGetChatMessageByDate ();
  var->ID = CODE_GetChatMessageByDate;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->date_ = date_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChatMessageByDate> TdConvertToInternal (struct TdGetChatMessageByDate *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->date_;
  return td::td_api::make_object<td::td_api::getChatMessageByDate>(std::move (v0), std::move (v100));
}
struct TdGetChatMessageByDate *TdConvertFromInternal (const td::td_api::getChatMessageByDate &from) {
  auto res = new TdGetChatMessageByDate ();
  res->ID = CODE_GetChatMessageByDate;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->date_ = from.date_;
  return res;
}
char *TdSerializeGetChatMessageByDate (struct TdGetChatMessageByDate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChatMessageByDate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChatMessageByDate (struct TdGetChatMessageByDate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChatMessageByDate *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetChatMessageByDate (struct TdGetChatMessageByDate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChatMessageByDate *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChatMessageByDate");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->date_);
  M->new_field ("date_");
}
struct TdGetChatMessageByDate *TdStackFetcherGetChatMessageByDate (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChatMessageByDate ();
  res->ID = CODE_GetChatMessageByDate;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("date_");
  res->date_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetChatMessageCount *TdCreateObjectGetChatMessageCount (long long chat_id_, struct TdSearchMessagesFilter *filter_, int return_local_) {
  auto var = new struct TdGetChatMessageCount ();
  var->ID = CODE_GetChatMessageCount;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->filter_ = filter_;
  var->return_local_ = return_local_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChatMessageCount> TdConvertToInternal (struct TdGetChatMessageCount *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::SearchMessagesFilter> v100;
  v100 = TdConvertToInternal (var->filter_);
  bool v200;
  v200 = var->return_local_ != 0;
  return td::td_api::make_object<td::td_api::getChatMessageCount>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGetChatMessageCount *TdConvertFromInternal (const td::td_api::getChatMessageCount &from) {
  auto res = new TdGetChatMessageCount ();
  res->ID = CODE_GetChatMessageCount;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.filter_) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdConvertFromInternal (static_cast<const td::td_api::SearchMessagesFilter &>(*from.filter_));
  }
  res->return_local_ = from.return_local_;
  return res;
}
char *TdSerializeGetChatMessageCount (struct TdGetChatMessageCount *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChatMessageCount *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChatMessageCount (struct TdGetChatMessageCount *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChatMessageCount *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->filter_);
  delete var;
}
void TdStackStorerGetChatMessageCount (struct TdGetChatMessageCount *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChatMessageCount *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChatMessageCount");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->filter_, M);
  M->new_field ("filter_");
  M->pack_bool (var->return_local_);
  M->new_field ("return_local_");
}
struct TdGetChatMessageCount *TdStackFetcherGetChatMessageCount (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChatMessageCount ();
  res->ID = CODE_GetChatMessageCount;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("filter_");
  if (M->is_nil ()) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdStackFetcherSearchMessagesFilter (M);
  }
  M->pop ();
  M->get_field ("return_local_");
  res->return_local_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetChatPinnedMessage *TdCreateObjectGetChatPinnedMessage (long long chat_id_) {
  auto var = new struct TdGetChatPinnedMessage ();
  var->ID = CODE_GetChatPinnedMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChatPinnedMessage> TdConvertToInternal (struct TdGetChatPinnedMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::getChatPinnedMessage>(std::move (v0));
}
struct TdGetChatPinnedMessage *TdConvertFromInternal (const td::td_api::getChatPinnedMessage &from) {
  auto res = new TdGetChatPinnedMessage ();
  res->ID = CODE_GetChatPinnedMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeGetChatPinnedMessage (struct TdGetChatPinnedMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChatPinnedMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChatPinnedMessage (struct TdGetChatPinnedMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChatPinnedMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetChatPinnedMessage (struct TdGetChatPinnedMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChatPinnedMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChatPinnedMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdGetChatPinnedMessage *TdStackFetcherGetChatPinnedMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChatPinnedMessage ();
  res->ID = CODE_GetChatPinnedMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetChatReportSpamState *TdCreateObjectGetChatReportSpamState (long long chat_id_) {
  auto var = new struct TdGetChatReportSpamState ();
  var->ID = CODE_GetChatReportSpamState;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChatReportSpamState> TdConvertToInternal (struct TdGetChatReportSpamState *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::getChatReportSpamState>(std::move (v0));
}
struct TdGetChatReportSpamState *TdConvertFromInternal (const td::td_api::getChatReportSpamState &from) {
  auto res = new TdGetChatReportSpamState ();
  res->ID = CODE_GetChatReportSpamState;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeGetChatReportSpamState (struct TdGetChatReportSpamState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChatReportSpamState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChatReportSpamState (struct TdGetChatReportSpamState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChatReportSpamState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetChatReportSpamState (struct TdGetChatReportSpamState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChatReportSpamState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChatReportSpamState");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdGetChatReportSpamState *TdStackFetcherGetChatReportSpamState (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChatReportSpamState ();
  res->ID = CODE_GetChatReportSpamState;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetChats *TdCreateObjectGetChats (long long offset_order_, long long offset_chat_id_, int limit_) {
  auto var = new struct TdGetChats ();
  var->ID = CODE_GetChats;
  var->refcnt = 1;
  var->offset_order_ = offset_order_;
  var->offset_chat_id_ = offset_chat_id_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getChats> TdConvertToInternal (struct TdGetChats *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->offset_order_;
  std::int64_t v100;
  v100 = var->offset_chat_id_;
  std::int32_t v200;
  v200 = var->limit_;
  return td::td_api::make_object<td::td_api::getChats>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGetChats *TdConvertFromInternal (const td::td_api::getChats &from) {
  auto res = new TdGetChats ();
  res->ID = CODE_GetChats;
  res->refcnt = 1;
  res->offset_order_ = from.offset_order_;
  res->offset_chat_id_ = from.offset_chat_id_;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeGetChats (struct TdGetChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetChats (struct TdGetChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetChats (struct TdGetChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetChats");
  M->new_field ("ID");
  M->pack_long (var->offset_order_);
  M->new_field ("offset_order_");
  M->pack_long (var->offset_chat_id_);
  M->new_field ("offset_chat_id_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdGetChats *TdStackFetcherGetChats (struct TdStackFetcherMethods *M) {
  auto res = new TdGetChats ();
  res->ID = CODE_GetChats;
  res->refcnt = 1;
  M->get_field ("offset_order_");
  res->offset_order_ = M->get_long ();
  M->pop ();
  M->get_field ("offset_chat_id_");
  res->offset_chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetConnectedWebsites *TdCreateObjectGetConnectedWebsites (void) {
  auto var = new struct TdGetConnectedWebsites ();
  var->ID = CODE_GetConnectedWebsites;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getConnectedWebsites> TdConvertToInternal (struct TdGetConnectedWebsites *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getConnectedWebsites>();
}
struct TdGetConnectedWebsites *TdConvertFromInternal (const td::td_api::getConnectedWebsites &from) {
  auto res = new TdGetConnectedWebsites ();
  res->ID = CODE_GetConnectedWebsites;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetConnectedWebsites (struct TdGetConnectedWebsites *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetConnectedWebsites *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetConnectedWebsites (struct TdGetConnectedWebsites *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetConnectedWebsites *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetConnectedWebsites (struct TdGetConnectedWebsites *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetConnectedWebsites *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetConnectedWebsites");
  M->new_field ("ID");
}
struct TdGetConnectedWebsites *TdStackFetcherGetConnectedWebsites (struct TdStackFetcherMethods *M) {
  auto res = new TdGetConnectedWebsites ();
  res->ID = CODE_GetConnectedWebsites;
  res->refcnt = 1;
  return res;
}
struct TdGetContacts *TdCreateObjectGetContacts (void) {
  auto var = new struct TdGetContacts ();
  var->ID = CODE_GetContacts;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getContacts> TdConvertToInternal (struct TdGetContacts *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getContacts>();
}
struct TdGetContacts *TdConvertFromInternal (const td::td_api::getContacts &from) {
  auto res = new TdGetContacts ();
  res->ID = CODE_GetContacts;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetContacts (struct TdGetContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetContacts (struct TdGetContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetContacts (struct TdGetContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetContacts");
  M->new_field ("ID");
}
struct TdGetContacts *TdStackFetcherGetContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdGetContacts ();
  res->ID = CODE_GetContacts;
  res->refcnt = 1;
  return res;
}
struct TdGetCountryCode *TdCreateObjectGetCountryCode (void) {
  auto var = new struct TdGetCountryCode ();
  var->ID = CODE_GetCountryCode;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getCountryCode> TdConvertToInternal (struct TdGetCountryCode *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getCountryCode>();
}
struct TdGetCountryCode *TdConvertFromInternal (const td::td_api::getCountryCode &from) {
  auto res = new TdGetCountryCode ();
  res->ID = CODE_GetCountryCode;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetCountryCode (struct TdGetCountryCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetCountryCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetCountryCode (struct TdGetCountryCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetCountryCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetCountryCode (struct TdGetCountryCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetCountryCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetCountryCode");
  M->new_field ("ID");
}
struct TdGetCountryCode *TdStackFetcherGetCountryCode (struct TdStackFetcherMethods *M) {
  auto res = new TdGetCountryCode ();
  res->ID = CODE_GetCountryCode;
  res->refcnt = 1;
  return res;
}
struct TdGetCreatedPublicChats *TdCreateObjectGetCreatedPublicChats (void) {
  auto var = new struct TdGetCreatedPublicChats ();
  var->ID = CODE_GetCreatedPublicChats;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getCreatedPublicChats> TdConvertToInternal (struct TdGetCreatedPublicChats *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getCreatedPublicChats>();
}
struct TdGetCreatedPublicChats *TdConvertFromInternal (const td::td_api::getCreatedPublicChats &from) {
  auto res = new TdGetCreatedPublicChats ();
  res->ID = CODE_GetCreatedPublicChats;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetCreatedPublicChats (struct TdGetCreatedPublicChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetCreatedPublicChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetCreatedPublicChats (struct TdGetCreatedPublicChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetCreatedPublicChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetCreatedPublicChats (struct TdGetCreatedPublicChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetCreatedPublicChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetCreatedPublicChats");
  M->new_field ("ID");
}
struct TdGetCreatedPublicChats *TdStackFetcherGetCreatedPublicChats (struct TdStackFetcherMethods *M) {
  auto res = new TdGetCreatedPublicChats ();
  res->ID = CODE_GetCreatedPublicChats;
  res->refcnt = 1;
  return res;
}
struct TdGetDeepLinkInfo *TdCreateObjectGetDeepLinkInfo (char *link_) {
  auto var = new struct TdGetDeepLinkInfo ();
  var->ID = CODE_GetDeepLinkInfo;
  var->refcnt = 1;
  var->link_ = (link_) ? td::str_dup (td::Slice (link_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getDeepLinkInfo> TdConvertToInternal (struct TdGetDeepLinkInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->link_) ? var->link_: "";
  return td::td_api::make_object<td::td_api::getDeepLinkInfo>(std::move (v0));
}
struct TdGetDeepLinkInfo *TdConvertFromInternal (const td::td_api::getDeepLinkInfo &from) {
  auto res = new TdGetDeepLinkInfo ();
  res->ID = CODE_GetDeepLinkInfo;
  res->refcnt = 1;
  res->link_ = (from.link_.length ()) ? td::str_dup (from.link_) : nullptr;
  return res;
}
char *TdSerializeGetDeepLinkInfo (struct TdGetDeepLinkInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetDeepLinkInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetDeepLinkInfo (struct TdGetDeepLinkInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetDeepLinkInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->link_);
  delete var;
}
void TdStackStorerGetDeepLinkInfo (struct TdGetDeepLinkInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetDeepLinkInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetDeepLinkInfo");
  M->new_field ("ID");
  M->pack_string (var->link_);
  M->new_field ("link_");
}
struct TdGetDeepLinkInfo *TdStackFetcherGetDeepLinkInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdGetDeepLinkInfo ();
  res->ID = CODE_GetDeepLinkInfo;
  res->refcnt = 1;
  M->get_field ("link_");
  res->link_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetFavoriteStickers *TdCreateObjectGetFavoriteStickers (void) {
  auto var = new struct TdGetFavoriteStickers ();
  var->ID = CODE_GetFavoriteStickers;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getFavoriteStickers> TdConvertToInternal (struct TdGetFavoriteStickers *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getFavoriteStickers>();
}
struct TdGetFavoriteStickers *TdConvertFromInternal (const td::td_api::getFavoriteStickers &from) {
  auto res = new TdGetFavoriteStickers ();
  res->ID = CODE_GetFavoriteStickers;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetFavoriteStickers (struct TdGetFavoriteStickers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetFavoriteStickers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetFavoriteStickers (struct TdGetFavoriteStickers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetFavoriteStickers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetFavoriteStickers (struct TdGetFavoriteStickers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetFavoriteStickers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetFavoriteStickers");
  M->new_field ("ID");
}
struct TdGetFavoriteStickers *TdStackFetcherGetFavoriteStickers (struct TdStackFetcherMethods *M) {
  auto res = new TdGetFavoriteStickers ();
  res->ID = CODE_GetFavoriteStickers;
  res->refcnt = 1;
  return res;
}
struct TdGetFile *TdCreateObjectGetFile (int file_id_) {
  auto var = new struct TdGetFile ();
  var->ID = CODE_GetFile;
  var->refcnt = 1;
  var->file_id_ = file_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getFile> TdConvertToInternal (struct TdGetFile *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->file_id_;
  return td::td_api::make_object<td::td_api::getFile>(std::move (v0));
}
struct TdGetFile *TdConvertFromInternal (const td::td_api::getFile &from) {
  auto res = new TdGetFile ();
  res->ID = CODE_GetFile;
  res->refcnt = 1;
  res->file_id_ = from.file_id_;
  return res;
}
char *TdSerializeGetFile (struct TdGetFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetFile (struct TdGetFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetFile (struct TdGetFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetFile");
  M->new_field ("ID");
  M->pack_long (var->file_id_);
  M->new_field ("file_id_");
}
struct TdGetFile *TdStackFetcherGetFile (struct TdStackFetcherMethods *M) {
  auto res = new TdGetFile ();
  res->ID = CODE_GetFile;
  res->refcnt = 1;
  M->get_field ("file_id_");
  res->file_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetFileExtension *TdCreateObjectGetFileExtension (char *mime_type_) {
  auto var = new struct TdGetFileExtension ();
  var->ID = CODE_GetFileExtension;
  var->refcnt = 1;
  var->mime_type_ = (mime_type_) ? td::str_dup (td::Slice (mime_type_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getFileExtension> TdConvertToInternal (struct TdGetFileExtension *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->mime_type_) ? var->mime_type_: "";
  return td::td_api::make_object<td::td_api::getFileExtension>(std::move (v0));
}
struct TdGetFileExtension *TdConvertFromInternal (const td::td_api::getFileExtension &from) {
  auto res = new TdGetFileExtension ();
  res->ID = CODE_GetFileExtension;
  res->refcnt = 1;
  res->mime_type_ = (from.mime_type_.length ()) ? td::str_dup (from.mime_type_) : nullptr;
  return res;
}
char *TdSerializeGetFileExtension (struct TdGetFileExtension *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetFileExtension *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetFileExtension (struct TdGetFileExtension *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetFileExtension *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->mime_type_);
  delete var;
}
void TdStackStorerGetFileExtension (struct TdGetFileExtension *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetFileExtension *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetFileExtension");
  M->new_field ("ID");
  M->pack_string (var->mime_type_);
  M->new_field ("mime_type_");
}
struct TdGetFileExtension *TdStackFetcherGetFileExtension (struct TdStackFetcherMethods *M) {
  auto res = new TdGetFileExtension ();
  res->ID = CODE_GetFileExtension;
  res->refcnt = 1;
  M->get_field ("mime_type_");
  res->mime_type_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetFileMimeType *TdCreateObjectGetFileMimeType (char *file_name_) {
  auto var = new struct TdGetFileMimeType ();
  var->ID = CODE_GetFileMimeType;
  var->refcnt = 1;
  var->file_name_ = (file_name_) ? td::str_dup (td::Slice (file_name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getFileMimeType> TdConvertToInternal (struct TdGetFileMimeType *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->file_name_) ? var->file_name_: "";
  return td::td_api::make_object<td::td_api::getFileMimeType>(std::move (v0));
}
struct TdGetFileMimeType *TdConvertFromInternal (const td::td_api::getFileMimeType &from) {
  auto res = new TdGetFileMimeType ();
  res->ID = CODE_GetFileMimeType;
  res->refcnt = 1;
  res->file_name_ = (from.file_name_.length ()) ? td::str_dup (from.file_name_) : nullptr;
  return res;
}
char *TdSerializeGetFileMimeType (struct TdGetFileMimeType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetFileMimeType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetFileMimeType (struct TdGetFileMimeType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetFileMimeType *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->file_name_);
  delete var;
}
void TdStackStorerGetFileMimeType (struct TdGetFileMimeType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetFileMimeType *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetFileMimeType");
  M->new_field ("ID");
  M->pack_string (var->file_name_);
  M->new_field ("file_name_");
}
struct TdGetFileMimeType *TdStackFetcherGetFileMimeType (struct TdStackFetcherMethods *M) {
  auto res = new TdGetFileMimeType ();
  res->ID = CODE_GetFileMimeType;
  res->refcnt = 1;
  M->get_field ("file_name_");
  res->file_name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetGameHighScores *TdCreateObjectGetGameHighScores (long long chat_id_, long long message_id_, int user_id_) {
  auto var = new struct TdGetGameHighScores ();
  var->ID = CODE_GetGameHighScores;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getGameHighScores> TdConvertToInternal (struct TdGetGameHighScores *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  std::int32_t v200;
  v200 = var->user_id_;
  return td::td_api::make_object<td::td_api::getGameHighScores>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGetGameHighScores *TdConvertFromInternal (const td::td_api::getGameHighScores &from) {
  auto res = new TdGetGameHighScores ();
  res->ID = CODE_GetGameHighScores;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeGetGameHighScores (struct TdGetGameHighScores *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetGameHighScores *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetGameHighScores (struct TdGetGameHighScores *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetGameHighScores *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetGameHighScores (struct TdGetGameHighScores *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetGameHighScores *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetGameHighScores");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdGetGameHighScores *TdStackFetcherGetGameHighScores (struct TdStackFetcherMethods *M) {
  auto res = new TdGetGameHighScores ();
  res->ID = CODE_GetGameHighScores;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetGroupsInCommon *TdCreateObjectGetGroupsInCommon (int user_id_, long long offset_chat_id_, int limit_) {
  auto var = new struct TdGetGroupsInCommon ();
  var->ID = CODE_GetGroupsInCommon;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->offset_chat_id_ = offset_chat_id_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getGroupsInCommon> TdConvertToInternal (struct TdGetGroupsInCommon *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  std::int64_t v100;
  v100 = var->offset_chat_id_;
  std::int32_t v200;
  v200 = var->limit_;
  return td::td_api::make_object<td::td_api::getGroupsInCommon>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGetGroupsInCommon *TdConvertFromInternal (const td::td_api::getGroupsInCommon &from) {
  auto res = new TdGetGroupsInCommon ();
  res->ID = CODE_GetGroupsInCommon;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  res->offset_chat_id_ = from.offset_chat_id_;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeGetGroupsInCommon (struct TdGetGroupsInCommon *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetGroupsInCommon *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetGroupsInCommon (struct TdGetGroupsInCommon *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetGroupsInCommon *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetGroupsInCommon (struct TdGetGroupsInCommon *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetGroupsInCommon *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetGroupsInCommon");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_long (var->offset_chat_id_);
  M->new_field ("offset_chat_id_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdGetGroupsInCommon *TdStackFetcherGetGroupsInCommon (struct TdStackFetcherMethods *M) {
  auto res = new TdGetGroupsInCommon ();
  res->ID = CODE_GetGroupsInCommon;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("offset_chat_id_");
  res->offset_chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetImportedContactCount *TdCreateObjectGetImportedContactCount (void) {
  auto var = new struct TdGetImportedContactCount ();
  var->ID = CODE_GetImportedContactCount;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getImportedContactCount> TdConvertToInternal (struct TdGetImportedContactCount *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getImportedContactCount>();
}
struct TdGetImportedContactCount *TdConvertFromInternal (const td::td_api::getImportedContactCount &from) {
  auto res = new TdGetImportedContactCount ();
  res->ID = CODE_GetImportedContactCount;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetImportedContactCount (struct TdGetImportedContactCount *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetImportedContactCount *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetImportedContactCount (struct TdGetImportedContactCount *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetImportedContactCount *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetImportedContactCount (struct TdGetImportedContactCount *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetImportedContactCount *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetImportedContactCount");
  M->new_field ("ID");
}
struct TdGetImportedContactCount *TdStackFetcherGetImportedContactCount (struct TdStackFetcherMethods *M) {
  auto res = new TdGetImportedContactCount ();
  res->ID = CODE_GetImportedContactCount;
  res->refcnt = 1;
  return res;
}
struct TdGetInlineGameHighScores *TdCreateObjectGetInlineGameHighScores (char *inline_message_id_, int user_id_) {
  auto var = new struct TdGetInlineGameHighScores ();
  var->ID = CODE_GetInlineGameHighScores;
  var->refcnt = 1;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getInlineGameHighScores> TdConvertToInternal (struct TdGetInlineGameHighScores *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->inline_message_id_) ? var->inline_message_id_: "";
  std::int32_t v100;
  v100 = var->user_id_;
  return td::td_api::make_object<td::td_api::getInlineGameHighScores>(std::move (v0), std::move (v100));
}
struct TdGetInlineGameHighScores *TdConvertFromInternal (const td::td_api::getInlineGameHighScores &from) {
  auto res = new TdGetInlineGameHighScores ();
  res->ID = CODE_GetInlineGameHighScores;
  res->refcnt = 1;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeGetInlineGameHighScores (struct TdGetInlineGameHighScores *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetInlineGameHighScores *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetInlineGameHighScores (struct TdGetInlineGameHighScores *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetInlineGameHighScores *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_message_id_);
  delete var;
}
void TdStackStorerGetInlineGameHighScores (struct TdGetInlineGameHighScores *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetInlineGameHighScores *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetInlineGameHighScores");
  M->new_field ("ID");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdGetInlineGameHighScores *TdStackFetcherGetInlineGameHighScores (struct TdStackFetcherMethods *M) {
  auto res = new TdGetInlineGameHighScores ();
  res->ID = CODE_GetInlineGameHighScores;
  res->refcnt = 1;
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetInlineQueryResults *TdCreateObjectGetInlineQueryResults (int bot_user_id_, long long chat_id_, struct TdLocation *user_location_, char *query_, char *offset_) {
  auto var = new struct TdGetInlineQueryResults ();
  var->ID = CODE_GetInlineQueryResults;
  var->refcnt = 1;
  var->bot_user_id_ = bot_user_id_;
  var->chat_id_ = chat_id_;
  var->user_location_ = user_location_;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->offset_ = (offset_) ? td::str_dup (td::Slice (offset_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getInlineQueryResults> TdConvertToInternal (struct TdGetInlineQueryResults *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->bot_user_id_;
  std::int64_t v100;
  v100 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::location> v200;
  v200 = TdConvertToInternal (var->user_location_);
  std::string v300;
  v300 = (var->query_) ? var->query_: "";
  std::string v400;
  v400 = (var->offset_) ? var->offset_: "";
  return td::td_api::make_object<td::td_api::getInlineQueryResults>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdGetInlineQueryResults *TdConvertFromInternal (const td::td_api::getInlineQueryResults &from) {
  auto res = new TdGetInlineQueryResults ();
  res->ID = CODE_GetInlineQueryResults;
  res->refcnt = 1;
  res->bot_user_id_ = from.bot_user_id_;
  res->chat_id_ = from.chat_id_;
  if (!from.user_location_) {
    res->user_location_ = nullptr;
  } else {
    res->user_location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.user_location_));
  }
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->offset_ = (from.offset_.length ()) ? td::str_dup (from.offset_) : nullptr;
  return res;
}
char *TdSerializeGetInlineQueryResults (struct TdGetInlineQueryResults *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetInlineQueryResults *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetInlineQueryResults (struct TdGetInlineQueryResults *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetInlineQueryResults *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->user_location_);
  free (var->query_);
  free (var->offset_);
  delete var;
}
void TdStackStorerGetInlineQueryResults (struct TdGetInlineQueryResults *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetInlineQueryResults *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetInlineQueryResults");
  M->new_field ("ID");
  M->pack_long (var->bot_user_id_);
  M->new_field ("bot_user_id_");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->user_location_, M);
  M->new_field ("user_location_");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_string (var->offset_);
  M->new_field ("offset_");
}
struct TdGetInlineQueryResults *TdStackFetcherGetInlineQueryResults (struct TdStackFetcherMethods *M) {
  auto res = new TdGetInlineQueryResults ();
  res->ID = CODE_GetInlineQueryResults;
  res->refcnt = 1;
  M->get_field ("bot_user_id_");
  res->bot_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("user_location_");
  if (M->is_nil ()) {
    res->user_location_ = nullptr;
  } else {
    res->user_location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("offset_");
  res->offset_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetInstalledStickerSets *TdCreateObjectGetInstalledStickerSets (int is_masks_) {
  auto var = new struct TdGetInstalledStickerSets ();
  var->ID = CODE_GetInstalledStickerSets;
  var->refcnt = 1;
  var->is_masks_ = is_masks_;
  return var;
}
td::td_api::object_ptr<td::td_api::getInstalledStickerSets> TdConvertToInternal (struct TdGetInstalledStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_masks_ != 0;
  return td::td_api::make_object<td::td_api::getInstalledStickerSets>(std::move (v0));
}
struct TdGetInstalledStickerSets *TdConvertFromInternal (const td::td_api::getInstalledStickerSets &from) {
  auto res = new TdGetInstalledStickerSets ();
  res->ID = CODE_GetInstalledStickerSets;
  res->refcnt = 1;
  res->is_masks_ = from.is_masks_;
  return res;
}
char *TdSerializeGetInstalledStickerSets (struct TdGetInstalledStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetInstalledStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetInstalledStickerSets (struct TdGetInstalledStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetInstalledStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetInstalledStickerSets (struct TdGetInstalledStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetInstalledStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetInstalledStickerSets");
  M->new_field ("ID");
  M->pack_bool (var->is_masks_);
  M->new_field ("is_masks_");
}
struct TdGetInstalledStickerSets *TdStackFetcherGetInstalledStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdGetInstalledStickerSets ();
  res->ID = CODE_GetInstalledStickerSets;
  res->refcnt = 1;
  M->get_field ("is_masks_");
  res->is_masks_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetInviteText *TdCreateObjectGetInviteText (void) {
  auto var = new struct TdGetInviteText ();
  var->ID = CODE_GetInviteText;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getInviteText> TdConvertToInternal (struct TdGetInviteText *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getInviteText>();
}
struct TdGetInviteText *TdConvertFromInternal (const td::td_api::getInviteText &from) {
  auto res = new TdGetInviteText ();
  res->ID = CODE_GetInviteText;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetInviteText (struct TdGetInviteText *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetInviteText *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetInviteText (struct TdGetInviteText *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetInviteText *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetInviteText (struct TdGetInviteText *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetInviteText *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetInviteText");
  M->new_field ("ID");
}
struct TdGetInviteText *TdStackFetcherGetInviteText (struct TdStackFetcherMethods *M) {
  auto res = new TdGetInviteText ();
  res->ID = CODE_GetInviteText;
  res->refcnt = 1;
  return res;
}
struct TdGetLanguagePackString *TdCreateObjectGetLanguagePackString (char *language_pack_database_path_, char *localization_target_, char *language_pack_id_, char *key_) {
  auto var = new struct TdGetLanguagePackString ();
  var->ID = CODE_GetLanguagePackString;
  var->refcnt = 1;
  var->language_pack_database_path_ = (language_pack_database_path_) ? td::str_dup (td::Slice (language_pack_database_path_)) : nullptr;
  var->localization_target_ = (localization_target_) ? td::str_dup (td::Slice (localization_target_)) : nullptr;
  var->language_pack_id_ = (language_pack_id_) ? td::str_dup (td::Slice (language_pack_id_)) : nullptr;
  var->key_ = (key_) ? td::str_dup (td::Slice (key_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getLanguagePackString> TdConvertToInternal (struct TdGetLanguagePackString *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->language_pack_database_path_) ? var->language_pack_database_path_: "";
  std::string v100;
  v100 = (var->localization_target_) ? var->localization_target_: "";
  std::string v200;
  v200 = (var->language_pack_id_) ? var->language_pack_id_: "";
  std::string v300;
  v300 = (var->key_) ? var->key_: "";
  return td::td_api::make_object<td::td_api::getLanguagePackString>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdGetLanguagePackString *TdConvertFromInternal (const td::td_api::getLanguagePackString &from) {
  auto res = new TdGetLanguagePackString ();
  res->ID = CODE_GetLanguagePackString;
  res->refcnt = 1;
  res->language_pack_database_path_ = (from.language_pack_database_path_.length ()) ? td::str_dup (from.language_pack_database_path_) : nullptr;
  res->localization_target_ = (from.localization_target_.length ()) ? td::str_dup (from.localization_target_) : nullptr;
  res->language_pack_id_ = (from.language_pack_id_.length ()) ? td::str_dup (from.language_pack_id_) : nullptr;
  res->key_ = (from.key_.length ()) ? td::str_dup (from.key_) : nullptr;
  return res;
}
char *TdSerializeGetLanguagePackString (struct TdGetLanguagePackString *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetLanguagePackString *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetLanguagePackString (struct TdGetLanguagePackString *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetLanguagePackString *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->language_pack_database_path_);
  free (var->localization_target_);
  free (var->language_pack_id_);
  free (var->key_);
  delete var;
}
void TdStackStorerGetLanguagePackString (struct TdGetLanguagePackString *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetLanguagePackString *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetLanguagePackString");
  M->new_field ("ID");
  M->pack_string (var->language_pack_database_path_);
  M->new_field ("language_pack_database_path_");
  M->pack_string (var->localization_target_);
  M->new_field ("localization_target_");
  M->pack_string (var->language_pack_id_);
  M->new_field ("language_pack_id_");
  M->pack_string (var->key_);
  M->new_field ("key_");
}
struct TdGetLanguagePackString *TdStackFetcherGetLanguagePackString (struct TdStackFetcherMethods *M) {
  auto res = new TdGetLanguagePackString ();
  res->ID = CODE_GetLanguagePackString;
  res->refcnt = 1;
  M->get_field ("language_pack_database_path_");
  res->language_pack_database_path_ = M->get_string ();
  M->pop ();
  M->get_field ("localization_target_");
  res->localization_target_ = M->get_string ();
  M->pop ();
  M->get_field ("language_pack_id_");
  res->language_pack_id_ = M->get_string ();
  M->pop ();
  M->get_field ("key_");
  res->key_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetLanguagePackStrings *TdCreateObjectGetLanguagePackStrings (char *language_pack_id_, struct TdVectorString *keys_) {
  auto var = new struct TdGetLanguagePackStrings ();
  var->ID = CODE_GetLanguagePackStrings;
  var->refcnt = 1;
  var->language_pack_id_ = (language_pack_id_) ? td::str_dup (td::Slice (language_pack_id_)) : nullptr;
  var->keys_ = keys_;
  return var;
}
td::td_api::object_ptr<td::td_api::getLanguagePackStrings> TdConvertToInternal (struct TdGetLanguagePackStrings *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->language_pack_id_) ? var->language_pack_id_: "";
  std::vector<std::string> v100;
  for (int i100 = 0; i100 < var->keys_->len; i100++) {
    std::string v101;
    v101 = (var->keys_->data[i100]) ? var->keys_->data[i100]: "";
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::getLanguagePackStrings>(std::move (v0), std::move (v100));
}
struct TdGetLanguagePackStrings *TdConvertFromInternal (const td::td_api::getLanguagePackStrings &from) {
  auto res = new TdGetLanguagePackStrings ();
  res->ID = CODE_GetLanguagePackStrings;
  res->refcnt = 1;
  res->language_pack_id_ = (from.language_pack_id_.length ()) ? td::str_dup (from.language_pack_id_) : nullptr;
  res->keys_ = new TdVectorString ();
  res->keys_->len = (int)from.keys_.size ();
  res->keys_->data = new char * [res->keys_->len];
  for (int i100 = 0; i100 < res->keys_->len; i100++) {
    res->keys_->data[i100] = (from.keys_[i100].length ()) ? td::str_dup (from.keys_[i100]) : nullptr;
  }
  return res;
}
char *TdSerializeGetLanguagePackStrings (struct TdGetLanguagePackStrings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetLanguagePackStrings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetLanguagePackStrings (struct TdGetLanguagePackStrings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetLanguagePackStrings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->language_pack_id_);
  for (int i100 = 0; i100 < var->keys_->len; i100++) {
    free (var->keys_->data[i100]);
  }
  delete[] var->keys_->data;
  delete var->keys_;
  delete var;
}
void TdStackStorerGetLanguagePackStrings (struct TdGetLanguagePackStrings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetLanguagePackStrings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetLanguagePackStrings");
  M->new_field ("ID");
  M->pack_string (var->language_pack_id_);
  M->new_field ("language_pack_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->keys_->len; i100++) {
    M->pack_string (var->keys_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("keys_");
}
struct TdGetLanguagePackStrings *TdStackFetcherGetLanguagePackStrings (struct TdStackFetcherMethods *M) {
  auto res = new TdGetLanguagePackStrings ();
  res->ID = CODE_GetLanguagePackStrings;
  res->refcnt = 1;
  M->get_field ("language_pack_id_");
  res->language_pack_id_ = M->get_string ();
  M->pop ();
  M->get_field ("keys_");
  res->keys_ = new TdVectorString ();
  res->keys_->len = M->get_arr_size ();
  res->keys_->data = new char * [res->keys_->len];
  for (int i100 = 0; i100 < res->keys_->len; i100++) {
    M->get_arr_field (i100);
    res->keys_->data[i100] = M->get_string ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdGetLocalizationTargetInfo *TdCreateObjectGetLocalizationTargetInfo (int only_local_) {
  auto var = new struct TdGetLocalizationTargetInfo ();
  var->ID = CODE_GetLocalizationTargetInfo;
  var->refcnt = 1;
  var->only_local_ = only_local_;
  return var;
}
td::td_api::object_ptr<td::td_api::getLocalizationTargetInfo> TdConvertToInternal (struct TdGetLocalizationTargetInfo *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->only_local_ != 0;
  return td::td_api::make_object<td::td_api::getLocalizationTargetInfo>(std::move (v0));
}
struct TdGetLocalizationTargetInfo *TdConvertFromInternal (const td::td_api::getLocalizationTargetInfo &from) {
  auto res = new TdGetLocalizationTargetInfo ();
  res->ID = CODE_GetLocalizationTargetInfo;
  res->refcnt = 1;
  res->only_local_ = from.only_local_;
  return res;
}
char *TdSerializeGetLocalizationTargetInfo (struct TdGetLocalizationTargetInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetLocalizationTargetInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetLocalizationTargetInfo (struct TdGetLocalizationTargetInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetLocalizationTargetInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetLocalizationTargetInfo (struct TdGetLocalizationTargetInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetLocalizationTargetInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetLocalizationTargetInfo");
  M->new_field ("ID");
  M->pack_bool (var->only_local_);
  M->new_field ("only_local_");
}
struct TdGetLocalizationTargetInfo *TdStackFetcherGetLocalizationTargetInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdGetLocalizationTargetInfo ();
  res->ID = CODE_GetLocalizationTargetInfo;
  res->refcnt = 1;
  M->get_field ("only_local_");
  res->only_local_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetMapThumbnailFile *TdCreateObjectGetMapThumbnailFile (struct TdLocation *location_, int zoom_, int width_, int height_, int scale_, long long chat_id_) {
  auto var = new struct TdGetMapThumbnailFile ();
  var->ID = CODE_GetMapThumbnailFile;
  var->refcnt = 1;
  var->location_ = location_;
  var->zoom_ = zoom_;
  var->width_ = width_;
  var->height_ = height_;
  var->scale_ = scale_;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getMapThumbnailFile> TdConvertToInternal (struct TdGetMapThumbnailFile *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::location> v0;
  v0 = TdConvertToInternal (var->location_);
  std::int32_t v100;
  v100 = var->zoom_;
  std::int32_t v200;
  v200 = var->width_;
  std::int32_t v300;
  v300 = var->height_;
  std::int32_t v400;
  v400 = var->scale_;
  std::int64_t v500;
  v500 = var->chat_id_;
  return td::td_api::make_object<td::td_api::getMapThumbnailFile>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdGetMapThumbnailFile *TdConvertFromInternal (const td::td_api::getMapThumbnailFile &from) {
  auto res = new TdGetMapThumbnailFile ();
  res->ID = CODE_GetMapThumbnailFile;
  res->refcnt = 1;
  if (!from.location_) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdConvertFromInternal (static_cast<const td::td_api::location &>(*from.location_));
  }
  res->zoom_ = from.zoom_;
  res->width_ = from.width_;
  res->height_ = from.height_;
  res->scale_ = from.scale_;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeGetMapThumbnailFile (struct TdGetMapThumbnailFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetMapThumbnailFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetMapThumbnailFile (struct TdGetMapThumbnailFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetMapThumbnailFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->location_);
  delete var;
}
void TdStackStorerGetMapThumbnailFile (struct TdGetMapThumbnailFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetMapThumbnailFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetMapThumbnailFile");
  M->new_field ("ID");
  TdStackStorer (var->location_, M);
  M->new_field ("location_");
  M->pack_long (var->zoom_);
  M->new_field ("zoom_");
  M->pack_long (var->width_);
  M->new_field ("width_");
  M->pack_long (var->height_);
  M->new_field ("height_");
  M->pack_long (var->scale_);
  M->new_field ("scale_");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdGetMapThumbnailFile *TdStackFetcherGetMapThumbnailFile (struct TdStackFetcherMethods *M) {
  auto res = new TdGetMapThumbnailFile ();
  res->ID = CODE_GetMapThumbnailFile;
  res->refcnt = 1;
  M->get_field ("location_");
  if (M->is_nil ()) {
    res->location_ = nullptr;
  } else {
    res->location_ = TdStackFetcherLocation (M);
  }
  M->pop ();
  M->get_field ("zoom_");
  res->zoom_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("width_");
  res->width_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("height_");
  res->height_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("scale_");
  res->scale_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetMe *TdCreateObjectGetMe (void) {
  auto var = new struct TdGetMe ();
  var->ID = CODE_GetMe;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getMe> TdConvertToInternal (struct TdGetMe *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getMe>();
}
struct TdGetMe *TdConvertFromInternal (const td::td_api::getMe &from) {
  auto res = new TdGetMe ();
  res->ID = CODE_GetMe;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetMe (struct TdGetMe *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetMe *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetMe (struct TdGetMe *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetMe *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetMe (struct TdGetMe *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetMe *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetMe");
  M->new_field ("ID");
}
struct TdGetMe *TdStackFetcherGetMe (struct TdStackFetcherMethods *M) {
  auto res = new TdGetMe ();
  res->ID = CODE_GetMe;
  res->refcnt = 1;
  return res;
}
struct TdGetMessage *TdCreateObjectGetMessage (long long chat_id_, long long message_id_) {
  auto var = new struct TdGetMessage ();
  var->ID = CODE_GetMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getMessage> TdConvertToInternal (struct TdGetMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  return td::td_api::make_object<td::td_api::getMessage>(std::move (v0), std::move (v100));
}
struct TdGetMessage *TdConvertFromInternal (const td::td_api::getMessage &from) {
  auto res = new TdGetMessage ();
  res->ID = CODE_GetMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeGetMessage (struct TdGetMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetMessage (struct TdGetMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetMessage (struct TdGetMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdGetMessage *TdStackFetcherGetMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdGetMessage ();
  res->ID = CODE_GetMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetMessages *TdCreateObjectGetMessages (long long chat_id_, struct TdVectorLong *message_ids_) {
  auto var = new struct TdGetMessages ();
  var->ID = CODE_GetMessages;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_ids_ = message_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::getMessages> TdConvertToInternal (struct TdGetMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::vector<std::int64_t> v100;
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
    std::int64_t v101;
    v101 = var->message_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::getMessages>(std::move (v0), std::move (v100));
}
struct TdGetMessages *TdConvertFromInternal (const td::td_api::getMessages &from) {
  auto res = new TdGetMessages ();
  res->ID = CODE_GetMessages;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = (int)from.message_ids_.size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i100 = 0; i100 < res->message_ids_->len; i100++) {
    res->message_ids_->data[i100] = from.message_ids_[i100];
  }
  return res;
}
char *TdSerializeGetMessages (struct TdGetMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetMessages (struct TdGetMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
  }
  delete[] var->message_ids_->data;
  delete var->message_ids_;
  delete var;
}
void TdStackStorerGetMessages (struct TdGetMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetMessages");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
    M->pack_long (var->message_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("message_ids_");
}
struct TdGetMessages *TdStackFetcherGetMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdGetMessages ();
  res->ID = CODE_GetMessages;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_ids_");
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = M->get_arr_size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i100 = 0; i100 < res->message_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->message_ids_->data[i100] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdGetNetworkStatistics *TdCreateObjectGetNetworkStatistics (int only_current_) {
  auto var = new struct TdGetNetworkStatistics ();
  var->ID = CODE_GetNetworkStatistics;
  var->refcnt = 1;
  var->only_current_ = only_current_;
  return var;
}
td::td_api::object_ptr<td::td_api::getNetworkStatistics> TdConvertToInternal (struct TdGetNetworkStatistics *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->only_current_ != 0;
  return td::td_api::make_object<td::td_api::getNetworkStatistics>(std::move (v0));
}
struct TdGetNetworkStatistics *TdConvertFromInternal (const td::td_api::getNetworkStatistics &from) {
  auto res = new TdGetNetworkStatistics ();
  res->ID = CODE_GetNetworkStatistics;
  res->refcnt = 1;
  res->only_current_ = from.only_current_;
  return res;
}
char *TdSerializeGetNetworkStatistics (struct TdGetNetworkStatistics *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetNetworkStatistics *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetNetworkStatistics (struct TdGetNetworkStatistics *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetNetworkStatistics *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetNetworkStatistics (struct TdGetNetworkStatistics *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetNetworkStatistics *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetNetworkStatistics");
  M->new_field ("ID");
  M->pack_bool (var->only_current_);
  M->new_field ("only_current_");
}
struct TdGetNetworkStatistics *TdStackFetcherGetNetworkStatistics (struct TdStackFetcherMethods *M) {
  auto res = new TdGetNetworkStatistics ();
  res->ID = CODE_GetNetworkStatistics;
  res->refcnt = 1;
  M->get_field ("only_current_");
  res->only_current_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetOption *TdCreateObjectGetOption (char *name_) {
  auto var = new struct TdGetOption ();
  var->ID = CODE_GetOption;
  var->refcnt = 1;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getOption> TdConvertToInternal (struct TdGetOption *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->name_) ? var->name_: "";
  return td::td_api::make_object<td::td_api::getOption>(std::move (v0));
}
struct TdGetOption *TdConvertFromInternal (const td::td_api::getOption &from) {
  auto res = new TdGetOption ();
  res->ID = CODE_GetOption;
  res->refcnt = 1;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  return res;
}
char *TdSerializeGetOption (struct TdGetOption *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetOption *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetOption (struct TdGetOption *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetOption *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->name_);
  delete var;
}
void TdStackStorerGetOption (struct TdGetOption *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetOption *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetOption");
  M->new_field ("ID");
  M->pack_string (var->name_);
  M->new_field ("name_");
}
struct TdGetOption *TdStackFetcherGetOption (struct TdStackFetcherMethods *M) {
  auto res = new TdGetOption ();
  res->ID = CODE_GetOption;
  res->refcnt = 1;
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetPassportAuthorizationForm *TdCreateObjectGetPassportAuthorizationForm (int bot_user_id_, char *scope_, char *public_key_, char *nonce_, char *password_) {
  auto var = new struct TdGetPassportAuthorizationForm ();
  var->ID = CODE_GetPassportAuthorizationForm;
  var->refcnt = 1;
  var->bot_user_id_ = bot_user_id_;
  var->scope_ = (scope_) ? td::str_dup (td::Slice (scope_)) : nullptr;
  var->public_key_ = (public_key_) ? td::str_dup (td::Slice (public_key_)) : nullptr;
  var->nonce_ = (nonce_) ? td::str_dup (td::Slice (nonce_)) : nullptr;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getPassportAuthorizationForm> TdConvertToInternal (struct TdGetPassportAuthorizationForm *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->bot_user_id_;
  std::string v100;
  v100 = (var->scope_) ? var->scope_: "";
  std::string v200;
  v200 = (var->public_key_) ? var->public_key_: "";
  std::string v300;
  v300 = (var->nonce_) ? var->nonce_: "";
  std::string v400;
  v400 = (var->password_) ? var->password_: "";
  return td::td_api::make_object<td::td_api::getPassportAuthorizationForm>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdGetPassportAuthorizationForm *TdConvertFromInternal (const td::td_api::getPassportAuthorizationForm &from) {
  auto res = new TdGetPassportAuthorizationForm ();
  res->ID = CODE_GetPassportAuthorizationForm;
  res->refcnt = 1;
  res->bot_user_id_ = from.bot_user_id_;
  res->scope_ = (from.scope_.length ()) ? td::str_dup (from.scope_) : nullptr;
  res->public_key_ = (from.public_key_.length ()) ? td::str_dup (from.public_key_) : nullptr;
  res->nonce_ = (from.nonce_.length ()) ? td::str_dup (from.nonce_) : nullptr;
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  return res;
}
char *TdSerializeGetPassportAuthorizationForm (struct TdGetPassportAuthorizationForm *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetPassportAuthorizationForm *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetPassportAuthorizationForm (struct TdGetPassportAuthorizationForm *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetPassportAuthorizationForm *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->scope_);
  free (var->public_key_);
  free (var->nonce_);
  free (var->password_);
  delete var;
}
void TdStackStorerGetPassportAuthorizationForm (struct TdGetPassportAuthorizationForm *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetPassportAuthorizationForm *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetPassportAuthorizationForm");
  M->new_field ("ID");
  M->pack_long (var->bot_user_id_);
  M->new_field ("bot_user_id_");
  M->pack_string (var->scope_);
  M->new_field ("scope_");
  M->pack_string (var->public_key_);
  M->new_field ("public_key_");
  M->pack_string (var->nonce_);
  M->new_field ("nonce_");
  M->pack_string (var->password_);
  M->new_field ("password_");
}
struct TdGetPassportAuthorizationForm *TdStackFetcherGetPassportAuthorizationForm (struct TdStackFetcherMethods *M) {
  auto res = new TdGetPassportAuthorizationForm ();
  res->ID = CODE_GetPassportAuthorizationForm;
  res->refcnt = 1;
  M->get_field ("bot_user_id_");
  res->bot_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("scope_");
  res->scope_ = M->get_string ();
  M->pop ();
  M->get_field ("public_key_");
  res->public_key_ = M->get_string ();
  M->pop ();
  M->get_field ("nonce_");
  res->nonce_ = M->get_string ();
  M->pop ();
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetPassportElement *TdCreateObjectGetPassportElement (struct TdPassportElementType *type_, char *password_) {
  auto var = new struct TdGetPassportElement ();
  var->ID = CODE_GetPassportElement;
  var->refcnt = 1;
  var->type_ = type_;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getPassportElement> TdConvertToInternal (struct TdGetPassportElement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::PassportElementType> v0;
  v0 = TdConvertToInternal (var->type_);
  std::string v100;
  v100 = (var->password_) ? var->password_: "";
  return td::td_api::make_object<td::td_api::getPassportElement>(std::move (v0), std::move (v100));
}
struct TdGetPassportElement *TdConvertFromInternal (const td::td_api::getPassportElement &from) {
  auto res = new TdGetPassportElement ();
  res->ID = CODE_GetPassportElement;
  res->refcnt = 1;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::PassportElementType &>(*from.type_));
  }
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  return res;
}
char *TdSerializeGetPassportElement (struct TdGetPassportElement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetPassportElement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetPassportElement (struct TdGetPassportElement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetPassportElement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  free (var->password_);
  delete var;
}
void TdStackStorerGetPassportElement (struct TdGetPassportElement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetPassportElement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetPassportElement");
  M->new_field ("ID");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
  M->pack_string (var->password_);
  M->new_field ("password_");
}
struct TdGetPassportElement *TdStackFetcherGetPassportElement (struct TdStackFetcherMethods *M) {
  auto res = new TdGetPassportElement ();
  res->ID = CODE_GetPassportElement;
  res->refcnt = 1;
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherPassportElementType (M);
  }
  M->pop ();
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetPasswordState *TdCreateObjectGetPasswordState (void) {
  auto var = new struct TdGetPasswordState ();
  var->ID = CODE_GetPasswordState;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getPasswordState> TdConvertToInternal (struct TdGetPasswordState *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getPasswordState>();
}
struct TdGetPasswordState *TdConvertFromInternal (const td::td_api::getPasswordState &from) {
  auto res = new TdGetPasswordState ();
  res->ID = CODE_GetPasswordState;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetPasswordState (struct TdGetPasswordState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetPasswordState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetPasswordState (struct TdGetPasswordState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetPasswordState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetPasswordState (struct TdGetPasswordState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetPasswordState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetPasswordState");
  M->new_field ("ID");
}
struct TdGetPasswordState *TdStackFetcherGetPasswordState (struct TdStackFetcherMethods *M) {
  auto res = new TdGetPasswordState ();
  res->ID = CODE_GetPasswordState;
  res->refcnt = 1;
  return res;
}
struct TdGetPaymentForm *TdCreateObjectGetPaymentForm (long long chat_id_, long long message_id_) {
  auto var = new struct TdGetPaymentForm ();
  var->ID = CODE_GetPaymentForm;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getPaymentForm> TdConvertToInternal (struct TdGetPaymentForm *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  return td::td_api::make_object<td::td_api::getPaymentForm>(std::move (v0), std::move (v100));
}
struct TdGetPaymentForm *TdConvertFromInternal (const td::td_api::getPaymentForm &from) {
  auto res = new TdGetPaymentForm ();
  res->ID = CODE_GetPaymentForm;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeGetPaymentForm (struct TdGetPaymentForm *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetPaymentForm *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetPaymentForm (struct TdGetPaymentForm *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetPaymentForm *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetPaymentForm (struct TdGetPaymentForm *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetPaymentForm *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetPaymentForm");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdGetPaymentForm *TdStackFetcherGetPaymentForm (struct TdStackFetcherMethods *M) {
  auto res = new TdGetPaymentForm ();
  res->ID = CODE_GetPaymentForm;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetPaymentReceipt *TdCreateObjectGetPaymentReceipt (long long chat_id_, long long message_id_) {
  auto var = new struct TdGetPaymentReceipt ();
  var->ID = CODE_GetPaymentReceipt;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getPaymentReceipt> TdConvertToInternal (struct TdGetPaymentReceipt *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  return td::td_api::make_object<td::td_api::getPaymentReceipt>(std::move (v0), std::move (v100));
}
struct TdGetPaymentReceipt *TdConvertFromInternal (const td::td_api::getPaymentReceipt &from) {
  auto res = new TdGetPaymentReceipt ();
  res->ID = CODE_GetPaymentReceipt;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeGetPaymentReceipt (struct TdGetPaymentReceipt *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetPaymentReceipt *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetPaymentReceipt (struct TdGetPaymentReceipt *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetPaymentReceipt *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetPaymentReceipt (struct TdGetPaymentReceipt *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetPaymentReceipt *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetPaymentReceipt");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdGetPaymentReceipt *TdStackFetcherGetPaymentReceipt (struct TdStackFetcherMethods *M) {
  auto res = new TdGetPaymentReceipt ();
  res->ID = CODE_GetPaymentReceipt;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetPreferredCountryLanguage *TdCreateObjectGetPreferredCountryLanguage (char *country_code_) {
  auto var = new struct TdGetPreferredCountryLanguage ();
  var->ID = CODE_GetPreferredCountryLanguage;
  var->refcnt = 1;
  var->country_code_ = (country_code_) ? td::str_dup (td::Slice (country_code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getPreferredCountryLanguage> TdConvertToInternal (struct TdGetPreferredCountryLanguage *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->country_code_) ? var->country_code_: "";
  return td::td_api::make_object<td::td_api::getPreferredCountryLanguage>(std::move (v0));
}
struct TdGetPreferredCountryLanguage *TdConvertFromInternal (const td::td_api::getPreferredCountryLanguage &from) {
  auto res = new TdGetPreferredCountryLanguage ();
  res->ID = CODE_GetPreferredCountryLanguage;
  res->refcnt = 1;
  res->country_code_ = (from.country_code_.length ()) ? td::str_dup (from.country_code_) : nullptr;
  return res;
}
char *TdSerializeGetPreferredCountryLanguage (struct TdGetPreferredCountryLanguage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetPreferredCountryLanguage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetPreferredCountryLanguage (struct TdGetPreferredCountryLanguage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetPreferredCountryLanguage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->country_code_);
  delete var;
}
void TdStackStorerGetPreferredCountryLanguage (struct TdGetPreferredCountryLanguage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetPreferredCountryLanguage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetPreferredCountryLanguage");
  M->new_field ("ID");
  M->pack_string (var->country_code_);
  M->new_field ("country_code_");
}
struct TdGetPreferredCountryLanguage *TdStackFetcherGetPreferredCountryLanguage (struct TdStackFetcherMethods *M) {
  auto res = new TdGetPreferredCountryLanguage ();
  res->ID = CODE_GetPreferredCountryLanguage;
  res->refcnt = 1;
  M->get_field ("country_code_");
  res->country_code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetProxies *TdCreateObjectGetProxies (void) {
  auto var = new struct TdGetProxies ();
  var->ID = CODE_GetProxies;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getProxies> TdConvertToInternal (struct TdGetProxies *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getProxies>();
}
struct TdGetProxies *TdConvertFromInternal (const td::td_api::getProxies &from) {
  auto res = new TdGetProxies ();
  res->ID = CODE_GetProxies;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetProxies (struct TdGetProxies *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetProxies *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetProxies (struct TdGetProxies *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetProxies *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetProxies (struct TdGetProxies *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetProxies *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetProxies");
  M->new_field ("ID");
}
struct TdGetProxies *TdStackFetcherGetProxies (struct TdStackFetcherMethods *M) {
  auto res = new TdGetProxies ();
  res->ID = CODE_GetProxies;
  res->refcnt = 1;
  return res;
}
struct TdGetProxyLink *TdCreateObjectGetProxyLink (int proxy_id_) {
  auto var = new struct TdGetProxyLink ();
  var->ID = CODE_GetProxyLink;
  var->refcnt = 1;
  var->proxy_id_ = proxy_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getProxyLink> TdConvertToInternal (struct TdGetProxyLink *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->proxy_id_;
  return td::td_api::make_object<td::td_api::getProxyLink>(std::move (v0));
}
struct TdGetProxyLink *TdConvertFromInternal (const td::td_api::getProxyLink &from) {
  auto res = new TdGetProxyLink ();
  res->ID = CODE_GetProxyLink;
  res->refcnt = 1;
  res->proxy_id_ = from.proxy_id_;
  return res;
}
char *TdSerializeGetProxyLink (struct TdGetProxyLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetProxyLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetProxyLink (struct TdGetProxyLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetProxyLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetProxyLink (struct TdGetProxyLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetProxyLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetProxyLink");
  M->new_field ("ID");
  M->pack_long (var->proxy_id_);
  M->new_field ("proxy_id_");
}
struct TdGetProxyLink *TdStackFetcherGetProxyLink (struct TdStackFetcherMethods *M) {
  auto res = new TdGetProxyLink ();
  res->ID = CODE_GetProxyLink;
  res->refcnt = 1;
  M->get_field ("proxy_id_");
  res->proxy_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetPublicMessageLink *TdCreateObjectGetPublicMessageLink (long long chat_id_, long long message_id_, int for_album_) {
  auto var = new struct TdGetPublicMessageLink ();
  var->ID = CODE_GetPublicMessageLink;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->for_album_ = for_album_;
  return var;
}
td::td_api::object_ptr<td::td_api::getPublicMessageLink> TdConvertToInternal (struct TdGetPublicMessageLink *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  bool v200;
  v200 = var->for_album_ != 0;
  return td::td_api::make_object<td::td_api::getPublicMessageLink>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGetPublicMessageLink *TdConvertFromInternal (const td::td_api::getPublicMessageLink &from) {
  auto res = new TdGetPublicMessageLink ();
  res->ID = CODE_GetPublicMessageLink;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  res->for_album_ = from.for_album_;
  return res;
}
char *TdSerializeGetPublicMessageLink (struct TdGetPublicMessageLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetPublicMessageLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetPublicMessageLink (struct TdGetPublicMessageLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetPublicMessageLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetPublicMessageLink (struct TdGetPublicMessageLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetPublicMessageLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetPublicMessageLink");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_bool (var->for_album_);
  M->new_field ("for_album_");
}
struct TdGetPublicMessageLink *TdStackFetcherGetPublicMessageLink (struct TdStackFetcherMethods *M) {
  auto res = new TdGetPublicMessageLink ();
  res->ID = CODE_GetPublicMessageLink;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("for_album_");
  res->for_album_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetRecentInlineBots *TdCreateObjectGetRecentInlineBots (void) {
  auto var = new struct TdGetRecentInlineBots ();
  var->ID = CODE_GetRecentInlineBots;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getRecentInlineBots> TdConvertToInternal (struct TdGetRecentInlineBots *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getRecentInlineBots>();
}
struct TdGetRecentInlineBots *TdConvertFromInternal (const td::td_api::getRecentInlineBots &from) {
  auto res = new TdGetRecentInlineBots ();
  res->ID = CODE_GetRecentInlineBots;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetRecentInlineBots (struct TdGetRecentInlineBots *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetRecentInlineBots *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetRecentInlineBots (struct TdGetRecentInlineBots *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetRecentInlineBots *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetRecentInlineBots (struct TdGetRecentInlineBots *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetRecentInlineBots *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetRecentInlineBots");
  M->new_field ("ID");
}
struct TdGetRecentInlineBots *TdStackFetcherGetRecentInlineBots (struct TdStackFetcherMethods *M) {
  auto res = new TdGetRecentInlineBots ();
  res->ID = CODE_GetRecentInlineBots;
  res->refcnt = 1;
  return res;
}
struct TdGetRecentStickers *TdCreateObjectGetRecentStickers (int is_attached_) {
  auto var = new struct TdGetRecentStickers ();
  var->ID = CODE_GetRecentStickers;
  var->refcnt = 1;
  var->is_attached_ = is_attached_;
  return var;
}
td::td_api::object_ptr<td::td_api::getRecentStickers> TdConvertToInternal (struct TdGetRecentStickers *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_attached_ != 0;
  return td::td_api::make_object<td::td_api::getRecentStickers>(std::move (v0));
}
struct TdGetRecentStickers *TdConvertFromInternal (const td::td_api::getRecentStickers &from) {
  auto res = new TdGetRecentStickers ();
  res->ID = CODE_GetRecentStickers;
  res->refcnt = 1;
  res->is_attached_ = from.is_attached_;
  return res;
}
char *TdSerializeGetRecentStickers (struct TdGetRecentStickers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetRecentStickers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetRecentStickers (struct TdGetRecentStickers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetRecentStickers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetRecentStickers (struct TdGetRecentStickers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetRecentStickers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetRecentStickers");
  M->new_field ("ID");
  M->pack_bool (var->is_attached_);
  M->new_field ("is_attached_");
}
struct TdGetRecentStickers *TdStackFetcherGetRecentStickers (struct TdStackFetcherMethods *M) {
  auto res = new TdGetRecentStickers ();
  res->ID = CODE_GetRecentStickers;
  res->refcnt = 1;
  M->get_field ("is_attached_");
  res->is_attached_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetRecentlyVisitedTMeUrls *TdCreateObjectGetRecentlyVisitedTMeUrls (char *referrer_) {
  auto var = new struct TdGetRecentlyVisitedTMeUrls ();
  var->ID = CODE_GetRecentlyVisitedTMeUrls;
  var->refcnt = 1;
  var->referrer_ = (referrer_) ? td::str_dup (td::Slice (referrer_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getRecentlyVisitedTMeUrls> TdConvertToInternal (struct TdGetRecentlyVisitedTMeUrls *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->referrer_) ? var->referrer_: "";
  return td::td_api::make_object<td::td_api::getRecentlyVisitedTMeUrls>(std::move (v0));
}
struct TdGetRecentlyVisitedTMeUrls *TdConvertFromInternal (const td::td_api::getRecentlyVisitedTMeUrls &from) {
  auto res = new TdGetRecentlyVisitedTMeUrls ();
  res->ID = CODE_GetRecentlyVisitedTMeUrls;
  res->refcnt = 1;
  res->referrer_ = (from.referrer_.length ()) ? td::str_dup (from.referrer_) : nullptr;
  return res;
}
char *TdSerializeGetRecentlyVisitedTMeUrls (struct TdGetRecentlyVisitedTMeUrls *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetRecentlyVisitedTMeUrls *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetRecentlyVisitedTMeUrls (struct TdGetRecentlyVisitedTMeUrls *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetRecentlyVisitedTMeUrls *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->referrer_);
  delete var;
}
void TdStackStorerGetRecentlyVisitedTMeUrls (struct TdGetRecentlyVisitedTMeUrls *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetRecentlyVisitedTMeUrls *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetRecentlyVisitedTMeUrls");
  M->new_field ("ID");
  M->pack_string (var->referrer_);
  M->new_field ("referrer_");
}
struct TdGetRecentlyVisitedTMeUrls *TdStackFetcherGetRecentlyVisitedTMeUrls (struct TdStackFetcherMethods *M) {
  auto res = new TdGetRecentlyVisitedTMeUrls ();
  res->ID = CODE_GetRecentlyVisitedTMeUrls;
  res->refcnt = 1;
  M->get_field ("referrer_");
  res->referrer_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetRecoveryEmailAddress *TdCreateObjectGetRecoveryEmailAddress (char *password_) {
  auto var = new struct TdGetRecoveryEmailAddress ();
  var->ID = CODE_GetRecoveryEmailAddress;
  var->refcnt = 1;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getRecoveryEmailAddress> TdConvertToInternal (struct TdGetRecoveryEmailAddress *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->password_) ? var->password_: "";
  return td::td_api::make_object<td::td_api::getRecoveryEmailAddress>(std::move (v0));
}
struct TdGetRecoveryEmailAddress *TdConvertFromInternal (const td::td_api::getRecoveryEmailAddress &from) {
  auto res = new TdGetRecoveryEmailAddress ();
  res->ID = CODE_GetRecoveryEmailAddress;
  res->refcnt = 1;
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  return res;
}
char *TdSerializeGetRecoveryEmailAddress (struct TdGetRecoveryEmailAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetRecoveryEmailAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetRecoveryEmailAddress (struct TdGetRecoveryEmailAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetRecoveryEmailAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->password_);
  delete var;
}
void TdStackStorerGetRecoveryEmailAddress (struct TdGetRecoveryEmailAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetRecoveryEmailAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetRecoveryEmailAddress");
  M->new_field ("ID");
  M->pack_string (var->password_);
  M->new_field ("password_");
}
struct TdGetRecoveryEmailAddress *TdStackFetcherGetRecoveryEmailAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdGetRecoveryEmailAddress ();
  res->ID = CODE_GetRecoveryEmailAddress;
  res->refcnt = 1;
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetRemoteFile *TdCreateObjectGetRemoteFile (char *remote_file_id_, struct TdFileType *file_type_) {
  auto var = new struct TdGetRemoteFile ();
  var->ID = CODE_GetRemoteFile;
  var->refcnt = 1;
  var->remote_file_id_ = (remote_file_id_) ? td::str_dup (td::Slice (remote_file_id_)) : nullptr;
  var->file_type_ = file_type_;
  return var;
}
td::td_api::object_ptr<td::td_api::getRemoteFile> TdConvertToInternal (struct TdGetRemoteFile *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->remote_file_id_) ? var->remote_file_id_: "";
  td::td_api::object_ptr<td::td_api::FileType> v100;
  v100 = TdConvertToInternal (var->file_type_);
  return td::td_api::make_object<td::td_api::getRemoteFile>(std::move (v0), std::move (v100));
}
struct TdGetRemoteFile *TdConvertFromInternal (const td::td_api::getRemoteFile &from) {
  auto res = new TdGetRemoteFile ();
  res->ID = CODE_GetRemoteFile;
  res->refcnt = 1;
  res->remote_file_id_ = (from.remote_file_id_.length ()) ? td::str_dup (from.remote_file_id_) : nullptr;
  if (!from.file_type_) {
    res->file_type_ = nullptr;
  } else {
    res->file_type_ = TdConvertFromInternal (static_cast<const td::td_api::FileType &>(*from.file_type_));
  }
  return res;
}
char *TdSerializeGetRemoteFile (struct TdGetRemoteFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetRemoteFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetRemoteFile (struct TdGetRemoteFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetRemoteFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->remote_file_id_);
  TdDestroyObject (var->file_type_);
  delete var;
}
void TdStackStorerGetRemoteFile (struct TdGetRemoteFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetRemoteFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetRemoteFile");
  M->new_field ("ID");
  M->pack_string (var->remote_file_id_);
  M->new_field ("remote_file_id_");
  TdStackStorer (var->file_type_, M);
  M->new_field ("file_type_");
}
struct TdGetRemoteFile *TdStackFetcherGetRemoteFile (struct TdStackFetcherMethods *M) {
  auto res = new TdGetRemoteFile ();
  res->ID = CODE_GetRemoteFile;
  res->refcnt = 1;
  M->get_field ("remote_file_id_");
  res->remote_file_id_ = M->get_string ();
  M->pop ();
  M->get_field ("file_type_");
  if (M->is_nil ()) {
    res->file_type_ = nullptr;
  } else {
    res->file_type_ = TdStackFetcherFileType (M);
  }
  M->pop ();
  return res;
}
struct TdGetRepliedMessage *TdCreateObjectGetRepliedMessage (long long chat_id_, long long message_id_) {
  auto var = new struct TdGetRepliedMessage ();
  var->ID = CODE_GetRepliedMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getRepliedMessage> TdConvertToInternal (struct TdGetRepliedMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  return td::td_api::make_object<td::td_api::getRepliedMessage>(std::move (v0), std::move (v100));
}
struct TdGetRepliedMessage *TdConvertFromInternal (const td::td_api::getRepliedMessage &from) {
  auto res = new TdGetRepliedMessage ();
  res->ID = CODE_GetRepliedMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeGetRepliedMessage (struct TdGetRepliedMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetRepliedMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetRepliedMessage (struct TdGetRepliedMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetRepliedMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetRepliedMessage (struct TdGetRepliedMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetRepliedMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetRepliedMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdGetRepliedMessage *TdStackFetcherGetRepliedMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdGetRepliedMessage ();
  res->ID = CODE_GetRepliedMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetSavedAnimations *TdCreateObjectGetSavedAnimations (void) {
  auto var = new struct TdGetSavedAnimations ();
  var->ID = CODE_GetSavedAnimations;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getSavedAnimations> TdConvertToInternal (struct TdGetSavedAnimations *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getSavedAnimations>();
}
struct TdGetSavedAnimations *TdConvertFromInternal (const td::td_api::getSavedAnimations &from) {
  auto res = new TdGetSavedAnimations ();
  res->ID = CODE_GetSavedAnimations;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetSavedAnimations (struct TdGetSavedAnimations *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetSavedAnimations *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetSavedAnimations (struct TdGetSavedAnimations *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetSavedAnimations *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetSavedAnimations (struct TdGetSavedAnimations *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetSavedAnimations *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetSavedAnimations");
  M->new_field ("ID");
}
struct TdGetSavedAnimations *TdStackFetcherGetSavedAnimations (struct TdStackFetcherMethods *M) {
  auto res = new TdGetSavedAnimations ();
  res->ID = CODE_GetSavedAnimations;
  res->refcnt = 1;
  return res;
}
struct TdGetSavedOrderInfo *TdCreateObjectGetSavedOrderInfo (void) {
  auto var = new struct TdGetSavedOrderInfo ();
  var->ID = CODE_GetSavedOrderInfo;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getSavedOrderInfo> TdConvertToInternal (struct TdGetSavedOrderInfo *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getSavedOrderInfo>();
}
struct TdGetSavedOrderInfo *TdConvertFromInternal (const td::td_api::getSavedOrderInfo &from) {
  auto res = new TdGetSavedOrderInfo ();
  res->ID = CODE_GetSavedOrderInfo;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetSavedOrderInfo (struct TdGetSavedOrderInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetSavedOrderInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetSavedOrderInfo (struct TdGetSavedOrderInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetSavedOrderInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetSavedOrderInfo (struct TdGetSavedOrderInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetSavedOrderInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetSavedOrderInfo");
  M->new_field ("ID");
}
struct TdGetSavedOrderInfo *TdStackFetcherGetSavedOrderInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdGetSavedOrderInfo ();
  res->ID = CODE_GetSavedOrderInfo;
  res->refcnt = 1;
  return res;
}
struct TdGetScopeNotificationSettings *TdCreateObjectGetScopeNotificationSettings (struct TdNotificationSettingsScope *scope_) {
  auto var = new struct TdGetScopeNotificationSettings ();
  var->ID = CODE_GetScopeNotificationSettings;
  var->refcnt = 1;
  var->scope_ = scope_;
  return var;
}
td::td_api::object_ptr<td::td_api::getScopeNotificationSettings> TdConvertToInternal (struct TdGetScopeNotificationSettings *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::NotificationSettingsScope> v0;
  v0 = TdConvertToInternal (var->scope_);
  return td::td_api::make_object<td::td_api::getScopeNotificationSettings>(std::move (v0));
}
struct TdGetScopeNotificationSettings *TdConvertFromInternal (const td::td_api::getScopeNotificationSettings &from) {
  auto res = new TdGetScopeNotificationSettings ();
  res->ID = CODE_GetScopeNotificationSettings;
  res->refcnt = 1;
  if (!from.scope_) {
    res->scope_ = nullptr;
  } else {
    res->scope_ = TdConvertFromInternal (static_cast<const td::td_api::NotificationSettingsScope &>(*from.scope_));
  }
  return res;
}
char *TdSerializeGetScopeNotificationSettings (struct TdGetScopeNotificationSettings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetScopeNotificationSettings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetScopeNotificationSettings (struct TdGetScopeNotificationSettings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetScopeNotificationSettings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->scope_);
  delete var;
}
void TdStackStorerGetScopeNotificationSettings (struct TdGetScopeNotificationSettings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetScopeNotificationSettings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetScopeNotificationSettings");
  M->new_field ("ID");
  TdStackStorer (var->scope_, M);
  M->new_field ("scope_");
}
struct TdGetScopeNotificationSettings *TdStackFetcherGetScopeNotificationSettings (struct TdStackFetcherMethods *M) {
  auto res = new TdGetScopeNotificationSettings ();
  res->ID = CODE_GetScopeNotificationSettings;
  res->refcnt = 1;
  M->get_field ("scope_");
  if (M->is_nil ()) {
    res->scope_ = nullptr;
  } else {
    res->scope_ = TdStackFetcherNotificationSettingsScope (M);
  }
  M->pop ();
  return res;
}
struct TdGetSecretChat *TdCreateObjectGetSecretChat (int secret_chat_id_) {
  auto var = new struct TdGetSecretChat ();
  var->ID = CODE_GetSecretChat;
  var->refcnt = 1;
  var->secret_chat_id_ = secret_chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getSecretChat> TdConvertToInternal (struct TdGetSecretChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->secret_chat_id_;
  return td::td_api::make_object<td::td_api::getSecretChat>(std::move (v0));
}
struct TdGetSecretChat *TdConvertFromInternal (const td::td_api::getSecretChat &from) {
  auto res = new TdGetSecretChat ();
  res->ID = CODE_GetSecretChat;
  res->refcnt = 1;
  res->secret_chat_id_ = from.secret_chat_id_;
  return res;
}
char *TdSerializeGetSecretChat (struct TdGetSecretChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetSecretChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetSecretChat (struct TdGetSecretChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetSecretChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetSecretChat (struct TdGetSecretChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetSecretChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetSecretChat");
  M->new_field ("ID");
  M->pack_long (var->secret_chat_id_);
  M->new_field ("secret_chat_id_");
}
struct TdGetSecretChat *TdStackFetcherGetSecretChat (struct TdStackFetcherMethods *M) {
  auto res = new TdGetSecretChat ();
  res->ID = CODE_GetSecretChat;
  res->refcnt = 1;
  M->get_field ("secret_chat_id_");
  res->secret_chat_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetStickerEmojis *TdCreateObjectGetStickerEmojis (struct TdInputFile *sticker_) {
  auto var = new struct TdGetStickerEmojis ();
  var->ID = CODE_GetStickerEmojis;
  var->refcnt = 1;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::getStickerEmojis> TdConvertToInternal (struct TdGetStickerEmojis *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::getStickerEmojis>(std::move (v0));
}
struct TdGetStickerEmojis *TdConvertFromInternal (const td::td_api::getStickerEmojis &from) {
  auto res = new TdGetStickerEmojis ();
  res->ID = CODE_GetStickerEmojis;
  res->refcnt = 1;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeGetStickerEmojis (struct TdGetStickerEmojis *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetStickerEmojis *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetStickerEmojis (struct TdGetStickerEmojis *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetStickerEmojis *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerGetStickerEmojis (struct TdGetStickerEmojis *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetStickerEmojis *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetStickerEmojis");
  M->new_field ("ID");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdGetStickerEmojis *TdStackFetcherGetStickerEmojis (struct TdStackFetcherMethods *M) {
  auto res = new TdGetStickerEmojis ();
  res->ID = CODE_GetStickerEmojis;
  res->refcnt = 1;
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdGetStickerSet *TdCreateObjectGetStickerSet (long long set_id_) {
  auto var = new struct TdGetStickerSet ();
  var->ID = CODE_GetStickerSet;
  var->refcnt = 1;
  var->set_id_ = set_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getStickerSet> TdConvertToInternal (struct TdGetStickerSet *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->set_id_;
  return td::td_api::make_object<td::td_api::getStickerSet>(std::move (v0));
}
struct TdGetStickerSet *TdConvertFromInternal (const td::td_api::getStickerSet &from) {
  auto res = new TdGetStickerSet ();
  res->ID = CODE_GetStickerSet;
  res->refcnt = 1;
  res->set_id_ = from.set_id_;
  return res;
}
char *TdSerializeGetStickerSet (struct TdGetStickerSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetStickerSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetStickerSet (struct TdGetStickerSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetStickerSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetStickerSet (struct TdGetStickerSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetStickerSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetStickerSet");
  M->new_field ("ID");
  M->pack_long (var->set_id_);
  M->new_field ("set_id_");
}
struct TdGetStickerSet *TdStackFetcherGetStickerSet (struct TdStackFetcherMethods *M) {
  auto res = new TdGetStickerSet ();
  res->ID = CODE_GetStickerSet;
  res->refcnt = 1;
  M->get_field ("set_id_");
  res->set_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdGetStickers *TdCreateObjectGetStickers (char *emoji_, int limit_) {
  auto var = new struct TdGetStickers ();
  var->ID = CODE_GetStickers;
  var->refcnt = 1;
  var->emoji_ = (emoji_) ? td::str_dup (td::Slice (emoji_)) : nullptr;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getStickers> TdConvertToInternal (struct TdGetStickers *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->emoji_) ? var->emoji_: "";
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::getStickers>(std::move (v0), std::move (v100));
}
struct TdGetStickers *TdConvertFromInternal (const td::td_api::getStickers &from) {
  auto res = new TdGetStickers ();
  res->ID = CODE_GetStickers;
  res->refcnt = 1;
  res->emoji_ = (from.emoji_.length ()) ? td::str_dup (from.emoji_) : nullptr;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeGetStickers (struct TdGetStickers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetStickers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetStickers (struct TdGetStickers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetStickers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->emoji_);
  delete var;
}
void TdStackStorerGetStickers (struct TdGetStickers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetStickers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetStickers");
  M->new_field ("ID");
  M->pack_string (var->emoji_);
  M->new_field ("emoji_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdGetStickers *TdStackFetcherGetStickers (struct TdStackFetcherMethods *M) {
  auto res = new TdGetStickers ();
  res->ID = CODE_GetStickers;
  res->refcnt = 1;
  M->get_field ("emoji_");
  res->emoji_ = M->get_string ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetStorageStatistics *TdCreateObjectGetStorageStatistics (int chat_limit_) {
  auto var = new struct TdGetStorageStatistics ();
  var->ID = CODE_GetStorageStatistics;
  var->refcnt = 1;
  var->chat_limit_ = chat_limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getStorageStatistics> TdConvertToInternal (struct TdGetStorageStatistics *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->chat_limit_;
  return td::td_api::make_object<td::td_api::getStorageStatistics>(std::move (v0));
}
struct TdGetStorageStatistics *TdConvertFromInternal (const td::td_api::getStorageStatistics &from) {
  auto res = new TdGetStorageStatistics ();
  res->ID = CODE_GetStorageStatistics;
  res->refcnt = 1;
  res->chat_limit_ = from.chat_limit_;
  return res;
}
char *TdSerializeGetStorageStatistics (struct TdGetStorageStatistics *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetStorageStatistics *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetStorageStatistics (struct TdGetStorageStatistics *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetStorageStatistics *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetStorageStatistics (struct TdGetStorageStatistics *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetStorageStatistics *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetStorageStatistics");
  M->new_field ("ID");
  M->pack_long (var->chat_limit_);
  M->new_field ("chat_limit_");
}
struct TdGetStorageStatistics *TdStackFetcherGetStorageStatistics (struct TdStackFetcherMethods *M) {
  auto res = new TdGetStorageStatistics ();
  res->ID = CODE_GetStorageStatistics;
  res->refcnt = 1;
  M->get_field ("chat_limit_");
  res->chat_limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetStorageStatisticsFast *TdCreateObjectGetStorageStatisticsFast (void) {
  auto var = new struct TdGetStorageStatisticsFast ();
  var->ID = CODE_GetStorageStatisticsFast;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getStorageStatisticsFast> TdConvertToInternal (struct TdGetStorageStatisticsFast *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getStorageStatisticsFast>();
}
struct TdGetStorageStatisticsFast *TdConvertFromInternal (const td::td_api::getStorageStatisticsFast &from) {
  auto res = new TdGetStorageStatisticsFast ();
  res->ID = CODE_GetStorageStatisticsFast;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetStorageStatisticsFast (struct TdGetStorageStatisticsFast *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetStorageStatisticsFast *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetStorageStatisticsFast (struct TdGetStorageStatisticsFast *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetStorageStatisticsFast *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetStorageStatisticsFast (struct TdGetStorageStatisticsFast *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetStorageStatisticsFast *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetStorageStatisticsFast");
  M->new_field ("ID");
}
struct TdGetStorageStatisticsFast *TdStackFetcherGetStorageStatisticsFast (struct TdStackFetcherMethods *M) {
  auto res = new TdGetStorageStatisticsFast ();
  res->ID = CODE_GetStorageStatisticsFast;
  res->refcnt = 1;
  return res;
}
struct TdGetSupergroup *TdCreateObjectGetSupergroup (int supergroup_id_) {
  auto var = new struct TdGetSupergroup ();
  var->ID = CODE_GetSupergroup;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getSupergroup> TdConvertToInternal (struct TdGetSupergroup *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  return td::td_api::make_object<td::td_api::getSupergroup>(std::move (v0));
}
struct TdGetSupergroup *TdConvertFromInternal (const td::td_api::getSupergroup &from) {
  auto res = new TdGetSupergroup ();
  res->ID = CODE_GetSupergroup;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  return res;
}
char *TdSerializeGetSupergroup (struct TdGetSupergroup *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetSupergroup *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetSupergroup (struct TdGetSupergroup *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetSupergroup *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetSupergroup (struct TdGetSupergroup *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetSupergroup *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetSupergroup");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
}
struct TdGetSupergroup *TdStackFetcherGetSupergroup (struct TdStackFetcherMethods *M) {
  auto res = new TdGetSupergroup ();
  res->ID = CODE_GetSupergroup;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetSupergroupFullInfo *TdCreateObjectGetSupergroupFullInfo (int supergroup_id_) {
  auto var = new struct TdGetSupergroupFullInfo ();
  var->ID = CODE_GetSupergroupFullInfo;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getSupergroupFullInfo> TdConvertToInternal (struct TdGetSupergroupFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  return td::td_api::make_object<td::td_api::getSupergroupFullInfo>(std::move (v0));
}
struct TdGetSupergroupFullInfo *TdConvertFromInternal (const td::td_api::getSupergroupFullInfo &from) {
  auto res = new TdGetSupergroupFullInfo ();
  res->ID = CODE_GetSupergroupFullInfo;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  return res;
}
char *TdSerializeGetSupergroupFullInfo (struct TdGetSupergroupFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetSupergroupFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetSupergroupFullInfo (struct TdGetSupergroupFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetSupergroupFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetSupergroupFullInfo (struct TdGetSupergroupFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetSupergroupFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetSupergroupFullInfo");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
}
struct TdGetSupergroupFullInfo *TdStackFetcherGetSupergroupFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdGetSupergroupFullInfo ();
  res->ID = CODE_GetSupergroupFullInfo;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetSupergroupMembers *TdCreateObjectGetSupergroupMembers (int supergroup_id_, struct TdSupergroupMembersFilter *filter_, int offset_, int limit_) {
  auto var = new struct TdGetSupergroupMembers ();
  var->ID = CODE_GetSupergroupMembers;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->filter_ = filter_;
  var->offset_ = offset_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getSupergroupMembers> TdConvertToInternal (struct TdGetSupergroupMembers *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  td::td_api::object_ptr<td::td_api::SupergroupMembersFilter> v100;
  v100 = TdConvertToInternal (var->filter_);
  std::int32_t v200;
  v200 = var->offset_;
  std::int32_t v300;
  v300 = var->limit_;
  return td::td_api::make_object<td::td_api::getSupergroupMembers>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdGetSupergroupMembers *TdConvertFromInternal (const td::td_api::getSupergroupMembers &from) {
  auto res = new TdGetSupergroupMembers ();
  res->ID = CODE_GetSupergroupMembers;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  if (!from.filter_) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdConvertFromInternal (static_cast<const td::td_api::SupergroupMembersFilter &>(*from.filter_));
  }
  res->offset_ = from.offset_;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeGetSupergroupMembers (struct TdGetSupergroupMembers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetSupergroupMembers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetSupergroupMembers (struct TdGetSupergroupMembers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetSupergroupMembers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->filter_);
  delete var;
}
void TdStackStorerGetSupergroupMembers (struct TdGetSupergroupMembers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetSupergroupMembers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetSupergroupMembers");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  TdStackStorer (var->filter_, M);
  M->new_field ("filter_");
  M->pack_long (var->offset_);
  M->new_field ("offset_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdGetSupergroupMembers *TdStackFetcherGetSupergroupMembers (struct TdStackFetcherMethods *M) {
  auto res = new TdGetSupergroupMembers ();
  res->ID = CODE_GetSupergroupMembers;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("filter_");
  if (M->is_nil ()) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdStackFetcherSupergroupMembersFilter (M);
  }
  M->pop ();
  M->get_field ("offset_");
  res->offset_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetSupportUser *TdCreateObjectGetSupportUser (void) {
  auto var = new struct TdGetSupportUser ();
  var->ID = CODE_GetSupportUser;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getSupportUser> TdConvertToInternal (struct TdGetSupportUser *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getSupportUser>();
}
struct TdGetSupportUser *TdConvertFromInternal (const td::td_api::getSupportUser &from) {
  auto res = new TdGetSupportUser ();
  res->ID = CODE_GetSupportUser;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetSupportUser (struct TdGetSupportUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetSupportUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetSupportUser (struct TdGetSupportUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetSupportUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetSupportUser (struct TdGetSupportUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetSupportUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetSupportUser");
  M->new_field ("ID");
}
struct TdGetSupportUser *TdStackFetcherGetSupportUser (struct TdStackFetcherMethods *M) {
  auto res = new TdGetSupportUser ();
  res->ID = CODE_GetSupportUser;
  res->refcnt = 1;
  return res;
}
struct TdGetTemporaryPasswordState *TdCreateObjectGetTemporaryPasswordState (void) {
  auto var = new struct TdGetTemporaryPasswordState ();
  var->ID = CODE_GetTemporaryPasswordState;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getTemporaryPasswordState> TdConvertToInternal (struct TdGetTemporaryPasswordState *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getTemporaryPasswordState>();
}
struct TdGetTemporaryPasswordState *TdConvertFromInternal (const td::td_api::getTemporaryPasswordState &from) {
  auto res = new TdGetTemporaryPasswordState ();
  res->ID = CODE_GetTemporaryPasswordState;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetTemporaryPasswordState (struct TdGetTemporaryPasswordState *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetTemporaryPasswordState *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetTemporaryPasswordState (struct TdGetTemporaryPasswordState *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetTemporaryPasswordState *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetTemporaryPasswordState (struct TdGetTemporaryPasswordState *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetTemporaryPasswordState *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetTemporaryPasswordState");
  M->new_field ("ID");
}
struct TdGetTemporaryPasswordState *TdStackFetcherGetTemporaryPasswordState (struct TdStackFetcherMethods *M) {
  auto res = new TdGetTemporaryPasswordState ();
  res->ID = CODE_GetTemporaryPasswordState;
  res->refcnt = 1;
  return res;
}
struct TdGetTextEntities *TdCreateObjectGetTextEntities (char *text_) {
  auto var = new struct TdGetTextEntities ();
  var->ID = CODE_GetTextEntities;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::getTextEntities> TdConvertToInternal (struct TdGetTextEntities *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  return td::td_api::make_object<td::td_api::getTextEntities>(std::move (v0));
}
struct TdGetTextEntities *TdConvertFromInternal (const td::td_api::getTextEntities &from) {
  auto res = new TdGetTextEntities ();
  res->ID = CODE_GetTextEntities;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  return res;
}
char *TdSerializeGetTextEntities (struct TdGetTextEntities *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetTextEntities *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetTextEntities (struct TdGetTextEntities *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetTextEntities *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  delete var;
}
void TdStackStorerGetTextEntities (struct TdGetTextEntities *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetTextEntities *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetTextEntities");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
}
struct TdGetTextEntities *TdStackFetcherGetTextEntities (struct TdStackFetcherMethods *M) {
  auto res = new TdGetTextEntities ();
  res->ID = CODE_GetTextEntities;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdGetTopChats *TdCreateObjectGetTopChats (struct TdTopChatCategory *category_, int limit_) {
  auto var = new struct TdGetTopChats ();
  var->ID = CODE_GetTopChats;
  var->refcnt = 1;
  var->category_ = category_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getTopChats> TdConvertToInternal (struct TdGetTopChats *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::TopChatCategory> v0;
  v0 = TdConvertToInternal (var->category_);
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::getTopChats>(std::move (v0), std::move (v100));
}
struct TdGetTopChats *TdConvertFromInternal (const td::td_api::getTopChats &from) {
  auto res = new TdGetTopChats ();
  res->ID = CODE_GetTopChats;
  res->refcnt = 1;
  if (!from.category_) {
    res->category_ = nullptr;
  } else {
    res->category_ = TdConvertFromInternal (static_cast<const td::td_api::TopChatCategory &>(*from.category_));
  }
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeGetTopChats (struct TdGetTopChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetTopChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetTopChats (struct TdGetTopChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetTopChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->category_);
  delete var;
}
void TdStackStorerGetTopChats (struct TdGetTopChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetTopChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetTopChats");
  M->new_field ("ID");
  TdStackStorer (var->category_, M);
  M->new_field ("category_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdGetTopChats *TdStackFetcherGetTopChats (struct TdStackFetcherMethods *M) {
  auto res = new TdGetTopChats ();
  res->ID = CODE_GetTopChats;
  res->refcnt = 1;
  M->get_field ("category_");
  if (M->is_nil ()) {
    res->category_ = nullptr;
  } else {
    res->category_ = TdStackFetcherTopChatCategory (M);
  }
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetTrendingStickerSets *TdCreateObjectGetTrendingStickerSets (void) {
  auto var = new struct TdGetTrendingStickerSets ();
  var->ID = CODE_GetTrendingStickerSets;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getTrendingStickerSets> TdConvertToInternal (struct TdGetTrendingStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getTrendingStickerSets>();
}
struct TdGetTrendingStickerSets *TdConvertFromInternal (const td::td_api::getTrendingStickerSets &from) {
  auto res = new TdGetTrendingStickerSets ();
  res->ID = CODE_GetTrendingStickerSets;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetTrendingStickerSets (struct TdGetTrendingStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetTrendingStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetTrendingStickerSets (struct TdGetTrendingStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetTrendingStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetTrendingStickerSets (struct TdGetTrendingStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetTrendingStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetTrendingStickerSets");
  M->new_field ("ID");
}
struct TdGetTrendingStickerSets *TdStackFetcherGetTrendingStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdGetTrendingStickerSets ();
  res->ID = CODE_GetTrendingStickerSets;
  res->refcnt = 1;
  return res;
}
struct TdGetUser *TdCreateObjectGetUser (int user_id_) {
  auto var = new struct TdGetUser ();
  var->ID = CODE_GetUser;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getUser> TdConvertToInternal (struct TdGetUser *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::getUser>(std::move (v0));
}
struct TdGetUser *TdConvertFromInternal (const td::td_api::getUser &from) {
  auto res = new TdGetUser ();
  res->ID = CODE_GetUser;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeGetUser (struct TdGetUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetUser (struct TdGetUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetUser (struct TdGetUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetUser");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdGetUser *TdStackFetcherGetUser (struct TdStackFetcherMethods *M) {
  auto res = new TdGetUser ();
  res->ID = CODE_GetUser;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetUserFullInfo *TdCreateObjectGetUserFullInfo (int user_id_) {
  auto var = new struct TdGetUserFullInfo ();
  var->ID = CODE_GetUserFullInfo;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::getUserFullInfo> TdConvertToInternal (struct TdGetUserFullInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::getUserFullInfo>(std::move (v0));
}
struct TdGetUserFullInfo *TdConvertFromInternal (const td::td_api::getUserFullInfo &from) {
  auto res = new TdGetUserFullInfo ();
  res->ID = CODE_GetUserFullInfo;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeGetUserFullInfo (struct TdGetUserFullInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetUserFullInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetUserFullInfo (struct TdGetUserFullInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetUserFullInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetUserFullInfo (struct TdGetUserFullInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetUserFullInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetUserFullInfo");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdGetUserFullInfo *TdStackFetcherGetUserFullInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdGetUserFullInfo ();
  res->ID = CODE_GetUserFullInfo;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetUserPrivacySettingRules *TdCreateObjectGetUserPrivacySettingRules (struct TdUserPrivacySetting *setting_) {
  auto var = new struct TdGetUserPrivacySettingRules ();
  var->ID = CODE_GetUserPrivacySettingRules;
  var->refcnt = 1;
  var->setting_ = setting_;
  return var;
}
td::td_api::object_ptr<td::td_api::getUserPrivacySettingRules> TdConvertToInternal (struct TdGetUserPrivacySettingRules *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::UserPrivacySetting> v0;
  v0 = TdConvertToInternal (var->setting_);
  return td::td_api::make_object<td::td_api::getUserPrivacySettingRules>(std::move (v0));
}
struct TdGetUserPrivacySettingRules *TdConvertFromInternal (const td::td_api::getUserPrivacySettingRules &from) {
  auto res = new TdGetUserPrivacySettingRules ();
  res->ID = CODE_GetUserPrivacySettingRules;
  res->refcnt = 1;
  if (!from.setting_) {
    res->setting_ = nullptr;
  } else {
    res->setting_ = TdConvertFromInternal (static_cast<const td::td_api::UserPrivacySetting &>(*from.setting_));
  }
  return res;
}
char *TdSerializeGetUserPrivacySettingRules (struct TdGetUserPrivacySettingRules *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetUserPrivacySettingRules *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetUserPrivacySettingRules (struct TdGetUserPrivacySettingRules *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetUserPrivacySettingRules *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->setting_);
  delete var;
}
void TdStackStorerGetUserPrivacySettingRules (struct TdGetUserPrivacySettingRules *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetUserPrivacySettingRules *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetUserPrivacySettingRules");
  M->new_field ("ID");
  TdStackStorer (var->setting_, M);
  M->new_field ("setting_");
}
struct TdGetUserPrivacySettingRules *TdStackFetcherGetUserPrivacySettingRules (struct TdStackFetcherMethods *M) {
  auto res = new TdGetUserPrivacySettingRules ();
  res->ID = CODE_GetUserPrivacySettingRules;
  res->refcnt = 1;
  M->get_field ("setting_");
  if (M->is_nil ()) {
    res->setting_ = nullptr;
  } else {
    res->setting_ = TdStackFetcherUserPrivacySetting (M);
  }
  M->pop ();
  return res;
}
struct TdGetUserProfilePhotos *TdCreateObjectGetUserProfilePhotos (int user_id_, int offset_, int limit_) {
  auto var = new struct TdGetUserProfilePhotos ();
  var->ID = CODE_GetUserProfilePhotos;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->offset_ = offset_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::getUserProfilePhotos> TdConvertToInternal (struct TdGetUserProfilePhotos *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  std::int32_t v100;
  v100 = var->offset_;
  std::int32_t v200;
  v200 = var->limit_;
  return td::td_api::make_object<td::td_api::getUserProfilePhotos>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdGetUserProfilePhotos *TdConvertFromInternal (const td::td_api::getUserProfilePhotos &from) {
  auto res = new TdGetUserProfilePhotos ();
  res->ID = CODE_GetUserProfilePhotos;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  res->offset_ = from.offset_;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeGetUserProfilePhotos (struct TdGetUserProfilePhotos *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetUserProfilePhotos *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetUserProfilePhotos (struct TdGetUserProfilePhotos *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetUserProfilePhotos *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetUserProfilePhotos (struct TdGetUserProfilePhotos *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetUserProfilePhotos *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetUserProfilePhotos");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_long (var->offset_);
  M->new_field ("offset_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdGetUserProfilePhotos *TdStackFetcherGetUserProfilePhotos (struct TdStackFetcherMethods *M) {
  auto res = new TdGetUserProfilePhotos ();
  res->ID = CODE_GetUserProfilePhotos;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("offset_");
  res->offset_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetWallpapers *TdCreateObjectGetWallpapers (void) {
  auto var = new struct TdGetWallpapers ();
  var->ID = CODE_GetWallpapers;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::getWallpapers> TdConvertToInternal (struct TdGetWallpapers *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::getWallpapers>();
}
struct TdGetWallpapers *TdConvertFromInternal (const td::td_api::getWallpapers &from) {
  auto res = new TdGetWallpapers ();
  res->ID = CODE_GetWallpapers;
  res->refcnt = 1;
  return res;
}
char *TdSerializeGetWallpapers (struct TdGetWallpapers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetWallpapers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetWallpapers (struct TdGetWallpapers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetWallpapers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerGetWallpapers (struct TdGetWallpapers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetWallpapers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetWallpapers");
  M->new_field ("ID");
}
struct TdGetWallpapers *TdStackFetcherGetWallpapers (struct TdStackFetcherMethods *M) {
  auto res = new TdGetWallpapers ();
  res->ID = CODE_GetWallpapers;
  res->refcnt = 1;
  return res;
}
struct TdGetWebPageInstantView *TdCreateObjectGetWebPageInstantView (char *url_, int force_full_) {
  auto var = new struct TdGetWebPageInstantView ();
  var->ID = CODE_GetWebPageInstantView;
  var->refcnt = 1;
  var->url_ = (url_) ? td::str_dup (td::Slice (url_)) : nullptr;
  var->force_full_ = force_full_;
  return var;
}
td::td_api::object_ptr<td::td_api::getWebPageInstantView> TdConvertToInternal (struct TdGetWebPageInstantView *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->url_) ? var->url_: "";
  bool v100;
  v100 = var->force_full_ != 0;
  return td::td_api::make_object<td::td_api::getWebPageInstantView>(std::move (v0), std::move (v100));
}
struct TdGetWebPageInstantView *TdConvertFromInternal (const td::td_api::getWebPageInstantView &from) {
  auto res = new TdGetWebPageInstantView ();
  res->ID = CODE_GetWebPageInstantView;
  res->refcnt = 1;
  res->url_ = (from.url_.length ()) ? td::str_dup (from.url_) : nullptr;
  res->force_full_ = from.force_full_;
  return res;
}
char *TdSerializeGetWebPageInstantView (struct TdGetWebPageInstantView *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetWebPageInstantView *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetWebPageInstantView (struct TdGetWebPageInstantView *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetWebPageInstantView *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->url_);
  delete var;
}
void TdStackStorerGetWebPageInstantView (struct TdGetWebPageInstantView *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetWebPageInstantView *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetWebPageInstantView");
  M->new_field ("ID");
  M->pack_string (var->url_);
  M->new_field ("url_");
  M->pack_bool (var->force_full_);
  M->new_field ("force_full_");
}
struct TdGetWebPageInstantView *TdStackFetcherGetWebPageInstantView (struct TdStackFetcherMethods *M) {
  auto res = new TdGetWebPageInstantView ();
  res->ID = CODE_GetWebPageInstantView;
  res->refcnt = 1;
  M->get_field ("url_");
  res->url_ = M->get_string ();
  M->pop ();
  M->get_field ("force_full_");
  res->force_full_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdGetWebPagePreview *TdCreateObjectGetWebPagePreview (struct TdFormattedText *text_) {
  auto var = new struct TdGetWebPagePreview ();
  var->ID = CODE_GetWebPagePreview;
  var->refcnt = 1;
  var->text_ = text_;
  return var;
}
td::td_api::object_ptr<td::td_api::getWebPagePreview> TdConvertToInternal (struct TdGetWebPagePreview *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::formattedText> v0;
  v0 = TdConvertToInternal (var->text_);
  return td::td_api::make_object<td::td_api::getWebPagePreview>(std::move (v0));
}
struct TdGetWebPagePreview *TdConvertFromInternal (const td::td_api::getWebPagePreview &from) {
  auto res = new TdGetWebPagePreview ();
  res->ID = CODE_GetWebPagePreview;
  res->refcnt = 1;
  if (!from.text_) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdConvertFromInternal (static_cast<const td::td_api::formattedText &>(*from.text_));
  }
  return res;
}
char *TdSerializeGetWebPagePreview (struct TdGetWebPagePreview *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdGetWebPagePreview *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectGetWebPagePreview (struct TdGetWebPagePreview *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdGetWebPagePreview *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->text_);
  delete var;
}
void TdStackStorerGetWebPagePreview (struct TdGetWebPagePreview *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdGetWebPagePreview *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("GetWebPagePreview");
  M->new_field ("ID");
  TdStackStorer (var->text_, M);
  M->new_field ("text_");
}
struct TdGetWebPagePreview *TdStackFetcherGetWebPagePreview (struct TdStackFetcherMethods *M) {
  auto res = new TdGetWebPagePreview ();
  res->ID = CODE_GetWebPagePreview;
  res->refcnt = 1;
  M->get_field ("text_");
  if (M->is_nil ()) {
    res->text_ = nullptr;
  } else {
    res->text_ = TdStackFetcherFormattedText (M);
  }
  M->pop ();
  return res;
}
struct TdImportContacts *TdCreateObjectImportContacts (struct TdVectorContact *contacts_) {
  auto var = new struct TdImportContacts ();
  var->ID = CODE_ImportContacts;
  var->refcnt = 1;
  var->contacts_ = contacts_;
  return var;
}
td::td_api::object_ptr<td::td_api::importContacts> TdConvertToInternal (struct TdImportContacts *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::contact>> v0;
  for (int i0 = 0; i0 < var->contacts_->len; i0++) {
    td::td_api::object_ptr<td::td_api::contact> v1;
    v1 = TdConvertToInternal (var->contacts_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::importContacts>(std::move (v0));
}
struct TdImportContacts *TdConvertFromInternal (const td::td_api::importContacts &from) {
  auto res = new TdImportContacts ();
  res->ID = CODE_ImportContacts;
  res->refcnt = 1;
  res->contacts_ = new TdVectorContact ();
  res->contacts_->len = (int)from.contacts_.size ();
  res->contacts_->data = new struct TdContact * [res->contacts_->len];
  for (int i0 = 0; i0 < res->contacts_->len; i0++) {
    if (!from.contacts_[i0]) {
      res->contacts_->data[i0] = nullptr;
    } else {
      res->contacts_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::contact &>(*from.contacts_[i0]));
    }
  }
  return res;
}
char *TdSerializeImportContacts (struct TdImportContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdImportContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectImportContacts (struct TdImportContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdImportContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->contacts_->len; i0++) {
    TdDestroyObject (var->contacts_->data[i0]);
  }
  delete[] var->contacts_->data;
  delete var->contacts_;
  delete var;
}
void TdStackStorerImportContacts (struct TdImportContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdImportContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ImportContacts");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->contacts_->len; i0++) {
    TdStackStorer (var->contacts_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("contacts_");
}
struct TdImportContacts *TdStackFetcherImportContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdImportContacts ();
  res->ID = CODE_ImportContacts;
  res->refcnt = 1;
  M->get_field ("contacts_");
  res->contacts_ = new TdVectorContact ();
  res->contacts_->len = M->get_arr_size ();
  res->contacts_->data = new struct TdContact * [res->contacts_->len];
  for (int i0 = 0; i0 < res->contacts_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->contacts_->data[i0] = nullptr;
    } else {
      res->contacts_->data[i0] = TdStackFetcherContact (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdJoinChat *TdCreateObjectJoinChat (long long chat_id_) {
  auto var = new struct TdJoinChat ();
  var->ID = CODE_JoinChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::joinChat> TdConvertToInternal (struct TdJoinChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::joinChat>(std::move (v0));
}
struct TdJoinChat *TdConvertFromInternal (const td::td_api::joinChat &from) {
  auto res = new TdJoinChat ();
  res->ID = CODE_JoinChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeJoinChat (struct TdJoinChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdJoinChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectJoinChat (struct TdJoinChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdJoinChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerJoinChat (struct TdJoinChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdJoinChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("JoinChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdJoinChat *TdStackFetcherJoinChat (struct TdStackFetcherMethods *M) {
  auto res = new TdJoinChat ();
  res->ID = CODE_JoinChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdJoinChatByInviteLink *TdCreateObjectJoinChatByInviteLink (char *invite_link_) {
  auto var = new struct TdJoinChatByInviteLink ();
  var->ID = CODE_JoinChatByInviteLink;
  var->refcnt = 1;
  var->invite_link_ = (invite_link_) ? td::str_dup (td::Slice (invite_link_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::joinChatByInviteLink> TdConvertToInternal (struct TdJoinChatByInviteLink *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->invite_link_) ? var->invite_link_: "";
  return td::td_api::make_object<td::td_api::joinChatByInviteLink>(std::move (v0));
}
struct TdJoinChatByInviteLink *TdConvertFromInternal (const td::td_api::joinChatByInviteLink &from) {
  auto res = new TdJoinChatByInviteLink ();
  res->ID = CODE_JoinChatByInviteLink;
  res->refcnt = 1;
  res->invite_link_ = (from.invite_link_.length ()) ? td::str_dup (from.invite_link_) : nullptr;
  return res;
}
char *TdSerializeJoinChatByInviteLink (struct TdJoinChatByInviteLink *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdJoinChatByInviteLink *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectJoinChatByInviteLink (struct TdJoinChatByInviteLink *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdJoinChatByInviteLink *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->invite_link_);
  delete var;
}
void TdStackStorerJoinChatByInviteLink (struct TdJoinChatByInviteLink *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdJoinChatByInviteLink *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("JoinChatByInviteLink");
  M->new_field ("ID");
  M->pack_string (var->invite_link_);
  M->new_field ("invite_link_");
}
struct TdJoinChatByInviteLink *TdStackFetcherJoinChatByInviteLink (struct TdStackFetcherMethods *M) {
  auto res = new TdJoinChatByInviteLink ();
  res->ID = CODE_JoinChatByInviteLink;
  res->refcnt = 1;
  M->get_field ("invite_link_");
  res->invite_link_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdLeaveChat *TdCreateObjectLeaveChat (long long chat_id_) {
  auto var = new struct TdLeaveChat ();
  var->ID = CODE_LeaveChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::leaveChat> TdConvertToInternal (struct TdLeaveChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::leaveChat>(std::move (v0));
}
struct TdLeaveChat *TdConvertFromInternal (const td::td_api::leaveChat &from) {
  auto res = new TdLeaveChat ();
  res->ID = CODE_LeaveChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeLeaveChat (struct TdLeaveChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLeaveChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLeaveChat (struct TdLeaveChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLeaveChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerLeaveChat (struct TdLeaveChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLeaveChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LeaveChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdLeaveChat *TdStackFetcherLeaveChat (struct TdStackFetcherMethods *M) {
  auto res = new TdLeaveChat ();
  res->ID = CODE_LeaveChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdLogOut *TdCreateObjectLogOut (void) {
  auto var = new struct TdLogOut ();
  var->ID = CODE_LogOut;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::logOut> TdConvertToInternal (struct TdLogOut *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::logOut>();
}
struct TdLogOut *TdConvertFromInternal (const td::td_api::logOut &from) {
  auto res = new TdLogOut ();
  res->ID = CODE_LogOut;
  res->refcnt = 1;
  return res;
}
char *TdSerializeLogOut (struct TdLogOut *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdLogOut *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectLogOut (struct TdLogOut *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdLogOut *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerLogOut (struct TdLogOut *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdLogOut *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("LogOut");
  M->new_field ("ID");
}
struct TdLogOut *TdStackFetcherLogOut (struct TdStackFetcherMethods *M) {
  auto res = new TdLogOut ();
  res->ID = CODE_LogOut;
  res->refcnt = 1;
  return res;
}
struct TdOpenChat *TdCreateObjectOpenChat (long long chat_id_) {
  auto var = new struct TdOpenChat ();
  var->ID = CODE_OpenChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::openChat> TdConvertToInternal (struct TdOpenChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::openChat>(std::move (v0));
}
struct TdOpenChat *TdConvertFromInternal (const td::td_api::openChat &from) {
  auto res = new TdOpenChat ();
  res->ID = CODE_OpenChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeOpenChat (struct TdOpenChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOpenChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOpenChat (struct TdOpenChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOpenChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerOpenChat (struct TdOpenChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOpenChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("OpenChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdOpenChat *TdStackFetcherOpenChat (struct TdStackFetcherMethods *M) {
  auto res = new TdOpenChat ();
  res->ID = CODE_OpenChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdOpenMessageContent *TdCreateObjectOpenMessageContent (long long chat_id_, long long message_id_) {
  auto var = new struct TdOpenMessageContent ();
  var->ID = CODE_OpenMessageContent;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::openMessageContent> TdConvertToInternal (struct TdOpenMessageContent *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  return td::td_api::make_object<td::td_api::openMessageContent>(std::move (v0), std::move (v100));
}
struct TdOpenMessageContent *TdConvertFromInternal (const td::td_api::openMessageContent &from) {
  auto res = new TdOpenMessageContent ();
  res->ID = CODE_OpenMessageContent;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  return res;
}
char *TdSerializeOpenMessageContent (struct TdOpenMessageContent *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOpenMessageContent *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOpenMessageContent (struct TdOpenMessageContent *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOpenMessageContent *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerOpenMessageContent (struct TdOpenMessageContent *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOpenMessageContent *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("OpenMessageContent");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
}
struct TdOpenMessageContent *TdStackFetcherOpenMessageContent (struct TdStackFetcherMethods *M) {
  auto res = new TdOpenMessageContent ();
  res->ID = CODE_OpenMessageContent;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdOptimizeStorage *TdCreateObjectOptimizeStorage (long long size_, int ttl_, int count_, int immunity_delay_, struct TdVectorFileType *file_types_, struct TdVectorLong *chat_ids_, struct TdVectorLong *exclude_chat_ids_, int chat_limit_) {
  auto var = new struct TdOptimizeStorage ();
  var->ID = CODE_OptimizeStorage;
  var->refcnt = 1;
  var->size_ = size_;
  var->ttl_ = ttl_;
  var->count_ = count_;
  var->immunity_delay_ = immunity_delay_;
  var->file_types_ = file_types_;
  var->chat_ids_ = chat_ids_;
  var->exclude_chat_ids_ = exclude_chat_ids_;
  var->chat_limit_ = chat_limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::optimizeStorage> TdConvertToInternal (struct TdOptimizeStorage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->size_;
  std::int32_t v100;
  v100 = var->ttl_;
  std::int32_t v200;
  v200 = var->count_;
  std::int32_t v300;
  v300 = var->immunity_delay_;
  std::vector<td::td_api::object_ptr<td::td_api::FileType>> v400;
  for (int i400 = 0; i400 < var->file_types_->len; i400++) {
    td::td_api::object_ptr<td::td_api::FileType> v401;
    v401 = TdConvertToInternal (var->file_types_->data[i400]);
    v400.push_back (std::move (v401));
  }
  std::vector<std::int64_t> v500;
  for (int i500 = 0; i500 < var->chat_ids_->len; i500++) {
    std::int64_t v501;
    v501 = var->chat_ids_->data[i500];
    v500.push_back (std::move (v501));
  }
  std::vector<std::int64_t> v600;
  for (int i600 = 0; i600 < var->exclude_chat_ids_->len; i600++) {
    std::int64_t v601;
    v601 = var->exclude_chat_ids_->data[i600];
    v600.push_back (std::move (v601));
  }
  std::int32_t v700;
  v700 = var->chat_limit_;
  return td::td_api::make_object<td::td_api::optimizeStorage>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600), std::move (v700));
}
struct TdOptimizeStorage *TdConvertFromInternal (const td::td_api::optimizeStorage &from) {
  auto res = new TdOptimizeStorage ();
  res->ID = CODE_OptimizeStorage;
  res->refcnt = 1;
  res->size_ = from.size_;
  res->ttl_ = from.ttl_;
  res->count_ = from.count_;
  res->immunity_delay_ = from.immunity_delay_;
  res->file_types_ = new TdVectorFileType ();
  res->file_types_->len = (int)from.file_types_.size ();
  res->file_types_->data = new struct TdFileType * [res->file_types_->len];
  for (int i400 = 0; i400 < res->file_types_->len; i400++) {
    if (!from.file_types_[i400]) {
      res->file_types_->data[i400] = nullptr;
    } else {
      res->file_types_->data[i400] = TdConvertFromInternal (static_cast<const td::td_api::FileType &>(*from.file_types_[i400]));
    }
  }
  res->chat_ids_ = new TdVectorLong ();
  res->chat_ids_->len = (int)from.chat_ids_.size ();
  res->chat_ids_->data = new long long  [res->chat_ids_->len];
  for (int i500 = 0; i500 < res->chat_ids_->len; i500++) {
    res->chat_ids_->data[i500] = from.chat_ids_[i500];
  }
  res->exclude_chat_ids_ = new TdVectorLong ();
  res->exclude_chat_ids_->len = (int)from.exclude_chat_ids_.size ();
  res->exclude_chat_ids_->data = new long long  [res->exclude_chat_ids_->len];
  for (int i600 = 0; i600 < res->exclude_chat_ids_->len; i600++) {
    res->exclude_chat_ids_->data[i600] = from.exclude_chat_ids_[i600];
  }
  res->chat_limit_ = from.chat_limit_;
  return res;
}
char *TdSerializeOptimizeStorage (struct TdOptimizeStorage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdOptimizeStorage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectOptimizeStorage (struct TdOptimizeStorage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdOptimizeStorage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i400 = 0; i400 < var->file_types_->len; i400++) {
    TdDestroyObject (var->file_types_->data[i400]);
  }
  delete[] var->file_types_->data;
  delete var->file_types_;
  for (int i500 = 0; i500 < var->chat_ids_->len; i500++) {
  }
  delete[] var->chat_ids_->data;
  delete var->chat_ids_;
  for (int i600 = 0; i600 < var->exclude_chat_ids_->len; i600++) {
  }
  delete[] var->exclude_chat_ids_->data;
  delete var->exclude_chat_ids_;
  delete var;
}
void TdStackStorerOptimizeStorage (struct TdOptimizeStorage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdOptimizeStorage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("OptimizeStorage");
  M->new_field ("ID");
  M->pack_long (var->size_);
  M->new_field ("size_");
  M->pack_long (var->ttl_);
  M->new_field ("ttl_");
  M->pack_long (var->count_);
  M->new_field ("count_");
  M->pack_long (var->immunity_delay_);
  M->new_field ("immunity_delay_");
  M->new_array ();
  for (int i400 = 0; i400 < var->file_types_->len; i400++) {
    TdStackStorer (var->file_types_->data[i400], M);
    M->new_arr_field (i400);
  }
  M->new_field ("file_types_");
  M->new_array ();
  for (int i500 = 0; i500 < var->chat_ids_->len; i500++) {
    M->pack_long (var->chat_ids_->data[i500]);
    M->new_arr_field (i500);
  }
  M->new_field ("chat_ids_");
  M->new_array ();
  for (int i600 = 0; i600 < var->exclude_chat_ids_->len; i600++) {
    M->pack_long (var->exclude_chat_ids_->data[i600]);
    M->new_arr_field (i600);
  }
  M->new_field ("exclude_chat_ids_");
  M->pack_long (var->chat_limit_);
  M->new_field ("chat_limit_");
}
struct TdOptimizeStorage *TdStackFetcherOptimizeStorage (struct TdStackFetcherMethods *M) {
  auto res = new TdOptimizeStorage ();
  res->ID = CODE_OptimizeStorage;
  res->refcnt = 1;
  M->get_field ("size_");
  res->size_ = M->get_long ();
  M->pop ();
  M->get_field ("ttl_");
  res->ttl_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("count_");
  res->count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("immunity_delay_");
  res->immunity_delay_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("file_types_");
  res->file_types_ = new TdVectorFileType ();
  res->file_types_->len = M->get_arr_size ();
  res->file_types_->data = new struct TdFileType * [res->file_types_->len];
  for (int i400 = 0; i400 < res->file_types_->len; i400++) {
    M->get_arr_field (i400);
    if (M->is_nil ()) {
      res->file_types_->data[i400] = nullptr;
    } else {
      res->file_types_->data[i400] = TdStackFetcherFileType (M);
    }
    M->pop ();
  }
  M->pop ();
  M->get_field ("chat_ids_");
  res->chat_ids_ = new TdVectorLong ();
  res->chat_ids_->len = M->get_arr_size ();
  res->chat_ids_->data = new long long  [res->chat_ids_->len];
  for (int i500 = 0; i500 < res->chat_ids_->len; i500++) {
    M->get_arr_field (i500);
    res->chat_ids_->data[i500] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("exclude_chat_ids_");
  res->exclude_chat_ids_ = new TdVectorLong ();
  res->exclude_chat_ids_->len = M->get_arr_size ();
  res->exclude_chat_ids_->data = new long long  [res->exclude_chat_ids_->len];
  for (int i600 = 0; i600 < res->exclude_chat_ids_->len; i600++) {
    M->get_arr_field (i600);
    res->exclude_chat_ids_->data[i600] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("chat_limit_");
  res->chat_limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdParseTextEntities *TdCreateObjectParseTextEntities (char *text_, struct TdTextParseMode *parse_mode_) {
  auto var = new struct TdParseTextEntities ();
  var->ID = CODE_ParseTextEntities;
  var->refcnt = 1;
  var->text_ = (text_) ? td::str_dup (td::Slice (text_)) : nullptr;
  var->parse_mode_ = parse_mode_;
  return var;
}
td::td_api::object_ptr<td::td_api::parseTextEntities> TdConvertToInternal (struct TdParseTextEntities *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->text_) ? var->text_: "";
  td::td_api::object_ptr<td::td_api::TextParseMode> v100;
  v100 = TdConvertToInternal (var->parse_mode_);
  return td::td_api::make_object<td::td_api::parseTextEntities>(std::move (v0), std::move (v100));
}
struct TdParseTextEntities *TdConvertFromInternal (const td::td_api::parseTextEntities &from) {
  auto res = new TdParseTextEntities ();
  res->ID = CODE_ParseTextEntities;
  res->refcnt = 1;
  res->text_ = (from.text_.length ()) ? td::str_dup (from.text_) : nullptr;
  if (!from.parse_mode_) {
    res->parse_mode_ = nullptr;
  } else {
    res->parse_mode_ = TdConvertFromInternal (static_cast<const td::td_api::TextParseMode &>(*from.parse_mode_));
  }
  return res;
}
char *TdSerializeParseTextEntities (struct TdParseTextEntities *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdParseTextEntities *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectParseTextEntities (struct TdParseTextEntities *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdParseTextEntities *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->text_);
  TdDestroyObject (var->parse_mode_);
  delete var;
}
void TdStackStorerParseTextEntities (struct TdParseTextEntities *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdParseTextEntities *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ParseTextEntities");
  M->new_field ("ID");
  M->pack_string (var->text_);
  M->new_field ("text_");
  TdStackStorer (var->parse_mode_, M);
  M->new_field ("parse_mode_");
}
struct TdParseTextEntities *TdStackFetcherParseTextEntities (struct TdStackFetcherMethods *M) {
  auto res = new TdParseTextEntities ();
  res->ID = CODE_ParseTextEntities;
  res->refcnt = 1;
  M->get_field ("text_");
  res->text_ = M->get_string ();
  M->pop ();
  M->get_field ("parse_mode_");
  if (M->is_nil ()) {
    res->parse_mode_ = nullptr;
  } else {
    res->parse_mode_ = TdStackFetcherTextParseMode (M);
  }
  M->pop ();
  return res;
}
struct TdPinSupergroupMessage *TdCreateObjectPinSupergroupMessage (int supergroup_id_, long long message_id_, int disable_notification_) {
  auto var = new struct TdPinSupergroupMessage ();
  var->ID = CODE_PinSupergroupMessage;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->message_id_ = message_id_;
  var->disable_notification_ = disable_notification_;
  return var;
}
td::td_api::object_ptr<td::td_api::pinSupergroupMessage> TdConvertToInternal (struct TdPinSupergroupMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  bool v200;
  v200 = var->disable_notification_ != 0;
  return td::td_api::make_object<td::td_api::pinSupergroupMessage>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdPinSupergroupMessage *TdConvertFromInternal (const td::td_api::pinSupergroupMessage &from) {
  auto res = new TdPinSupergroupMessage ();
  res->ID = CODE_PinSupergroupMessage;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->message_id_ = from.message_id_;
  res->disable_notification_ = from.disable_notification_;
  return res;
}
char *TdSerializePinSupergroupMessage (struct TdPinSupergroupMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPinSupergroupMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPinSupergroupMessage (struct TdPinSupergroupMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPinSupergroupMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPinSupergroupMessage (struct TdPinSupergroupMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPinSupergroupMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PinSupergroupMessage");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_bool (var->disable_notification_);
  M->new_field ("disable_notification_");
}
struct TdPinSupergroupMessage *TdStackFetcherPinSupergroupMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdPinSupergroupMessage ();
  res->ID = CODE_PinSupergroupMessage;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("disable_notification_");
  res->disable_notification_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdPingProxy *TdCreateObjectPingProxy (int proxy_id_) {
  auto var = new struct TdPingProxy ();
  var->ID = CODE_PingProxy;
  var->refcnt = 1;
  var->proxy_id_ = proxy_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::pingProxy> TdConvertToInternal (struct TdPingProxy *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->proxy_id_;
  return td::td_api::make_object<td::td_api::pingProxy>(std::move (v0));
}
struct TdPingProxy *TdConvertFromInternal (const td::td_api::pingProxy &from) {
  auto res = new TdPingProxy ();
  res->ID = CODE_PingProxy;
  res->refcnt = 1;
  res->proxy_id_ = from.proxy_id_;
  return res;
}
char *TdSerializePingProxy (struct TdPingProxy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdPingProxy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectPingProxy (struct TdPingProxy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdPingProxy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerPingProxy (struct TdPingProxy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdPingProxy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("PingProxy");
  M->new_field ("ID");
  M->pack_long (var->proxy_id_);
  M->new_field ("proxy_id_");
}
struct TdPingProxy *TdStackFetcherPingProxy (struct TdStackFetcherMethods *M) {
  auto res = new TdPingProxy ();
  res->ID = CODE_PingProxy;
  res->refcnt = 1;
  M->get_field ("proxy_id_");
  res->proxy_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdProcessDcUpdate *TdCreateObjectProcessDcUpdate (char *dc_, char *addr_) {
  auto var = new struct TdProcessDcUpdate ();
  var->ID = CODE_ProcessDcUpdate;
  var->refcnt = 1;
  var->dc_ = (dc_) ? td::str_dup (td::Slice (dc_)) : nullptr;
  var->addr_ = (addr_) ? td::str_dup (td::Slice (addr_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::processDcUpdate> TdConvertToInternal (struct TdProcessDcUpdate *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->dc_) ? var->dc_: "";
  std::string v100;
  v100 = (var->addr_) ? var->addr_: "";
  return td::td_api::make_object<td::td_api::processDcUpdate>(std::move (v0), std::move (v100));
}
struct TdProcessDcUpdate *TdConvertFromInternal (const td::td_api::processDcUpdate &from) {
  auto res = new TdProcessDcUpdate ();
  res->ID = CODE_ProcessDcUpdate;
  res->refcnt = 1;
  res->dc_ = (from.dc_.length ()) ? td::str_dup (from.dc_) : nullptr;
  res->addr_ = (from.addr_.length ()) ? td::str_dup (from.addr_) : nullptr;
  return res;
}
char *TdSerializeProcessDcUpdate (struct TdProcessDcUpdate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdProcessDcUpdate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectProcessDcUpdate (struct TdProcessDcUpdate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdProcessDcUpdate *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->dc_);
  free (var->addr_);
  delete var;
}
void TdStackStorerProcessDcUpdate (struct TdProcessDcUpdate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdProcessDcUpdate *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ProcessDcUpdate");
  M->new_field ("ID");
  M->pack_string (var->dc_);
  M->new_field ("dc_");
  M->pack_string (var->addr_);
  M->new_field ("addr_");
}
struct TdProcessDcUpdate *TdStackFetcherProcessDcUpdate (struct TdStackFetcherMethods *M) {
  auto res = new TdProcessDcUpdate ();
  res->ID = CODE_ProcessDcUpdate;
  res->refcnt = 1;
  M->get_field ("dc_");
  res->dc_ = M->get_string ();
  M->pop ();
  M->get_field ("addr_");
  res->addr_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdReadAllChatMentions *TdCreateObjectReadAllChatMentions (long long chat_id_) {
  auto var = new struct TdReadAllChatMentions ();
  var->ID = CODE_ReadAllChatMentions;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::readAllChatMentions> TdConvertToInternal (struct TdReadAllChatMentions *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::readAllChatMentions>(std::move (v0));
}
struct TdReadAllChatMentions *TdConvertFromInternal (const td::td_api::readAllChatMentions &from) {
  auto res = new TdReadAllChatMentions ();
  res->ID = CODE_ReadAllChatMentions;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeReadAllChatMentions (struct TdReadAllChatMentions *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReadAllChatMentions *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReadAllChatMentions (struct TdReadAllChatMentions *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReadAllChatMentions *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerReadAllChatMentions (struct TdReadAllChatMentions *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReadAllChatMentions *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ReadAllChatMentions");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdReadAllChatMentions *TdStackFetcherReadAllChatMentions (struct TdStackFetcherMethods *M) {
  auto res = new TdReadAllChatMentions ();
  res->ID = CODE_ReadAllChatMentions;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdRecoverAuthenticationPassword *TdCreateObjectRecoverAuthenticationPassword (char *recovery_code_) {
  auto var = new struct TdRecoverAuthenticationPassword ();
  var->ID = CODE_RecoverAuthenticationPassword;
  var->refcnt = 1;
  var->recovery_code_ = (recovery_code_) ? td::str_dup (td::Slice (recovery_code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::recoverAuthenticationPassword> TdConvertToInternal (struct TdRecoverAuthenticationPassword *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->recovery_code_) ? var->recovery_code_: "";
  return td::td_api::make_object<td::td_api::recoverAuthenticationPassword>(std::move (v0));
}
struct TdRecoverAuthenticationPassword *TdConvertFromInternal (const td::td_api::recoverAuthenticationPassword &from) {
  auto res = new TdRecoverAuthenticationPassword ();
  res->ID = CODE_RecoverAuthenticationPassword;
  res->refcnt = 1;
  res->recovery_code_ = (from.recovery_code_.length ()) ? td::str_dup (from.recovery_code_) : nullptr;
  return res;
}
char *TdSerializeRecoverAuthenticationPassword (struct TdRecoverAuthenticationPassword *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRecoverAuthenticationPassword *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRecoverAuthenticationPassword (struct TdRecoverAuthenticationPassword *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRecoverAuthenticationPassword *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->recovery_code_);
  delete var;
}
void TdStackStorerRecoverAuthenticationPassword (struct TdRecoverAuthenticationPassword *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRecoverAuthenticationPassword *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RecoverAuthenticationPassword");
  M->new_field ("ID");
  M->pack_string (var->recovery_code_);
  M->new_field ("recovery_code_");
}
struct TdRecoverAuthenticationPassword *TdStackFetcherRecoverAuthenticationPassword (struct TdStackFetcherMethods *M) {
  auto res = new TdRecoverAuthenticationPassword ();
  res->ID = CODE_RecoverAuthenticationPassword;
  res->refcnt = 1;
  M->get_field ("recovery_code_");
  res->recovery_code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdRecoverPassword *TdCreateObjectRecoverPassword (char *recovery_code_) {
  auto var = new struct TdRecoverPassword ();
  var->ID = CODE_RecoverPassword;
  var->refcnt = 1;
  var->recovery_code_ = (recovery_code_) ? td::str_dup (td::Slice (recovery_code_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::recoverPassword> TdConvertToInternal (struct TdRecoverPassword *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->recovery_code_) ? var->recovery_code_: "";
  return td::td_api::make_object<td::td_api::recoverPassword>(std::move (v0));
}
struct TdRecoverPassword *TdConvertFromInternal (const td::td_api::recoverPassword &from) {
  auto res = new TdRecoverPassword ();
  res->ID = CODE_RecoverPassword;
  res->refcnt = 1;
  res->recovery_code_ = (from.recovery_code_.length ()) ? td::str_dup (from.recovery_code_) : nullptr;
  return res;
}
char *TdSerializeRecoverPassword (struct TdRecoverPassword *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRecoverPassword *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRecoverPassword (struct TdRecoverPassword *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRecoverPassword *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->recovery_code_);
  delete var;
}
void TdStackStorerRecoverPassword (struct TdRecoverPassword *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRecoverPassword *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RecoverPassword");
  M->new_field ("ID");
  M->pack_string (var->recovery_code_);
  M->new_field ("recovery_code_");
}
struct TdRecoverPassword *TdStackFetcherRecoverPassword (struct TdStackFetcherMethods *M) {
  auto res = new TdRecoverPassword ();
  res->ID = CODE_RecoverPassword;
  res->refcnt = 1;
  M->get_field ("recovery_code_");
  res->recovery_code_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdRegisterDevice *TdCreateObjectRegisterDevice (struct TdDeviceToken *device_token_, struct TdVectorInt *other_user_ids_) {
  auto var = new struct TdRegisterDevice ();
  var->ID = CODE_RegisterDevice;
  var->refcnt = 1;
  var->device_token_ = device_token_;
  var->other_user_ids_ = other_user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::registerDevice> TdConvertToInternal (struct TdRegisterDevice *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::DeviceToken> v0;
  v0 = TdConvertToInternal (var->device_token_);
  std::vector<std::int32_t> v100;
  for (int i100 = 0; i100 < var->other_user_ids_->len; i100++) {
    std::int32_t v101;
    v101 = var->other_user_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::registerDevice>(std::move (v0), std::move (v100));
}
struct TdRegisterDevice *TdConvertFromInternal (const td::td_api::registerDevice &from) {
  auto res = new TdRegisterDevice ();
  res->ID = CODE_RegisterDevice;
  res->refcnt = 1;
  if (!from.device_token_) {
    res->device_token_ = nullptr;
  } else {
    res->device_token_ = TdConvertFromInternal (static_cast<const td::td_api::DeviceToken &>(*from.device_token_));
  }
  res->other_user_ids_ = new TdVectorInt ();
  res->other_user_ids_->len = (int)from.other_user_ids_.size ();
  res->other_user_ids_->data = new int  [res->other_user_ids_->len];
  for (int i100 = 0; i100 < res->other_user_ids_->len; i100++) {
    res->other_user_ids_->data[i100] = from.other_user_ids_[i100];
  }
  return res;
}
char *TdSerializeRegisterDevice (struct TdRegisterDevice *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRegisterDevice *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRegisterDevice (struct TdRegisterDevice *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRegisterDevice *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->device_token_);
  for (int i100 = 0; i100 < var->other_user_ids_->len; i100++) {
  }
  delete[] var->other_user_ids_->data;
  delete var->other_user_ids_;
  delete var;
}
void TdStackStorerRegisterDevice (struct TdRegisterDevice *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRegisterDevice *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RegisterDevice");
  M->new_field ("ID");
  TdStackStorer (var->device_token_, M);
  M->new_field ("device_token_");
  M->new_array ();
  for (int i100 = 0; i100 < var->other_user_ids_->len; i100++) {
    M->pack_long (var->other_user_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("other_user_ids_");
}
struct TdRegisterDevice *TdStackFetcherRegisterDevice (struct TdStackFetcherMethods *M) {
  auto res = new TdRegisterDevice ();
  res->ID = CODE_RegisterDevice;
  res->refcnt = 1;
  M->get_field ("device_token_");
  if (M->is_nil ()) {
    res->device_token_ = nullptr;
  } else {
    res->device_token_ = TdStackFetcherDeviceToken (M);
  }
  M->pop ();
  M->get_field ("other_user_ids_");
  res->other_user_ids_ = new TdVectorInt ();
  res->other_user_ids_->len = M->get_arr_size ();
  res->other_user_ids_->data = new int  [res->other_user_ids_->len];
  for (int i100 = 0; i100 < res->other_user_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->other_user_ids_->data[i100] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdRemoveContacts *TdCreateObjectRemoveContacts (struct TdVectorInt *user_ids_) {
  auto var = new struct TdRemoveContacts ();
  var->ID = CODE_RemoveContacts;
  var->refcnt = 1;
  var->user_ids_ = user_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::removeContacts> TdConvertToInternal (struct TdRemoveContacts *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    std::int32_t v1;
    v1 = var->user_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::removeContacts>(std::move (v0));
}
struct TdRemoveContacts *TdConvertFromInternal (const td::td_api::removeContacts &from) {
  auto res = new TdRemoveContacts ();
  res->ID = CODE_RemoveContacts;
  res->refcnt = 1;
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = (int)from.user_ids_.size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    res->user_ids_->data[i0] = from.user_ids_[i0];
  }
  return res;
}
char *TdSerializeRemoveContacts (struct TdRemoveContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveContacts (struct TdRemoveContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
  }
  delete[] var->user_ids_->data;
  delete var->user_ids_;
  delete var;
}
void TdStackStorerRemoveContacts (struct TdRemoveContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveContacts");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->user_ids_->len; i0++) {
    M->pack_long (var->user_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("user_ids_");
}
struct TdRemoveContacts *TdStackFetcherRemoveContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveContacts ();
  res->ID = CODE_RemoveContacts;
  res->refcnt = 1;
  M->get_field ("user_ids_");
  res->user_ids_ = new TdVectorInt ();
  res->user_ids_->len = M->get_arr_size ();
  res->user_ids_->data = new int  [res->user_ids_->len];
  for (int i0 = 0; i0 < res->user_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->user_ids_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdRemoveFavoriteSticker *TdCreateObjectRemoveFavoriteSticker (struct TdInputFile *sticker_) {
  auto var = new struct TdRemoveFavoriteSticker ();
  var->ID = CODE_RemoveFavoriteSticker;
  var->refcnt = 1;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::removeFavoriteSticker> TdConvertToInternal (struct TdRemoveFavoriteSticker *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::removeFavoriteSticker>(std::move (v0));
}
struct TdRemoveFavoriteSticker *TdConvertFromInternal (const td::td_api::removeFavoriteSticker &from) {
  auto res = new TdRemoveFavoriteSticker ();
  res->ID = CODE_RemoveFavoriteSticker;
  res->refcnt = 1;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeRemoveFavoriteSticker (struct TdRemoveFavoriteSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveFavoriteSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveFavoriteSticker (struct TdRemoveFavoriteSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveFavoriteSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerRemoveFavoriteSticker (struct TdRemoveFavoriteSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveFavoriteSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveFavoriteSticker");
  M->new_field ("ID");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdRemoveFavoriteSticker *TdStackFetcherRemoveFavoriteSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveFavoriteSticker ();
  res->ID = CODE_RemoveFavoriteSticker;
  res->refcnt = 1;
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdRemoveProxy *TdCreateObjectRemoveProxy (int proxy_id_) {
  auto var = new struct TdRemoveProxy ();
  var->ID = CODE_RemoveProxy;
  var->refcnt = 1;
  var->proxy_id_ = proxy_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::removeProxy> TdConvertToInternal (struct TdRemoveProxy *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->proxy_id_;
  return td::td_api::make_object<td::td_api::removeProxy>(std::move (v0));
}
struct TdRemoveProxy *TdConvertFromInternal (const td::td_api::removeProxy &from) {
  auto res = new TdRemoveProxy ();
  res->ID = CODE_RemoveProxy;
  res->refcnt = 1;
  res->proxy_id_ = from.proxy_id_;
  return res;
}
char *TdSerializeRemoveProxy (struct TdRemoveProxy *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveProxy *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveProxy (struct TdRemoveProxy *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveProxy *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerRemoveProxy (struct TdRemoveProxy *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveProxy *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveProxy");
  M->new_field ("ID");
  M->pack_long (var->proxy_id_);
  M->new_field ("proxy_id_");
}
struct TdRemoveProxy *TdStackFetcherRemoveProxy (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveProxy ();
  res->ID = CODE_RemoveProxy;
  res->refcnt = 1;
  M->get_field ("proxy_id_");
  res->proxy_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdRemoveRecentHashtag *TdCreateObjectRemoveRecentHashtag (char *hashtag_) {
  auto var = new struct TdRemoveRecentHashtag ();
  var->ID = CODE_RemoveRecentHashtag;
  var->refcnt = 1;
  var->hashtag_ = (hashtag_) ? td::str_dup (td::Slice (hashtag_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::removeRecentHashtag> TdConvertToInternal (struct TdRemoveRecentHashtag *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->hashtag_) ? var->hashtag_: "";
  return td::td_api::make_object<td::td_api::removeRecentHashtag>(std::move (v0));
}
struct TdRemoveRecentHashtag *TdConvertFromInternal (const td::td_api::removeRecentHashtag &from) {
  auto res = new TdRemoveRecentHashtag ();
  res->ID = CODE_RemoveRecentHashtag;
  res->refcnt = 1;
  res->hashtag_ = (from.hashtag_.length ()) ? td::str_dup (from.hashtag_) : nullptr;
  return res;
}
char *TdSerializeRemoveRecentHashtag (struct TdRemoveRecentHashtag *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveRecentHashtag *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveRecentHashtag (struct TdRemoveRecentHashtag *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveRecentHashtag *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->hashtag_);
  delete var;
}
void TdStackStorerRemoveRecentHashtag (struct TdRemoveRecentHashtag *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveRecentHashtag *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveRecentHashtag");
  M->new_field ("ID");
  M->pack_string (var->hashtag_);
  M->new_field ("hashtag_");
}
struct TdRemoveRecentHashtag *TdStackFetcherRemoveRecentHashtag (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveRecentHashtag ();
  res->ID = CODE_RemoveRecentHashtag;
  res->refcnt = 1;
  M->get_field ("hashtag_");
  res->hashtag_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdRemoveRecentSticker *TdCreateObjectRemoveRecentSticker (int is_attached_, struct TdInputFile *sticker_) {
  auto var = new struct TdRemoveRecentSticker ();
  var->ID = CODE_RemoveRecentSticker;
  var->refcnt = 1;
  var->is_attached_ = is_attached_;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::removeRecentSticker> TdConvertToInternal (struct TdRemoveRecentSticker *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_attached_ != 0;
  td::td_api::object_ptr<td::td_api::InputFile> v100;
  v100 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::removeRecentSticker>(std::move (v0), std::move (v100));
}
struct TdRemoveRecentSticker *TdConvertFromInternal (const td::td_api::removeRecentSticker &from) {
  auto res = new TdRemoveRecentSticker ();
  res->ID = CODE_RemoveRecentSticker;
  res->refcnt = 1;
  res->is_attached_ = from.is_attached_;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeRemoveRecentSticker (struct TdRemoveRecentSticker *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveRecentSticker *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveRecentSticker (struct TdRemoveRecentSticker *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveRecentSticker *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerRemoveRecentSticker (struct TdRemoveRecentSticker *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveRecentSticker *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveRecentSticker");
  M->new_field ("ID");
  M->pack_bool (var->is_attached_);
  M->new_field ("is_attached_");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdRemoveRecentSticker *TdStackFetcherRemoveRecentSticker (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveRecentSticker ();
  res->ID = CODE_RemoveRecentSticker;
  res->refcnt = 1;
  M->get_field ("is_attached_");
  res->is_attached_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdRemoveRecentlyFoundChat *TdCreateObjectRemoveRecentlyFoundChat (long long chat_id_) {
  auto var = new struct TdRemoveRecentlyFoundChat ();
  var->ID = CODE_RemoveRecentlyFoundChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::removeRecentlyFoundChat> TdConvertToInternal (struct TdRemoveRecentlyFoundChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::removeRecentlyFoundChat>(std::move (v0));
}
struct TdRemoveRecentlyFoundChat *TdConvertFromInternal (const td::td_api::removeRecentlyFoundChat &from) {
  auto res = new TdRemoveRecentlyFoundChat ();
  res->ID = CODE_RemoveRecentlyFoundChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeRemoveRecentlyFoundChat (struct TdRemoveRecentlyFoundChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveRecentlyFoundChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveRecentlyFoundChat (struct TdRemoveRecentlyFoundChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveRecentlyFoundChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerRemoveRecentlyFoundChat (struct TdRemoveRecentlyFoundChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveRecentlyFoundChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveRecentlyFoundChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdRemoveRecentlyFoundChat *TdStackFetcherRemoveRecentlyFoundChat (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveRecentlyFoundChat ();
  res->ID = CODE_RemoveRecentlyFoundChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdRemoveSavedAnimation *TdCreateObjectRemoveSavedAnimation (struct TdInputFile *animation_) {
  auto var = new struct TdRemoveSavedAnimation ();
  var->ID = CODE_RemoveSavedAnimation;
  var->refcnt = 1;
  var->animation_ = animation_;
  return var;
}
td::td_api::object_ptr<td::td_api::removeSavedAnimation> TdConvertToInternal (struct TdRemoveSavedAnimation *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->animation_);
  return td::td_api::make_object<td::td_api::removeSavedAnimation>(std::move (v0));
}
struct TdRemoveSavedAnimation *TdConvertFromInternal (const td::td_api::removeSavedAnimation &from) {
  auto res = new TdRemoveSavedAnimation ();
  res->ID = CODE_RemoveSavedAnimation;
  res->refcnt = 1;
  if (!from.animation_) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.animation_));
  }
  return res;
}
char *TdSerializeRemoveSavedAnimation (struct TdRemoveSavedAnimation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveSavedAnimation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveSavedAnimation (struct TdRemoveSavedAnimation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveSavedAnimation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->animation_);
  delete var;
}
void TdStackStorerRemoveSavedAnimation (struct TdRemoveSavedAnimation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveSavedAnimation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveSavedAnimation");
  M->new_field ("ID");
  TdStackStorer (var->animation_, M);
  M->new_field ("animation_");
}
struct TdRemoveSavedAnimation *TdStackFetcherRemoveSavedAnimation (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveSavedAnimation ();
  res->ID = CODE_RemoveSavedAnimation;
  res->refcnt = 1;
  M->get_field ("animation_");
  if (M->is_nil ()) {
    res->animation_ = nullptr;
  } else {
    res->animation_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdRemoveStickerFromSet *TdCreateObjectRemoveStickerFromSet (struct TdInputFile *sticker_) {
  auto var = new struct TdRemoveStickerFromSet ();
  var->ID = CODE_RemoveStickerFromSet;
  var->refcnt = 1;
  var->sticker_ = sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::removeStickerFromSet> TdConvertToInternal (struct TdRemoveStickerFromSet *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->sticker_);
  return td::td_api::make_object<td::td_api::removeStickerFromSet>(std::move (v0));
}
struct TdRemoveStickerFromSet *TdConvertFromInternal (const td::td_api::removeStickerFromSet &from) {
  auto res = new TdRemoveStickerFromSet ();
  res->ID = CODE_RemoveStickerFromSet;
  res->refcnt = 1;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.sticker_));
  }
  return res;
}
char *TdSerializeRemoveStickerFromSet (struct TdRemoveStickerFromSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveStickerFromSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveStickerFromSet (struct TdRemoveStickerFromSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveStickerFromSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerRemoveStickerFromSet (struct TdRemoveStickerFromSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveStickerFromSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveStickerFromSet");
  M->new_field ("ID");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
}
struct TdRemoveStickerFromSet *TdStackFetcherRemoveStickerFromSet (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveStickerFromSet ();
  res->ID = CODE_RemoveStickerFromSet;
  res->refcnt = 1;
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdRemoveTopChat *TdCreateObjectRemoveTopChat (struct TdTopChatCategory *category_, long long chat_id_) {
  auto var = new struct TdRemoveTopChat ();
  var->ID = CODE_RemoveTopChat;
  var->refcnt = 1;
  var->category_ = category_;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::removeTopChat> TdConvertToInternal (struct TdRemoveTopChat *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::TopChatCategory> v0;
  v0 = TdConvertToInternal (var->category_);
  std::int64_t v100;
  v100 = var->chat_id_;
  return td::td_api::make_object<td::td_api::removeTopChat>(std::move (v0), std::move (v100));
}
struct TdRemoveTopChat *TdConvertFromInternal (const td::td_api::removeTopChat &from) {
  auto res = new TdRemoveTopChat ();
  res->ID = CODE_RemoveTopChat;
  res->refcnt = 1;
  if (!from.category_) {
    res->category_ = nullptr;
  } else {
    res->category_ = TdConvertFromInternal (static_cast<const td::td_api::TopChatCategory &>(*from.category_));
  }
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeRemoveTopChat (struct TdRemoveTopChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRemoveTopChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRemoveTopChat (struct TdRemoveTopChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRemoveTopChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->category_);
  delete var;
}
void TdStackStorerRemoveTopChat (struct TdRemoveTopChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRemoveTopChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RemoveTopChat");
  M->new_field ("ID");
  TdStackStorer (var->category_, M);
  M->new_field ("category_");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdRemoveTopChat *TdStackFetcherRemoveTopChat (struct TdStackFetcherMethods *M) {
  auto res = new TdRemoveTopChat ();
  res->ID = CODE_RemoveTopChat;
  res->refcnt = 1;
  M->get_field ("category_");
  if (M->is_nil ()) {
    res->category_ = nullptr;
  } else {
    res->category_ = TdStackFetcherTopChatCategory (M);
  }
  M->pop ();
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdReorderInstalledStickerSets *TdCreateObjectReorderInstalledStickerSets (int is_masks_, struct TdVectorLong *sticker_set_ids_) {
  auto var = new struct TdReorderInstalledStickerSets ();
  var->ID = CODE_ReorderInstalledStickerSets;
  var->refcnt = 1;
  var->is_masks_ = is_masks_;
  var->sticker_set_ids_ = sticker_set_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::reorderInstalledStickerSets> TdConvertToInternal (struct TdReorderInstalledStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_masks_ != 0;
  std::vector<std::int64_t> v100;
  for (int i100 = 0; i100 < var->sticker_set_ids_->len; i100++) {
    std::int64_t v101;
    v101 = var->sticker_set_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::reorderInstalledStickerSets>(std::move (v0), std::move (v100));
}
struct TdReorderInstalledStickerSets *TdConvertFromInternal (const td::td_api::reorderInstalledStickerSets &from) {
  auto res = new TdReorderInstalledStickerSets ();
  res->ID = CODE_ReorderInstalledStickerSets;
  res->refcnt = 1;
  res->is_masks_ = from.is_masks_;
  res->sticker_set_ids_ = new TdVectorLong ();
  res->sticker_set_ids_->len = (int)from.sticker_set_ids_.size ();
  res->sticker_set_ids_->data = new long long  [res->sticker_set_ids_->len];
  for (int i100 = 0; i100 < res->sticker_set_ids_->len; i100++) {
    res->sticker_set_ids_->data[i100] = from.sticker_set_ids_[i100];
  }
  return res;
}
char *TdSerializeReorderInstalledStickerSets (struct TdReorderInstalledStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReorderInstalledStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReorderInstalledStickerSets (struct TdReorderInstalledStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReorderInstalledStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->sticker_set_ids_->len; i100++) {
  }
  delete[] var->sticker_set_ids_->data;
  delete var->sticker_set_ids_;
  delete var;
}
void TdStackStorerReorderInstalledStickerSets (struct TdReorderInstalledStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReorderInstalledStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ReorderInstalledStickerSets");
  M->new_field ("ID");
  M->pack_bool (var->is_masks_);
  M->new_field ("is_masks_");
  M->new_array ();
  for (int i100 = 0; i100 < var->sticker_set_ids_->len; i100++) {
    M->pack_long (var->sticker_set_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("sticker_set_ids_");
}
struct TdReorderInstalledStickerSets *TdStackFetcherReorderInstalledStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdReorderInstalledStickerSets ();
  res->ID = CODE_ReorderInstalledStickerSets;
  res->refcnt = 1;
  M->get_field ("is_masks_");
  res->is_masks_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sticker_set_ids_");
  res->sticker_set_ids_ = new TdVectorLong ();
  res->sticker_set_ids_->len = M->get_arr_size ();
  res->sticker_set_ids_->data = new long long  [res->sticker_set_ids_->len];
  for (int i100 = 0; i100 < res->sticker_set_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->sticker_set_ids_->data[i100] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdReportChat *TdCreateObjectReportChat (long long chat_id_, struct TdChatReportReason *reason_, struct TdVectorLong *message_ids_) {
  auto var = new struct TdReportChat ();
  var->ID = CODE_ReportChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->reason_ = reason_;
  var->message_ids_ = message_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::reportChat> TdConvertToInternal (struct TdReportChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::ChatReportReason> v100;
  v100 = TdConvertToInternal (var->reason_);
  std::vector<std::int64_t> v200;
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
    std::int64_t v201;
    v201 = var->message_ids_->data[i200];
    v200.push_back (std::move (v201));
  }
  return td::td_api::make_object<td::td_api::reportChat>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdReportChat *TdConvertFromInternal (const td::td_api::reportChat &from) {
  auto res = new TdReportChat ();
  res->ID = CODE_ReportChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.reason_) {
    res->reason_ = nullptr;
  } else {
    res->reason_ = TdConvertFromInternal (static_cast<const td::td_api::ChatReportReason &>(*from.reason_));
  }
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = (int)from.message_ids_.size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i200 = 0; i200 < res->message_ids_->len; i200++) {
    res->message_ids_->data[i200] = from.message_ids_[i200];
  }
  return res;
}
char *TdSerializeReportChat (struct TdReportChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReportChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReportChat (struct TdReportChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReportChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reason_);
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
  }
  delete[] var->message_ids_->data;
  delete var->message_ids_;
  delete var;
}
void TdStackStorerReportChat (struct TdReportChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReportChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ReportChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->reason_, M);
  M->new_field ("reason_");
  M->new_array ();
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
    M->pack_long (var->message_ids_->data[i200]);
    M->new_arr_field (i200);
  }
  M->new_field ("message_ids_");
}
struct TdReportChat *TdStackFetcherReportChat (struct TdStackFetcherMethods *M) {
  auto res = new TdReportChat ();
  res->ID = CODE_ReportChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reason_");
  if (M->is_nil ()) {
    res->reason_ = nullptr;
  } else {
    res->reason_ = TdStackFetcherChatReportReason (M);
  }
  M->pop ();
  M->get_field ("message_ids_");
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = M->get_arr_size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i200 = 0; i200 < res->message_ids_->len; i200++) {
    M->get_arr_field (i200);
    res->message_ids_->data[i200] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdReportSupergroupSpam *TdCreateObjectReportSupergroupSpam (int supergroup_id_, int user_id_, struct TdVectorLong *message_ids_) {
  auto var = new struct TdReportSupergroupSpam ();
  var->ID = CODE_ReportSupergroupSpam;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->user_id_ = user_id_;
  var->message_ids_ = message_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::reportSupergroupSpam> TdConvertToInternal (struct TdReportSupergroupSpam *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  std::int32_t v100;
  v100 = var->user_id_;
  std::vector<std::int64_t> v200;
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
    std::int64_t v201;
    v201 = var->message_ids_->data[i200];
    v200.push_back (std::move (v201));
  }
  return td::td_api::make_object<td::td_api::reportSupergroupSpam>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdReportSupergroupSpam *TdConvertFromInternal (const td::td_api::reportSupergroupSpam &from) {
  auto res = new TdReportSupergroupSpam ();
  res->ID = CODE_ReportSupergroupSpam;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->user_id_ = from.user_id_;
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = (int)from.message_ids_.size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i200 = 0; i200 < res->message_ids_->len; i200++) {
    res->message_ids_->data[i200] = from.message_ids_[i200];
  }
  return res;
}
char *TdSerializeReportSupergroupSpam (struct TdReportSupergroupSpam *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdReportSupergroupSpam *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectReportSupergroupSpam (struct TdReportSupergroupSpam *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdReportSupergroupSpam *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
  }
  delete[] var->message_ids_->data;
  delete var->message_ids_;
  delete var;
}
void TdStackStorerReportSupergroupSpam (struct TdReportSupergroupSpam *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdReportSupergroupSpam *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ReportSupergroupSpam");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->new_array ();
  for (int i200 = 0; i200 < var->message_ids_->len; i200++) {
    M->pack_long (var->message_ids_->data[i200]);
    M->new_arr_field (i200);
  }
  M->new_field ("message_ids_");
}
struct TdReportSupergroupSpam *TdStackFetcherReportSupergroupSpam (struct TdStackFetcherMethods *M) {
  auto res = new TdReportSupergroupSpam ();
  res->ID = CODE_ReportSupergroupSpam;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("message_ids_");
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = M->get_arr_size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i200 = 0; i200 < res->message_ids_->len; i200++) {
    M->get_arr_field (i200);
    res->message_ids_->data[i200] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdRequestAuthenticationPasswordRecovery *TdCreateObjectRequestAuthenticationPasswordRecovery (void) {
  auto var = new struct TdRequestAuthenticationPasswordRecovery ();
  var->ID = CODE_RequestAuthenticationPasswordRecovery;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::requestAuthenticationPasswordRecovery> TdConvertToInternal (struct TdRequestAuthenticationPasswordRecovery *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::requestAuthenticationPasswordRecovery>();
}
struct TdRequestAuthenticationPasswordRecovery *TdConvertFromInternal (const td::td_api::requestAuthenticationPasswordRecovery &from) {
  auto res = new TdRequestAuthenticationPasswordRecovery ();
  res->ID = CODE_RequestAuthenticationPasswordRecovery;
  res->refcnt = 1;
  return res;
}
char *TdSerializeRequestAuthenticationPasswordRecovery (struct TdRequestAuthenticationPasswordRecovery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRequestAuthenticationPasswordRecovery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRequestAuthenticationPasswordRecovery (struct TdRequestAuthenticationPasswordRecovery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRequestAuthenticationPasswordRecovery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerRequestAuthenticationPasswordRecovery (struct TdRequestAuthenticationPasswordRecovery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRequestAuthenticationPasswordRecovery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RequestAuthenticationPasswordRecovery");
  M->new_field ("ID");
}
struct TdRequestAuthenticationPasswordRecovery *TdStackFetcherRequestAuthenticationPasswordRecovery (struct TdStackFetcherMethods *M) {
  auto res = new TdRequestAuthenticationPasswordRecovery ();
  res->ID = CODE_RequestAuthenticationPasswordRecovery;
  res->refcnt = 1;
  return res;
}
struct TdRequestPasswordRecovery *TdCreateObjectRequestPasswordRecovery (void) {
  auto var = new struct TdRequestPasswordRecovery ();
  var->ID = CODE_RequestPasswordRecovery;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::requestPasswordRecovery> TdConvertToInternal (struct TdRequestPasswordRecovery *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::requestPasswordRecovery>();
}
struct TdRequestPasswordRecovery *TdConvertFromInternal (const td::td_api::requestPasswordRecovery &from) {
  auto res = new TdRequestPasswordRecovery ();
  res->ID = CODE_RequestPasswordRecovery;
  res->refcnt = 1;
  return res;
}
char *TdSerializeRequestPasswordRecovery (struct TdRequestPasswordRecovery *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdRequestPasswordRecovery *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectRequestPasswordRecovery (struct TdRequestPasswordRecovery *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdRequestPasswordRecovery *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerRequestPasswordRecovery (struct TdRequestPasswordRecovery *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdRequestPasswordRecovery *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("RequestPasswordRecovery");
  M->new_field ("ID");
}
struct TdRequestPasswordRecovery *TdStackFetcherRequestPasswordRecovery (struct TdStackFetcherMethods *M) {
  auto res = new TdRequestPasswordRecovery ();
  res->ID = CODE_RequestPasswordRecovery;
  res->refcnt = 1;
  return res;
}
struct TdResendAuthenticationCode *TdCreateObjectResendAuthenticationCode (void) {
  auto var = new struct TdResendAuthenticationCode ();
  var->ID = CODE_ResendAuthenticationCode;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::resendAuthenticationCode> TdConvertToInternal (struct TdResendAuthenticationCode *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::resendAuthenticationCode>();
}
struct TdResendAuthenticationCode *TdConvertFromInternal (const td::td_api::resendAuthenticationCode &from) {
  auto res = new TdResendAuthenticationCode ();
  res->ID = CODE_ResendAuthenticationCode;
  res->refcnt = 1;
  return res;
}
char *TdSerializeResendAuthenticationCode (struct TdResendAuthenticationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdResendAuthenticationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectResendAuthenticationCode (struct TdResendAuthenticationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdResendAuthenticationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerResendAuthenticationCode (struct TdResendAuthenticationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdResendAuthenticationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ResendAuthenticationCode");
  M->new_field ("ID");
}
struct TdResendAuthenticationCode *TdStackFetcherResendAuthenticationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdResendAuthenticationCode ();
  res->ID = CODE_ResendAuthenticationCode;
  res->refcnt = 1;
  return res;
}
struct TdResendChangePhoneNumberCode *TdCreateObjectResendChangePhoneNumberCode (void) {
  auto var = new struct TdResendChangePhoneNumberCode ();
  var->ID = CODE_ResendChangePhoneNumberCode;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::resendChangePhoneNumberCode> TdConvertToInternal (struct TdResendChangePhoneNumberCode *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::resendChangePhoneNumberCode>();
}
struct TdResendChangePhoneNumberCode *TdConvertFromInternal (const td::td_api::resendChangePhoneNumberCode &from) {
  auto res = new TdResendChangePhoneNumberCode ();
  res->ID = CODE_ResendChangePhoneNumberCode;
  res->refcnt = 1;
  return res;
}
char *TdSerializeResendChangePhoneNumberCode (struct TdResendChangePhoneNumberCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdResendChangePhoneNumberCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectResendChangePhoneNumberCode (struct TdResendChangePhoneNumberCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdResendChangePhoneNumberCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerResendChangePhoneNumberCode (struct TdResendChangePhoneNumberCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdResendChangePhoneNumberCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ResendChangePhoneNumberCode");
  M->new_field ("ID");
}
struct TdResendChangePhoneNumberCode *TdStackFetcherResendChangePhoneNumberCode (struct TdStackFetcherMethods *M) {
  auto res = new TdResendChangePhoneNumberCode ();
  res->ID = CODE_ResendChangePhoneNumberCode;
  res->refcnt = 1;
  return res;
}
struct TdResendEmailAddressVerificationCode *TdCreateObjectResendEmailAddressVerificationCode (void) {
  auto var = new struct TdResendEmailAddressVerificationCode ();
  var->ID = CODE_ResendEmailAddressVerificationCode;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::resendEmailAddressVerificationCode> TdConvertToInternal (struct TdResendEmailAddressVerificationCode *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::resendEmailAddressVerificationCode>();
}
struct TdResendEmailAddressVerificationCode *TdConvertFromInternal (const td::td_api::resendEmailAddressVerificationCode &from) {
  auto res = new TdResendEmailAddressVerificationCode ();
  res->ID = CODE_ResendEmailAddressVerificationCode;
  res->refcnt = 1;
  return res;
}
char *TdSerializeResendEmailAddressVerificationCode (struct TdResendEmailAddressVerificationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdResendEmailAddressVerificationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectResendEmailAddressVerificationCode (struct TdResendEmailAddressVerificationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdResendEmailAddressVerificationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerResendEmailAddressVerificationCode (struct TdResendEmailAddressVerificationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdResendEmailAddressVerificationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ResendEmailAddressVerificationCode");
  M->new_field ("ID");
}
struct TdResendEmailAddressVerificationCode *TdStackFetcherResendEmailAddressVerificationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdResendEmailAddressVerificationCode ();
  res->ID = CODE_ResendEmailAddressVerificationCode;
  res->refcnt = 1;
  return res;
}
struct TdResendPhoneNumberConfirmationCode *TdCreateObjectResendPhoneNumberConfirmationCode (void) {
  auto var = new struct TdResendPhoneNumberConfirmationCode ();
  var->ID = CODE_ResendPhoneNumberConfirmationCode;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::resendPhoneNumberConfirmationCode> TdConvertToInternal (struct TdResendPhoneNumberConfirmationCode *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::resendPhoneNumberConfirmationCode>();
}
struct TdResendPhoneNumberConfirmationCode *TdConvertFromInternal (const td::td_api::resendPhoneNumberConfirmationCode &from) {
  auto res = new TdResendPhoneNumberConfirmationCode ();
  res->ID = CODE_ResendPhoneNumberConfirmationCode;
  res->refcnt = 1;
  return res;
}
char *TdSerializeResendPhoneNumberConfirmationCode (struct TdResendPhoneNumberConfirmationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdResendPhoneNumberConfirmationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectResendPhoneNumberConfirmationCode (struct TdResendPhoneNumberConfirmationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdResendPhoneNumberConfirmationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerResendPhoneNumberConfirmationCode (struct TdResendPhoneNumberConfirmationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdResendPhoneNumberConfirmationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ResendPhoneNumberConfirmationCode");
  M->new_field ("ID");
}
struct TdResendPhoneNumberConfirmationCode *TdStackFetcherResendPhoneNumberConfirmationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdResendPhoneNumberConfirmationCode ();
  res->ID = CODE_ResendPhoneNumberConfirmationCode;
  res->refcnt = 1;
  return res;
}
struct TdResendPhoneNumberVerificationCode *TdCreateObjectResendPhoneNumberVerificationCode (void) {
  auto var = new struct TdResendPhoneNumberVerificationCode ();
  var->ID = CODE_ResendPhoneNumberVerificationCode;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::resendPhoneNumberVerificationCode> TdConvertToInternal (struct TdResendPhoneNumberVerificationCode *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::resendPhoneNumberVerificationCode>();
}
struct TdResendPhoneNumberVerificationCode *TdConvertFromInternal (const td::td_api::resendPhoneNumberVerificationCode &from) {
  auto res = new TdResendPhoneNumberVerificationCode ();
  res->ID = CODE_ResendPhoneNumberVerificationCode;
  res->refcnt = 1;
  return res;
}
char *TdSerializeResendPhoneNumberVerificationCode (struct TdResendPhoneNumberVerificationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdResendPhoneNumberVerificationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectResendPhoneNumberVerificationCode (struct TdResendPhoneNumberVerificationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdResendPhoneNumberVerificationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerResendPhoneNumberVerificationCode (struct TdResendPhoneNumberVerificationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdResendPhoneNumberVerificationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ResendPhoneNumberVerificationCode");
  M->new_field ("ID");
}
struct TdResendPhoneNumberVerificationCode *TdStackFetcherResendPhoneNumberVerificationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdResendPhoneNumberVerificationCode ();
  res->ID = CODE_ResendPhoneNumberVerificationCode;
  res->refcnt = 1;
  return res;
}
struct TdResetAllNotificationSettings *TdCreateObjectResetAllNotificationSettings (void) {
  auto var = new struct TdResetAllNotificationSettings ();
  var->ID = CODE_ResetAllNotificationSettings;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::resetAllNotificationSettings> TdConvertToInternal (struct TdResetAllNotificationSettings *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::resetAllNotificationSettings>();
}
struct TdResetAllNotificationSettings *TdConvertFromInternal (const td::td_api::resetAllNotificationSettings &from) {
  auto res = new TdResetAllNotificationSettings ();
  res->ID = CODE_ResetAllNotificationSettings;
  res->refcnt = 1;
  return res;
}
char *TdSerializeResetAllNotificationSettings (struct TdResetAllNotificationSettings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdResetAllNotificationSettings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectResetAllNotificationSettings (struct TdResetAllNotificationSettings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdResetAllNotificationSettings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerResetAllNotificationSettings (struct TdResetAllNotificationSettings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdResetAllNotificationSettings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ResetAllNotificationSettings");
  M->new_field ("ID");
}
struct TdResetAllNotificationSettings *TdStackFetcherResetAllNotificationSettings (struct TdStackFetcherMethods *M) {
  auto res = new TdResetAllNotificationSettings ();
  res->ID = CODE_ResetAllNotificationSettings;
  res->refcnt = 1;
  return res;
}
struct TdResetNetworkStatistics *TdCreateObjectResetNetworkStatistics (void) {
  auto var = new struct TdResetNetworkStatistics ();
  var->ID = CODE_ResetNetworkStatistics;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::resetNetworkStatistics> TdConvertToInternal (struct TdResetNetworkStatistics *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::resetNetworkStatistics>();
}
struct TdResetNetworkStatistics *TdConvertFromInternal (const td::td_api::resetNetworkStatistics &from) {
  auto res = new TdResetNetworkStatistics ();
  res->ID = CODE_ResetNetworkStatistics;
  res->refcnt = 1;
  return res;
}
char *TdSerializeResetNetworkStatistics (struct TdResetNetworkStatistics *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdResetNetworkStatistics *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectResetNetworkStatistics (struct TdResetNetworkStatistics *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdResetNetworkStatistics *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerResetNetworkStatistics (struct TdResetNetworkStatistics *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdResetNetworkStatistics *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ResetNetworkStatistics");
  M->new_field ("ID");
}
struct TdResetNetworkStatistics *TdStackFetcherResetNetworkStatistics (struct TdStackFetcherMethods *M) {
  auto res = new TdResetNetworkStatistics ();
  res->ID = CODE_ResetNetworkStatistics;
  res->refcnt = 1;
  return res;
}
struct TdSearchCallMessages *TdCreateObjectSearchCallMessages (long long from_message_id_, int limit_, int only_missed_) {
  auto var = new struct TdSearchCallMessages ();
  var->ID = CODE_SearchCallMessages;
  var->refcnt = 1;
  var->from_message_id_ = from_message_id_;
  var->limit_ = limit_;
  var->only_missed_ = only_missed_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchCallMessages> TdConvertToInternal (struct TdSearchCallMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->from_message_id_;
  std::int32_t v100;
  v100 = var->limit_;
  bool v200;
  v200 = var->only_missed_ != 0;
  return td::td_api::make_object<td::td_api::searchCallMessages>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdSearchCallMessages *TdConvertFromInternal (const td::td_api::searchCallMessages &from) {
  auto res = new TdSearchCallMessages ();
  res->ID = CODE_SearchCallMessages;
  res->refcnt = 1;
  res->from_message_id_ = from.from_message_id_;
  res->limit_ = from.limit_;
  res->only_missed_ = from.only_missed_;
  return res;
}
char *TdSerializeSearchCallMessages (struct TdSearchCallMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchCallMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchCallMessages (struct TdSearchCallMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchCallMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchCallMessages (struct TdSearchCallMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchCallMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchCallMessages");
  M->new_field ("ID");
  M->pack_long (var->from_message_id_);
  M->new_field ("from_message_id_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
  M->pack_bool (var->only_missed_);
  M->new_field ("only_missed_");
}
struct TdSearchCallMessages *TdStackFetcherSearchCallMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchCallMessages ();
  res->ID = CODE_SearchCallMessages;
  res->refcnt = 1;
  M->get_field ("from_message_id_");
  res->from_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("only_missed_");
  res->only_missed_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSearchChatMembers *TdCreateObjectSearchChatMembers (long long chat_id_, char *query_, int limit_, struct TdChatMembersFilter *filter_) {
  auto var = new struct TdSearchChatMembers ();
  var->ID = CODE_SearchChatMembers;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->limit_ = limit_;
  var->filter_ = filter_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchChatMembers> TdConvertToInternal (struct TdSearchChatMembers *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->query_) ? var->query_: "";
  std::int32_t v200;
  v200 = var->limit_;
  td::td_api::object_ptr<td::td_api::ChatMembersFilter> v300;
  v300 = TdConvertToInternal (var->filter_);
  return td::td_api::make_object<td::td_api::searchChatMembers>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdSearchChatMembers *TdConvertFromInternal (const td::td_api::searchChatMembers &from) {
  auto res = new TdSearchChatMembers ();
  res->ID = CODE_SearchChatMembers;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->limit_ = from.limit_;
  if (!from.filter_) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMembersFilter &>(*from.filter_));
  }
  return res;
}
char *TdSerializeSearchChatMembers (struct TdSearchChatMembers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchChatMembers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchChatMembers (struct TdSearchChatMembers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchChatMembers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  TdDestroyObject (var->filter_);
  delete var;
}
void TdStackStorerSearchChatMembers (struct TdSearchChatMembers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchChatMembers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchChatMembers");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
  TdStackStorer (var->filter_, M);
  M->new_field ("filter_");
}
struct TdSearchChatMembers *TdStackFetcherSearchChatMembers (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchChatMembers ();
  res->ID = CODE_SearchChatMembers;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("filter_");
  if (M->is_nil ()) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdStackFetcherChatMembersFilter (M);
  }
  M->pop ();
  return res;
}
struct TdSearchChatMessages *TdCreateObjectSearchChatMessages (long long chat_id_, char *query_, int sender_user_id_, long long from_message_id_, int offset_, int limit_, struct TdSearchMessagesFilter *filter_) {
  auto var = new struct TdSearchChatMessages ();
  var->ID = CODE_SearchChatMessages;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->sender_user_id_ = sender_user_id_;
  var->from_message_id_ = from_message_id_;
  var->offset_ = offset_;
  var->limit_ = limit_;
  var->filter_ = filter_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchChatMessages> TdConvertToInternal (struct TdSearchChatMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->query_) ? var->query_: "";
  std::int32_t v200;
  v200 = var->sender_user_id_;
  std::int64_t v300;
  v300 = var->from_message_id_;
  std::int32_t v400;
  v400 = var->offset_;
  std::int32_t v500;
  v500 = var->limit_;
  td::td_api::object_ptr<td::td_api::SearchMessagesFilter> v600;
  v600 = TdConvertToInternal (var->filter_);
  return td::td_api::make_object<td::td_api::searchChatMessages>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500), std::move (v600));
}
struct TdSearchChatMessages *TdConvertFromInternal (const td::td_api::searchChatMessages &from) {
  auto res = new TdSearchChatMessages ();
  res->ID = CODE_SearchChatMessages;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->sender_user_id_ = from.sender_user_id_;
  res->from_message_id_ = from.from_message_id_;
  res->offset_ = from.offset_;
  res->limit_ = from.limit_;
  if (!from.filter_) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdConvertFromInternal (static_cast<const td::td_api::SearchMessagesFilter &>(*from.filter_));
  }
  return res;
}
char *TdSerializeSearchChatMessages (struct TdSearchChatMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchChatMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchChatMessages (struct TdSearchChatMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchChatMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  TdDestroyObject (var->filter_);
  delete var;
}
void TdStackStorerSearchChatMessages (struct TdSearchChatMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchChatMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchChatMessages");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->sender_user_id_);
  M->new_field ("sender_user_id_");
  M->pack_long (var->from_message_id_);
  M->new_field ("from_message_id_");
  M->pack_long (var->offset_);
  M->new_field ("offset_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
  TdStackStorer (var->filter_, M);
  M->new_field ("filter_");
}
struct TdSearchChatMessages *TdStackFetcherSearchChatMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchChatMessages ();
  res->ID = CODE_SearchChatMessages;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("sender_user_id_");
  res->sender_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("from_message_id_");
  res->from_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("offset_");
  res->offset_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("filter_");
  if (M->is_nil ()) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdStackFetcherSearchMessagesFilter (M);
  }
  M->pop ();
  return res;
}
struct TdSearchChatRecentLocationMessages *TdCreateObjectSearchChatRecentLocationMessages (long long chat_id_, int limit_) {
  auto var = new struct TdSearchChatRecentLocationMessages ();
  var->ID = CODE_SearchChatRecentLocationMessages;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchChatRecentLocationMessages> TdConvertToInternal (struct TdSearchChatRecentLocationMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::searchChatRecentLocationMessages>(std::move (v0), std::move (v100));
}
struct TdSearchChatRecentLocationMessages *TdConvertFromInternal (const td::td_api::searchChatRecentLocationMessages &from) {
  auto res = new TdSearchChatRecentLocationMessages ();
  res->ID = CODE_SearchChatRecentLocationMessages;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeSearchChatRecentLocationMessages (struct TdSearchChatRecentLocationMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchChatRecentLocationMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchChatRecentLocationMessages (struct TdSearchChatRecentLocationMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchChatRecentLocationMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSearchChatRecentLocationMessages (struct TdSearchChatRecentLocationMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchChatRecentLocationMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchChatRecentLocationMessages");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdSearchChatRecentLocationMessages *TdStackFetcherSearchChatRecentLocationMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchChatRecentLocationMessages ();
  res->ID = CODE_SearchChatRecentLocationMessages;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSearchChats *TdCreateObjectSearchChats (char *query_, int limit_) {
  auto var = new struct TdSearchChats ();
  var->ID = CODE_SearchChats;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchChats> TdConvertToInternal (struct TdSearchChats *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::searchChats>(std::move (v0), std::move (v100));
}
struct TdSearchChats *TdConvertFromInternal (const td::td_api::searchChats &from) {
  auto res = new TdSearchChats ();
  res->ID = CODE_SearchChats;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeSearchChats (struct TdSearchChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchChats (struct TdSearchChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSearchChats (struct TdSearchChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchChats");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdSearchChats *TdStackFetcherSearchChats (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchChats ();
  res->ID = CODE_SearchChats;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSearchChatsOnServer *TdCreateObjectSearchChatsOnServer (char *query_, int limit_) {
  auto var = new struct TdSearchChatsOnServer ();
  var->ID = CODE_SearchChatsOnServer;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchChatsOnServer> TdConvertToInternal (struct TdSearchChatsOnServer *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::searchChatsOnServer>(std::move (v0), std::move (v100));
}
struct TdSearchChatsOnServer *TdConvertFromInternal (const td::td_api::searchChatsOnServer &from) {
  auto res = new TdSearchChatsOnServer ();
  res->ID = CODE_SearchChatsOnServer;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeSearchChatsOnServer (struct TdSearchChatsOnServer *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchChatsOnServer *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchChatsOnServer (struct TdSearchChatsOnServer *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchChatsOnServer *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSearchChatsOnServer (struct TdSearchChatsOnServer *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchChatsOnServer *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchChatsOnServer");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdSearchChatsOnServer *TdStackFetcherSearchChatsOnServer (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchChatsOnServer ();
  res->ID = CODE_SearchChatsOnServer;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSearchContacts *TdCreateObjectSearchContacts (char *query_, int limit_) {
  auto var = new struct TdSearchContacts ();
  var->ID = CODE_SearchContacts;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchContacts> TdConvertToInternal (struct TdSearchContacts *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::searchContacts>(std::move (v0), std::move (v100));
}
struct TdSearchContacts *TdConvertFromInternal (const td::td_api::searchContacts &from) {
  auto res = new TdSearchContacts ();
  res->ID = CODE_SearchContacts;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeSearchContacts (struct TdSearchContacts *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchContacts *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchContacts (struct TdSearchContacts *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchContacts *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSearchContacts (struct TdSearchContacts *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchContacts *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchContacts");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdSearchContacts *TdStackFetcherSearchContacts (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchContacts ();
  res->ID = CODE_SearchContacts;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSearchHashtags *TdCreateObjectSearchHashtags (char *prefix_, int limit_) {
  auto var = new struct TdSearchHashtags ();
  var->ID = CODE_SearchHashtags;
  var->refcnt = 1;
  var->prefix_ = (prefix_) ? td::str_dup (td::Slice (prefix_)) : nullptr;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchHashtags> TdConvertToInternal (struct TdSearchHashtags *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->prefix_) ? var->prefix_: "";
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::searchHashtags>(std::move (v0), std::move (v100));
}
struct TdSearchHashtags *TdConvertFromInternal (const td::td_api::searchHashtags &from) {
  auto res = new TdSearchHashtags ();
  res->ID = CODE_SearchHashtags;
  res->refcnt = 1;
  res->prefix_ = (from.prefix_.length ()) ? td::str_dup (from.prefix_) : nullptr;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeSearchHashtags (struct TdSearchHashtags *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchHashtags *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchHashtags (struct TdSearchHashtags *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchHashtags *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->prefix_);
  delete var;
}
void TdStackStorerSearchHashtags (struct TdSearchHashtags *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchHashtags *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchHashtags");
  M->new_field ("ID");
  M->pack_string (var->prefix_);
  M->new_field ("prefix_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdSearchHashtags *TdStackFetcherSearchHashtags (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchHashtags ();
  res->ID = CODE_SearchHashtags;
  res->refcnt = 1;
  M->get_field ("prefix_");
  res->prefix_ = M->get_string ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSearchInstalledStickerSets *TdCreateObjectSearchInstalledStickerSets (int is_masks_, char *query_, int limit_) {
  auto var = new struct TdSearchInstalledStickerSets ();
  var->ID = CODE_SearchInstalledStickerSets;
  var->refcnt = 1;
  var->is_masks_ = is_masks_;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchInstalledStickerSets> TdConvertToInternal (struct TdSearchInstalledStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  bool v0;
  v0 = var->is_masks_ != 0;
  std::string v100;
  v100 = (var->query_) ? var->query_: "";
  std::int32_t v200;
  v200 = var->limit_;
  return td::td_api::make_object<td::td_api::searchInstalledStickerSets>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdSearchInstalledStickerSets *TdConvertFromInternal (const td::td_api::searchInstalledStickerSets &from) {
  auto res = new TdSearchInstalledStickerSets ();
  res->ID = CODE_SearchInstalledStickerSets;
  res->refcnt = 1;
  res->is_masks_ = from.is_masks_;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeSearchInstalledStickerSets (struct TdSearchInstalledStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchInstalledStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchInstalledStickerSets (struct TdSearchInstalledStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchInstalledStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSearchInstalledStickerSets (struct TdSearchInstalledStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchInstalledStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchInstalledStickerSets");
  M->new_field ("ID");
  M->pack_bool (var->is_masks_);
  M->new_field ("is_masks_");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdSearchInstalledStickerSets *TdStackFetcherSearchInstalledStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchInstalledStickerSets ();
  res->ID = CODE_SearchInstalledStickerSets;
  res->refcnt = 1;
  M->get_field ("is_masks_");
  res->is_masks_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSearchMessages *TdCreateObjectSearchMessages (char *query_, int offset_date_, long long offset_chat_id_, long long offset_message_id_, int limit_) {
  auto var = new struct TdSearchMessages ();
  var->ID = CODE_SearchMessages;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->offset_date_ = offset_date_;
  var->offset_chat_id_ = offset_chat_id_;
  var->offset_message_id_ = offset_message_id_;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchMessages> TdConvertToInternal (struct TdSearchMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  std::int32_t v100;
  v100 = var->offset_date_;
  std::int64_t v200;
  v200 = var->offset_chat_id_;
  std::int64_t v300;
  v300 = var->offset_message_id_;
  std::int32_t v400;
  v400 = var->limit_;
  return td::td_api::make_object<td::td_api::searchMessages>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdSearchMessages *TdConvertFromInternal (const td::td_api::searchMessages &from) {
  auto res = new TdSearchMessages ();
  res->ID = CODE_SearchMessages;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->offset_date_ = from.offset_date_;
  res->offset_chat_id_ = from.offset_chat_id_;
  res->offset_message_id_ = from.offset_message_id_;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeSearchMessages (struct TdSearchMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchMessages (struct TdSearchMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSearchMessages (struct TdSearchMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchMessages");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->offset_date_);
  M->new_field ("offset_date_");
  M->pack_long (var->offset_chat_id_);
  M->new_field ("offset_chat_id_");
  M->pack_long (var->offset_message_id_);
  M->new_field ("offset_message_id_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdSearchMessages *TdStackFetcherSearchMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchMessages ();
  res->ID = CODE_SearchMessages;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("offset_date_");
  res->offset_date_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("offset_chat_id_");
  res->offset_chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("offset_message_id_");
  res->offset_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSearchPublicChat *TdCreateObjectSearchPublicChat (char *username_) {
  auto var = new struct TdSearchPublicChat ();
  var->ID = CODE_SearchPublicChat;
  var->refcnt = 1;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::searchPublicChat> TdConvertToInternal (struct TdSearchPublicChat *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->username_) ? var->username_: "";
  return td::td_api::make_object<td::td_api::searchPublicChat>(std::move (v0));
}
struct TdSearchPublicChat *TdConvertFromInternal (const td::td_api::searchPublicChat &from) {
  auto res = new TdSearchPublicChat ();
  res->ID = CODE_SearchPublicChat;
  res->refcnt = 1;
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  return res;
}
char *TdSerializeSearchPublicChat (struct TdSearchPublicChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchPublicChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchPublicChat (struct TdSearchPublicChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchPublicChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->username_);
  delete var;
}
void TdStackStorerSearchPublicChat (struct TdSearchPublicChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchPublicChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchPublicChat");
  M->new_field ("ID");
  M->pack_string (var->username_);
  M->new_field ("username_");
}
struct TdSearchPublicChat *TdStackFetcherSearchPublicChat (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchPublicChat ();
  res->ID = CODE_SearchPublicChat;
  res->refcnt = 1;
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSearchPublicChats *TdCreateObjectSearchPublicChats (char *query_) {
  auto var = new struct TdSearchPublicChats ();
  var->ID = CODE_SearchPublicChats;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::searchPublicChats> TdConvertToInternal (struct TdSearchPublicChats *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  return td::td_api::make_object<td::td_api::searchPublicChats>(std::move (v0));
}
struct TdSearchPublicChats *TdConvertFromInternal (const td::td_api::searchPublicChats &from) {
  auto res = new TdSearchPublicChats ();
  res->ID = CODE_SearchPublicChats;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  return res;
}
char *TdSerializeSearchPublicChats (struct TdSearchPublicChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchPublicChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchPublicChats (struct TdSearchPublicChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchPublicChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSearchPublicChats (struct TdSearchPublicChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchPublicChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchPublicChats");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
}
struct TdSearchPublicChats *TdStackFetcherSearchPublicChats (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchPublicChats ();
  res->ID = CODE_SearchPublicChats;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSearchSecretMessages *TdCreateObjectSearchSecretMessages (long long chat_id_, char *query_, long long from_search_id_, int limit_, struct TdSearchMessagesFilter *filter_) {
  auto var = new struct TdSearchSecretMessages ();
  var->ID = CODE_SearchSecretMessages;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  var->from_search_id_ = from_search_id_;
  var->limit_ = limit_;
  var->filter_ = filter_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchSecretMessages> TdConvertToInternal (struct TdSearchSecretMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->query_) ? var->query_: "";
  std::int64_t v200;
  v200 = var->from_search_id_;
  std::int32_t v300;
  v300 = var->limit_;
  td::td_api::object_ptr<td::td_api::SearchMessagesFilter> v400;
  v400 = TdConvertToInternal (var->filter_);
  return td::td_api::make_object<td::td_api::searchSecretMessages>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdSearchSecretMessages *TdConvertFromInternal (const td::td_api::searchSecretMessages &from) {
  auto res = new TdSearchSecretMessages ();
  res->ID = CODE_SearchSecretMessages;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  res->from_search_id_ = from.from_search_id_;
  res->limit_ = from.limit_;
  if (!from.filter_) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdConvertFromInternal (static_cast<const td::td_api::SearchMessagesFilter &>(*from.filter_));
  }
  return res;
}
char *TdSerializeSearchSecretMessages (struct TdSearchSecretMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchSecretMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchSecretMessages (struct TdSearchSecretMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchSecretMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  TdDestroyObject (var->filter_);
  delete var;
}
void TdStackStorerSearchSecretMessages (struct TdSearchSecretMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchSecretMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchSecretMessages");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->query_);
  M->new_field ("query_");
  M->pack_long (var->from_search_id_);
  M->new_field ("from_search_id_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
  TdStackStorer (var->filter_, M);
  M->new_field ("filter_");
}
struct TdSearchSecretMessages *TdStackFetcherSearchSecretMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchSecretMessages ();
  res->ID = CODE_SearchSecretMessages;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  M->get_field ("from_search_id_");
  res->from_search_id_ = M->get_long ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("filter_");
  if (M->is_nil ()) {
    res->filter_ = nullptr;
  } else {
    res->filter_ = TdStackFetcherSearchMessagesFilter (M);
  }
  M->pop ();
  return res;
}
struct TdSearchStickerSet *TdCreateObjectSearchStickerSet (char *name_) {
  auto var = new struct TdSearchStickerSet ();
  var->ID = CODE_SearchStickerSet;
  var->refcnt = 1;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::searchStickerSet> TdConvertToInternal (struct TdSearchStickerSet *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->name_) ? var->name_: "";
  return td::td_api::make_object<td::td_api::searchStickerSet>(std::move (v0));
}
struct TdSearchStickerSet *TdConvertFromInternal (const td::td_api::searchStickerSet &from) {
  auto res = new TdSearchStickerSet ();
  res->ID = CODE_SearchStickerSet;
  res->refcnt = 1;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  return res;
}
char *TdSerializeSearchStickerSet (struct TdSearchStickerSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchStickerSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchStickerSet (struct TdSearchStickerSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchStickerSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->name_);
  delete var;
}
void TdStackStorerSearchStickerSet (struct TdSearchStickerSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchStickerSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchStickerSet");
  M->new_field ("ID");
  M->pack_string (var->name_);
  M->new_field ("name_");
}
struct TdSearchStickerSet *TdStackFetcherSearchStickerSet (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchStickerSet ();
  res->ID = CODE_SearchStickerSet;
  res->refcnt = 1;
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSearchStickerSets *TdCreateObjectSearchStickerSets (char *query_) {
  auto var = new struct TdSearchStickerSets ();
  var->ID = CODE_SearchStickerSets;
  var->refcnt = 1;
  var->query_ = (query_) ? td::str_dup (td::Slice (query_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::searchStickerSets> TdConvertToInternal (struct TdSearchStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->query_) ? var->query_: "";
  return td::td_api::make_object<td::td_api::searchStickerSets>(std::move (v0));
}
struct TdSearchStickerSets *TdConvertFromInternal (const td::td_api::searchStickerSets &from) {
  auto res = new TdSearchStickerSets ();
  res->ID = CODE_SearchStickerSets;
  res->refcnt = 1;
  res->query_ = (from.query_.length ()) ? td::str_dup (from.query_) : nullptr;
  return res;
}
char *TdSerializeSearchStickerSets (struct TdSearchStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchStickerSets (struct TdSearchStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->query_);
  delete var;
}
void TdStackStorerSearchStickerSets (struct TdSearchStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchStickerSets");
  M->new_field ("ID");
  M->pack_string (var->query_);
  M->new_field ("query_");
}
struct TdSearchStickerSets *TdStackFetcherSearchStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchStickerSets ();
  res->ID = CODE_SearchStickerSets;
  res->refcnt = 1;
  M->get_field ("query_");
  res->query_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSearchStickers *TdCreateObjectSearchStickers (char *emoji_, int limit_) {
  auto var = new struct TdSearchStickers ();
  var->ID = CODE_SearchStickers;
  var->refcnt = 1;
  var->emoji_ = (emoji_) ? td::str_dup (td::Slice (emoji_)) : nullptr;
  var->limit_ = limit_;
  return var;
}
td::td_api::object_ptr<td::td_api::searchStickers> TdConvertToInternal (struct TdSearchStickers *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->emoji_) ? var->emoji_: "";
  std::int32_t v100;
  v100 = var->limit_;
  return td::td_api::make_object<td::td_api::searchStickers>(std::move (v0), std::move (v100));
}
struct TdSearchStickers *TdConvertFromInternal (const td::td_api::searchStickers &from) {
  auto res = new TdSearchStickers ();
  res->ID = CODE_SearchStickers;
  res->refcnt = 1;
  res->emoji_ = (from.emoji_.length ()) ? td::str_dup (from.emoji_) : nullptr;
  res->limit_ = from.limit_;
  return res;
}
char *TdSerializeSearchStickers (struct TdSearchStickers *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSearchStickers *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSearchStickers (struct TdSearchStickers *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSearchStickers *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->emoji_);
  delete var;
}
void TdStackStorerSearchStickers (struct TdSearchStickers *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSearchStickers *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SearchStickers");
  M->new_field ("ID");
  M->pack_string (var->emoji_);
  M->new_field ("emoji_");
  M->pack_long (var->limit_);
  M->new_field ("limit_");
}
struct TdSearchStickers *TdStackFetcherSearchStickers (struct TdStackFetcherMethods *M) {
  auto res = new TdSearchStickers ();
  res->ID = CODE_SearchStickers;
  res->refcnt = 1;
  M->get_field ("emoji_");
  res->emoji_ = M->get_string ();
  M->pop ();
  M->get_field ("limit_");
  res->limit_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSendBotStartMessage *TdCreateObjectSendBotStartMessage (int bot_user_id_, long long chat_id_, char *parameter_) {
  auto var = new struct TdSendBotStartMessage ();
  var->ID = CODE_SendBotStartMessage;
  var->refcnt = 1;
  var->bot_user_id_ = bot_user_id_;
  var->chat_id_ = chat_id_;
  var->parameter_ = (parameter_) ? td::str_dup (td::Slice (parameter_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::sendBotStartMessage> TdConvertToInternal (struct TdSendBotStartMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->bot_user_id_;
  std::int64_t v100;
  v100 = var->chat_id_;
  std::string v200;
  v200 = (var->parameter_) ? var->parameter_: "";
  return td::td_api::make_object<td::td_api::sendBotStartMessage>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdSendBotStartMessage *TdConvertFromInternal (const td::td_api::sendBotStartMessage &from) {
  auto res = new TdSendBotStartMessage ();
  res->ID = CODE_SendBotStartMessage;
  res->refcnt = 1;
  res->bot_user_id_ = from.bot_user_id_;
  res->chat_id_ = from.chat_id_;
  res->parameter_ = (from.parameter_.length ()) ? td::str_dup (from.parameter_) : nullptr;
  return res;
}
char *TdSerializeSendBotStartMessage (struct TdSendBotStartMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendBotStartMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendBotStartMessage (struct TdSendBotStartMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendBotStartMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->parameter_);
  delete var;
}
void TdStackStorerSendBotStartMessage (struct TdSendBotStartMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendBotStartMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendBotStartMessage");
  M->new_field ("ID");
  M->pack_long (var->bot_user_id_);
  M->new_field ("bot_user_id_");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->parameter_);
  M->new_field ("parameter_");
}
struct TdSendBotStartMessage *TdStackFetcherSendBotStartMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdSendBotStartMessage ();
  res->ID = CODE_SendBotStartMessage;
  res->refcnt = 1;
  M->get_field ("bot_user_id_");
  res->bot_user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("parameter_");
  res->parameter_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSendCallDebugInformation *TdCreateObjectSendCallDebugInformation (int call_id_, char *debug_information_) {
  auto var = new struct TdSendCallDebugInformation ();
  var->ID = CODE_SendCallDebugInformation;
  var->refcnt = 1;
  var->call_id_ = call_id_;
  var->debug_information_ = (debug_information_) ? td::str_dup (td::Slice (debug_information_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::sendCallDebugInformation> TdConvertToInternal (struct TdSendCallDebugInformation *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->call_id_;
  std::string v100;
  v100 = (var->debug_information_) ? var->debug_information_: "";
  return td::td_api::make_object<td::td_api::sendCallDebugInformation>(std::move (v0), std::move (v100));
}
struct TdSendCallDebugInformation *TdConvertFromInternal (const td::td_api::sendCallDebugInformation &from) {
  auto res = new TdSendCallDebugInformation ();
  res->ID = CODE_SendCallDebugInformation;
  res->refcnt = 1;
  res->call_id_ = from.call_id_;
  res->debug_information_ = (from.debug_information_.length ()) ? td::str_dup (from.debug_information_) : nullptr;
  return res;
}
char *TdSerializeSendCallDebugInformation (struct TdSendCallDebugInformation *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendCallDebugInformation *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendCallDebugInformation (struct TdSendCallDebugInformation *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendCallDebugInformation *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->debug_information_);
  delete var;
}
void TdStackStorerSendCallDebugInformation (struct TdSendCallDebugInformation *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendCallDebugInformation *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendCallDebugInformation");
  M->new_field ("ID");
  M->pack_long (var->call_id_);
  M->new_field ("call_id_");
  M->pack_string (var->debug_information_);
  M->new_field ("debug_information_");
}
struct TdSendCallDebugInformation *TdStackFetcherSendCallDebugInformation (struct TdStackFetcherMethods *M) {
  auto res = new TdSendCallDebugInformation ();
  res->ID = CODE_SendCallDebugInformation;
  res->refcnt = 1;
  M->get_field ("call_id_");
  res->call_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("debug_information_");
  res->debug_information_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSendCallRating *TdCreateObjectSendCallRating (int call_id_, int rating_, char *comment_) {
  auto var = new struct TdSendCallRating ();
  var->ID = CODE_SendCallRating;
  var->refcnt = 1;
  var->call_id_ = call_id_;
  var->rating_ = rating_;
  var->comment_ = (comment_) ? td::str_dup (td::Slice (comment_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::sendCallRating> TdConvertToInternal (struct TdSendCallRating *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->call_id_;
  std::int32_t v100;
  v100 = var->rating_;
  std::string v200;
  v200 = (var->comment_) ? var->comment_: "";
  return td::td_api::make_object<td::td_api::sendCallRating>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdSendCallRating *TdConvertFromInternal (const td::td_api::sendCallRating &from) {
  auto res = new TdSendCallRating ();
  res->ID = CODE_SendCallRating;
  res->refcnt = 1;
  res->call_id_ = from.call_id_;
  res->rating_ = from.rating_;
  res->comment_ = (from.comment_.length ()) ? td::str_dup (from.comment_) : nullptr;
  return res;
}
char *TdSerializeSendCallRating (struct TdSendCallRating *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendCallRating *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendCallRating (struct TdSendCallRating *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendCallRating *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->comment_);
  delete var;
}
void TdStackStorerSendCallRating (struct TdSendCallRating *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendCallRating *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendCallRating");
  M->new_field ("ID");
  M->pack_long (var->call_id_);
  M->new_field ("call_id_");
  M->pack_long (var->rating_);
  M->new_field ("rating_");
  M->pack_string (var->comment_);
  M->new_field ("comment_");
}
struct TdSendCallRating *TdStackFetcherSendCallRating (struct TdStackFetcherMethods *M) {
  auto res = new TdSendCallRating ();
  res->ID = CODE_SendCallRating;
  res->refcnt = 1;
  M->get_field ("call_id_");
  res->call_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("rating_");
  res->rating_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("comment_");
  res->comment_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSendChatAction *TdCreateObjectSendChatAction (long long chat_id_, struct TdChatAction *action_) {
  auto var = new struct TdSendChatAction ();
  var->ID = CODE_SendChatAction;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->action_ = action_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendChatAction> TdConvertToInternal (struct TdSendChatAction *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::ChatAction> v100;
  v100 = TdConvertToInternal (var->action_);
  return td::td_api::make_object<td::td_api::sendChatAction>(std::move (v0), std::move (v100));
}
struct TdSendChatAction *TdConvertFromInternal (const td::td_api::sendChatAction &from) {
  auto res = new TdSendChatAction ();
  res->ID = CODE_SendChatAction;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.action_) {
    res->action_ = nullptr;
  } else {
    res->action_ = TdConvertFromInternal (static_cast<const td::td_api::ChatAction &>(*from.action_));
  }
  return res;
}
char *TdSerializeSendChatAction (struct TdSendChatAction *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendChatAction *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendChatAction (struct TdSendChatAction *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendChatAction *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->action_);
  delete var;
}
void TdStackStorerSendChatAction (struct TdSendChatAction *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendChatAction *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendChatAction");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->action_, M);
  M->new_field ("action_");
}
struct TdSendChatAction *TdStackFetcherSendChatAction (struct TdStackFetcherMethods *M) {
  auto res = new TdSendChatAction ();
  res->ID = CODE_SendChatAction;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("action_");
  if (M->is_nil ()) {
    res->action_ = nullptr;
  } else {
    res->action_ = TdStackFetcherChatAction (M);
  }
  M->pop ();
  return res;
}
struct TdSendChatScreenshotTakenNotification *TdCreateObjectSendChatScreenshotTakenNotification (long long chat_id_) {
  auto var = new struct TdSendChatScreenshotTakenNotification ();
  var->ID = CODE_SendChatScreenshotTakenNotification;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendChatScreenshotTakenNotification> TdConvertToInternal (struct TdSendChatScreenshotTakenNotification *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::sendChatScreenshotTakenNotification>(std::move (v0));
}
struct TdSendChatScreenshotTakenNotification *TdConvertFromInternal (const td::td_api::sendChatScreenshotTakenNotification &from) {
  auto res = new TdSendChatScreenshotTakenNotification ();
  res->ID = CODE_SendChatScreenshotTakenNotification;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeSendChatScreenshotTakenNotification (struct TdSendChatScreenshotTakenNotification *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendChatScreenshotTakenNotification *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendChatScreenshotTakenNotification (struct TdSendChatScreenshotTakenNotification *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendChatScreenshotTakenNotification *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSendChatScreenshotTakenNotification (struct TdSendChatScreenshotTakenNotification *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendChatScreenshotTakenNotification *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendChatScreenshotTakenNotification");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdSendChatScreenshotTakenNotification *TdStackFetcherSendChatScreenshotTakenNotification (struct TdStackFetcherMethods *M) {
  auto res = new TdSendChatScreenshotTakenNotification ();
  res->ID = CODE_SendChatScreenshotTakenNotification;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdSendChatSetTtlMessage *TdCreateObjectSendChatSetTtlMessage (long long chat_id_, int ttl_) {
  auto var = new struct TdSendChatSetTtlMessage ();
  var->ID = CODE_SendChatSetTtlMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->ttl_ = ttl_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendChatSetTtlMessage> TdConvertToInternal (struct TdSendChatSetTtlMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->ttl_;
  return td::td_api::make_object<td::td_api::sendChatSetTtlMessage>(std::move (v0), std::move (v100));
}
struct TdSendChatSetTtlMessage *TdConvertFromInternal (const td::td_api::sendChatSetTtlMessage &from) {
  auto res = new TdSendChatSetTtlMessage ();
  res->ID = CODE_SendChatSetTtlMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->ttl_ = from.ttl_;
  return res;
}
char *TdSerializeSendChatSetTtlMessage (struct TdSendChatSetTtlMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendChatSetTtlMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendChatSetTtlMessage (struct TdSendChatSetTtlMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendChatSetTtlMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSendChatSetTtlMessage (struct TdSendChatSetTtlMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendChatSetTtlMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendChatSetTtlMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->ttl_);
  M->new_field ("ttl_");
}
struct TdSendChatSetTtlMessage *TdStackFetcherSendChatSetTtlMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdSendChatSetTtlMessage ();
  res->ID = CODE_SendChatSetTtlMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("ttl_");
  res->ttl_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSendCustomRequest *TdCreateObjectSendCustomRequest (char *method_, char *parameters_) {
  auto var = new struct TdSendCustomRequest ();
  var->ID = CODE_SendCustomRequest;
  var->refcnt = 1;
  var->method_ = (method_) ? td::str_dup (td::Slice (method_)) : nullptr;
  var->parameters_ = (parameters_) ? td::str_dup (td::Slice (parameters_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::sendCustomRequest> TdConvertToInternal (struct TdSendCustomRequest *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->method_) ? var->method_: "";
  std::string v100;
  v100 = (var->parameters_) ? var->parameters_: "";
  return td::td_api::make_object<td::td_api::sendCustomRequest>(std::move (v0), std::move (v100));
}
struct TdSendCustomRequest *TdConvertFromInternal (const td::td_api::sendCustomRequest &from) {
  auto res = new TdSendCustomRequest ();
  res->ID = CODE_SendCustomRequest;
  res->refcnt = 1;
  res->method_ = (from.method_.length ()) ? td::str_dup (from.method_) : nullptr;
  res->parameters_ = (from.parameters_.length ()) ? td::str_dup (from.parameters_) : nullptr;
  return res;
}
char *TdSerializeSendCustomRequest (struct TdSendCustomRequest *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendCustomRequest *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendCustomRequest (struct TdSendCustomRequest *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendCustomRequest *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->method_);
  free (var->parameters_);
  delete var;
}
void TdStackStorerSendCustomRequest (struct TdSendCustomRequest *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendCustomRequest *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendCustomRequest");
  M->new_field ("ID");
  M->pack_string (var->method_);
  M->new_field ("method_");
  M->pack_string (var->parameters_);
  M->new_field ("parameters_");
}
struct TdSendCustomRequest *TdStackFetcherSendCustomRequest (struct TdStackFetcherMethods *M) {
  auto res = new TdSendCustomRequest ();
  res->ID = CODE_SendCustomRequest;
  res->refcnt = 1;
  M->get_field ("method_");
  res->method_ = M->get_string ();
  M->pop ();
  M->get_field ("parameters_");
  res->parameters_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSendEmailAddressVerificationCode *TdCreateObjectSendEmailAddressVerificationCode (char *email_address_) {
  auto var = new struct TdSendEmailAddressVerificationCode ();
  var->ID = CODE_SendEmailAddressVerificationCode;
  var->refcnt = 1;
  var->email_address_ = (email_address_) ? td::str_dup (td::Slice (email_address_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::sendEmailAddressVerificationCode> TdConvertToInternal (struct TdSendEmailAddressVerificationCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->email_address_) ? var->email_address_: "";
  return td::td_api::make_object<td::td_api::sendEmailAddressVerificationCode>(std::move (v0));
}
struct TdSendEmailAddressVerificationCode *TdConvertFromInternal (const td::td_api::sendEmailAddressVerificationCode &from) {
  auto res = new TdSendEmailAddressVerificationCode ();
  res->ID = CODE_SendEmailAddressVerificationCode;
  res->refcnt = 1;
  res->email_address_ = (from.email_address_.length ()) ? td::str_dup (from.email_address_) : nullptr;
  return res;
}
char *TdSerializeSendEmailAddressVerificationCode (struct TdSendEmailAddressVerificationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendEmailAddressVerificationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendEmailAddressVerificationCode (struct TdSendEmailAddressVerificationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendEmailAddressVerificationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->email_address_);
  delete var;
}
void TdStackStorerSendEmailAddressVerificationCode (struct TdSendEmailAddressVerificationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendEmailAddressVerificationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendEmailAddressVerificationCode");
  M->new_field ("ID");
  M->pack_string (var->email_address_);
  M->new_field ("email_address_");
}
struct TdSendEmailAddressVerificationCode *TdStackFetcherSendEmailAddressVerificationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdSendEmailAddressVerificationCode ();
  res->ID = CODE_SendEmailAddressVerificationCode;
  res->refcnt = 1;
  M->get_field ("email_address_");
  res->email_address_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSendInlineQueryResultMessage *TdCreateObjectSendInlineQueryResultMessage (long long chat_id_, long long reply_to_message_id_, int disable_notification_, int from_background_, long long query_id_, char *result_id_) {
  auto var = new struct TdSendInlineQueryResultMessage ();
  var->ID = CODE_SendInlineQueryResultMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->reply_to_message_id_ = reply_to_message_id_;
  var->disable_notification_ = disable_notification_;
  var->from_background_ = from_background_;
  var->query_id_ = query_id_;
  var->result_id_ = (result_id_) ? td::str_dup (td::Slice (result_id_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::sendInlineQueryResultMessage> TdConvertToInternal (struct TdSendInlineQueryResultMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->reply_to_message_id_;
  bool v200;
  v200 = var->disable_notification_ != 0;
  bool v300;
  v300 = var->from_background_ != 0;
  std::int64_t v400;
  v400 = var->query_id_;
  std::string v500;
  v500 = (var->result_id_) ? var->result_id_: "";
  return td::td_api::make_object<td::td_api::sendInlineQueryResultMessage>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdSendInlineQueryResultMessage *TdConvertFromInternal (const td::td_api::sendInlineQueryResultMessage &from) {
  auto res = new TdSendInlineQueryResultMessage ();
  res->ID = CODE_SendInlineQueryResultMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->reply_to_message_id_ = from.reply_to_message_id_;
  res->disable_notification_ = from.disable_notification_;
  res->from_background_ = from.from_background_;
  res->query_id_ = from.query_id_;
  res->result_id_ = (from.result_id_.length ()) ? td::str_dup (from.result_id_) : nullptr;
  return res;
}
char *TdSerializeSendInlineQueryResultMessage (struct TdSendInlineQueryResultMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendInlineQueryResultMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendInlineQueryResultMessage (struct TdSendInlineQueryResultMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendInlineQueryResultMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->result_id_);
  delete var;
}
void TdStackStorerSendInlineQueryResultMessage (struct TdSendInlineQueryResultMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendInlineQueryResultMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendInlineQueryResultMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->reply_to_message_id_);
  M->new_field ("reply_to_message_id_");
  M->pack_bool (var->disable_notification_);
  M->new_field ("disable_notification_");
  M->pack_bool (var->from_background_);
  M->new_field ("from_background_");
  M->pack_long (var->query_id_);
  M->new_field ("query_id_");
  M->pack_string (var->result_id_);
  M->new_field ("result_id_");
}
struct TdSendInlineQueryResultMessage *TdStackFetcherSendInlineQueryResultMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdSendInlineQueryResultMessage ();
  res->ID = CODE_SendInlineQueryResultMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_to_message_id_");
  res->reply_to_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("disable_notification_");
  res->disable_notification_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("from_background_");
  res->from_background_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("query_id_");
  res->query_id_ = M->get_long ();
  M->pop ();
  M->get_field ("result_id_");
  res->result_id_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSendMessage *TdCreateObjectSendMessage (long long chat_id_, long long reply_to_message_id_, int disable_notification_, int from_background_, struct TdReplyMarkup *reply_markup_, struct TdInputMessageContent *input_message_content_) {
  auto var = new struct TdSendMessage ();
  var->ID = CODE_SendMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->reply_to_message_id_ = reply_to_message_id_;
  var->disable_notification_ = disable_notification_;
  var->from_background_ = from_background_;
  var->reply_markup_ = reply_markup_;
  var->input_message_content_ = input_message_content_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendMessage> TdConvertToInternal (struct TdSendMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->reply_to_message_id_;
  bool v200;
  v200 = var->disable_notification_ != 0;
  bool v300;
  v300 = var->from_background_ != 0;
  td::td_api::object_ptr<td::td_api::ReplyMarkup> v400;
  v400 = TdConvertToInternal (var->reply_markup_);
  td::td_api::object_ptr<td::td_api::InputMessageContent> v500;
  v500 = TdConvertToInternal (var->input_message_content_);
  return td::td_api::make_object<td::td_api::sendMessage>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdSendMessage *TdConvertFromInternal (const td::td_api::sendMessage &from) {
  auto res = new TdSendMessage ();
  res->ID = CODE_SendMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->reply_to_message_id_ = from.reply_to_message_id_;
  res->disable_notification_ = from.disable_notification_;
  res->from_background_ = from.from_background_;
  if (!from.reply_markup_) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdConvertFromInternal (static_cast<const td::td_api::ReplyMarkup &>(*from.reply_markup_));
  }
  if (!from.input_message_content_) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_content_));
  }
  return res;
}
char *TdSerializeSendMessage (struct TdSendMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendMessage (struct TdSendMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->reply_markup_);
  TdDestroyObject (var->input_message_content_);
  delete var;
}
void TdStackStorerSendMessage (struct TdSendMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->reply_to_message_id_);
  M->new_field ("reply_to_message_id_");
  M->pack_bool (var->disable_notification_);
  M->new_field ("disable_notification_");
  M->pack_bool (var->from_background_);
  M->new_field ("from_background_");
  TdStackStorer (var->reply_markup_, M);
  M->new_field ("reply_markup_");
  TdStackStorer (var->input_message_content_, M);
  M->new_field ("input_message_content_");
}
struct TdSendMessage *TdStackFetcherSendMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdSendMessage ();
  res->ID = CODE_SendMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_to_message_id_");
  res->reply_to_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("disable_notification_");
  res->disable_notification_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("from_background_");
  res->from_background_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("reply_markup_");
  if (M->is_nil ()) {
    res->reply_markup_ = nullptr;
  } else {
    res->reply_markup_ = TdStackFetcherReplyMarkup (M);
  }
  M->pop ();
  M->get_field ("input_message_content_");
  if (M->is_nil ()) {
    res->input_message_content_ = nullptr;
  } else {
    res->input_message_content_ = TdStackFetcherInputMessageContent (M);
  }
  M->pop ();
  return res;
}
struct TdSendMessageAlbum *TdCreateObjectSendMessageAlbum (long long chat_id_, long long reply_to_message_id_, int disable_notification_, int from_background_, struct TdVectorInputMessageContent *input_message_contents_) {
  auto var = new struct TdSendMessageAlbum ();
  var->ID = CODE_SendMessageAlbum;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->reply_to_message_id_ = reply_to_message_id_;
  var->disable_notification_ = disable_notification_;
  var->from_background_ = from_background_;
  var->input_message_contents_ = input_message_contents_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendMessageAlbum> TdConvertToInternal (struct TdSendMessageAlbum *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->reply_to_message_id_;
  bool v200;
  v200 = var->disable_notification_ != 0;
  bool v300;
  v300 = var->from_background_ != 0;
  std::vector<td::td_api::object_ptr<td::td_api::InputMessageContent>> v400;
  for (int i400 = 0; i400 < var->input_message_contents_->len; i400++) {
    td::td_api::object_ptr<td::td_api::InputMessageContent> v401;
    v401 = TdConvertToInternal (var->input_message_contents_->data[i400]);
    v400.push_back (std::move (v401));
  }
  return td::td_api::make_object<td::td_api::sendMessageAlbum>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdSendMessageAlbum *TdConvertFromInternal (const td::td_api::sendMessageAlbum &from) {
  auto res = new TdSendMessageAlbum ();
  res->ID = CODE_SendMessageAlbum;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->reply_to_message_id_ = from.reply_to_message_id_;
  res->disable_notification_ = from.disable_notification_;
  res->from_background_ = from.from_background_;
  res->input_message_contents_ = new TdVectorInputMessageContent ();
  res->input_message_contents_->len = (int)from.input_message_contents_.size ();
  res->input_message_contents_->data = new struct TdInputMessageContent * [res->input_message_contents_->len];
  for (int i400 = 0; i400 < res->input_message_contents_->len; i400++) {
    if (!from.input_message_contents_[i400]) {
      res->input_message_contents_->data[i400] = nullptr;
    } else {
      res->input_message_contents_->data[i400] = TdConvertFromInternal (static_cast<const td::td_api::InputMessageContent &>(*from.input_message_contents_[i400]));
    }
  }
  return res;
}
char *TdSerializeSendMessageAlbum (struct TdSendMessageAlbum *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendMessageAlbum *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendMessageAlbum (struct TdSendMessageAlbum *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendMessageAlbum *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i400 = 0; i400 < var->input_message_contents_->len; i400++) {
    TdDestroyObject (var->input_message_contents_->data[i400]);
  }
  delete[] var->input_message_contents_->data;
  delete var->input_message_contents_;
  delete var;
}
void TdStackStorerSendMessageAlbum (struct TdSendMessageAlbum *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendMessageAlbum *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendMessageAlbum");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->reply_to_message_id_);
  M->new_field ("reply_to_message_id_");
  M->pack_bool (var->disable_notification_);
  M->new_field ("disable_notification_");
  M->pack_bool (var->from_background_);
  M->new_field ("from_background_");
  M->new_array ();
  for (int i400 = 0; i400 < var->input_message_contents_->len; i400++) {
    TdStackStorer (var->input_message_contents_->data[i400], M);
    M->new_arr_field (i400);
  }
  M->new_field ("input_message_contents_");
}
struct TdSendMessageAlbum *TdStackFetcherSendMessageAlbum (struct TdStackFetcherMethods *M) {
  auto res = new TdSendMessageAlbum ();
  res->ID = CODE_SendMessageAlbum;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("reply_to_message_id_");
  res->reply_to_message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("disable_notification_");
  res->disable_notification_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("from_background_");
  res->from_background_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("input_message_contents_");
  res->input_message_contents_ = new TdVectorInputMessageContent ();
  res->input_message_contents_->len = M->get_arr_size ();
  res->input_message_contents_->data = new struct TdInputMessageContent * [res->input_message_contents_->len];
  for (int i400 = 0; i400 < res->input_message_contents_->len; i400++) {
    M->get_arr_field (i400);
    if (M->is_nil ()) {
      res->input_message_contents_->data[i400] = nullptr;
    } else {
      res->input_message_contents_->data[i400] = TdStackFetcherInputMessageContent (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdSendPassportAuthorizationForm *TdCreateObjectSendPassportAuthorizationForm (int autorization_form_id_, struct TdVectorPassportElementType *types_) {
  auto var = new struct TdSendPassportAuthorizationForm ();
  var->ID = CODE_SendPassportAuthorizationForm;
  var->refcnt = 1;
  var->autorization_form_id_ = autorization_form_id_;
  var->types_ = types_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendPassportAuthorizationForm> TdConvertToInternal (struct TdSendPassportAuthorizationForm *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->autorization_form_id_;
  std::vector<td::td_api::object_ptr<td::td_api::PassportElementType>> v100;
  for (int i100 = 0; i100 < var->types_->len; i100++) {
    td::td_api::object_ptr<td::td_api::PassportElementType> v101;
    v101 = TdConvertToInternal (var->types_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::sendPassportAuthorizationForm>(std::move (v0), std::move (v100));
}
struct TdSendPassportAuthorizationForm *TdConvertFromInternal (const td::td_api::sendPassportAuthorizationForm &from) {
  auto res = new TdSendPassportAuthorizationForm ();
  res->ID = CODE_SendPassportAuthorizationForm;
  res->refcnt = 1;
  res->autorization_form_id_ = from.autorization_form_id_;
  res->types_ = new TdVectorPassportElementType ();
  res->types_->len = (int)from.types_.size ();
  res->types_->data = new struct TdPassportElementType * [res->types_->len];
  for (int i100 = 0; i100 < res->types_->len; i100++) {
    if (!from.types_[i100]) {
      res->types_->data[i100] = nullptr;
    } else {
      res->types_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::PassportElementType &>(*from.types_[i100]));
    }
  }
  return res;
}
char *TdSerializeSendPassportAuthorizationForm (struct TdSendPassportAuthorizationForm *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendPassportAuthorizationForm *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendPassportAuthorizationForm (struct TdSendPassportAuthorizationForm *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendPassportAuthorizationForm *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->types_->len; i100++) {
    TdDestroyObject (var->types_->data[i100]);
  }
  delete[] var->types_->data;
  delete var->types_;
  delete var;
}
void TdStackStorerSendPassportAuthorizationForm (struct TdSendPassportAuthorizationForm *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendPassportAuthorizationForm *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendPassportAuthorizationForm");
  M->new_field ("ID");
  M->pack_long (var->autorization_form_id_);
  M->new_field ("autorization_form_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->types_->len; i100++) {
    TdStackStorer (var->types_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("types_");
}
struct TdSendPassportAuthorizationForm *TdStackFetcherSendPassportAuthorizationForm (struct TdStackFetcherMethods *M) {
  auto res = new TdSendPassportAuthorizationForm ();
  res->ID = CODE_SendPassportAuthorizationForm;
  res->refcnt = 1;
  M->get_field ("autorization_form_id_");
  res->autorization_form_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("types_");
  res->types_ = new TdVectorPassportElementType ();
  res->types_->len = M->get_arr_size ();
  res->types_->data = new struct TdPassportElementType * [res->types_->len];
  for (int i100 = 0; i100 < res->types_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->types_->data[i100] = nullptr;
    } else {
      res->types_->data[i100] = TdStackFetcherPassportElementType (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdSendPaymentForm *TdCreateObjectSendPaymentForm (long long chat_id_, long long message_id_, char *order_info_id_, char *shipping_option_id_, struct TdInputCredentials *credentials_) {
  auto var = new struct TdSendPaymentForm ();
  var->ID = CODE_SendPaymentForm;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->order_info_id_ = (order_info_id_) ? td::str_dup (td::Slice (order_info_id_)) : nullptr;
  var->shipping_option_id_ = (shipping_option_id_) ? td::str_dup (td::Slice (shipping_option_id_)) : nullptr;
  var->credentials_ = credentials_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendPaymentForm> TdConvertToInternal (struct TdSendPaymentForm *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  std::string v200;
  v200 = (var->order_info_id_) ? var->order_info_id_: "";
  std::string v300;
  v300 = (var->shipping_option_id_) ? var->shipping_option_id_: "";
  td::td_api::object_ptr<td::td_api::InputCredentials> v400;
  v400 = TdConvertToInternal (var->credentials_);
  return td::td_api::make_object<td::td_api::sendPaymentForm>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdSendPaymentForm *TdConvertFromInternal (const td::td_api::sendPaymentForm &from) {
  auto res = new TdSendPaymentForm ();
  res->ID = CODE_SendPaymentForm;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  res->order_info_id_ = (from.order_info_id_.length ()) ? td::str_dup (from.order_info_id_) : nullptr;
  res->shipping_option_id_ = (from.shipping_option_id_.length ()) ? td::str_dup (from.shipping_option_id_) : nullptr;
  if (!from.credentials_) {
    res->credentials_ = nullptr;
  } else {
    res->credentials_ = TdConvertFromInternal (static_cast<const td::td_api::InputCredentials &>(*from.credentials_));
  }
  return res;
}
char *TdSerializeSendPaymentForm (struct TdSendPaymentForm *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendPaymentForm *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendPaymentForm (struct TdSendPaymentForm *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendPaymentForm *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->order_info_id_);
  free (var->shipping_option_id_);
  TdDestroyObject (var->credentials_);
  delete var;
}
void TdStackStorerSendPaymentForm (struct TdSendPaymentForm *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendPaymentForm *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendPaymentForm");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_string (var->order_info_id_);
  M->new_field ("order_info_id_");
  M->pack_string (var->shipping_option_id_);
  M->new_field ("shipping_option_id_");
  TdStackStorer (var->credentials_, M);
  M->new_field ("credentials_");
}
struct TdSendPaymentForm *TdStackFetcherSendPaymentForm (struct TdStackFetcherMethods *M) {
  auto res = new TdSendPaymentForm ();
  res->ID = CODE_SendPaymentForm;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("order_info_id_");
  res->order_info_id_ = M->get_string ();
  M->pop ();
  M->get_field ("shipping_option_id_");
  res->shipping_option_id_ = M->get_string ();
  M->pop ();
  M->get_field ("credentials_");
  if (M->is_nil ()) {
    res->credentials_ = nullptr;
  } else {
    res->credentials_ = TdStackFetcherInputCredentials (M);
  }
  M->pop ();
  return res;
}
struct TdSendPhoneNumberConfirmationCode *TdCreateObjectSendPhoneNumberConfirmationCode (char *hash_, char *phone_number_, int allow_flash_call_, int is_current_phone_number_) {
  auto var = new struct TdSendPhoneNumberConfirmationCode ();
  var->ID = CODE_SendPhoneNumberConfirmationCode;
  var->refcnt = 1;
  var->hash_ = (hash_) ? td::str_dup (td::Slice (hash_)) : nullptr;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  var->allow_flash_call_ = allow_flash_call_;
  var->is_current_phone_number_ = is_current_phone_number_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendPhoneNumberConfirmationCode> TdConvertToInternal (struct TdSendPhoneNumberConfirmationCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->hash_) ? var->hash_: "";
  std::string v100;
  v100 = (var->phone_number_) ? var->phone_number_: "";
  bool v200;
  v200 = var->allow_flash_call_ != 0;
  bool v300;
  v300 = var->is_current_phone_number_ != 0;
  return td::td_api::make_object<td::td_api::sendPhoneNumberConfirmationCode>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdSendPhoneNumberConfirmationCode *TdConvertFromInternal (const td::td_api::sendPhoneNumberConfirmationCode &from) {
  auto res = new TdSendPhoneNumberConfirmationCode ();
  res->ID = CODE_SendPhoneNumberConfirmationCode;
  res->refcnt = 1;
  res->hash_ = (from.hash_.length ()) ? td::str_dup (from.hash_) : nullptr;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  res->allow_flash_call_ = from.allow_flash_call_;
  res->is_current_phone_number_ = from.is_current_phone_number_;
  return res;
}
char *TdSerializeSendPhoneNumberConfirmationCode (struct TdSendPhoneNumberConfirmationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendPhoneNumberConfirmationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendPhoneNumberConfirmationCode (struct TdSendPhoneNumberConfirmationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendPhoneNumberConfirmationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->hash_);
  free (var->phone_number_);
  delete var;
}
void TdStackStorerSendPhoneNumberConfirmationCode (struct TdSendPhoneNumberConfirmationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendPhoneNumberConfirmationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendPhoneNumberConfirmationCode");
  M->new_field ("ID");
  M->pack_string (var->hash_);
  M->new_field ("hash_");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
  M->pack_bool (var->allow_flash_call_);
  M->new_field ("allow_flash_call_");
  M->pack_bool (var->is_current_phone_number_);
  M->new_field ("is_current_phone_number_");
}
struct TdSendPhoneNumberConfirmationCode *TdStackFetcherSendPhoneNumberConfirmationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdSendPhoneNumberConfirmationCode ();
  res->ID = CODE_SendPhoneNumberConfirmationCode;
  res->refcnt = 1;
  M->get_field ("hash_");
  res->hash_ = M->get_string ();
  M->pop ();
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  M->get_field ("allow_flash_call_");
  res->allow_flash_call_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_current_phone_number_");
  res->is_current_phone_number_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSendPhoneNumberVerificationCode *TdCreateObjectSendPhoneNumberVerificationCode (char *phone_number_, int allow_flash_call_, int is_current_phone_number_) {
  auto var = new struct TdSendPhoneNumberVerificationCode ();
  var->ID = CODE_SendPhoneNumberVerificationCode;
  var->refcnt = 1;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  var->allow_flash_call_ = allow_flash_call_;
  var->is_current_phone_number_ = is_current_phone_number_;
  return var;
}
td::td_api::object_ptr<td::td_api::sendPhoneNumberVerificationCode> TdConvertToInternal (struct TdSendPhoneNumberVerificationCode *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->phone_number_) ? var->phone_number_: "";
  bool v100;
  v100 = var->allow_flash_call_ != 0;
  bool v200;
  v200 = var->is_current_phone_number_ != 0;
  return td::td_api::make_object<td::td_api::sendPhoneNumberVerificationCode>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdSendPhoneNumberVerificationCode *TdConvertFromInternal (const td::td_api::sendPhoneNumberVerificationCode &from) {
  auto res = new TdSendPhoneNumberVerificationCode ();
  res->ID = CODE_SendPhoneNumberVerificationCode;
  res->refcnt = 1;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  res->allow_flash_call_ = from.allow_flash_call_;
  res->is_current_phone_number_ = from.is_current_phone_number_;
  return res;
}
char *TdSerializeSendPhoneNumberVerificationCode (struct TdSendPhoneNumberVerificationCode *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSendPhoneNumberVerificationCode *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSendPhoneNumberVerificationCode (struct TdSendPhoneNumberVerificationCode *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSendPhoneNumberVerificationCode *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->phone_number_);
  delete var;
}
void TdStackStorerSendPhoneNumberVerificationCode (struct TdSendPhoneNumberVerificationCode *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSendPhoneNumberVerificationCode *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SendPhoneNumberVerificationCode");
  M->new_field ("ID");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
  M->pack_bool (var->allow_flash_call_);
  M->new_field ("allow_flash_call_");
  M->pack_bool (var->is_current_phone_number_);
  M->new_field ("is_current_phone_number_");
}
struct TdSendPhoneNumberVerificationCode *TdStackFetcherSendPhoneNumberVerificationCode (struct TdStackFetcherMethods *M) {
  auto res = new TdSendPhoneNumberVerificationCode ();
  res->ID = CODE_SendPhoneNumberVerificationCode;
  res->refcnt = 1;
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  M->get_field ("allow_flash_call_");
  res->allow_flash_call_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_current_phone_number_");
  res->is_current_phone_number_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSetAccountTtl *TdCreateObjectSetAccountTtl (struct TdAccountTtl *ttl_) {
  auto var = new struct TdSetAccountTtl ();
  var->ID = CODE_SetAccountTtl;
  var->refcnt = 1;
  var->ttl_ = ttl_;
  return var;
}
td::td_api::object_ptr<td::td_api::setAccountTtl> TdConvertToInternal (struct TdSetAccountTtl *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::accountTtl> v0;
  v0 = TdConvertToInternal (var->ttl_);
  return td::td_api::make_object<td::td_api::setAccountTtl>(std::move (v0));
}
struct TdSetAccountTtl *TdConvertFromInternal (const td::td_api::setAccountTtl &from) {
  auto res = new TdSetAccountTtl ();
  res->ID = CODE_SetAccountTtl;
  res->refcnt = 1;
  if (!from.ttl_) {
    res->ttl_ = nullptr;
  } else {
    res->ttl_ = TdConvertFromInternal (static_cast<const td::td_api::accountTtl &>(*from.ttl_));
  }
  return res;
}
char *TdSerializeSetAccountTtl (struct TdSetAccountTtl *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetAccountTtl *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetAccountTtl (struct TdSetAccountTtl *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetAccountTtl *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->ttl_);
  delete var;
}
void TdStackStorerSetAccountTtl (struct TdSetAccountTtl *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetAccountTtl *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetAccountTtl");
  M->new_field ("ID");
  TdStackStorer (var->ttl_, M);
  M->new_field ("ttl_");
}
struct TdSetAccountTtl *TdStackFetcherSetAccountTtl (struct TdStackFetcherMethods *M) {
  auto res = new TdSetAccountTtl ();
  res->ID = CODE_SetAccountTtl;
  res->refcnt = 1;
  M->get_field ("ttl_");
  if (M->is_nil ()) {
    res->ttl_ = nullptr;
  } else {
    res->ttl_ = TdStackFetcherAccountTtl (M);
  }
  M->pop ();
  return res;
}
struct TdSetAlarm *TdCreateObjectSetAlarm (double seconds_) {
  auto var = new struct TdSetAlarm ();
  var->ID = CODE_SetAlarm;
  var->refcnt = 1;
  var->seconds_ = seconds_;
  return var;
}
td::td_api::object_ptr<td::td_api::setAlarm> TdConvertToInternal (struct TdSetAlarm *var) {
  if (!var) {
    return nullptr;
  }
  double v0;
  v0 = var->seconds_;
  return td::td_api::make_object<td::td_api::setAlarm>(std::move (v0));
}
struct TdSetAlarm *TdConvertFromInternal (const td::td_api::setAlarm &from) {
  auto res = new TdSetAlarm ();
  res->ID = CODE_SetAlarm;
  res->refcnt = 1;
  res->seconds_ = from.seconds_;
  return res;
}
char *TdSerializeSetAlarm (struct TdSetAlarm *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetAlarm *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetAlarm (struct TdSetAlarm *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetAlarm *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSetAlarm (struct TdSetAlarm *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetAlarm *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetAlarm");
  M->new_field ("ID");
  M->pack_double (var->seconds_);
  M->new_field ("seconds_");
}
struct TdSetAlarm *TdStackFetcherSetAlarm (struct TdStackFetcherMethods *M) {
  auto res = new TdSetAlarm ();
  res->ID = CODE_SetAlarm;
  res->refcnt = 1;
  M->get_field ("seconds_");
  res->seconds_ = M->get_double ();
  M->pop ();
  return res;
}
struct TdSetAuthenticationPhoneNumber *TdCreateObjectSetAuthenticationPhoneNumber (char *phone_number_, int allow_flash_call_, int is_current_phone_number_) {
  auto var = new struct TdSetAuthenticationPhoneNumber ();
  var->ID = CODE_SetAuthenticationPhoneNumber;
  var->refcnt = 1;
  var->phone_number_ = (phone_number_) ? td::str_dup (td::Slice (phone_number_)) : nullptr;
  var->allow_flash_call_ = allow_flash_call_;
  var->is_current_phone_number_ = is_current_phone_number_;
  return var;
}
td::td_api::object_ptr<td::td_api::setAuthenticationPhoneNumber> TdConvertToInternal (struct TdSetAuthenticationPhoneNumber *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->phone_number_) ? var->phone_number_: "";
  bool v100;
  v100 = var->allow_flash_call_ != 0;
  bool v200;
  v200 = var->is_current_phone_number_ != 0;
  return td::td_api::make_object<td::td_api::setAuthenticationPhoneNumber>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdSetAuthenticationPhoneNumber *TdConvertFromInternal (const td::td_api::setAuthenticationPhoneNumber &from) {
  auto res = new TdSetAuthenticationPhoneNumber ();
  res->ID = CODE_SetAuthenticationPhoneNumber;
  res->refcnt = 1;
  res->phone_number_ = (from.phone_number_.length ()) ? td::str_dup (from.phone_number_) : nullptr;
  res->allow_flash_call_ = from.allow_flash_call_;
  res->is_current_phone_number_ = from.is_current_phone_number_;
  return res;
}
char *TdSerializeSetAuthenticationPhoneNumber (struct TdSetAuthenticationPhoneNumber *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetAuthenticationPhoneNumber *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetAuthenticationPhoneNumber (struct TdSetAuthenticationPhoneNumber *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetAuthenticationPhoneNumber *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->phone_number_);
  delete var;
}
void TdStackStorerSetAuthenticationPhoneNumber (struct TdSetAuthenticationPhoneNumber *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetAuthenticationPhoneNumber *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetAuthenticationPhoneNumber");
  M->new_field ("ID");
  M->pack_string (var->phone_number_);
  M->new_field ("phone_number_");
  M->pack_bool (var->allow_flash_call_);
  M->new_field ("allow_flash_call_");
  M->pack_bool (var->is_current_phone_number_);
  M->new_field ("is_current_phone_number_");
}
struct TdSetAuthenticationPhoneNumber *TdStackFetcherSetAuthenticationPhoneNumber (struct TdStackFetcherMethods *M) {
  auto res = new TdSetAuthenticationPhoneNumber ();
  res->ID = CODE_SetAuthenticationPhoneNumber;
  res->refcnt = 1;
  M->get_field ("phone_number_");
  res->phone_number_ = M->get_string ();
  M->pop ();
  M->get_field ("allow_flash_call_");
  res->allow_flash_call_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_current_phone_number_");
  res->is_current_phone_number_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSetBio *TdCreateObjectSetBio (char *bio_) {
  auto var = new struct TdSetBio ();
  var->ID = CODE_SetBio;
  var->refcnt = 1;
  var->bio_ = (bio_) ? td::str_dup (td::Slice (bio_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setBio> TdConvertToInternal (struct TdSetBio *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->bio_) ? var->bio_: "";
  return td::td_api::make_object<td::td_api::setBio>(std::move (v0));
}
struct TdSetBio *TdConvertFromInternal (const td::td_api::setBio &from) {
  auto res = new TdSetBio ();
  res->ID = CODE_SetBio;
  res->refcnt = 1;
  res->bio_ = (from.bio_.length ()) ? td::str_dup (from.bio_) : nullptr;
  return res;
}
char *TdSerializeSetBio (struct TdSetBio *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetBio *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetBio (struct TdSetBio *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetBio *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->bio_);
  delete var;
}
void TdStackStorerSetBio (struct TdSetBio *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetBio *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetBio");
  M->new_field ("ID");
  M->pack_string (var->bio_);
  M->new_field ("bio_");
}
struct TdSetBio *TdStackFetcherSetBio (struct TdStackFetcherMethods *M) {
  auto res = new TdSetBio ();
  res->ID = CODE_SetBio;
  res->refcnt = 1;
  M->get_field ("bio_");
  res->bio_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetBotUpdatesStatus *TdCreateObjectSetBotUpdatesStatus (int pending_update_count_, char *error_message_) {
  auto var = new struct TdSetBotUpdatesStatus ();
  var->ID = CODE_SetBotUpdatesStatus;
  var->refcnt = 1;
  var->pending_update_count_ = pending_update_count_;
  var->error_message_ = (error_message_) ? td::str_dup (td::Slice (error_message_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setBotUpdatesStatus> TdConvertToInternal (struct TdSetBotUpdatesStatus *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->pending_update_count_;
  std::string v100;
  v100 = (var->error_message_) ? var->error_message_: "";
  return td::td_api::make_object<td::td_api::setBotUpdatesStatus>(std::move (v0), std::move (v100));
}
struct TdSetBotUpdatesStatus *TdConvertFromInternal (const td::td_api::setBotUpdatesStatus &from) {
  auto res = new TdSetBotUpdatesStatus ();
  res->ID = CODE_SetBotUpdatesStatus;
  res->refcnt = 1;
  res->pending_update_count_ = from.pending_update_count_;
  res->error_message_ = (from.error_message_.length ()) ? td::str_dup (from.error_message_) : nullptr;
  return res;
}
char *TdSerializeSetBotUpdatesStatus (struct TdSetBotUpdatesStatus *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetBotUpdatesStatus *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetBotUpdatesStatus (struct TdSetBotUpdatesStatus *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetBotUpdatesStatus *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->error_message_);
  delete var;
}
void TdStackStorerSetBotUpdatesStatus (struct TdSetBotUpdatesStatus *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetBotUpdatesStatus *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetBotUpdatesStatus");
  M->new_field ("ID");
  M->pack_long (var->pending_update_count_);
  M->new_field ("pending_update_count_");
  M->pack_string (var->error_message_);
  M->new_field ("error_message_");
}
struct TdSetBotUpdatesStatus *TdStackFetcherSetBotUpdatesStatus (struct TdStackFetcherMethods *M) {
  auto res = new TdSetBotUpdatesStatus ();
  res->ID = CODE_SetBotUpdatesStatus;
  res->refcnt = 1;
  M->get_field ("pending_update_count_");
  res->pending_update_count_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("error_message_");
  res->error_message_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetChatClientData *TdCreateObjectSetChatClientData (long long chat_id_, char *client_data_) {
  auto var = new struct TdSetChatClientData ();
  var->ID = CODE_SetChatClientData;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->client_data_ = (client_data_) ? td::str_dup (td::Slice (client_data_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setChatClientData> TdConvertToInternal (struct TdSetChatClientData *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->client_data_) ? var->client_data_: "";
  return td::td_api::make_object<td::td_api::setChatClientData>(std::move (v0), std::move (v100));
}
struct TdSetChatClientData *TdConvertFromInternal (const td::td_api::setChatClientData &from) {
  auto res = new TdSetChatClientData ();
  res->ID = CODE_SetChatClientData;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->client_data_ = (from.client_data_.length ()) ? td::str_dup (from.client_data_) : nullptr;
  return res;
}
char *TdSerializeSetChatClientData (struct TdSetChatClientData *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetChatClientData *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetChatClientData (struct TdSetChatClientData *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetChatClientData *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->client_data_);
  delete var;
}
void TdStackStorerSetChatClientData (struct TdSetChatClientData *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetChatClientData *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetChatClientData");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->client_data_);
  M->new_field ("client_data_");
}
struct TdSetChatClientData *TdStackFetcherSetChatClientData (struct TdStackFetcherMethods *M) {
  auto res = new TdSetChatClientData ();
  res->ID = CODE_SetChatClientData;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("client_data_");
  res->client_data_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetChatDraftMessage *TdCreateObjectSetChatDraftMessage (long long chat_id_, struct TdDraftMessage *draft_message_) {
  auto var = new struct TdSetChatDraftMessage ();
  var->ID = CODE_SetChatDraftMessage;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->draft_message_ = draft_message_;
  return var;
}
td::td_api::object_ptr<td::td_api::setChatDraftMessage> TdConvertToInternal (struct TdSetChatDraftMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::draftMessage> v100;
  v100 = TdConvertToInternal (var->draft_message_);
  return td::td_api::make_object<td::td_api::setChatDraftMessage>(std::move (v0), std::move (v100));
}
struct TdSetChatDraftMessage *TdConvertFromInternal (const td::td_api::setChatDraftMessage &from) {
  auto res = new TdSetChatDraftMessage ();
  res->ID = CODE_SetChatDraftMessage;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.draft_message_) {
    res->draft_message_ = nullptr;
  } else {
    res->draft_message_ = TdConvertFromInternal (static_cast<const td::td_api::draftMessage &>(*from.draft_message_));
  }
  return res;
}
char *TdSerializeSetChatDraftMessage (struct TdSetChatDraftMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetChatDraftMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetChatDraftMessage (struct TdSetChatDraftMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetChatDraftMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->draft_message_);
  delete var;
}
void TdStackStorerSetChatDraftMessage (struct TdSetChatDraftMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetChatDraftMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetChatDraftMessage");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->draft_message_, M);
  M->new_field ("draft_message_");
}
struct TdSetChatDraftMessage *TdStackFetcherSetChatDraftMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdSetChatDraftMessage ();
  res->ID = CODE_SetChatDraftMessage;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("draft_message_");
  if (M->is_nil ()) {
    res->draft_message_ = nullptr;
  } else {
    res->draft_message_ = TdStackFetcherDraftMessage (M);
  }
  M->pop ();
  return res;
}
struct TdSetChatMemberStatus *TdCreateObjectSetChatMemberStatus (long long chat_id_, int user_id_, struct TdChatMemberStatus *status_) {
  auto var = new struct TdSetChatMemberStatus ();
  var->ID = CODE_SetChatMemberStatus;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->user_id_ = user_id_;
  var->status_ = status_;
  return var;
}
td::td_api::object_ptr<td::td_api::setChatMemberStatus> TdConvertToInternal (struct TdSetChatMemberStatus *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int32_t v100;
  v100 = var->user_id_;
  td::td_api::object_ptr<td::td_api::ChatMemberStatus> v200;
  v200 = TdConvertToInternal (var->status_);
  return td::td_api::make_object<td::td_api::setChatMemberStatus>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdSetChatMemberStatus *TdConvertFromInternal (const td::td_api::setChatMemberStatus &from) {
  auto res = new TdSetChatMemberStatus ();
  res->ID = CODE_SetChatMemberStatus;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->user_id_ = from.user_id_;
  if (!from.status_) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdConvertFromInternal (static_cast<const td::td_api::ChatMemberStatus &>(*from.status_));
  }
  return res;
}
char *TdSerializeSetChatMemberStatus (struct TdSetChatMemberStatus *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetChatMemberStatus *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetChatMemberStatus (struct TdSetChatMemberStatus *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetChatMemberStatus *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->status_);
  delete var;
}
void TdStackStorerSetChatMemberStatus (struct TdSetChatMemberStatus *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetChatMemberStatus *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetChatMemberStatus");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->status_, M);
  M->new_field ("status_");
}
struct TdSetChatMemberStatus *TdStackFetcherSetChatMemberStatus (struct TdStackFetcherMethods *M) {
  auto res = new TdSetChatMemberStatus ();
  res->ID = CODE_SetChatMemberStatus;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("status_");
  if (M->is_nil ()) {
    res->status_ = nullptr;
  } else {
    res->status_ = TdStackFetcherChatMemberStatus (M);
  }
  M->pop ();
  return res;
}
struct TdSetChatNotificationSettings *TdCreateObjectSetChatNotificationSettings (long long chat_id_, struct TdChatNotificationSettings *notification_settings_) {
  auto var = new struct TdSetChatNotificationSettings ();
  var->ID = CODE_SetChatNotificationSettings;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->notification_settings_ = notification_settings_;
  return var;
}
td::td_api::object_ptr<td::td_api::setChatNotificationSettings> TdConvertToInternal (struct TdSetChatNotificationSettings *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::chatNotificationSettings> v100;
  v100 = TdConvertToInternal (var->notification_settings_);
  return td::td_api::make_object<td::td_api::setChatNotificationSettings>(std::move (v0), std::move (v100));
}
struct TdSetChatNotificationSettings *TdConvertFromInternal (const td::td_api::setChatNotificationSettings &from) {
  auto res = new TdSetChatNotificationSettings ();
  res->ID = CODE_SetChatNotificationSettings;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.notification_settings_) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdConvertFromInternal (static_cast<const td::td_api::chatNotificationSettings &>(*from.notification_settings_));
  }
  return res;
}
char *TdSerializeSetChatNotificationSettings (struct TdSetChatNotificationSettings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetChatNotificationSettings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetChatNotificationSettings (struct TdSetChatNotificationSettings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetChatNotificationSettings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->notification_settings_);
  delete var;
}
void TdStackStorerSetChatNotificationSettings (struct TdSetChatNotificationSettings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetChatNotificationSettings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetChatNotificationSettings");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->notification_settings_, M);
  M->new_field ("notification_settings_");
}
struct TdSetChatNotificationSettings *TdStackFetcherSetChatNotificationSettings (struct TdStackFetcherMethods *M) {
  auto res = new TdSetChatNotificationSettings ();
  res->ID = CODE_SetChatNotificationSettings;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("notification_settings_");
  if (M->is_nil ()) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdStackFetcherChatNotificationSettings (M);
  }
  M->pop ();
  return res;
}
struct TdSetChatPhoto *TdCreateObjectSetChatPhoto (long long chat_id_, struct TdInputFile *photo_) {
  auto var = new struct TdSetChatPhoto ();
  var->ID = CODE_SetChatPhoto;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->photo_ = photo_;
  return var;
}
td::td_api::object_ptr<td::td_api::setChatPhoto> TdConvertToInternal (struct TdSetChatPhoto *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  td::td_api::object_ptr<td::td_api::InputFile> v100;
  v100 = TdConvertToInternal (var->photo_);
  return td::td_api::make_object<td::td_api::setChatPhoto>(std::move (v0), std::move (v100));
}
struct TdSetChatPhoto *TdConvertFromInternal (const td::td_api::setChatPhoto &from) {
  auto res = new TdSetChatPhoto ();
  res->ID = CODE_SetChatPhoto;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.photo_));
  }
  return res;
}
char *TdSerializeSetChatPhoto (struct TdSetChatPhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetChatPhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetChatPhoto (struct TdSetChatPhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetChatPhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->photo_);
  delete var;
}
void TdStackStorerSetChatPhoto (struct TdSetChatPhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetChatPhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetChatPhoto");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
}
struct TdSetChatPhoto *TdStackFetcherSetChatPhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdSetChatPhoto ();
  res->ID = CODE_SetChatPhoto;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdSetChatTitle *TdCreateObjectSetChatTitle (long long chat_id_, char *title_) {
  auto var = new struct TdSetChatTitle ();
  var->ID = CODE_SetChatTitle;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->title_ = (title_) ? td::str_dup (td::Slice (title_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setChatTitle> TdConvertToInternal (struct TdSetChatTitle *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::string v100;
  v100 = (var->title_) ? var->title_: "";
  return td::td_api::make_object<td::td_api::setChatTitle>(std::move (v0), std::move (v100));
}
struct TdSetChatTitle *TdConvertFromInternal (const td::td_api::setChatTitle &from) {
  auto res = new TdSetChatTitle ();
  res->ID = CODE_SetChatTitle;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->title_ = (from.title_.length ()) ? td::str_dup (from.title_) : nullptr;
  return res;
}
char *TdSerializeSetChatTitle (struct TdSetChatTitle *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetChatTitle *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetChatTitle (struct TdSetChatTitle *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetChatTitle *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->title_);
  delete var;
}
void TdStackStorerSetChatTitle (struct TdSetChatTitle *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetChatTitle *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetChatTitle");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_string (var->title_);
  M->new_field ("title_");
}
struct TdSetChatTitle *TdStackFetcherSetChatTitle (struct TdStackFetcherMethods *M) {
  auto res = new TdSetChatTitle ();
  res->ID = CODE_SetChatTitle;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("title_");
  res->title_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetCustomLanguagePack *TdCreateObjectSetCustomLanguagePack (struct TdLanguagePackInfo *info_, struct TdVectorLanguagePackString *strings_) {
  auto var = new struct TdSetCustomLanguagePack ();
  var->ID = CODE_SetCustomLanguagePack;
  var->refcnt = 1;
  var->info_ = info_;
  var->strings_ = strings_;
  return var;
}
td::td_api::object_ptr<td::td_api::setCustomLanguagePack> TdConvertToInternal (struct TdSetCustomLanguagePack *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::languagePackInfo> v0;
  v0 = TdConvertToInternal (var->info_);
  std::vector<td::td_api::object_ptr<td::td_api::languagePackString>> v100;
  for (int i100 = 0; i100 < var->strings_->len; i100++) {
    td::td_api::object_ptr<td::td_api::languagePackString> v101;
    v101 = TdConvertToInternal (var->strings_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::setCustomLanguagePack>(std::move (v0), std::move (v100));
}
struct TdSetCustomLanguagePack *TdConvertFromInternal (const td::td_api::setCustomLanguagePack &from) {
  auto res = new TdSetCustomLanguagePack ();
  res->ID = CODE_SetCustomLanguagePack;
  res->refcnt = 1;
  if (!from.info_) {
    res->info_ = nullptr;
  } else {
    res->info_ = TdConvertFromInternal (static_cast<const td::td_api::languagePackInfo &>(*from.info_));
  }
  res->strings_ = new TdVectorLanguagePackString ();
  res->strings_->len = (int)from.strings_.size ();
  res->strings_->data = new struct TdLanguagePackString * [res->strings_->len];
  for (int i100 = 0; i100 < res->strings_->len; i100++) {
    if (!from.strings_[i100]) {
      res->strings_->data[i100] = nullptr;
    } else {
      res->strings_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::languagePackString &>(*from.strings_[i100]));
    }
  }
  return res;
}
char *TdSerializeSetCustomLanguagePack (struct TdSetCustomLanguagePack *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetCustomLanguagePack *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetCustomLanguagePack (struct TdSetCustomLanguagePack *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetCustomLanguagePack *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->info_);
  for (int i100 = 0; i100 < var->strings_->len; i100++) {
    TdDestroyObject (var->strings_->data[i100]);
  }
  delete[] var->strings_->data;
  delete var->strings_;
  delete var;
}
void TdStackStorerSetCustomLanguagePack (struct TdSetCustomLanguagePack *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetCustomLanguagePack *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetCustomLanguagePack");
  M->new_field ("ID");
  TdStackStorer (var->info_, M);
  M->new_field ("info_");
  M->new_array ();
  for (int i100 = 0; i100 < var->strings_->len; i100++) {
    TdStackStorer (var->strings_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("strings_");
}
struct TdSetCustomLanguagePack *TdStackFetcherSetCustomLanguagePack (struct TdStackFetcherMethods *M) {
  auto res = new TdSetCustomLanguagePack ();
  res->ID = CODE_SetCustomLanguagePack;
  res->refcnt = 1;
  M->get_field ("info_");
  if (M->is_nil ()) {
    res->info_ = nullptr;
  } else {
    res->info_ = TdStackFetcherLanguagePackInfo (M);
  }
  M->pop ();
  M->get_field ("strings_");
  res->strings_ = new TdVectorLanguagePackString ();
  res->strings_->len = M->get_arr_size ();
  res->strings_->data = new struct TdLanguagePackString * [res->strings_->len];
  for (int i100 = 0; i100 < res->strings_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->strings_->data[i100] = nullptr;
    } else {
      res->strings_->data[i100] = TdStackFetcherLanguagePackString (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdSetCustomLanguagePackString *TdCreateObjectSetCustomLanguagePackString (char *language_pack_id_, struct TdLanguagePackString *new_string_) {
  auto var = new struct TdSetCustomLanguagePackString ();
  var->ID = CODE_SetCustomLanguagePackString;
  var->refcnt = 1;
  var->language_pack_id_ = (language_pack_id_) ? td::str_dup (td::Slice (language_pack_id_)) : nullptr;
  var->new_string_ = new_string_;
  return var;
}
td::td_api::object_ptr<td::td_api::setCustomLanguagePackString> TdConvertToInternal (struct TdSetCustomLanguagePackString *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->language_pack_id_) ? var->language_pack_id_: "";
  td::td_api::object_ptr<td::td_api::languagePackString> v100;
  v100 = TdConvertToInternal (var->new_string_);
  return td::td_api::make_object<td::td_api::setCustomLanguagePackString>(std::move (v0), std::move (v100));
}
struct TdSetCustomLanguagePackString *TdConvertFromInternal (const td::td_api::setCustomLanguagePackString &from) {
  auto res = new TdSetCustomLanguagePackString ();
  res->ID = CODE_SetCustomLanguagePackString;
  res->refcnt = 1;
  res->language_pack_id_ = (from.language_pack_id_.length ()) ? td::str_dup (from.language_pack_id_) : nullptr;
  if (!from.new_string_) {
    res->new_string_ = nullptr;
  } else {
    res->new_string_ = TdConvertFromInternal (static_cast<const td::td_api::languagePackString &>(*from.new_string_));
  }
  return res;
}
char *TdSerializeSetCustomLanguagePackString (struct TdSetCustomLanguagePackString *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetCustomLanguagePackString *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetCustomLanguagePackString (struct TdSetCustomLanguagePackString *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetCustomLanguagePackString *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->language_pack_id_);
  TdDestroyObject (var->new_string_);
  delete var;
}
void TdStackStorerSetCustomLanguagePackString (struct TdSetCustomLanguagePackString *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetCustomLanguagePackString *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetCustomLanguagePackString");
  M->new_field ("ID");
  M->pack_string (var->language_pack_id_);
  M->new_field ("language_pack_id_");
  TdStackStorer (var->new_string_, M);
  M->new_field ("new_string_");
}
struct TdSetCustomLanguagePackString *TdStackFetcherSetCustomLanguagePackString (struct TdStackFetcherMethods *M) {
  auto res = new TdSetCustomLanguagePackString ();
  res->ID = CODE_SetCustomLanguagePackString;
  res->refcnt = 1;
  M->get_field ("language_pack_id_");
  res->language_pack_id_ = M->get_string ();
  M->pop ();
  M->get_field ("new_string_");
  if (M->is_nil ()) {
    res->new_string_ = nullptr;
  } else {
    res->new_string_ = TdStackFetcherLanguagePackString (M);
  }
  M->pop ();
  return res;
}
struct TdSetDatabaseEncryptionKey *TdCreateObjectSetDatabaseEncryptionKey (struct TdBytes new_encryption_key_) {
  auto var = new struct TdSetDatabaseEncryptionKey ();
  var->ID = CODE_SetDatabaseEncryptionKey;
  var->refcnt = 1;
  var->new_encryption_key_ = new_encryption_key_;
  return var;
}
td::td_api::object_ptr<td::td_api::setDatabaseEncryptionKey> TdConvertToInternal (struct TdSetDatabaseEncryptionKey *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->new_encryption_key_.data, var->new_encryption_key_.len);
  return td::td_api::make_object<td::td_api::setDatabaseEncryptionKey>(std::move (v0));
}
struct TdSetDatabaseEncryptionKey *TdConvertFromInternal (const td::td_api::setDatabaseEncryptionKey &from) {
  auto res = new TdSetDatabaseEncryptionKey ();
  res->ID = CODE_SetDatabaseEncryptionKey;
  res->refcnt = 1;
  res->new_encryption_key_.len = (int)from.new_encryption_key_.length ();
  if (res->new_encryption_key_.len) {
    res->new_encryption_key_.data = new unsigned char[res->new_encryption_key_.len];
    memcpy (res->new_encryption_key_.data, from.new_encryption_key_.c_str (), res->new_encryption_key_.len);
  } else {
    res->new_encryption_key_.data = nullptr;
  }
  return res;
}
char *TdSerializeSetDatabaseEncryptionKey (struct TdSetDatabaseEncryptionKey *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetDatabaseEncryptionKey *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetDatabaseEncryptionKey (struct TdSetDatabaseEncryptionKey *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetDatabaseEncryptionKey *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->new_encryption_key_.data;
  delete var;
}
void TdStackStorerSetDatabaseEncryptionKey (struct TdSetDatabaseEncryptionKey *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetDatabaseEncryptionKey *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetDatabaseEncryptionKey");
  M->new_field ("ID");
  M->pack_bytes (var->new_encryption_key_.data, var->new_encryption_key_.len);
  M->new_field ("new_encryption_key_");
}
struct TdSetDatabaseEncryptionKey *TdStackFetcherSetDatabaseEncryptionKey (struct TdStackFetcherMethods *M) {
  auto res = new TdSetDatabaseEncryptionKey ();
  res->ID = CODE_SetDatabaseEncryptionKey;
  res->refcnt = 1;
  M->get_field ("new_encryption_key_");
  res->new_encryption_key_.data = M->get_bytes (&res->new_encryption_key_.len);
  M->pop ();
  return res;
}
struct TdSetFileGenerationProgress *TdCreateObjectSetFileGenerationProgress (long long generation_id_, int expected_size_, int local_prefix_size_) {
  auto var = new struct TdSetFileGenerationProgress ();
  var->ID = CODE_SetFileGenerationProgress;
  var->refcnt = 1;
  var->generation_id_ = generation_id_;
  var->expected_size_ = expected_size_;
  var->local_prefix_size_ = local_prefix_size_;
  return var;
}
td::td_api::object_ptr<td::td_api::setFileGenerationProgress> TdConvertToInternal (struct TdSetFileGenerationProgress *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->generation_id_;
  std::int32_t v100;
  v100 = var->expected_size_;
  std::int32_t v200;
  v200 = var->local_prefix_size_;
  return td::td_api::make_object<td::td_api::setFileGenerationProgress>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdSetFileGenerationProgress *TdConvertFromInternal (const td::td_api::setFileGenerationProgress &from) {
  auto res = new TdSetFileGenerationProgress ();
  res->ID = CODE_SetFileGenerationProgress;
  res->refcnt = 1;
  res->generation_id_ = from.generation_id_;
  res->expected_size_ = from.expected_size_;
  res->local_prefix_size_ = from.local_prefix_size_;
  return res;
}
char *TdSerializeSetFileGenerationProgress (struct TdSetFileGenerationProgress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetFileGenerationProgress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetFileGenerationProgress (struct TdSetFileGenerationProgress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetFileGenerationProgress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSetFileGenerationProgress (struct TdSetFileGenerationProgress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetFileGenerationProgress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetFileGenerationProgress");
  M->new_field ("ID");
  M->pack_long (var->generation_id_);
  M->new_field ("generation_id_");
  M->pack_long (var->expected_size_);
  M->new_field ("expected_size_");
  M->pack_long (var->local_prefix_size_);
  M->new_field ("local_prefix_size_");
}
struct TdSetFileGenerationProgress *TdStackFetcherSetFileGenerationProgress (struct TdStackFetcherMethods *M) {
  auto res = new TdSetFileGenerationProgress ();
  res->ID = CODE_SetFileGenerationProgress;
  res->refcnt = 1;
  M->get_field ("generation_id_");
  res->generation_id_ = M->get_long ();
  M->pop ();
  M->get_field ("expected_size_");
  res->expected_size_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("local_prefix_size_");
  res->local_prefix_size_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSetGameScore *TdCreateObjectSetGameScore (long long chat_id_, long long message_id_, int edit_message_, int user_id_, int score_, int force_) {
  auto var = new struct TdSetGameScore ();
  var->ID = CODE_SetGameScore;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->edit_message_ = edit_message_;
  var->user_id_ = user_id_;
  var->score_ = score_;
  var->force_ = force_;
  return var;
}
td::td_api::object_ptr<td::td_api::setGameScore> TdConvertToInternal (struct TdSetGameScore *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  bool v200;
  v200 = var->edit_message_ != 0;
  std::int32_t v300;
  v300 = var->user_id_;
  std::int32_t v400;
  v400 = var->score_;
  bool v500;
  v500 = var->force_ != 0;
  return td::td_api::make_object<td::td_api::setGameScore>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400), std::move (v500));
}
struct TdSetGameScore *TdConvertFromInternal (const td::td_api::setGameScore &from) {
  auto res = new TdSetGameScore ();
  res->ID = CODE_SetGameScore;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  res->edit_message_ = from.edit_message_;
  res->user_id_ = from.user_id_;
  res->score_ = from.score_;
  res->force_ = from.force_;
  return res;
}
char *TdSerializeSetGameScore (struct TdSetGameScore *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetGameScore *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetGameScore (struct TdSetGameScore *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetGameScore *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSetGameScore (struct TdSetGameScore *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetGameScore *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetGameScore");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  M->pack_bool (var->edit_message_);
  M->new_field ("edit_message_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_long (var->score_);
  M->new_field ("score_");
  M->pack_bool (var->force_);
  M->new_field ("force_");
}
struct TdSetGameScore *TdStackFetcherSetGameScore (struct TdStackFetcherMethods *M) {
  auto res = new TdSetGameScore ();
  res->ID = CODE_SetGameScore;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("edit_message_");
  res->edit_message_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("score_");
  res->score_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("force_");
  res->force_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSetInlineGameScore *TdCreateObjectSetInlineGameScore (char *inline_message_id_, int edit_message_, int user_id_, int score_, int force_) {
  auto var = new struct TdSetInlineGameScore ();
  var->ID = CODE_SetInlineGameScore;
  var->refcnt = 1;
  var->inline_message_id_ = (inline_message_id_) ? td::str_dup (td::Slice (inline_message_id_)) : nullptr;
  var->edit_message_ = edit_message_;
  var->user_id_ = user_id_;
  var->score_ = score_;
  var->force_ = force_;
  return var;
}
td::td_api::object_ptr<td::td_api::setInlineGameScore> TdConvertToInternal (struct TdSetInlineGameScore *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->inline_message_id_) ? var->inline_message_id_: "";
  bool v100;
  v100 = var->edit_message_ != 0;
  std::int32_t v200;
  v200 = var->user_id_;
  std::int32_t v300;
  v300 = var->score_;
  bool v400;
  v400 = var->force_ != 0;
  return td::td_api::make_object<td::td_api::setInlineGameScore>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdSetInlineGameScore *TdConvertFromInternal (const td::td_api::setInlineGameScore &from) {
  auto res = new TdSetInlineGameScore ();
  res->ID = CODE_SetInlineGameScore;
  res->refcnt = 1;
  res->inline_message_id_ = (from.inline_message_id_.length ()) ? td::str_dup (from.inline_message_id_) : nullptr;
  res->edit_message_ = from.edit_message_;
  res->user_id_ = from.user_id_;
  res->score_ = from.score_;
  res->force_ = from.force_;
  return res;
}
char *TdSerializeSetInlineGameScore (struct TdSetInlineGameScore *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetInlineGameScore *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetInlineGameScore (struct TdSetInlineGameScore *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetInlineGameScore *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->inline_message_id_);
  delete var;
}
void TdStackStorerSetInlineGameScore (struct TdSetInlineGameScore *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetInlineGameScore *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetInlineGameScore");
  M->new_field ("ID");
  M->pack_string (var->inline_message_id_);
  M->new_field ("inline_message_id_");
  M->pack_bool (var->edit_message_);
  M->new_field ("edit_message_");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->pack_long (var->score_);
  M->new_field ("score_");
  M->pack_bool (var->force_);
  M->new_field ("force_");
}
struct TdSetInlineGameScore *TdStackFetcherSetInlineGameScore (struct TdStackFetcherMethods *M) {
  auto res = new TdSetInlineGameScore ();
  res->ID = CODE_SetInlineGameScore;
  res->refcnt = 1;
  M->get_field ("inline_message_id_");
  res->inline_message_id_ = M->get_string ();
  M->pop ();
  M->get_field ("edit_message_");
  res->edit_message_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("score_");
  res->score_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("force_");
  res->force_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSetName *TdCreateObjectSetName (char *first_name_, char *last_name_) {
  auto var = new struct TdSetName ();
  var->ID = CODE_SetName;
  var->refcnt = 1;
  var->first_name_ = (first_name_) ? td::str_dup (td::Slice (first_name_)) : nullptr;
  var->last_name_ = (last_name_) ? td::str_dup (td::Slice (last_name_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setName> TdConvertToInternal (struct TdSetName *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->first_name_) ? var->first_name_: "";
  std::string v100;
  v100 = (var->last_name_) ? var->last_name_: "";
  return td::td_api::make_object<td::td_api::setName>(std::move (v0), std::move (v100));
}
struct TdSetName *TdConvertFromInternal (const td::td_api::setName &from) {
  auto res = new TdSetName ();
  res->ID = CODE_SetName;
  res->refcnt = 1;
  res->first_name_ = (from.first_name_.length ()) ? td::str_dup (from.first_name_) : nullptr;
  res->last_name_ = (from.last_name_.length ()) ? td::str_dup (from.last_name_) : nullptr;
  return res;
}
char *TdSerializeSetName (struct TdSetName *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetName *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetName (struct TdSetName *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetName *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->first_name_);
  free (var->last_name_);
  delete var;
}
void TdStackStorerSetName (struct TdSetName *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetName *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetName");
  M->new_field ("ID");
  M->pack_string (var->first_name_);
  M->new_field ("first_name_");
  M->pack_string (var->last_name_);
  M->new_field ("last_name_");
}
struct TdSetName *TdStackFetcherSetName (struct TdStackFetcherMethods *M) {
  auto res = new TdSetName ();
  res->ID = CODE_SetName;
  res->refcnt = 1;
  M->get_field ("first_name_");
  res->first_name_ = M->get_string ();
  M->pop ();
  M->get_field ("last_name_");
  res->last_name_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetNetworkType *TdCreateObjectSetNetworkType (struct TdNetworkType *type_) {
  auto var = new struct TdSetNetworkType ();
  var->ID = CODE_SetNetworkType;
  var->refcnt = 1;
  var->type_ = type_;
  return var;
}
td::td_api::object_ptr<td::td_api::setNetworkType> TdConvertToInternal (struct TdSetNetworkType *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::NetworkType> v0;
  v0 = TdConvertToInternal (var->type_);
  return td::td_api::make_object<td::td_api::setNetworkType>(std::move (v0));
}
struct TdSetNetworkType *TdConvertFromInternal (const td::td_api::setNetworkType &from) {
  auto res = new TdSetNetworkType ();
  res->ID = CODE_SetNetworkType;
  res->refcnt = 1;
  if (!from.type_) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdConvertFromInternal (static_cast<const td::td_api::NetworkType &>(*from.type_));
  }
  return res;
}
char *TdSerializeSetNetworkType (struct TdSetNetworkType *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetNetworkType *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetNetworkType (struct TdSetNetworkType *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetNetworkType *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->type_);
  delete var;
}
void TdStackStorerSetNetworkType (struct TdSetNetworkType *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetNetworkType *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetNetworkType");
  M->new_field ("ID");
  TdStackStorer (var->type_, M);
  M->new_field ("type_");
}
struct TdSetNetworkType *TdStackFetcherSetNetworkType (struct TdStackFetcherMethods *M) {
  auto res = new TdSetNetworkType ();
  res->ID = CODE_SetNetworkType;
  res->refcnt = 1;
  M->get_field ("type_");
  if (M->is_nil ()) {
    res->type_ = nullptr;
  } else {
    res->type_ = TdStackFetcherNetworkType (M);
  }
  M->pop ();
  return res;
}
struct TdSetOption *TdCreateObjectSetOption (char *name_, struct TdOptionValue *value_) {
  auto var = new struct TdSetOption ();
  var->ID = CODE_SetOption;
  var->refcnt = 1;
  var->name_ = (name_) ? td::str_dup (td::Slice (name_)) : nullptr;
  var->value_ = value_;
  return var;
}
td::td_api::object_ptr<td::td_api::setOption> TdConvertToInternal (struct TdSetOption *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->name_) ? var->name_: "";
  td::td_api::object_ptr<td::td_api::OptionValue> v100;
  v100 = TdConvertToInternal (var->value_);
  return td::td_api::make_object<td::td_api::setOption>(std::move (v0), std::move (v100));
}
struct TdSetOption *TdConvertFromInternal (const td::td_api::setOption &from) {
  auto res = new TdSetOption ();
  res->ID = CODE_SetOption;
  res->refcnt = 1;
  res->name_ = (from.name_.length ()) ? td::str_dup (from.name_) : nullptr;
  if (!from.value_) {
    res->value_ = nullptr;
  } else {
    res->value_ = TdConvertFromInternal (static_cast<const td::td_api::OptionValue &>(*from.value_));
  }
  return res;
}
char *TdSerializeSetOption (struct TdSetOption *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetOption *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetOption (struct TdSetOption *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetOption *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->name_);
  TdDestroyObject (var->value_);
  delete var;
}
void TdStackStorerSetOption (struct TdSetOption *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetOption *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetOption");
  M->new_field ("ID");
  M->pack_string (var->name_);
  M->new_field ("name_");
  TdStackStorer (var->value_, M);
  M->new_field ("value_");
}
struct TdSetOption *TdStackFetcherSetOption (struct TdStackFetcherMethods *M) {
  auto res = new TdSetOption ();
  res->ID = CODE_SetOption;
  res->refcnt = 1;
  M->get_field ("name_");
  res->name_ = M->get_string ();
  M->pop ();
  M->get_field ("value_");
  if (M->is_nil ()) {
    res->value_ = nullptr;
  } else {
    res->value_ = TdStackFetcherOptionValue (M);
  }
  M->pop ();
  return res;
}
struct TdSetPassportElement *TdCreateObjectSetPassportElement (struct TdInputPassportElement *element_, char *password_) {
  auto var = new struct TdSetPassportElement ();
  var->ID = CODE_SetPassportElement;
  var->refcnt = 1;
  var->element_ = element_;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setPassportElement> TdConvertToInternal (struct TdSetPassportElement *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputPassportElement> v0;
  v0 = TdConvertToInternal (var->element_);
  std::string v100;
  v100 = (var->password_) ? var->password_: "";
  return td::td_api::make_object<td::td_api::setPassportElement>(std::move (v0), std::move (v100));
}
struct TdSetPassportElement *TdConvertFromInternal (const td::td_api::setPassportElement &from) {
  auto res = new TdSetPassportElement ();
  res->ID = CODE_SetPassportElement;
  res->refcnt = 1;
  if (!from.element_) {
    res->element_ = nullptr;
  } else {
    res->element_ = TdConvertFromInternal (static_cast<const td::td_api::InputPassportElement &>(*from.element_));
  }
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  return res;
}
char *TdSerializeSetPassportElement (struct TdSetPassportElement *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetPassportElement *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetPassportElement (struct TdSetPassportElement *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetPassportElement *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->element_);
  free (var->password_);
  delete var;
}
void TdStackStorerSetPassportElement (struct TdSetPassportElement *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetPassportElement *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetPassportElement");
  M->new_field ("ID");
  TdStackStorer (var->element_, M);
  M->new_field ("element_");
  M->pack_string (var->password_);
  M->new_field ("password_");
}
struct TdSetPassportElement *TdStackFetcherSetPassportElement (struct TdStackFetcherMethods *M) {
  auto res = new TdSetPassportElement ();
  res->ID = CODE_SetPassportElement;
  res->refcnt = 1;
  M->get_field ("element_");
  if (M->is_nil ()) {
    res->element_ = nullptr;
  } else {
    res->element_ = TdStackFetcherInputPassportElement (M);
  }
  M->pop ();
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetPassportElementErrors *TdCreateObjectSetPassportElementErrors (int user_id_, struct TdVectorInputPassportElementError *errors_) {
  auto var = new struct TdSetPassportElementErrors ();
  var->ID = CODE_SetPassportElementErrors;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->errors_ = errors_;
  return var;
}
td::td_api::object_ptr<td::td_api::setPassportElementErrors> TdConvertToInternal (struct TdSetPassportElementErrors *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  std::vector<td::td_api::object_ptr<td::td_api::inputPassportElementError>> v100;
  for (int i100 = 0; i100 < var->errors_->len; i100++) {
    td::td_api::object_ptr<td::td_api::inputPassportElementError> v101;
    v101 = TdConvertToInternal (var->errors_->data[i100]);
    v100.push_back (std::move (v101));
  }
  return td::td_api::make_object<td::td_api::setPassportElementErrors>(std::move (v0), std::move (v100));
}
struct TdSetPassportElementErrors *TdConvertFromInternal (const td::td_api::setPassportElementErrors &from) {
  auto res = new TdSetPassportElementErrors ();
  res->ID = CODE_SetPassportElementErrors;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  res->errors_ = new TdVectorInputPassportElementError ();
  res->errors_->len = (int)from.errors_.size ();
  res->errors_->data = new struct TdInputPassportElementError * [res->errors_->len];
  for (int i100 = 0; i100 < res->errors_->len; i100++) {
    if (!from.errors_[i100]) {
      res->errors_->data[i100] = nullptr;
    } else {
      res->errors_->data[i100] = TdConvertFromInternal (static_cast<const td::td_api::inputPassportElementError &>(*from.errors_[i100]));
    }
  }
  return res;
}
char *TdSerializeSetPassportElementErrors (struct TdSetPassportElementErrors *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetPassportElementErrors *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetPassportElementErrors (struct TdSetPassportElementErrors *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetPassportElementErrors *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->errors_->len; i100++) {
    TdDestroyObject (var->errors_->data[i100]);
  }
  delete[] var->errors_->data;
  delete var->errors_;
  delete var;
}
void TdStackStorerSetPassportElementErrors (struct TdSetPassportElementErrors *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetPassportElementErrors *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetPassportElementErrors");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->errors_->len; i100++) {
    TdStackStorer (var->errors_->data[i100], M);
    M->new_arr_field (i100);
  }
  M->new_field ("errors_");
}
struct TdSetPassportElementErrors *TdStackFetcherSetPassportElementErrors (struct TdStackFetcherMethods *M) {
  auto res = new TdSetPassportElementErrors ();
  res->ID = CODE_SetPassportElementErrors;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("errors_");
  res->errors_ = new TdVectorInputPassportElementError ();
  res->errors_->len = M->get_arr_size ();
  res->errors_->data = new struct TdInputPassportElementError * [res->errors_->len];
  for (int i100 = 0; i100 < res->errors_->len; i100++) {
    M->get_arr_field (i100);
    if (M->is_nil ()) {
      res->errors_->data[i100] = nullptr;
    } else {
      res->errors_->data[i100] = TdStackFetcherInputPassportElementError (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdSetPassword *TdCreateObjectSetPassword (char *old_password_, char *new_password_, char *new_hint_, int set_recovery_email_address_, char *new_recovery_email_address_) {
  auto var = new struct TdSetPassword ();
  var->ID = CODE_SetPassword;
  var->refcnt = 1;
  var->old_password_ = (old_password_) ? td::str_dup (td::Slice (old_password_)) : nullptr;
  var->new_password_ = (new_password_) ? td::str_dup (td::Slice (new_password_)) : nullptr;
  var->new_hint_ = (new_hint_) ? td::str_dup (td::Slice (new_hint_)) : nullptr;
  var->set_recovery_email_address_ = set_recovery_email_address_;
  var->new_recovery_email_address_ = (new_recovery_email_address_) ? td::str_dup (td::Slice (new_recovery_email_address_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setPassword> TdConvertToInternal (struct TdSetPassword *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->old_password_) ? var->old_password_: "";
  std::string v100;
  v100 = (var->new_password_) ? var->new_password_: "";
  std::string v200;
  v200 = (var->new_hint_) ? var->new_hint_: "";
  bool v300;
  v300 = var->set_recovery_email_address_ != 0;
  std::string v400;
  v400 = (var->new_recovery_email_address_) ? var->new_recovery_email_address_: "";
  return td::td_api::make_object<td::td_api::setPassword>(std::move (v0), std::move (v100), std::move (v200), std::move (v300), std::move (v400));
}
struct TdSetPassword *TdConvertFromInternal (const td::td_api::setPassword &from) {
  auto res = new TdSetPassword ();
  res->ID = CODE_SetPassword;
  res->refcnt = 1;
  res->old_password_ = (from.old_password_.length ()) ? td::str_dup (from.old_password_) : nullptr;
  res->new_password_ = (from.new_password_.length ()) ? td::str_dup (from.new_password_) : nullptr;
  res->new_hint_ = (from.new_hint_.length ()) ? td::str_dup (from.new_hint_) : nullptr;
  res->set_recovery_email_address_ = from.set_recovery_email_address_;
  res->new_recovery_email_address_ = (from.new_recovery_email_address_.length ()) ? td::str_dup (from.new_recovery_email_address_) : nullptr;
  return res;
}
char *TdSerializeSetPassword (struct TdSetPassword *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetPassword *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetPassword (struct TdSetPassword *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetPassword *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->old_password_);
  free (var->new_password_);
  free (var->new_hint_);
  free (var->new_recovery_email_address_);
  delete var;
}
void TdStackStorerSetPassword (struct TdSetPassword *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetPassword *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetPassword");
  M->new_field ("ID");
  M->pack_string (var->old_password_);
  M->new_field ("old_password_");
  M->pack_string (var->new_password_);
  M->new_field ("new_password_");
  M->pack_string (var->new_hint_);
  M->new_field ("new_hint_");
  M->pack_bool (var->set_recovery_email_address_);
  M->new_field ("set_recovery_email_address_");
  M->pack_string (var->new_recovery_email_address_);
  M->new_field ("new_recovery_email_address_");
}
struct TdSetPassword *TdStackFetcherSetPassword (struct TdStackFetcherMethods *M) {
  auto res = new TdSetPassword ();
  res->ID = CODE_SetPassword;
  res->refcnt = 1;
  M->get_field ("old_password_");
  res->old_password_ = M->get_string ();
  M->pop ();
  M->get_field ("new_password_");
  res->new_password_ = M->get_string ();
  M->pop ();
  M->get_field ("new_hint_");
  res->new_hint_ = M->get_string ();
  M->pop ();
  M->get_field ("set_recovery_email_address_");
  res->set_recovery_email_address_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("new_recovery_email_address_");
  res->new_recovery_email_address_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetPinnedChats *TdCreateObjectSetPinnedChats (struct TdVectorLong *chat_ids_) {
  auto var = new struct TdSetPinnedChats ();
  var->ID = CODE_SetPinnedChats;
  var->refcnt = 1;
  var->chat_ids_ = chat_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::setPinnedChats> TdConvertToInternal (struct TdSetPinnedChats *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int64_t> v0;
  for (int i0 = 0; i0 < var->chat_ids_->len; i0++) {
    std::int64_t v1;
    v1 = var->chat_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::setPinnedChats>(std::move (v0));
}
struct TdSetPinnedChats *TdConvertFromInternal (const td::td_api::setPinnedChats &from) {
  auto res = new TdSetPinnedChats ();
  res->ID = CODE_SetPinnedChats;
  res->refcnt = 1;
  res->chat_ids_ = new TdVectorLong ();
  res->chat_ids_->len = (int)from.chat_ids_.size ();
  res->chat_ids_->data = new long long  [res->chat_ids_->len];
  for (int i0 = 0; i0 < res->chat_ids_->len; i0++) {
    res->chat_ids_->data[i0] = from.chat_ids_[i0];
  }
  return res;
}
char *TdSerializeSetPinnedChats (struct TdSetPinnedChats *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetPinnedChats *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetPinnedChats (struct TdSetPinnedChats *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetPinnedChats *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->chat_ids_->len; i0++) {
  }
  delete[] var->chat_ids_->data;
  delete var->chat_ids_;
  delete var;
}
void TdStackStorerSetPinnedChats (struct TdSetPinnedChats *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetPinnedChats *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetPinnedChats");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->chat_ids_->len; i0++) {
    M->pack_long (var->chat_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("chat_ids_");
}
struct TdSetPinnedChats *TdStackFetcherSetPinnedChats (struct TdStackFetcherMethods *M) {
  auto res = new TdSetPinnedChats ();
  res->ID = CODE_SetPinnedChats;
  res->refcnt = 1;
  M->get_field ("chat_ids_");
  res->chat_ids_ = new TdVectorLong ();
  res->chat_ids_->len = M->get_arr_size ();
  res->chat_ids_->data = new long long  [res->chat_ids_->len];
  for (int i0 = 0; i0 < res->chat_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->chat_ids_->data[i0] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdSetProfilePhoto *TdCreateObjectSetProfilePhoto (struct TdInputFile *photo_) {
  auto var = new struct TdSetProfilePhoto ();
  var->ID = CODE_SetProfilePhoto;
  var->refcnt = 1;
  var->photo_ = photo_;
  return var;
}
td::td_api::object_ptr<td::td_api::setProfilePhoto> TdConvertToInternal (struct TdSetProfilePhoto *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->photo_);
  return td::td_api::make_object<td::td_api::setProfilePhoto>(std::move (v0));
}
struct TdSetProfilePhoto *TdConvertFromInternal (const td::td_api::setProfilePhoto &from) {
  auto res = new TdSetProfilePhoto ();
  res->ID = CODE_SetProfilePhoto;
  res->refcnt = 1;
  if (!from.photo_) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.photo_));
  }
  return res;
}
char *TdSerializeSetProfilePhoto (struct TdSetProfilePhoto *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetProfilePhoto *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetProfilePhoto (struct TdSetProfilePhoto *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetProfilePhoto *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->photo_);
  delete var;
}
void TdStackStorerSetProfilePhoto (struct TdSetProfilePhoto *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetProfilePhoto *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetProfilePhoto");
  M->new_field ("ID");
  TdStackStorer (var->photo_, M);
  M->new_field ("photo_");
}
struct TdSetProfilePhoto *TdStackFetcherSetProfilePhoto (struct TdStackFetcherMethods *M) {
  auto res = new TdSetProfilePhoto ();
  res->ID = CODE_SetProfilePhoto;
  res->refcnt = 1;
  M->get_field ("photo_");
  if (M->is_nil ()) {
    res->photo_ = nullptr;
  } else {
    res->photo_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdSetRecoveryEmailAddress *TdCreateObjectSetRecoveryEmailAddress (char *password_, char *new_recovery_email_address_) {
  auto var = new struct TdSetRecoveryEmailAddress ();
  var->ID = CODE_SetRecoveryEmailAddress;
  var->refcnt = 1;
  var->password_ = (password_) ? td::str_dup (td::Slice (password_)) : nullptr;
  var->new_recovery_email_address_ = (new_recovery_email_address_) ? td::str_dup (td::Slice (new_recovery_email_address_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setRecoveryEmailAddress> TdConvertToInternal (struct TdSetRecoveryEmailAddress *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->password_) ? var->password_: "";
  std::string v100;
  v100 = (var->new_recovery_email_address_) ? var->new_recovery_email_address_: "";
  return td::td_api::make_object<td::td_api::setRecoveryEmailAddress>(std::move (v0), std::move (v100));
}
struct TdSetRecoveryEmailAddress *TdConvertFromInternal (const td::td_api::setRecoveryEmailAddress &from) {
  auto res = new TdSetRecoveryEmailAddress ();
  res->ID = CODE_SetRecoveryEmailAddress;
  res->refcnt = 1;
  res->password_ = (from.password_.length ()) ? td::str_dup (from.password_) : nullptr;
  res->new_recovery_email_address_ = (from.new_recovery_email_address_.length ()) ? td::str_dup (from.new_recovery_email_address_) : nullptr;
  return res;
}
char *TdSerializeSetRecoveryEmailAddress (struct TdSetRecoveryEmailAddress *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetRecoveryEmailAddress *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetRecoveryEmailAddress (struct TdSetRecoveryEmailAddress *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetRecoveryEmailAddress *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->password_);
  free (var->new_recovery_email_address_);
  delete var;
}
void TdStackStorerSetRecoveryEmailAddress (struct TdSetRecoveryEmailAddress *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetRecoveryEmailAddress *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetRecoveryEmailAddress");
  M->new_field ("ID");
  M->pack_string (var->password_);
  M->new_field ("password_");
  M->pack_string (var->new_recovery_email_address_);
  M->new_field ("new_recovery_email_address_");
}
struct TdSetRecoveryEmailAddress *TdStackFetcherSetRecoveryEmailAddress (struct TdStackFetcherMethods *M) {
  auto res = new TdSetRecoveryEmailAddress ();
  res->ID = CODE_SetRecoveryEmailAddress;
  res->refcnt = 1;
  M->get_field ("password_");
  res->password_ = M->get_string ();
  M->pop ();
  M->get_field ("new_recovery_email_address_");
  res->new_recovery_email_address_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetScopeNotificationSettings *TdCreateObjectSetScopeNotificationSettings (struct TdNotificationSettingsScope *scope_, struct TdScopeNotificationSettings *notification_settings_) {
  auto var = new struct TdSetScopeNotificationSettings ();
  var->ID = CODE_SetScopeNotificationSettings;
  var->refcnt = 1;
  var->scope_ = scope_;
  var->notification_settings_ = notification_settings_;
  return var;
}
td::td_api::object_ptr<td::td_api::setScopeNotificationSettings> TdConvertToInternal (struct TdSetScopeNotificationSettings *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::NotificationSettingsScope> v0;
  v0 = TdConvertToInternal (var->scope_);
  td::td_api::object_ptr<td::td_api::scopeNotificationSettings> v100;
  v100 = TdConvertToInternal (var->notification_settings_);
  return td::td_api::make_object<td::td_api::setScopeNotificationSettings>(std::move (v0), std::move (v100));
}
struct TdSetScopeNotificationSettings *TdConvertFromInternal (const td::td_api::setScopeNotificationSettings &from) {
  auto res = new TdSetScopeNotificationSettings ();
  res->ID = CODE_SetScopeNotificationSettings;
  res->refcnt = 1;
  if (!from.scope_) {
    res->scope_ = nullptr;
  } else {
    res->scope_ = TdConvertFromInternal (static_cast<const td::td_api::NotificationSettingsScope &>(*from.scope_));
  }
  if (!from.notification_settings_) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdConvertFromInternal (static_cast<const td::td_api::scopeNotificationSettings &>(*from.notification_settings_));
  }
  return res;
}
char *TdSerializeSetScopeNotificationSettings (struct TdSetScopeNotificationSettings *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetScopeNotificationSettings *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetScopeNotificationSettings (struct TdSetScopeNotificationSettings *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetScopeNotificationSettings *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->scope_);
  TdDestroyObject (var->notification_settings_);
  delete var;
}
void TdStackStorerSetScopeNotificationSettings (struct TdSetScopeNotificationSettings *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetScopeNotificationSettings *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetScopeNotificationSettings");
  M->new_field ("ID");
  TdStackStorer (var->scope_, M);
  M->new_field ("scope_");
  TdStackStorer (var->notification_settings_, M);
  M->new_field ("notification_settings_");
}
struct TdSetScopeNotificationSettings *TdStackFetcherSetScopeNotificationSettings (struct TdStackFetcherMethods *M) {
  auto res = new TdSetScopeNotificationSettings ();
  res->ID = CODE_SetScopeNotificationSettings;
  res->refcnt = 1;
  M->get_field ("scope_");
  if (M->is_nil ()) {
    res->scope_ = nullptr;
  } else {
    res->scope_ = TdStackFetcherNotificationSettingsScope (M);
  }
  M->pop ();
  M->get_field ("notification_settings_");
  if (M->is_nil ()) {
    res->notification_settings_ = nullptr;
  } else {
    res->notification_settings_ = TdStackFetcherScopeNotificationSettings (M);
  }
  M->pop ();
  return res;
}
struct TdSetStickerPositionInSet *TdCreateObjectSetStickerPositionInSet (struct TdInputFile *sticker_, int position_) {
  auto var = new struct TdSetStickerPositionInSet ();
  var->ID = CODE_SetStickerPositionInSet;
  var->refcnt = 1;
  var->sticker_ = sticker_;
  var->position_ = position_;
  return var;
}
td::td_api::object_ptr<td::td_api::setStickerPositionInSet> TdConvertToInternal (struct TdSetStickerPositionInSet *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->sticker_);
  std::int32_t v100;
  v100 = var->position_;
  return td::td_api::make_object<td::td_api::setStickerPositionInSet>(std::move (v0), std::move (v100));
}
struct TdSetStickerPositionInSet *TdConvertFromInternal (const td::td_api::setStickerPositionInSet &from) {
  auto res = new TdSetStickerPositionInSet ();
  res->ID = CODE_SetStickerPositionInSet;
  res->refcnt = 1;
  if (!from.sticker_) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.sticker_));
  }
  res->position_ = from.position_;
  return res;
}
char *TdSerializeSetStickerPositionInSet (struct TdSetStickerPositionInSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetStickerPositionInSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetStickerPositionInSet (struct TdSetStickerPositionInSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetStickerPositionInSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->sticker_);
  delete var;
}
void TdStackStorerSetStickerPositionInSet (struct TdSetStickerPositionInSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetStickerPositionInSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetStickerPositionInSet");
  M->new_field ("ID");
  TdStackStorer (var->sticker_, M);
  M->new_field ("sticker_");
  M->pack_long (var->position_);
  M->new_field ("position_");
}
struct TdSetStickerPositionInSet *TdStackFetcherSetStickerPositionInSet (struct TdStackFetcherMethods *M) {
  auto res = new TdSetStickerPositionInSet ();
  res->ID = CODE_SetStickerPositionInSet;
  res->refcnt = 1;
  M->get_field ("sticker_");
  if (M->is_nil ()) {
    res->sticker_ = nullptr;
  } else {
    res->sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("position_");
  res->position_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdSetSupergroupDescription *TdCreateObjectSetSupergroupDescription (int supergroup_id_, char *description_) {
  auto var = new struct TdSetSupergroupDescription ();
  var->ID = CODE_SetSupergroupDescription;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->description_ = (description_) ? td::str_dup (td::Slice (description_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setSupergroupDescription> TdConvertToInternal (struct TdSetSupergroupDescription *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  std::string v100;
  v100 = (var->description_) ? var->description_: "";
  return td::td_api::make_object<td::td_api::setSupergroupDescription>(std::move (v0), std::move (v100));
}
struct TdSetSupergroupDescription *TdConvertFromInternal (const td::td_api::setSupergroupDescription &from) {
  auto res = new TdSetSupergroupDescription ();
  res->ID = CODE_SetSupergroupDescription;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->description_ = (from.description_.length ()) ? td::str_dup (from.description_) : nullptr;
  return res;
}
char *TdSerializeSetSupergroupDescription (struct TdSetSupergroupDescription *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetSupergroupDescription *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetSupergroupDescription (struct TdSetSupergroupDescription *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetSupergroupDescription *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->description_);
  delete var;
}
void TdStackStorerSetSupergroupDescription (struct TdSetSupergroupDescription *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetSupergroupDescription *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetSupergroupDescription");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_string (var->description_);
  M->new_field ("description_");
}
struct TdSetSupergroupDescription *TdStackFetcherSetSupergroupDescription (struct TdStackFetcherMethods *M) {
  auto res = new TdSetSupergroupDescription ();
  res->ID = CODE_SetSupergroupDescription;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("description_");
  res->description_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetSupergroupStickerSet *TdCreateObjectSetSupergroupStickerSet (int supergroup_id_, long long sticker_set_id_) {
  auto var = new struct TdSetSupergroupStickerSet ();
  var->ID = CODE_SetSupergroupStickerSet;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->sticker_set_id_ = sticker_set_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::setSupergroupStickerSet> TdConvertToInternal (struct TdSetSupergroupStickerSet *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  std::int64_t v100;
  v100 = var->sticker_set_id_;
  return td::td_api::make_object<td::td_api::setSupergroupStickerSet>(std::move (v0), std::move (v100));
}
struct TdSetSupergroupStickerSet *TdConvertFromInternal (const td::td_api::setSupergroupStickerSet &from) {
  auto res = new TdSetSupergroupStickerSet ();
  res->ID = CODE_SetSupergroupStickerSet;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->sticker_set_id_ = from.sticker_set_id_;
  return res;
}
char *TdSerializeSetSupergroupStickerSet (struct TdSetSupergroupStickerSet *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetSupergroupStickerSet *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetSupergroupStickerSet (struct TdSetSupergroupStickerSet *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetSupergroupStickerSet *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerSetSupergroupStickerSet (struct TdSetSupergroupStickerSet *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetSupergroupStickerSet *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetSupergroupStickerSet");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_long (var->sticker_set_id_);
  M->new_field ("sticker_set_id_");
}
struct TdSetSupergroupStickerSet *TdStackFetcherSetSupergroupStickerSet (struct TdStackFetcherMethods *M) {
  auto res = new TdSetSupergroupStickerSet ();
  res->ID = CODE_SetSupergroupStickerSet;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sticker_set_id_");
  res->sticker_set_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdSetSupergroupUsername *TdCreateObjectSetSupergroupUsername (int supergroup_id_, char *username_) {
  auto var = new struct TdSetSupergroupUsername ();
  var->ID = CODE_SetSupergroupUsername;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setSupergroupUsername> TdConvertToInternal (struct TdSetSupergroupUsername *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  std::string v100;
  v100 = (var->username_) ? var->username_: "";
  return td::td_api::make_object<td::td_api::setSupergroupUsername>(std::move (v0), std::move (v100));
}
struct TdSetSupergroupUsername *TdConvertFromInternal (const td::td_api::setSupergroupUsername &from) {
  auto res = new TdSetSupergroupUsername ();
  res->ID = CODE_SetSupergroupUsername;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  return res;
}
char *TdSerializeSetSupergroupUsername (struct TdSetSupergroupUsername *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetSupergroupUsername *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetSupergroupUsername (struct TdSetSupergroupUsername *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetSupergroupUsername *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->username_);
  delete var;
}
void TdStackStorerSetSupergroupUsername (struct TdSetSupergroupUsername *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetSupergroupUsername *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetSupergroupUsername");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_string (var->username_);
  M->new_field ("username_");
}
struct TdSetSupergroupUsername *TdStackFetcherSetSupergroupUsername (struct TdStackFetcherMethods *M) {
  auto res = new TdSetSupergroupUsername ();
  res->ID = CODE_SetSupergroupUsername;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdSetTdlibParameters *TdCreateObjectSetTdlibParameters (struct TdTdlibParameters *parameters_) {
  auto var = new struct TdSetTdlibParameters ();
  var->ID = CODE_SetTdlibParameters;
  var->refcnt = 1;
  var->parameters_ = parameters_;
  return var;
}
td::td_api::object_ptr<td::td_api::setTdlibParameters> TdConvertToInternal (struct TdSetTdlibParameters *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::tdlibParameters> v0;
  v0 = TdConvertToInternal (var->parameters_);
  return td::td_api::make_object<td::td_api::setTdlibParameters>(std::move (v0));
}
struct TdSetTdlibParameters *TdConvertFromInternal (const td::td_api::setTdlibParameters &from) {
  auto res = new TdSetTdlibParameters ();
  res->ID = CODE_SetTdlibParameters;
  res->refcnt = 1;
  if (!from.parameters_) {
    res->parameters_ = nullptr;
  } else {
    res->parameters_ = TdConvertFromInternal (static_cast<const td::td_api::tdlibParameters &>(*from.parameters_));
  }
  return res;
}
char *TdSerializeSetTdlibParameters (struct TdSetTdlibParameters *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetTdlibParameters *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetTdlibParameters (struct TdSetTdlibParameters *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetTdlibParameters *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->parameters_);
  delete var;
}
void TdStackStorerSetTdlibParameters (struct TdSetTdlibParameters *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetTdlibParameters *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetTdlibParameters");
  M->new_field ("ID");
  TdStackStorer (var->parameters_, M);
  M->new_field ("parameters_");
}
struct TdSetTdlibParameters *TdStackFetcherSetTdlibParameters (struct TdStackFetcherMethods *M) {
  auto res = new TdSetTdlibParameters ();
  res->ID = CODE_SetTdlibParameters;
  res->refcnt = 1;
  M->get_field ("parameters_");
  if (M->is_nil ()) {
    res->parameters_ = nullptr;
  } else {
    res->parameters_ = TdStackFetcherTdlibParameters (M);
  }
  M->pop ();
  return res;
}
struct TdSetUserPrivacySettingRules *TdCreateObjectSetUserPrivacySettingRules (struct TdUserPrivacySetting *setting_, struct TdUserPrivacySettingRules *rules_) {
  auto var = new struct TdSetUserPrivacySettingRules ();
  var->ID = CODE_SetUserPrivacySettingRules;
  var->refcnt = 1;
  var->setting_ = setting_;
  var->rules_ = rules_;
  return var;
}
td::td_api::object_ptr<td::td_api::setUserPrivacySettingRules> TdConvertToInternal (struct TdSetUserPrivacySettingRules *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::UserPrivacySetting> v0;
  v0 = TdConvertToInternal (var->setting_);
  td::td_api::object_ptr<td::td_api::userPrivacySettingRules> v100;
  v100 = TdConvertToInternal (var->rules_);
  return td::td_api::make_object<td::td_api::setUserPrivacySettingRules>(std::move (v0), std::move (v100));
}
struct TdSetUserPrivacySettingRules *TdConvertFromInternal (const td::td_api::setUserPrivacySettingRules &from) {
  auto res = new TdSetUserPrivacySettingRules ();
  res->ID = CODE_SetUserPrivacySettingRules;
  res->refcnt = 1;
  if (!from.setting_) {
    res->setting_ = nullptr;
  } else {
    res->setting_ = TdConvertFromInternal (static_cast<const td::td_api::UserPrivacySetting &>(*from.setting_));
  }
  if (!from.rules_) {
    res->rules_ = nullptr;
  } else {
    res->rules_ = TdConvertFromInternal (static_cast<const td::td_api::userPrivacySettingRules &>(*from.rules_));
  }
  return res;
}
char *TdSerializeSetUserPrivacySettingRules (struct TdSetUserPrivacySettingRules *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetUserPrivacySettingRules *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetUserPrivacySettingRules (struct TdSetUserPrivacySettingRules *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetUserPrivacySettingRules *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->setting_);
  TdDestroyObject (var->rules_);
  delete var;
}
void TdStackStorerSetUserPrivacySettingRules (struct TdSetUserPrivacySettingRules *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetUserPrivacySettingRules *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetUserPrivacySettingRules");
  M->new_field ("ID");
  TdStackStorer (var->setting_, M);
  M->new_field ("setting_");
  TdStackStorer (var->rules_, M);
  M->new_field ("rules_");
}
struct TdSetUserPrivacySettingRules *TdStackFetcherSetUserPrivacySettingRules (struct TdStackFetcherMethods *M) {
  auto res = new TdSetUserPrivacySettingRules ();
  res->ID = CODE_SetUserPrivacySettingRules;
  res->refcnt = 1;
  M->get_field ("setting_");
  if (M->is_nil ()) {
    res->setting_ = nullptr;
  } else {
    res->setting_ = TdStackFetcherUserPrivacySetting (M);
  }
  M->pop ();
  M->get_field ("rules_");
  if (M->is_nil ()) {
    res->rules_ = nullptr;
  } else {
    res->rules_ = TdStackFetcherUserPrivacySettingRules (M);
  }
  M->pop ();
  return res;
}
struct TdSetUsername *TdCreateObjectSetUsername (char *username_) {
  auto var = new struct TdSetUsername ();
  var->ID = CODE_SetUsername;
  var->refcnt = 1;
  var->username_ = (username_) ? td::str_dup (td::Slice (username_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::setUsername> TdConvertToInternal (struct TdSetUsername *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->username_) ? var->username_: "";
  return td::td_api::make_object<td::td_api::setUsername>(std::move (v0));
}
struct TdSetUsername *TdConvertFromInternal (const td::td_api::setUsername &from) {
  auto res = new TdSetUsername ();
  res->ID = CODE_SetUsername;
  res->refcnt = 1;
  res->username_ = (from.username_.length ()) ? td::str_dup (from.username_) : nullptr;
  return res;
}
char *TdSerializeSetUsername (struct TdSetUsername *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdSetUsername *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectSetUsername (struct TdSetUsername *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdSetUsername *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->username_);
  delete var;
}
void TdStackStorerSetUsername (struct TdSetUsername *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdSetUsername *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("SetUsername");
  M->new_field ("ID");
  M->pack_string (var->username_);
  M->new_field ("username_");
}
struct TdSetUsername *TdStackFetcherSetUsername (struct TdStackFetcherMethods *M) {
  auto res = new TdSetUsername ();
  res->ID = CODE_SetUsername;
  res->refcnt = 1;
  M->get_field ("username_");
  res->username_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdTerminateAllOtherSessions *TdCreateObjectTerminateAllOtherSessions (void) {
  auto var = new struct TdTerminateAllOtherSessions ();
  var->ID = CODE_TerminateAllOtherSessions;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::terminateAllOtherSessions> TdConvertToInternal (struct TdTerminateAllOtherSessions *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::terminateAllOtherSessions>();
}
struct TdTerminateAllOtherSessions *TdConvertFromInternal (const td::td_api::terminateAllOtherSessions &from) {
  auto res = new TdTerminateAllOtherSessions ();
  res->ID = CODE_TerminateAllOtherSessions;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTerminateAllOtherSessions (struct TdTerminateAllOtherSessions *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTerminateAllOtherSessions *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTerminateAllOtherSessions (struct TdTerminateAllOtherSessions *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTerminateAllOtherSessions *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTerminateAllOtherSessions (struct TdTerminateAllOtherSessions *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTerminateAllOtherSessions *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TerminateAllOtherSessions");
  M->new_field ("ID");
}
struct TdTerminateAllOtherSessions *TdStackFetcherTerminateAllOtherSessions (struct TdStackFetcherMethods *M) {
  auto res = new TdTerminateAllOtherSessions ();
  res->ID = CODE_TerminateAllOtherSessions;
  res->refcnt = 1;
  return res;
}
struct TdTerminateSession *TdCreateObjectTerminateSession (long long session_id_) {
  auto var = new struct TdTerminateSession ();
  var->ID = CODE_TerminateSession;
  var->refcnt = 1;
  var->session_id_ = session_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::terminateSession> TdConvertToInternal (struct TdTerminateSession *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->session_id_;
  return td::td_api::make_object<td::td_api::terminateSession>(std::move (v0));
}
struct TdTerminateSession *TdConvertFromInternal (const td::td_api::terminateSession &from) {
  auto res = new TdTerminateSession ();
  res->ID = CODE_TerminateSession;
  res->refcnt = 1;
  res->session_id_ = from.session_id_;
  return res;
}
char *TdSerializeTerminateSession (struct TdTerminateSession *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTerminateSession *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTerminateSession (struct TdTerminateSession *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTerminateSession *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTerminateSession (struct TdTerminateSession *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTerminateSession *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TerminateSession");
  M->new_field ("ID");
  M->pack_long (var->session_id_);
  M->new_field ("session_id_");
}
struct TdTerminateSession *TdStackFetcherTerminateSession (struct TdStackFetcherMethods *M) {
  auto res = new TdTerminateSession ();
  res->ID = CODE_TerminateSession;
  res->refcnt = 1;
  M->get_field ("session_id_");
  res->session_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdTestCallBytes *TdCreateObjectTestCallBytes (struct TdBytes x_) {
  auto var = new struct TdTestCallBytes ();
  var->ID = CODE_TestCallBytes;
  var->refcnt = 1;
  var->x_ = x_;
  return var;
}
td::td_api::object_ptr<td::td_api::testCallBytes> TdConvertToInternal (struct TdTestCallBytes *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = std::string ((char *)var->x_.data, var->x_.len);
  return td::td_api::make_object<td::td_api::testCallBytes>(std::move (v0));
}
struct TdTestCallBytes *TdConvertFromInternal (const td::td_api::testCallBytes &from) {
  auto res = new TdTestCallBytes ();
  res->ID = CODE_TestCallBytes;
  res->refcnt = 1;
  res->x_.len = (int)from.x_.length ();
  if (res->x_.len) {
    res->x_.data = new unsigned char[res->x_.len];
    memcpy (res->x_.data, from.x_.c_str (), res->x_.len);
  } else {
    res->x_.data = nullptr;
  }
  return res;
}
char *TdSerializeTestCallBytes (struct TdTestCallBytes *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestCallBytes *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestCallBytes (struct TdTestCallBytes *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestCallBytes *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete[]var->x_.data;
  delete var;
}
void TdStackStorerTestCallBytes (struct TdTestCallBytes *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestCallBytes *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestCallBytes");
  M->new_field ("ID");
  M->pack_bytes (var->x_.data, var->x_.len);
  M->new_field ("x_");
}
struct TdTestCallBytes *TdStackFetcherTestCallBytes (struct TdStackFetcherMethods *M) {
  auto res = new TdTestCallBytes ();
  res->ID = CODE_TestCallBytes;
  res->refcnt = 1;
  M->get_field ("x_");
  res->x_.data = M->get_bytes (&res->x_.len);
  M->pop ();
  return res;
}
struct TdTestCallEmpty *TdCreateObjectTestCallEmpty (void) {
  auto var = new struct TdTestCallEmpty ();
  var->ID = CODE_TestCallEmpty;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::testCallEmpty> TdConvertToInternal (struct TdTestCallEmpty *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::testCallEmpty>();
}
struct TdTestCallEmpty *TdConvertFromInternal (const td::td_api::testCallEmpty &from) {
  auto res = new TdTestCallEmpty ();
  res->ID = CODE_TestCallEmpty;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTestCallEmpty (struct TdTestCallEmpty *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestCallEmpty *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestCallEmpty (struct TdTestCallEmpty *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestCallEmpty *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTestCallEmpty (struct TdTestCallEmpty *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestCallEmpty *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestCallEmpty");
  M->new_field ("ID");
}
struct TdTestCallEmpty *TdStackFetcherTestCallEmpty (struct TdStackFetcherMethods *M) {
  auto res = new TdTestCallEmpty ();
  res->ID = CODE_TestCallEmpty;
  res->refcnt = 1;
  return res;
}
struct TdTestCallString *TdCreateObjectTestCallString (char *x_) {
  auto var = new struct TdTestCallString ();
  var->ID = CODE_TestCallString;
  var->refcnt = 1;
  var->x_ = (x_) ? td::str_dup (td::Slice (x_)) : nullptr;
  return var;
}
td::td_api::object_ptr<td::td_api::testCallString> TdConvertToInternal (struct TdTestCallString *var) {
  if (!var) {
    return nullptr;
  }
  std::string v0;
  v0 = (var->x_) ? var->x_: "";
  return td::td_api::make_object<td::td_api::testCallString>(std::move (v0));
}
struct TdTestCallString *TdConvertFromInternal (const td::td_api::testCallString &from) {
  auto res = new TdTestCallString ();
  res->ID = CODE_TestCallString;
  res->refcnt = 1;
  res->x_ = (from.x_.length ()) ? td::str_dup (from.x_) : nullptr;
  return res;
}
char *TdSerializeTestCallString (struct TdTestCallString *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestCallString *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestCallString (struct TdTestCallString *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestCallString *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  free (var->x_);
  delete var;
}
void TdStackStorerTestCallString (struct TdTestCallString *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestCallString *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestCallString");
  M->new_field ("ID");
  M->pack_string (var->x_);
  M->new_field ("x_");
}
struct TdTestCallString *TdStackFetcherTestCallString (struct TdStackFetcherMethods *M) {
  auto res = new TdTestCallString ();
  res->ID = CODE_TestCallString;
  res->refcnt = 1;
  M->get_field ("x_");
  res->x_ = M->get_string ();
  M->pop ();
  return res;
}
struct TdTestCallVectorInt *TdCreateObjectTestCallVectorInt (struct TdVectorInt *x_) {
  auto var = new struct TdTestCallVectorInt ();
  var->ID = CODE_TestCallVectorInt;
  var->refcnt = 1;
  var->x_ = x_;
  return var;
}
td::td_api::object_ptr<td::td_api::testCallVectorInt> TdConvertToInternal (struct TdTestCallVectorInt *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int32_t> v0;
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    std::int32_t v1;
    v1 = var->x_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::testCallVectorInt>(std::move (v0));
}
struct TdTestCallVectorInt *TdConvertFromInternal (const td::td_api::testCallVectorInt &from) {
  auto res = new TdTestCallVectorInt ();
  res->ID = CODE_TestCallVectorInt;
  res->refcnt = 1;
  res->x_ = new TdVectorInt ();
  res->x_->len = (int)from.x_.size ();
  res->x_->data = new int  [res->x_->len];
  for (int i0 = 0; i0 < res->x_->len; i0++) {
    res->x_->data[i0] = from.x_[i0];
  }
  return res;
}
char *TdSerializeTestCallVectorInt (struct TdTestCallVectorInt *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestCallVectorInt *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestCallVectorInt (struct TdTestCallVectorInt *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestCallVectorInt *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->x_->len; i0++) {
  }
  delete[] var->x_->data;
  delete var->x_;
  delete var;
}
void TdStackStorerTestCallVectorInt (struct TdTestCallVectorInt *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestCallVectorInt *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestCallVectorInt");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    M->pack_long (var->x_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("x_");
}
struct TdTestCallVectorInt *TdStackFetcherTestCallVectorInt (struct TdStackFetcherMethods *M) {
  auto res = new TdTestCallVectorInt ();
  res->ID = CODE_TestCallVectorInt;
  res->refcnt = 1;
  M->get_field ("x_");
  res->x_ = new TdVectorInt ();
  res->x_->len = M->get_arr_size ();
  res->x_->data = new int  [res->x_->len];
  for (int i0 = 0; i0 < res->x_->len; i0++) {
    M->get_arr_field (i0);
    res->x_->data[i0] = (int)M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTestCallVectorIntObject *TdCreateObjectTestCallVectorIntObject (struct TdVectorTestInt *x_) {
  auto var = new struct TdTestCallVectorIntObject ();
  var->ID = CODE_TestCallVectorIntObject;
  var->refcnt = 1;
  var->x_ = x_;
  return var;
}
td::td_api::object_ptr<td::td_api::testCallVectorIntObject> TdConvertToInternal (struct TdTestCallVectorIntObject *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::testInt>> v0;
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    td::td_api::object_ptr<td::td_api::testInt> v1;
    v1 = TdConvertToInternal (var->x_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::testCallVectorIntObject>(std::move (v0));
}
struct TdTestCallVectorIntObject *TdConvertFromInternal (const td::td_api::testCallVectorIntObject &from) {
  auto res = new TdTestCallVectorIntObject ();
  res->ID = CODE_TestCallVectorIntObject;
  res->refcnt = 1;
  res->x_ = new TdVectorTestInt ();
  res->x_->len = (int)from.x_.size ();
  res->x_->data = new struct TdTestInt * [res->x_->len];
  for (int i0 = 0; i0 < res->x_->len; i0++) {
    if (!from.x_[i0]) {
      res->x_->data[i0] = nullptr;
    } else {
      res->x_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::testInt &>(*from.x_[i0]));
    }
  }
  return res;
}
char *TdSerializeTestCallVectorIntObject (struct TdTestCallVectorIntObject *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestCallVectorIntObject *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestCallVectorIntObject (struct TdTestCallVectorIntObject *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestCallVectorIntObject *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    TdDestroyObject (var->x_->data[i0]);
  }
  delete[] var->x_->data;
  delete var->x_;
  delete var;
}
void TdStackStorerTestCallVectorIntObject (struct TdTestCallVectorIntObject *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestCallVectorIntObject *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestCallVectorIntObject");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    TdStackStorer (var->x_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("x_");
}
struct TdTestCallVectorIntObject *TdStackFetcherTestCallVectorIntObject (struct TdStackFetcherMethods *M) {
  auto res = new TdTestCallVectorIntObject ();
  res->ID = CODE_TestCallVectorIntObject;
  res->refcnt = 1;
  M->get_field ("x_");
  res->x_ = new TdVectorTestInt ();
  res->x_->len = M->get_arr_size ();
  res->x_->data = new struct TdTestInt * [res->x_->len];
  for (int i0 = 0; i0 < res->x_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->x_->data[i0] = nullptr;
    } else {
      res->x_->data[i0] = TdStackFetcherTestInt (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTestCallVectorString *TdCreateObjectTestCallVectorString (struct TdVectorString *x_) {
  auto var = new struct TdTestCallVectorString ();
  var->ID = CODE_TestCallVectorString;
  var->refcnt = 1;
  var->x_ = x_;
  return var;
}
td::td_api::object_ptr<td::td_api::testCallVectorString> TdConvertToInternal (struct TdTestCallVectorString *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::string> v0;
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    std::string v1;
    v1 = (var->x_->data[i0]) ? var->x_->data[i0]: "";
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::testCallVectorString>(std::move (v0));
}
struct TdTestCallVectorString *TdConvertFromInternal (const td::td_api::testCallVectorString &from) {
  auto res = new TdTestCallVectorString ();
  res->ID = CODE_TestCallVectorString;
  res->refcnt = 1;
  res->x_ = new TdVectorString ();
  res->x_->len = (int)from.x_.size ();
  res->x_->data = new char * [res->x_->len];
  for (int i0 = 0; i0 < res->x_->len; i0++) {
    res->x_->data[i0] = (from.x_[i0].length ()) ? td::str_dup (from.x_[i0]) : nullptr;
  }
  return res;
}
char *TdSerializeTestCallVectorString (struct TdTestCallVectorString *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestCallVectorString *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestCallVectorString (struct TdTestCallVectorString *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestCallVectorString *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    free (var->x_->data[i0]);
  }
  delete[] var->x_->data;
  delete var->x_;
  delete var;
}
void TdStackStorerTestCallVectorString (struct TdTestCallVectorString *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestCallVectorString *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestCallVectorString");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    M->pack_string (var->x_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("x_");
}
struct TdTestCallVectorString *TdStackFetcherTestCallVectorString (struct TdStackFetcherMethods *M) {
  auto res = new TdTestCallVectorString ();
  res->ID = CODE_TestCallVectorString;
  res->refcnt = 1;
  M->get_field ("x_");
  res->x_ = new TdVectorString ();
  res->x_->len = M->get_arr_size ();
  res->x_->data = new char * [res->x_->len];
  for (int i0 = 0; i0 < res->x_->len; i0++) {
    M->get_arr_field (i0);
    res->x_->data[i0] = M->get_string ();
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTestCallVectorStringObject *TdCreateObjectTestCallVectorStringObject (struct TdVectorTestString *x_) {
  auto var = new struct TdTestCallVectorStringObject ();
  var->ID = CODE_TestCallVectorStringObject;
  var->refcnt = 1;
  var->x_ = x_;
  return var;
}
td::td_api::object_ptr<td::td_api::testCallVectorStringObject> TdConvertToInternal (struct TdTestCallVectorStringObject *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<td::td_api::object_ptr<td::td_api::testString>> v0;
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    td::td_api::object_ptr<td::td_api::testString> v1;
    v1 = TdConvertToInternal (var->x_->data[i0]);
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::testCallVectorStringObject>(std::move (v0));
}
struct TdTestCallVectorStringObject *TdConvertFromInternal (const td::td_api::testCallVectorStringObject &from) {
  auto res = new TdTestCallVectorStringObject ();
  res->ID = CODE_TestCallVectorStringObject;
  res->refcnt = 1;
  res->x_ = new TdVectorTestString ();
  res->x_->len = (int)from.x_.size ();
  res->x_->data = new struct TdTestString * [res->x_->len];
  for (int i0 = 0; i0 < res->x_->len; i0++) {
    if (!from.x_[i0]) {
      res->x_->data[i0] = nullptr;
    } else {
      res->x_->data[i0] = TdConvertFromInternal (static_cast<const td::td_api::testString &>(*from.x_[i0]));
    }
  }
  return res;
}
char *TdSerializeTestCallVectorStringObject (struct TdTestCallVectorStringObject *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestCallVectorStringObject *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestCallVectorStringObject (struct TdTestCallVectorStringObject *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestCallVectorStringObject *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    TdDestroyObject (var->x_->data[i0]);
  }
  delete[] var->x_->data;
  delete var->x_;
  delete var;
}
void TdStackStorerTestCallVectorStringObject (struct TdTestCallVectorStringObject *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestCallVectorStringObject *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestCallVectorStringObject");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->x_->len; i0++) {
    TdStackStorer (var->x_->data[i0], M);
    M->new_arr_field (i0);
  }
  M->new_field ("x_");
}
struct TdTestCallVectorStringObject *TdStackFetcherTestCallVectorStringObject (struct TdStackFetcherMethods *M) {
  auto res = new TdTestCallVectorStringObject ();
  res->ID = CODE_TestCallVectorStringObject;
  res->refcnt = 1;
  M->get_field ("x_");
  res->x_ = new TdVectorTestString ();
  res->x_->len = M->get_arr_size ();
  res->x_->data = new struct TdTestString * [res->x_->len];
  for (int i0 = 0; i0 < res->x_->len; i0++) {
    M->get_arr_field (i0);
    if (M->is_nil ()) {
      res->x_->data[i0] = nullptr;
    } else {
      res->x_->data[i0] = TdStackFetcherTestString (M);
    }
    M->pop ();
  }
  M->pop ();
  return res;
}
struct TdTestGetDifference *TdCreateObjectTestGetDifference (void) {
  auto var = new struct TdTestGetDifference ();
  var->ID = CODE_TestGetDifference;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::testGetDifference> TdConvertToInternal (struct TdTestGetDifference *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::testGetDifference>();
}
struct TdTestGetDifference *TdConvertFromInternal (const td::td_api::testGetDifference &from) {
  auto res = new TdTestGetDifference ();
  res->ID = CODE_TestGetDifference;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTestGetDifference (struct TdTestGetDifference *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestGetDifference *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestGetDifference (struct TdTestGetDifference *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestGetDifference *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTestGetDifference (struct TdTestGetDifference *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestGetDifference *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestGetDifference");
  M->new_field ("ID");
}
struct TdTestGetDifference *TdStackFetcherTestGetDifference (struct TdStackFetcherMethods *M) {
  auto res = new TdTestGetDifference ();
  res->ID = CODE_TestGetDifference;
  res->refcnt = 1;
  return res;
}
struct TdTestNetwork *TdCreateObjectTestNetwork (void) {
  auto var = new struct TdTestNetwork ();
  var->ID = CODE_TestNetwork;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::testNetwork> TdConvertToInternal (struct TdTestNetwork *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::testNetwork>();
}
struct TdTestNetwork *TdConvertFromInternal (const td::td_api::testNetwork &from) {
  auto res = new TdTestNetwork ();
  res->ID = CODE_TestNetwork;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTestNetwork (struct TdTestNetwork *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestNetwork *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestNetwork (struct TdTestNetwork *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestNetwork *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTestNetwork (struct TdTestNetwork *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestNetwork *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestNetwork");
  M->new_field ("ID");
}
struct TdTestNetwork *TdStackFetcherTestNetwork (struct TdStackFetcherMethods *M) {
  auto res = new TdTestNetwork ();
  res->ID = CODE_TestNetwork;
  res->refcnt = 1;
  return res;
}
struct TdTestSquareInt *TdCreateObjectTestSquareInt (int x_) {
  auto var = new struct TdTestSquareInt ();
  var->ID = CODE_TestSquareInt;
  var->refcnt = 1;
  var->x_ = x_;
  return var;
}
td::td_api::object_ptr<td::td_api::testSquareInt> TdConvertToInternal (struct TdTestSquareInt *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->x_;
  return td::td_api::make_object<td::td_api::testSquareInt>(std::move (v0));
}
struct TdTestSquareInt *TdConvertFromInternal (const td::td_api::testSquareInt &from) {
  auto res = new TdTestSquareInt ();
  res->ID = CODE_TestSquareInt;
  res->refcnt = 1;
  res->x_ = from.x_;
  return res;
}
char *TdSerializeTestSquareInt (struct TdTestSquareInt *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestSquareInt *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestSquareInt (struct TdTestSquareInt *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestSquareInt *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTestSquareInt (struct TdTestSquareInt *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestSquareInt *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestSquareInt");
  M->new_field ("ID");
  M->pack_long (var->x_);
  M->new_field ("x_");
}
struct TdTestSquareInt *TdStackFetcherTestSquareInt (struct TdStackFetcherMethods *M) {
  auto res = new TdTestSquareInt ();
  res->ID = CODE_TestSquareInt;
  res->refcnt = 1;
  M->get_field ("x_");
  res->x_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdTestUseError *TdCreateObjectTestUseError (void) {
  auto var = new struct TdTestUseError ();
  var->ID = CODE_TestUseError;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::testUseError> TdConvertToInternal (struct TdTestUseError *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::testUseError>();
}
struct TdTestUseError *TdConvertFromInternal (const td::td_api::testUseError &from) {
  auto res = new TdTestUseError ();
  res->ID = CODE_TestUseError;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTestUseError (struct TdTestUseError *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestUseError *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestUseError (struct TdTestUseError *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestUseError *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTestUseError (struct TdTestUseError *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestUseError *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestUseError");
  M->new_field ("ID");
}
struct TdTestUseError *TdStackFetcherTestUseError (struct TdStackFetcherMethods *M) {
  auto res = new TdTestUseError ();
  res->ID = CODE_TestUseError;
  res->refcnt = 1;
  return res;
}
struct TdTestUseUpdate *TdCreateObjectTestUseUpdate (void) {
  auto var = new struct TdTestUseUpdate ();
  var->ID = CODE_TestUseUpdate;
  var->refcnt = 1;
  return var;
}
td::td_api::object_ptr<td::td_api::testUseUpdate> TdConvertToInternal (struct TdTestUseUpdate *var) {
  if (!var) {
    return nullptr;
  }
  return td::td_api::make_object<td::td_api::testUseUpdate>();
}
struct TdTestUseUpdate *TdConvertFromInternal (const td::td_api::testUseUpdate &from) {
  auto res = new TdTestUseUpdate ();
  res->ID = CODE_TestUseUpdate;
  res->refcnt = 1;
  return res;
}
char *TdSerializeTestUseUpdate (struct TdTestUseUpdate *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdTestUseUpdate *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectTestUseUpdate (struct TdTestUseUpdate *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdTestUseUpdate *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerTestUseUpdate (struct TdTestUseUpdate *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdTestUseUpdate *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("TestUseUpdate");
  M->new_field ("ID");
}
struct TdTestUseUpdate *TdStackFetcherTestUseUpdate (struct TdStackFetcherMethods *M) {
  auto res = new TdTestUseUpdate ();
  res->ID = CODE_TestUseUpdate;
  res->refcnt = 1;
  return res;
}
struct TdToggleBasicGroupAdministrators *TdCreateObjectToggleBasicGroupAdministrators (int basic_group_id_, int everyone_is_administrator_) {
  auto var = new struct TdToggleBasicGroupAdministrators ();
  var->ID = CODE_ToggleBasicGroupAdministrators;
  var->refcnt = 1;
  var->basic_group_id_ = basic_group_id_;
  var->everyone_is_administrator_ = everyone_is_administrator_;
  return var;
}
td::td_api::object_ptr<td::td_api::toggleBasicGroupAdministrators> TdConvertToInternal (struct TdToggleBasicGroupAdministrators *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->basic_group_id_;
  bool v100;
  v100 = var->everyone_is_administrator_ != 0;
  return td::td_api::make_object<td::td_api::toggleBasicGroupAdministrators>(std::move (v0), std::move (v100));
}
struct TdToggleBasicGroupAdministrators *TdConvertFromInternal (const td::td_api::toggleBasicGroupAdministrators &from) {
  auto res = new TdToggleBasicGroupAdministrators ();
  res->ID = CODE_ToggleBasicGroupAdministrators;
  res->refcnt = 1;
  res->basic_group_id_ = from.basic_group_id_;
  res->everyone_is_administrator_ = from.everyone_is_administrator_;
  return res;
}
char *TdSerializeToggleBasicGroupAdministrators (struct TdToggleBasicGroupAdministrators *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdToggleBasicGroupAdministrators *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectToggleBasicGroupAdministrators (struct TdToggleBasicGroupAdministrators *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdToggleBasicGroupAdministrators *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerToggleBasicGroupAdministrators (struct TdToggleBasicGroupAdministrators *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdToggleBasicGroupAdministrators *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ToggleBasicGroupAdministrators");
  M->new_field ("ID");
  M->pack_long (var->basic_group_id_);
  M->new_field ("basic_group_id_");
  M->pack_bool (var->everyone_is_administrator_);
  M->new_field ("everyone_is_administrator_");
}
struct TdToggleBasicGroupAdministrators *TdStackFetcherToggleBasicGroupAdministrators (struct TdStackFetcherMethods *M) {
  auto res = new TdToggleBasicGroupAdministrators ();
  res->ID = CODE_ToggleBasicGroupAdministrators;
  res->refcnt = 1;
  M->get_field ("basic_group_id_");
  res->basic_group_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("everyone_is_administrator_");
  res->everyone_is_administrator_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdToggleChatDefaultDisableNotification *TdCreateObjectToggleChatDefaultDisableNotification (long long chat_id_, int default_disable_notification_) {
  auto var = new struct TdToggleChatDefaultDisableNotification ();
  var->ID = CODE_ToggleChatDefaultDisableNotification;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->default_disable_notification_ = default_disable_notification_;
  return var;
}
td::td_api::object_ptr<td::td_api::toggleChatDefaultDisableNotification> TdConvertToInternal (struct TdToggleChatDefaultDisableNotification *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->default_disable_notification_ != 0;
  return td::td_api::make_object<td::td_api::toggleChatDefaultDisableNotification>(std::move (v0), std::move (v100));
}
struct TdToggleChatDefaultDisableNotification *TdConvertFromInternal (const td::td_api::toggleChatDefaultDisableNotification &from) {
  auto res = new TdToggleChatDefaultDisableNotification ();
  res->ID = CODE_ToggleChatDefaultDisableNotification;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->default_disable_notification_ = from.default_disable_notification_;
  return res;
}
char *TdSerializeToggleChatDefaultDisableNotification (struct TdToggleChatDefaultDisableNotification *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdToggleChatDefaultDisableNotification *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectToggleChatDefaultDisableNotification (struct TdToggleChatDefaultDisableNotification *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdToggleChatDefaultDisableNotification *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerToggleChatDefaultDisableNotification (struct TdToggleChatDefaultDisableNotification *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdToggleChatDefaultDisableNotification *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ToggleChatDefaultDisableNotification");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->default_disable_notification_);
  M->new_field ("default_disable_notification_");
}
struct TdToggleChatDefaultDisableNotification *TdStackFetcherToggleChatDefaultDisableNotification (struct TdStackFetcherMethods *M) {
  auto res = new TdToggleChatDefaultDisableNotification ();
  res->ID = CODE_ToggleChatDefaultDisableNotification;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("default_disable_notification_");
  res->default_disable_notification_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdToggleChatIsMarkedAsUnread *TdCreateObjectToggleChatIsMarkedAsUnread (long long chat_id_, int is_marked_as_unread_) {
  auto var = new struct TdToggleChatIsMarkedAsUnread ();
  var->ID = CODE_ToggleChatIsMarkedAsUnread;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->is_marked_as_unread_ = is_marked_as_unread_;
  return var;
}
td::td_api::object_ptr<td::td_api::toggleChatIsMarkedAsUnread> TdConvertToInternal (struct TdToggleChatIsMarkedAsUnread *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->is_marked_as_unread_ != 0;
  return td::td_api::make_object<td::td_api::toggleChatIsMarkedAsUnread>(std::move (v0), std::move (v100));
}
struct TdToggleChatIsMarkedAsUnread *TdConvertFromInternal (const td::td_api::toggleChatIsMarkedAsUnread &from) {
  auto res = new TdToggleChatIsMarkedAsUnread ();
  res->ID = CODE_ToggleChatIsMarkedAsUnread;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->is_marked_as_unread_ = from.is_marked_as_unread_;
  return res;
}
char *TdSerializeToggleChatIsMarkedAsUnread (struct TdToggleChatIsMarkedAsUnread *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdToggleChatIsMarkedAsUnread *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectToggleChatIsMarkedAsUnread (struct TdToggleChatIsMarkedAsUnread *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdToggleChatIsMarkedAsUnread *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerToggleChatIsMarkedAsUnread (struct TdToggleChatIsMarkedAsUnread *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdToggleChatIsMarkedAsUnread *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ToggleChatIsMarkedAsUnread");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->is_marked_as_unread_);
  M->new_field ("is_marked_as_unread_");
}
struct TdToggleChatIsMarkedAsUnread *TdStackFetcherToggleChatIsMarkedAsUnread (struct TdStackFetcherMethods *M) {
  auto res = new TdToggleChatIsMarkedAsUnread ();
  res->ID = CODE_ToggleChatIsMarkedAsUnread;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_marked_as_unread_");
  res->is_marked_as_unread_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdToggleChatIsPinned *TdCreateObjectToggleChatIsPinned (long long chat_id_, int is_pinned_) {
  auto var = new struct TdToggleChatIsPinned ();
  var->ID = CODE_ToggleChatIsPinned;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->is_pinned_ = is_pinned_;
  return var;
}
td::td_api::object_ptr<td::td_api::toggleChatIsPinned> TdConvertToInternal (struct TdToggleChatIsPinned *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  bool v100;
  v100 = var->is_pinned_ != 0;
  return td::td_api::make_object<td::td_api::toggleChatIsPinned>(std::move (v0), std::move (v100));
}
struct TdToggleChatIsPinned *TdConvertFromInternal (const td::td_api::toggleChatIsPinned &from) {
  auto res = new TdToggleChatIsPinned ();
  res->ID = CODE_ToggleChatIsPinned;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->is_pinned_ = from.is_pinned_;
  return res;
}
char *TdSerializeToggleChatIsPinned (struct TdToggleChatIsPinned *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdToggleChatIsPinned *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectToggleChatIsPinned (struct TdToggleChatIsPinned *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdToggleChatIsPinned *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerToggleChatIsPinned (struct TdToggleChatIsPinned *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdToggleChatIsPinned *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ToggleChatIsPinned");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_bool (var->is_pinned_);
  M->new_field ("is_pinned_");
}
struct TdToggleChatIsPinned *TdStackFetcherToggleChatIsPinned (struct TdStackFetcherMethods *M) {
  auto res = new TdToggleChatIsPinned ();
  res->ID = CODE_ToggleChatIsPinned;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("is_pinned_");
  res->is_pinned_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdToggleSupergroupInvites *TdCreateObjectToggleSupergroupInvites (int supergroup_id_, int anyone_can_invite_) {
  auto var = new struct TdToggleSupergroupInvites ();
  var->ID = CODE_ToggleSupergroupInvites;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->anyone_can_invite_ = anyone_can_invite_;
  return var;
}
td::td_api::object_ptr<td::td_api::toggleSupergroupInvites> TdConvertToInternal (struct TdToggleSupergroupInvites *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  bool v100;
  v100 = var->anyone_can_invite_ != 0;
  return td::td_api::make_object<td::td_api::toggleSupergroupInvites>(std::move (v0), std::move (v100));
}
struct TdToggleSupergroupInvites *TdConvertFromInternal (const td::td_api::toggleSupergroupInvites &from) {
  auto res = new TdToggleSupergroupInvites ();
  res->ID = CODE_ToggleSupergroupInvites;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->anyone_can_invite_ = from.anyone_can_invite_;
  return res;
}
char *TdSerializeToggleSupergroupInvites (struct TdToggleSupergroupInvites *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdToggleSupergroupInvites *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectToggleSupergroupInvites (struct TdToggleSupergroupInvites *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdToggleSupergroupInvites *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerToggleSupergroupInvites (struct TdToggleSupergroupInvites *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdToggleSupergroupInvites *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ToggleSupergroupInvites");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_bool (var->anyone_can_invite_);
  M->new_field ("anyone_can_invite_");
}
struct TdToggleSupergroupInvites *TdStackFetcherToggleSupergroupInvites (struct TdStackFetcherMethods *M) {
  auto res = new TdToggleSupergroupInvites ();
  res->ID = CODE_ToggleSupergroupInvites;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("anyone_can_invite_");
  res->anyone_can_invite_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdToggleSupergroupIsAllHistoryAvailable *TdCreateObjectToggleSupergroupIsAllHistoryAvailable (int supergroup_id_, int is_all_history_available_) {
  auto var = new struct TdToggleSupergroupIsAllHistoryAvailable ();
  var->ID = CODE_ToggleSupergroupIsAllHistoryAvailable;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->is_all_history_available_ = is_all_history_available_;
  return var;
}
td::td_api::object_ptr<td::td_api::toggleSupergroupIsAllHistoryAvailable> TdConvertToInternal (struct TdToggleSupergroupIsAllHistoryAvailable *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  bool v100;
  v100 = var->is_all_history_available_ != 0;
  return td::td_api::make_object<td::td_api::toggleSupergroupIsAllHistoryAvailable>(std::move (v0), std::move (v100));
}
struct TdToggleSupergroupIsAllHistoryAvailable *TdConvertFromInternal (const td::td_api::toggleSupergroupIsAllHistoryAvailable &from) {
  auto res = new TdToggleSupergroupIsAllHistoryAvailable ();
  res->ID = CODE_ToggleSupergroupIsAllHistoryAvailable;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->is_all_history_available_ = from.is_all_history_available_;
  return res;
}
char *TdSerializeToggleSupergroupIsAllHistoryAvailable (struct TdToggleSupergroupIsAllHistoryAvailable *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdToggleSupergroupIsAllHistoryAvailable *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectToggleSupergroupIsAllHistoryAvailable (struct TdToggleSupergroupIsAllHistoryAvailable *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdToggleSupergroupIsAllHistoryAvailable *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerToggleSupergroupIsAllHistoryAvailable (struct TdToggleSupergroupIsAllHistoryAvailable *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdToggleSupergroupIsAllHistoryAvailable *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ToggleSupergroupIsAllHistoryAvailable");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_bool (var->is_all_history_available_);
  M->new_field ("is_all_history_available_");
}
struct TdToggleSupergroupIsAllHistoryAvailable *TdStackFetcherToggleSupergroupIsAllHistoryAvailable (struct TdStackFetcherMethods *M) {
  auto res = new TdToggleSupergroupIsAllHistoryAvailable ();
  res->ID = CODE_ToggleSupergroupIsAllHistoryAvailable;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("is_all_history_available_");
  res->is_all_history_available_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdToggleSupergroupSignMessages *TdCreateObjectToggleSupergroupSignMessages (int supergroup_id_, int sign_messages_) {
  auto var = new struct TdToggleSupergroupSignMessages ();
  var->ID = CODE_ToggleSupergroupSignMessages;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  var->sign_messages_ = sign_messages_;
  return var;
}
td::td_api::object_ptr<td::td_api::toggleSupergroupSignMessages> TdConvertToInternal (struct TdToggleSupergroupSignMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  bool v100;
  v100 = var->sign_messages_ != 0;
  return td::td_api::make_object<td::td_api::toggleSupergroupSignMessages>(std::move (v0), std::move (v100));
}
struct TdToggleSupergroupSignMessages *TdConvertFromInternal (const td::td_api::toggleSupergroupSignMessages &from) {
  auto res = new TdToggleSupergroupSignMessages ();
  res->ID = CODE_ToggleSupergroupSignMessages;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  res->sign_messages_ = from.sign_messages_;
  return res;
}
char *TdSerializeToggleSupergroupSignMessages (struct TdToggleSupergroupSignMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdToggleSupergroupSignMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectToggleSupergroupSignMessages (struct TdToggleSupergroupSignMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdToggleSupergroupSignMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerToggleSupergroupSignMessages (struct TdToggleSupergroupSignMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdToggleSupergroupSignMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ToggleSupergroupSignMessages");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
  M->pack_bool (var->sign_messages_);
  M->new_field ("sign_messages_");
}
struct TdToggleSupergroupSignMessages *TdStackFetcherToggleSupergroupSignMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdToggleSupergroupSignMessages ();
  res->ID = CODE_ToggleSupergroupSignMessages;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("sign_messages_");
  res->sign_messages_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUnblockUser *TdCreateObjectUnblockUser (int user_id_) {
  auto var = new struct TdUnblockUser ();
  var->ID = CODE_UnblockUser;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::unblockUser> TdConvertToInternal (struct TdUnblockUser *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  return td::td_api::make_object<td::td_api::unblockUser>(std::move (v0));
}
struct TdUnblockUser *TdConvertFromInternal (const td::td_api::unblockUser &from) {
  auto res = new TdUnblockUser ();
  res->ID = CODE_UnblockUser;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  return res;
}
char *TdSerializeUnblockUser (struct TdUnblockUser *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUnblockUser *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUnblockUser (struct TdUnblockUser *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUnblockUser *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUnblockUser (struct TdUnblockUser *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUnblockUser *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UnblockUser");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
}
struct TdUnblockUser *TdStackFetcherUnblockUser (struct TdStackFetcherMethods *M) {
  auto res = new TdUnblockUser ();
  res->ID = CODE_UnblockUser;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUnpinSupergroupMessage *TdCreateObjectUnpinSupergroupMessage (int supergroup_id_) {
  auto var = new struct TdUnpinSupergroupMessage ();
  var->ID = CODE_UnpinSupergroupMessage;
  var->refcnt = 1;
  var->supergroup_id_ = supergroup_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::unpinSupergroupMessage> TdConvertToInternal (struct TdUnpinSupergroupMessage *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->supergroup_id_;
  return td::td_api::make_object<td::td_api::unpinSupergroupMessage>(std::move (v0));
}
struct TdUnpinSupergroupMessage *TdConvertFromInternal (const td::td_api::unpinSupergroupMessage &from) {
  auto res = new TdUnpinSupergroupMessage ();
  res->ID = CODE_UnpinSupergroupMessage;
  res->refcnt = 1;
  res->supergroup_id_ = from.supergroup_id_;
  return res;
}
char *TdSerializeUnpinSupergroupMessage (struct TdUnpinSupergroupMessage *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUnpinSupergroupMessage *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUnpinSupergroupMessage (struct TdUnpinSupergroupMessage *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUnpinSupergroupMessage *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUnpinSupergroupMessage (struct TdUnpinSupergroupMessage *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUnpinSupergroupMessage *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UnpinSupergroupMessage");
  M->new_field ("ID");
  M->pack_long (var->supergroup_id_);
  M->new_field ("supergroup_id_");
}
struct TdUnpinSupergroupMessage *TdStackFetcherUnpinSupergroupMessage (struct TdStackFetcherMethods *M) {
  auto res = new TdUnpinSupergroupMessage ();
  res->ID = CODE_UnpinSupergroupMessage;
  res->refcnt = 1;
  M->get_field ("supergroup_id_");
  res->supergroup_id_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUpgradeBasicGroupChatToSupergroupChat *TdCreateObjectUpgradeBasicGroupChatToSupergroupChat (long long chat_id_) {
  auto var = new struct TdUpgradeBasicGroupChatToSupergroupChat ();
  var->ID = CODE_UpgradeBasicGroupChatToSupergroupChat;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  return var;
}
td::td_api::object_ptr<td::td_api::upgradeBasicGroupChatToSupergroupChat> TdConvertToInternal (struct TdUpgradeBasicGroupChatToSupergroupChat *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  return td::td_api::make_object<td::td_api::upgradeBasicGroupChatToSupergroupChat>(std::move (v0));
}
struct TdUpgradeBasicGroupChatToSupergroupChat *TdConvertFromInternal (const td::td_api::upgradeBasicGroupChatToSupergroupChat &from) {
  auto res = new TdUpgradeBasicGroupChatToSupergroupChat ();
  res->ID = CODE_UpgradeBasicGroupChatToSupergroupChat;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  return res;
}
char *TdSerializeUpgradeBasicGroupChatToSupergroupChat (struct TdUpgradeBasicGroupChatToSupergroupChat *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUpgradeBasicGroupChatToSupergroupChat *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUpgradeBasicGroupChatToSupergroupChat (struct TdUpgradeBasicGroupChatToSupergroupChat *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUpgradeBasicGroupChatToSupergroupChat *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  delete var;
}
void TdStackStorerUpgradeBasicGroupChatToSupergroupChat (struct TdUpgradeBasicGroupChatToSupergroupChat *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUpgradeBasicGroupChatToSupergroupChat *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UpgradeBasicGroupChatToSupergroupChat");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
}
struct TdUpgradeBasicGroupChatToSupergroupChat *TdStackFetcherUpgradeBasicGroupChatToSupergroupChat (struct TdStackFetcherMethods *M) {
  auto res = new TdUpgradeBasicGroupChatToSupergroupChat ();
  res->ID = CODE_UpgradeBasicGroupChatToSupergroupChat;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  return res;
}
struct TdUploadFile *TdCreateObjectUploadFile (struct TdInputFile *file_, struct TdFileType *file_type_, int priority_) {
  auto var = new struct TdUploadFile ();
  var->ID = CODE_UploadFile;
  var->refcnt = 1;
  var->file_ = file_;
  var->file_type_ = file_type_;
  var->priority_ = priority_;
  return var;
}
td::td_api::object_ptr<td::td_api::uploadFile> TdConvertToInternal (struct TdUploadFile *var) {
  if (!var) {
    return nullptr;
  }
  td::td_api::object_ptr<td::td_api::InputFile> v0;
  v0 = TdConvertToInternal (var->file_);
  td::td_api::object_ptr<td::td_api::FileType> v100;
  v100 = TdConvertToInternal (var->file_type_);
  std::int32_t v200;
  v200 = var->priority_;
  return td::td_api::make_object<td::td_api::uploadFile>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdUploadFile *TdConvertFromInternal (const td::td_api::uploadFile &from) {
  auto res = new TdUploadFile ();
  res->ID = CODE_UploadFile;
  res->refcnt = 1;
  if (!from.file_) {
    res->file_ = nullptr;
  } else {
    res->file_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.file_));
  }
  if (!from.file_type_) {
    res->file_type_ = nullptr;
  } else {
    res->file_type_ = TdConvertFromInternal (static_cast<const td::td_api::FileType &>(*from.file_type_));
  }
  res->priority_ = from.priority_;
  return res;
}
char *TdSerializeUploadFile (struct TdUploadFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUploadFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUploadFile (struct TdUploadFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUploadFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->file_);
  TdDestroyObject (var->file_type_);
  delete var;
}
void TdStackStorerUploadFile (struct TdUploadFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUploadFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UploadFile");
  M->new_field ("ID");
  TdStackStorer (var->file_, M);
  M->new_field ("file_");
  TdStackStorer (var->file_type_, M);
  M->new_field ("file_type_");
  M->pack_long (var->priority_);
  M->new_field ("priority_");
}
struct TdUploadFile *TdStackFetcherUploadFile (struct TdStackFetcherMethods *M) {
  auto res = new TdUploadFile ();
  res->ID = CODE_UploadFile;
  res->refcnt = 1;
  M->get_field ("file_");
  if (M->is_nil ()) {
    res->file_ = nullptr;
  } else {
    res->file_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  M->get_field ("file_type_");
  if (M->is_nil ()) {
    res->file_type_ = nullptr;
  } else {
    res->file_type_ = TdStackFetcherFileType (M);
  }
  M->pop ();
  M->get_field ("priority_");
  res->priority_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdUploadStickerFile *TdCreateObjectUploadStickerFile (int user_id_, struct TdInputFile *png_sticker_) {
  auto var = new struct TdUploadStickerFile ();
  var->ID = CODE_UploadStickerFile;
  var->refcnt = 1;
  var->user_id_ = user_id_;
  var->png_sticker_ = png_sticker_;
  return var;
}
td::td_api::object_ptr<td::td_api::uploadStickerFile> TdConvertToInternal (struct TdUploadStickerFile *var) {
  if (!var) {
    return nullptr;
  }
  std::int32_t v0;
  v0 = var->user_id_;
  td::td_api::object_ptr<td::td_api::InputFile> v100;
  v100 = TdConvertToInternal (var->png_sticker_);
  return td::td_api::make_object<td::td_api::uploadStickerFile>(std::move (v0), std::move (v100));
}
struct TdUploadStickerFile *TdConvertFromInternal (const td::td_api::uploadStickerFile &from) {
  auto res = new TdUploadStickerFile ();
  res->ID = CODE_UploadStickerFile;
  res->refcnt = 1;
  res->user_id_ = from.user_id_;
  if (!from.png_sticker_) {
    res->png_sticker_ = nullptr;
  } else {
    res->png_sticker_ = TdConvertFromInternal (static_cast<const td::td_api::InputFile &>(*from.png_sticker_));
  }
  return res;
}
char *TdSerializeUploadStickerFile (struct TdUploadStickerFile *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdUploadStickerFile *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectUploadStickerFile (struct TdUploadStickerFile *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdUploadStickerFile *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->png_sticker_);
  delete var;
}
void TdStackStorerUploadStickerFile (struct TdUploadStickerFile *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdUploadStickerFile *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("UploadStickerFile");
  M->new_field ("ID");
  M->pack_long (var->user_id_);
  M->new_field ("user_id_");
  TdStackStorer (var->png_sticker_, M);
  M->new_field ("png_sticker_");
}
struct TdUploadStickerFile *TdStackFetcherUploadStickerFile (struct TdStackFetcherMethods *M) {
  auto res = new TdUploadStickerFile ();
  res->ID = CODE_UploadStickerFile;
  res->refcnt = 1;
  M->get_field ("user_id_");
  res->user_id_ = (int)M->get_long ();
  M->pop ();
  M->get_field ("png_sticker_");
  if (M->is_nil ()) {
    res->png_sticker_ = nullptr;
  } else {
    res->png_sticker_ = TdStackFetcherInputFile (M);
  }
  M->pop ();
  return res;
}
struct TdValidateOrderInfo *TdCreateObjectValidateOrderInfo (long long chat_id_, long long message_id_, struct TdOrderInfo *order_info_, int allow_save_) {
  auto var = new struct TdValidateOrderInfo ();
  var->ID = CODE_ValidateOrderInfo;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_id_ = message_id_;
  var->order_info_ = order_info_;
  var->allow_save_ = allow_save_;
  return var;
}
td::td_api::object_ptr<td::td_api::validateOrderInfo> TdConvertToInternal (struct TdValidateOrderInfo *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::int64_t v100;
  v100 = var->message_id_;
  td::td_api::object_ptr<td::td_api::orderInfo> v200;
  v200 = TdConvertToInternal (var->order_info_);
  bool v300;
  v300 = var->allow_save_ != 0;
  return td::td_api::make_object<td::td_api::validateOrderInfo>(std::move (v0), std::move (v100), std::move (v200), std::move (v300));
}
struct TdValidateOrderInfo *TdConvertFromInternal (const td::td_api::validateOrderInfo &from) {
  auto res = new TdValidateOrderInfo ();
  res->ID = CODE_ValidateOrderInfo;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_id_ = from.message_id_;
  if (!from.order_info_) {
    res->order_info_ = nullptr;
  } else {
    res->order_info_ = TdConvertFromInternal (static_cast<const td::td_api::orderInfo &>(*from.order_info_));
  }
  res->allow_save_ = from.allow_save_;
  return res;
}
char *TdSerializeValidateOrderInfo (struct TdValidateOrderInfo *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdValidateOrderInfo *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectValidateOrderInfo (struct TdValidateOrderInfo *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdValidateOrderInfo *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  TdDestroyObject (var->order_info_);
  delete var;
}
void TdStackStorerValidateOrderInfo (struct TdValidateOrderInfo *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdValidateOrderInfo *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ValidateOrderInfo");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->pack_long (var->message_id_);
  M->new_field ("message_id_");
  TdStackStorer (var->order_info_, M);
  M->new_field ("order_info_");
  M->pack_bool (var->allow_save_);
  M->new_field ("allow_save_");
}
struct TdValidateOrderInfo *TdStackFetcherValidateOrderInfo (struct TdStackFetcherMethods *M) {
  auto res = new TdValidateOrderInfo ();
  res->ID = CODE_ValidateOrderInfo;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_id_");
  res->message_id_ = M->get_long ();
  M->pop ();
  M->get_field ("order_info_");
  if (M->is_nil ()) {
    res->order_info_ = nullptr;
  } else {
    res->order_info_ = TdStackFetcherOrderInfo (M);
  }
  M->pop ();
  M->get_field ("allow_save_");
  res->allow_save_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdViewMessages *TdCreateObjectViewMessages (long long chat_id_, struct TdVectorLong *message_ids_, int force_read_) {
  auto var = new struct TdViewMessages ();
  var->ID = CODE_ViewMessages;
  var->refcnt = 1;
  var->chat_id_ = chat_id_;
  var->message_ids_ = message_ids_;
  var->force_read_ = force_read_;
  return var;
}
td::td_api::object_ptr<td::td_api::viewMessages> TdConvertToInternal (struct TdViewMessages *var) {
  if (!var) {
    return nullptr;
  }
  std::int64_t v0;
  v0 = var->chat_id_;
  std::vector<std::int64_t> v100;
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
    std::int64_t v101;
    v101 = var->message_ids_->data[i100];
    v100.push_back (std::move (v101));
  }
  bool v200;
  v200 = var->force_read_ != 0;
  return td::td_api::make_object<td::td_api::viewMessages>(std::move (v0), std::move (v100), std::move (v200));
}
struct TdViewMessages *TdConvertFromInternal (const td::td_api::viewMessages &from) {
  auto res = new TdViewMessages ();
  res->ID = CODE_ViewMessages;
  res->refcnt = 1;
  res->chat_id_ = from.chat_id_;
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = (int)from.message_ids_.size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i100 = 0; i100 < res->message_ids_->len; i100++) {
    res->message_ids_->data[i100] = from.message_ids_[i100];
  }
  res->force_read_ = from.force_read_;
  return res;
}
char *TdSerializeViewMessages (struct TdViewMessages *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdViewMessages *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectViewMessages (struct TdViewMessages *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdViewMessages *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
  }
  delete[] var->message_ids_->data;
  delete var->message_ids_;
  delete var;
}
void TdStackStorerViewMessages (struct TdViewMessages *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdViewMessages *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ViewMessages");
  M->new_field ("ID");
  M->pack_long (var->chat_id_);
  M->new_field ("chat_id_");
  M->new_array ();
  for (int i100 = 0; i100 < var->message_ids_->len; i100++) {
    M->pack_long (var->message_ids_->data[i100]);
    M->new_arr_field (i100);
  }
  M->new_field ("message_ids_");
  M->pack_bool (var->force_read_);
  M->new_field ("force_read_");
}
struct TdViewMessages *TdStackFetcherViewMessages (struct TdStackFetcherMethods *M) {
  auto res = new TdViewMessages ();
  res->ID = CODE_ViewMessages;
  res->refcnt = 1;
  M->get_field ("chat_id_");
  res->chat_id_ = M->get_long ();
  M->pop ();
  M->get_field ("message_ids_");
  res->message_ids_ = new TdVectorLong ();
  res->message_ids_->len = M->get_arr_size ();
  res->message_ids_->data = new long long  [res->message_ids_->len];
  for (int i100 = 0; i100 < res->message_ids_->len; i100++) {
    M->get_arr_field (i100);
    res->message_ids_->data[i100] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  M->get_field ("force_read_");
  res->force_read_ = (int)M->get_long ();
  M->pop ();
  return res;
}
struct TdViewTrendingStickerSets *TdCreateObjectViewTrendingStickerSets (struct TdVectorLong *sticker_set_ids_) {
  auto var = new struct TdViewTrendingStickerSets ();
  var->ID = CODE_ViewTrendingStickerSets;
  var->refcnt = 1;
  var->sticker_set_ids_ = sticker_set_ids_;
  return var;
}
td::td_api::object_ptr<td::td_api::viewTrendingStickerSets> TdConvertToInternal (struct TdViewTrendingStickerSets *var) {
  if (!var) {
    return nullptr;
  }
  std::vector<std::int64_t> v0;
  for (int i0 = 0; i0 < var->sticker_set_ids_->len; i0++) {
    std::int64_t v1;
    v1 = var->sticker_set_ids_->data[i0];
    v0.push_back (std::move (v1));
  }
  return td::td_api::make_object<td::td_api::viewTrendingStickerSets>(std::move (v0));
}
struct TdViewTrendingStickerSets *TdConvertFromInternal (const td::td_api::viewTrendingStickerSets &from) {
  auto res = new TdViewTrendingStickerSets ();
  res->ID = CODE_ViewTrendingStickerSets;
  res->refcnt = 1;
  res->sticker_set_ids_ = new TdVectorLong ();
  res->sticker_set_ids_->len = (int)from.sticker_set_ids_.size ();
  res->sticker_set_ids_->data = new long long  [res->sticker_set_ids_->len];
  for (int i0 = 0; i0 < res->sticker_set_ids_->len; i0++) {
    res->sticker_set_ids_->data[i0] = from.sticker_set_ids_[i0];
  }
  return res;
}
char *TdSerializeViewTrendingStickerSets (struct TdViewTrendingStickerSets *var) {
  return td::str_dup (TdToString (var));
}
std::string TdToString (struct TdViewTrendingStickerSets *var) {
  return to_string (TdConvertToInternal (var));
}
void TdDestroyObjectViewTrendingStickerSets (struct TdViewTrendingStickerSets *var) {
  TdDestroyObject (var);
}
void TdDestroyObject (struct TdViewTrendingStickerSets *var) {
  if (!var) {
    return;
  }
#if TD_MSVC
  static_assert (sizeof (long) == sizeof (var->refcnt), "Illegal InterlockedDecrement");
  int ref = InterlockedDecrement (reinterpret_cast<long *>(&var->refcnt));
#else
  int ref = __sync_add_and_fetch (&var->refcnt, -1);
#endif
  if (ref < 0) {
    LOG(FATAL) << "Negative reference counter in Td C object struct";
  }
  if (ref > 0) {
    return;
  }
  for (int i0 = 0; i0 < var->sticker_set_ids_->len; i0++) {
  }
  delete[] var->sticker_set_ids_->data;
  delete var->sticker_set_ids_;
  delete var;
}
void TdStackStorerViewTrendingStickerSets (struct TdViewTrendingStickerSets *var, struct TdStackStorerMethods *M) {
  TdStackStorer (var, M);
}
void TdStackStorer (struct TdViewTrendingStickerSets *var, struct TdStackStorerMethods *M) {
  if (!var) {
    M->pack_bool (0);
    return;
  }
  M->new_table ();
  M->pack_string ("ViewTrendingStickerSets");
  M->new_field ("ID");
  M->new_array ();
  for (int i0 = 0; i0 < var->sticker_set_ids_->len; i0++) {
    M->pack_long (var->sticker_set_ids_->data[i0]);
    M->new_arr_field (i0);
  }
  M->new_field ("sticker_set_ids_");
}
struct TdViewTrendingStickerSets *TdStackFetcherViewTrendingStickerSets (struct TdStackFetcherMethods *M) {
  auto res = new TdViewTrendingStickerSets ();
  res->ID = CODE_ViewTrendingStickerSets;
  res->refcnt = 1;
  M->get_field ("sticker_set_ids_");
  res->sticker_set_ids_ = new TdVectorLong ();
  res->sticker_set_ids_->len = M->get_arr_size ();
  res->sticker_set_ids_->data = new long long  [res->sticker_set_ids_->len];
  for (int i0 = 0; i0 < res->sticker_set_ids_->len; i0++) {
    M->get_arr_field (i0);
    res->sticker_set_ids_->data[i0] = M->get_long ();
    M->pop ();
  }
  M->pop ();
  return res;
}
