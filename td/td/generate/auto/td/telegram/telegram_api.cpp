#include "telegram_api.h"

#include "td/tl/tl_object_parse.h"
#include "td/tl/tl_object_store.h"

#include "td/utils/common.h"
#include "td/utils/format.h"
#include "td/utils/logging.h"
#include "td/utils/tl_parsers.h"
#include "td/utils/tl_storers.h"

namespace td {
namespace telegram_api {

std::string to_string(const BaseObject &value) {
  TlStorerToString storer;
  value.store(storer, "");
  return storer.str();
}

object_ptr<Object> Object::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case accessPointRule::ID:
      return accessPointRule::fetch(p);
    case accountDaysTTL::ID:
      return accountDaysTTL::fetch(p);
    case authorization::ID:
      return authorization::fetch(p);
    case botCommand::ID:
      return botCommand::fetch(p);
    case botInfo::ID:
      return botInfo::fetch(p);
    case botInlineMessageMediaAuto::ID:
      return botInlineMessageMediaAuto::fetch(p);
    case botInlineMessageText::ID:
      return botInlineMessageText::fetch(p);
    case botInlineMessageMediaGeo::ID:
      return botInlineMessageMediaGeo::fetch(p);
    case botInlineMessageMediaVenue::ID:
      return botInlineMessageMediaVenue::fetch(p);
    case botInlineMessageMediaContact::ID:
      return botInlineMessageMediaContact::fetch(p);
    case botInlineResult::ID:
      return botInlineResult::fetch(p);
    case botInlineMediaResult::ID:
      return botInlineMediaResult::fetch(p);
    case cdnConfig::ID:
      return cdnConfig::fetch(p);
    case cdnPublicKey::ID:
      return cdnPublicKey::fetch(p);
    case channelAdminLogEvent::ID:
      return channelAdminLogEvent::fetch(p);
    case channelAdminLogEventActionChangeTitle::ID:
      return channelAdminLogEventActionChangeTitle::fetch(p);
    case channelAdminLogEventActionChangeAbout::ID:
      return channelAdminLogEventActionChangeAbout::fetch(p);
    case channelAdminLogEventActionChangeUsername::ID:
      return channelAdminLogEventActionChangeUsername::fetch(p);
    case channelAdminLogEventActionChangePhoto::ID:
      return channelAdminLogEventActionChangePhoto::fetch(p);
    case channelAdminLogEventActionToggleInvites::ID:
      return channelAdminLogEventActionToggleInvites::fetch(p);
    case channelAdminLogEventActionToggleSignatures::ID:
      return channelAdminLogEventActionToggleSignatures::fetch(p);
    case channelAdminLogEventActionUpdatePinned::ID:
      return channelAdminLogEventActionUpdatePinned::fetch(p);
    case channelAdminLogEventActionEditMessage::ID:
      return channelAdminLogEventActionEditMessage::fetch(p);
    case channelAdminLogEventActionDeleteMessage::ID:
      return channelAdminLogEventActionDeleteMessage::fetch(p);
    case channelAdminLogEventActionParticipantJoin::ID:
      return channelAdminLogEventActionParticipantJoin::fetch(p);
    case channelAdminLogEventActionParticipantLeave::ID:
      return channelAdminLogEventActionParticipantLeave::fetch(p);
    case channelAdminLogEventActionParticipantInvite::ID:
      return channelAdminLogEventActionParticipantInvite::fetch(p);
    case channelAdminLogEventActionParticipantToggleBan::ID:
      return channelAdminLogEventActionParticipantToggleBan::fetch(p);
    case channelAdminLogEventActionParticipantToggleAdmin::ID:
      return channelAdminLogEventActionParticipantToggleAdmin::fetch(p);
    case channelAdminLogEventActionChangeStickerSet::ID:
      return channelAdminLogEventActionChangeStickerSet::fetch(p);
    case channelAdminLogEventActionTogglePreHistoryHidden::ID:
      return channelAdminLogEventActionTogglePreHistoryHidden::fetch(p);
    case channelAdminRights::ID:
      return channelAdminRights::fetch(p);
    case channelBannedRights::ID:
      return channelBannedRights::fetch(p);
    case channelParticipant::ID:
      return channelParticipant::fetch(p);
    case channelParticipantSelf::ID:
      return channelParticipantSelf::fetch(p);
    case channelParticipantCreator::ID:
      return channelParticipantCreator::fetch(p);
    case channelParticipantAdmin::ID:
      return channelParticipantAdmin::fetch(p);
    case channelParticipantBanned::ID:
      return channelParticipantBanned::fetch(p);
    case chatEmpty::ID:
      return chatEmpty::fetch(p);
    case chat::ID:
      return chat::fetch(p);
    case chatForbidden::ID:
      return chatForbidden::fetch(p);
    case channel::ID:
      return channel::fetch(p);
    case channelForbidden::ID:
      return channelForbidden::fetch(p);
    case chatFull::ID:
      return chatFull::fetch(p);
    case channelFull::ID:
      return channelFull::fetch(p);
    case chatInviteAlready::ID:
      return chatInviteAlready::fetch(p);
    case chatInvite::ID:
      return chatInvite::fetch(p);
    case chatParticipant::ID:
      return chatParticipant::fetch(p);
    case chatParticipantCreator::ID:
      return chatParticipantCreator::fetch(p);
    case chatParticipantAdmin::ID:
      return chatParticipantAdmin::fetch(p);
    case chatParticipantsForbidden::ID:
      return chatParticipantsForbidden::fetch(p);
    case chatParticipants::ID:
      return chatParticipants::fetch(p);
    case chatPhotoEmpty::ID:
      return chatPhotoEmpty::fetch(p);
    case chatPhoto::ID:
      return chatPhoto::fetch(p);
    case config::ID:
      return config::fetch(p);
    case contact::ID:
      return contact::fetch(p);
    case contactBlocked::ID:
      return contactBlocked::fetch(p);
    case contactLinkUnknown::ID:
      return contactLinkUnknown::fetch(p);
    case contactLinkNone::ID:
      return contactLinkNone::fetch(p);
    case contactLinkHasPhone::ID:
      return contactLinkHasPhone::fetch(p);
    case contactLinkContact::ID:
      return contactLinkContact::fetch(p);
    case contactStatus::ID:
      return contactStatus::fetch(p);
    case dataJSON::ID:
      return dataJSON::fetch(p);
    case dcOption::ID:
      return dcOption::fetch(p);
    case dialog::ID:
      return dialog::fetch(p);
    case dialogPeer::ID:
      return dialogPeer::fetch(p);
    case documentEmpty::ID:
      return documentEmpty::fetch(p);
    case document::ID:
      return document::fetch(p);
    case documentAttributeImageSize::ID:
      return documentAttributeImageSize::fetch(p);
    case documentAttributeAnimated::ID:
      return documentAttributeAnimated::fetch(p);
    case documentAttributeSticker::ID:
      return documentAttributeSticker::fetch(p);
    case documentAttributeVideo::ID:
      return documentAttributeVideo::fetch(p);
    case documentAttributeAudio::ID:
      return documentAttributeAudio::fetch(p);
    case documentAttributeFilename::ID:
      return documentAttributeFilename::fetch(p);
    case documentAttributeHasStickers::ID:
      return documentAttributeHasStickers::fetch(p);
    case draftMessageEmpty::ID:
      return draftMessageEmpty::fetch(p);
    case draftMessage::ID:
      return draftMessage::fetch(p);
    case encryptedChatEmpty::ID:
      return encryptedChatEmpty::fetch(p);
    case encryptedChatWaiting::ID:
      return encryptedChatWaiting::fetch(p);
    case encryptedChatRequested::ID:
      return encryptedChatRequested::fetch(p);
    case encryptedChat::ID:
      return encryptedChat::fetch(p);
    case encryptedChatDiscarded::ID:
      return encryptedChatDiscarded::fetch(p);
    case encryptedFileEmpty::ID:
      return encryptedFileEmpty::fetch(p);
    case encryptedFile::ID:
      return encryptedFile::fetch(p);
    case encryptedMessage::ID:
      return encryptedMessage::fetch(p);
    case encryptedMessageService::ID:
      return encryptedMessageService::fetch(p);
    case error::ID:
      return error::fetch(p);
    case chatInviteEmpty::ID:
      return chatInviteEmpty::fetch(p);
    case chatInviteExported::ID:
      return chatInviteExported::fetch(p);
    case exportedMessageLink::ID:
      return exportedMessageLink::fetch(p);
    case fileHash::ID:
      return fileHash::fetch(p);
    case fileLocationUnavailable::ID:
      return fileLocationUnavailable::fetch(p);
    case fileLocation::ID:
      return fileLocation::fetch(p);
    case foundGif::ID:
      return foundGif::fetch(p);
    case foundGifCached::ID:
      return foundGifCached::fetch(p);
    case game::ID:
      return game::fetch(p);
    case geoPointEmpty::ID:
      return geoPointEmpty::fetch(p);
    case geoPoint::ID:
      return geoPoint::fetch(p);
    case highScore::ID:
      return highScore::fetch(p);
    case importedContact::ID:
      return importedContact::fetch(p);
    case inlineBotSwitchPM::ID:
      return inlineBotSwitchPM::fetch(p);
    case inputBotInlineMessageID::ID:
      return inputBotInlineMessageID::fetch(p);
    case inputChannelEmpty::ID:
      return inputChannelEmpty::fetch(p);
    case inputChannel::ID:
      return inputChannel::fetch(p);
    case inputStickerSetEmpty::ID:
      return inputStickerSetEmpty::fetch(p);
    case inputStickerSetID::ID:
      return inputStickerSetID::fetch(p);
    case inputStickerSetShortName::ID:
      return inputStickerSetShortName::fetch(p);
    case inputUserEmpty::ID:
      return inputUserEmpty::fetch(p);
    case inputUserSelf::ID:
      return inputUserSelf::fetch(p);
    case inputUser::ID:
      return inputUser::fetch(p);
    case invoice::ID:
      return invoice::fetch(p);
    case ipPort::ID:
      return ipPort::fetch(p);
    case ipPortSecret::ID:
      return ipPortSecret::fetch(p);
    case keyboardButton::ID:
      return keyboardButton::fetch(p);
    case keyboardButtonUrl::ID:
      return keyboardButtonUrl::fetch(p);
    case keyboardButtonCallback::ID:
      return keyboardButtonCallback::fetch(p);
    case keyboardButtonRequestPhone::ID:
      return keyboardButtonRequestPhone::fetch(p);
    case keyboardButtonRequestGeoLocation::ID:
      return keyboardButtonRequestGeoLocation::fetch(p);
    case keyboardButtonSwitchInline::ID:
      return keyboardButtonSwitchInline::fetch(p);
    case keyboardButtonGame::ID:
      return keyboardButtonGame::fetch(p);
    case keyboardButtonBuy::ID:
      return keyboardButtonBuy::fetch(p);
    case keyboardButtonRow::ID:
      return keyboardButtonRow::fetch(p);
    case labeledPrice::ID:
      return labeledPrice::fetch(p);
    case langPackDifference::ID:
      return langPackDifference::fetch(p);
    case langPackLanguage::ID:
      return langPackLanguage::fetch(p);
    case langPackString::ID:
      return langPackString::fetch(p);
    case langPackStringPluralized::ID:
      return langPackStringPluralized::fetch(p);
    case langPackStringDeleted::ID:
      return langPackStringDeleted::fetch(p);
    case maskCoords::ID:
      return maskCoords::fetch(p);
    case messageEmpty::ID:
      return messageEmpty::fetch(p);
    case message::ID:
      return message::fetch(p);
    case messageService::ID:
      return messageService::fetch(p);
    case messageActionEmpty::ID:
      return messageActionEmpty::fetch(p);
    case messageActionChatCreate::ID:
      return messageActionChatCreate::fetch(p);
    case messageActionChatEditTitle::ID:
      return messageActionChatEditTitle::fetch(p);
    case messageActionChatEditPhoto::ID:
      return messageActionChatEditPhoto::fetch(p);
    case messageActionChatDeletePhoto::ID:
      return messageActionChatDeletePhoto::fetch(p);
    case messageActionChatAddUser::ID:
      return messageActionChatAddUser::fetch(p);
    case messageActionChatDeleteUser::ID:
      return messageActionChatDeleteUser::fetch(p);
    case messageActionChatJoinedByLink::ID:
      return messageActionChatJoinedByLink::fetch(p);
    case messageActionChannelCreate::ID:
      return messageActionChannelCreate::fetch(p);
    case messageActionChatMigrateTo::ID:
      return messageActionChatMigrateTo::fetch(p);
    case messageActionChannelMigrateFrom::ID:
      return messageActionChannelMigrateFrom::fetch(p);
    case messageActionPinMessage::ID:
      return messageActionPinMessage::fetch(p);
    case messageActionHistoryClear::ID:
      return messageActionHistoryClear::fetch(p);
    case messageActionGameScore::ID:
      return messageActionGameScore::fetch(p);
    case messageActionPaymentSentMe::ID:
      return messageActionPaymentSentMe::fetch(p);
    case messageActionPaymentSent::ID:
      return messageActionPaymentSent::fetch(p);
    case messageActionPhoneCall::ID:
      return messageActionPhoneCall::fetch(p);
    case messageActionScreenshotTaken::ID:
      return messageActionScreenshotTaken::fetch(p);
    case messageActionCustomAction::ID:
      return messageActionCustomAction::fetch(p);
    case messageActionBotAllowed::ID:
      return messageActionBotAllowed::fetch(p);
    case messageActionSecureValuesSentMe::ID:
      return messageActionSecureValuesSentMe::fetch(p);
    case messageActionSecureValuesSent::ID:
      return messageActionSecureValuesSent::fetch(p);
    case messageEntityUnknown::ID:
      return messageEntityUnknown::fetch(p);
    case messageEntityMention::ID:
      return messageEntityMention::fetch(p);
    case messageEntityHashtag::ID:
      return messageEntityHashtag::fetch(p);
    case messageEntityBotCommand::ID:
      return messageEntityBotCommand::fetch(p);
    case messageEntityUrl::ID:
      return messageEntityUrl::fetch(p);
    case messageEntityEmail::ID:
      return messageEntityEmail::fetch(p);
    case messageEntityBold::ID:
      return messageEntityBold::fetch(p);
    case messageEntityItalic::ID:
      return messageEntityItalic::fetch(p);
    case messageEntityCode::ID:
      return messageEntityCode::fetch(p);
    case messageEntityPre::ID:
      return messageEntityPre::fetch(p);
    case messageEntityTextUrl::ID:
      return messageEntityTextUrl::fetch(p);
    case messageEntityMentionName::ID:
      return messageEntityMentionName::fetch(p);
    case inputMessageEntityMentionName::ID:
      return inputMessageEntityMentionName::fetch(p);
    case messageEntityPhone::ID:
      return messageEntityPhone::fetch(p);
    case messageEntityCashtag::ID:
      return messageEntityCashtag::fetch(p);
    case messageFwdHeader::ID:
      return messageFwdHeader::fetch(p);
    case messageMediaEmpty::ID:
      return messageMediaEmpty::fetch(p);
    case messageMediaPhoto::ID:
      return messageMediaPhoto::fetch(p);
    case messageMediaGeo::ID:
      return messageMediaGeo::fetch(p);
    case messageMediaContact::ID:
      return messageMediaContact::fetch(p);
    case messageMediaUnsupported::ID:
      return messageMediaUnsupported::fetch(p);
    case messageMediaDocument::ID:
      return messageMediaDocument::fetch(p);
    case messageMediaWebPage::ID:
      return messageMediaWebPage::fetch(p);
    case messageMediaVenue::ID:
      return messageMediaVenue::fetch(p);
    case messageMediaGame::ID:
      return messageMediaGame::fetch(p);
    case messageMediaInvoice::ID:
      return messageMediaInvoice::fetch(p);
    case messageMediaGeoLive::ID:
      return messageMediaGeoLive::fetch(p);
    case messageRange::ID:
      return messageRange::fetch(p);
    case nearestDc::ID:
      return nearestDc::fetch(p);
    case notifyPeer::ID:
      return notifyPeer::fetch(p);
    case notifyUsers::ID:
      return notifyUsers::fetch(p);
    case notifyChats::ID:
      return notifyChats::fetch(p);
    case pagePart::ID:
      return pagePart::fetch(p);
    case pageFull::ID:
      return pageFull::fetch(p);
    case pageBlockUnsupported::ID:
      return pageBlockUnsupported::fetch(p);
    case pageBlockTitle::ID:
      return pageBlockTitle::fetch(p);
    case pageBlockSubtitle::ID:
      return pageBlockSubtitle::fetch(p);
    case pageBlockAuthorDate::ID:
      return pageBlockAuthorDate::fetch(p);
    case pageBlockHeader::ID:
      return pageBlockHeader::fetch(p);
    case pageBlockSubheader::ID:
      return pageBlockSubheader::fetch(p);
    case pageBlockParagraph::ID:
      return pageBlockParagraph::fetch(p);
    case pageBlockPreformatted::ID:
      return pageBlockPreformatted::fetch(p);
    case pageBlockFooter::ID:
      return pageBlockFooter::fetch(p);
    case pageBlockDivider::ID:
      return pageBlockDivider::fetch(p);
    case pageBlockAnchor::ID:
      return pageBlockAnchor::fetch(p);
    case pageBlockList::ID:
      return pageBlockList::fetch(p);
    case pageBlockBlockquote::ID:
      return pageBlockBlockquote::fetch(p);
    case pageBlockPullquote::ID:
      return pageBlockPullquote::fetch(p);
    case pageBlockPhoto::ID:
      return pageBlockPhoto::fetch(p);
    case pageBlockVideo::ID:
      return pageBlockVideo::fetch(p);
    case pageBlockCover::ID:
      return pageBlockCover::fetch(p);
    case pageBlockEmbed::ID:
      return pageBlockEmbed::fetch(p);
    case pageBlockEmbedPost::ID:
      return pageBlockEmbedPost::fetch(p);
    case pageBlockCollage::ID:
      return pageBlockCollage::fetch(p);
    case pageBlockSlideshow::ID:
      return pageBlockSlideshow::fetch(p);
    case pageBlockChannel::ID:
      return pageBlockChannel::fetch(p);
    case pageBlockAudio::ID:
      return pageBlockAudio::fetch(p);
    case passwordKdfAlgoUnknown::ID:
      return passwordKdfAlgoUnknown::fetch(p);
    case passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::ID:
      return passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::fetch(p);
    case paymentCharge::ID:
      return paymentCharge::fetch(p);
    case paymentRequestedInfo::ID:
      return paymentRequestedInfo::fetch(p);
    case paymentSavedCredentialsCard::ID:
      return paymentSavedCredentialsCard::fetch(p);
    case peerUser::ID:
      return peerUser::fetch(p);
    case peerChat::ID:
      return peerChat::fetch(p);
    case peerChannel::ID:
      return peerChannel::fetch(p);
    case peerNotifySettings::ID:
      return peerNotifySettings::fetch(p);
    case peerSettings::ID:
      return peerSettings::fetch(p);
    case phoneCallEmpty::ID:
      return phoneCallEmpty::fetch(p);
    case phoneCallWaiting::ID:
      return phoneCallWaiting::fetch(p);
    case phoneCallRequested::ID:
      return phoneCallRequested::fetch(p);
    case phoneCallAccepted::ID:
      return phoneCallAccepted::fetch(p);
    case phoneCall::ID:
      return phoneCall::fetch(p);
    case phoneCallDiscarded::ID:
      return phoneCallDiscarded::fetch(p);
    case phoneCallDiscardReasonMissed::ID:
      return phoneCallDiscardReasonMissed::fetch(p);
    case phoneCallDiscardReasonDisconnect::ID:
      return phoneCallDiscardReasonDisconnect::fetch(p);
    case phoneCallDiscardReasonHangup::ID:
      return phoneCallDiscardReasonHangup::fetch(p);
    case phoneCallDiscardReasonBusy::ID:
      return phoneCallDiscardReasonBusy::fetch(p);
    case phoneCallProtocol::ID:
      return phoneCallProtocol::fetch(p);
    case phoneConnection::ID:
      return phoneConnection::fetch(p);
    case photoEmpty::ID:
      return photoEmpty::fetch(p);
    case photo::ID:
      return photo::fetch(p);
    case photoSizeEmpty::ID:
      return photoSizeEmpty::fetch(p);
    case photoSize::ID:
      return photoSize::fetch(p);
    case photoCachedSize::ID:
      return photoCachedSize::fetch(p);
    case popularContact::ID:
      return popularContact::fetch(p);
    case postAddress::ID:
      return postAddress::fetch(p);
    case privacyKeyStatusTimestamp::ID:
      return privacyKeyStatusTimestamp::fetch(p);
    case privacyKeyChatInvite::ID:
      return privacyKeyChatInvite::fetch(p);
    case privacyKeyPhoneCall::ID:
      return privacyKeyPhoneCall::fetch(p);
    case privacyValueAllowContacts::ID:
      return privacyValueAllowContacts::fetch(p);
    case privacyValueAllowAll::ID:
      return privacyValueAllowAll::fetch(p);
    case privacyValueAllowUsers::ID:
      return privacyValueAllowUsers::fetch(p);
    case privacyValueDisallowContacts::ID:
      return privacyValueDisallowContacts::fetch(p);
    case privacyValueDisallowAll::ID:
      return privacyValueDisallowAll::fetch(p);
    case privacyValueDisallowUsers::ID:
      return privacyValueDisallowUsers::fetch(p);
    case receivedNotifyMessage::ID:
      return receivedNotifyMessage::fetch(p);
    case recentMeUrlUnknown::ID:
      return recentMeUrlUnknown::fetch(p);
    case recentMeUrlUser::ID:
      return recentMeUrlUser::fetch(p);
    case recentMeUrlChat::ID:
      return recentMeUrlChat::fetch(p);
    case recentMeUrlChatInvite::ID:
      return recentMeUrlChatInvite::fetch(p);
    case recentMeUrlStickerSet::ID:
      return recentMeUrlStickerSet::fetch(p);
    case replyKeyboardHide::ID:
      return replyKeyboardHide::fetch(p);
    case replyKeyboardForceReply::ID:
      return replyKeyboardForceReply::fetch(p);
    case replyKeyboardMarkup::ID:
      return replyKeyboardMarkup::fetch(p);
    case replyInlineMarkup::ID:
      return replyInlineMarkup::fetch(p);
    case textEmpty::ID:
      return textEmpty::fetch(p);
    case textPlain::ID:
      return textPlain::fetch(p);
    case textBold::ID:
      return textBold::fetch(p);
    case textItalic::ID:
      return textItalic::fetch(p);
    case textUnderline::ID:
      return textUnderline::fetch(p);
    case textStrike::ID:
      return textStrike::fetch(p);
    case textFixed::ID:
      return textFixed::fetch(p);
    case textUrl::ID:
      return textUrl::fetch(p);
    case textEmail::ID:
      return textEmail::fetch(p);
    case textConcat::ID:
      return textConcat::fetch(p);
    case savedPhoneContact::ID:
      return savedPhoneContact::fetch(p);
    case secureCredentialsEncrypted::ID:
      return secureCredentialsEncrypted::fetch(p);
    case secureData::ID:
      return secureData::fetch(p);
    case secureFileEmpty::ID:
      return secureFileEmpty::fetch(p);
    case secureFile::ID:
      return secureFile::fetch(p);
    case securePasswordKdfAlgoUnknown::ID:
      return securePasswordKdfAlgoUnknown::fetch(p);
    case securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::ID:
      return securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::fetch(p);
    case securePasswordKdfAlgoSHA512::ID:
      return securePasswordKdfAlgoSHA512::fetch(p);
    case securePlainPhone::ID:
      return securePlainPhone::fetch(p);
    case securePlainEmail::ID:
      return securePlainEmail::fetch(p);
    case secureRequiredType::ID:
      return secureRequiredType::fetch(p);
    case secureRequiredTypeOneOf::ID:
      return secureRequiredTypeOneOf::fetch(p);
    case secureSecretSettings::ID:
      return secureSecretSettings::fetch(p);
    case secureValue::ID:
      return secureValue::fetch(p);
    case secureValueErrorData::ID:
      return secureValueErrorData::fetch(p);
    case secureValueErrorFrontSide::ID:
      return secureValueErrorFrontSide::fetch(p);
    case secureValueErrorReverseSide::ID:
      return secureValueErrorReverseSide::fetch(p);
    case secureValueErrorSelfie::ID:
      return secureValueErrorSelfie::fetch(p);
    case secureValueErrorFile::ID:
      return secureValueErrorFile::fetch(p);
    case secureValueErrorFiles::ID:
      return secureValueErrorFiles::fetch(p);
    case secureValueError::ID:
      return secureValueError::fetch(p);
    case secureValueErrorTranslationFile::ID:
      return secureValueErrorTranslationFile::fetch(p);
    case secureValueErrorTranslationFiles::ID:
      return secureValueErrorTranslationFiles::fetch(p);
    case secureValueTypePersonalDetails::ID:
      return secureValueTypePersonalDetails::fetch(p);
    case secureValueTypePassport::ID:
      return secureValueTypePassport::fetch(p);
    case secureValueTypeDriverLicense::ID:
      return secureValueTypeDriverLicense::fetch(p);
    case secureValueTypeIdentityCard::ID:
      return secureValueTypeIdentityCard::fetch(p);
    case secureValueTypeInternalPassport::ID:
      return secureValueTypeInternalPassport::fetch(p);
    case secureValueTypeAddress::ID:
      return secureValueTypeAddress::fetch(p);
    case secureValueTypeUtilityBill::ID:
      return secureValueTypeUtilityBill::fetch(p);
    case secureValueTypeBankStatement::ID:
      return secureValueTypeBankStatement::fetch(p);
    case secureValueTypeRentalAgreement::ID:
      return secureValueTypeRentalAgreement::fetch(p);
    case secureValueTypePassportRegistration::ID:
      return secureValueTypePassportRegistration::fetch(p);
    case secureValueTypeTemporaryRegistration::ID:
      return secureValueTypeTemporaryRegistration::fetch(p);
    case secureValueTypePhone::ID:
      return secureValueTypePhone::fetch(p);
    case secureValueTypeEmail::ID:
      return secureValueTypeEmail::fetch(p);
    case sendMessageTypingAction::ID:
      return sendMessageTypingAction::fetch(p);
    case sendMessageCancelAction::ID:
      return sendMessageCancelAction::fetch(p);
    case sendMessageRecordVideoAction::ID:
      return sendMessageRecordVideoAction::fetch(p);
    case sendMessageUploadVideoAction::ID:
      return sendMessageUploadVideoAction::fetch(p);
    case sendMessageRecordAudioAction::ID:
      return sendMessageRecordAudioAction::fetch(p);
    case sendMessageUploadAudioAction::ID:
      return sendMessageUploadAudioAction::fetch(p);
    case sendMessageUploadPhotoAction::ID:
      return sendMessageUploadPhotoAction::fetch(p);
    case sendMessageUploadDocumentAction::ID:
      return sendMessageUploadDocumentAction::fetch(p);
    case sendMessageGeoLocationAction::ID:
      return sendMessageGeoLocationAction::fetch(p);
    case sendMessageChooseContactAction::ID:
      return sendMessageChooseContactAction::fetch(p);
    case sendMessageGamePlayAction::ID:
      return sendMessageGamePlayAction::fetch(p);
    case sendMessageRecordRoundAction::ID:
      return sendMessageRecordRoundAction::fetch(p);
    case sendMessageUploadRoundAction::ID:
      return sendMessageUploadRoundAction::fetch(p);
    case shippingOption::ID:
      return shippingOption::fetch(p);
    case stickerPack::ID:
      return stickerPack::fetch(p);
    case stickerSet::ID:
      return stickerSet::fetch(p);
    case stickerSetCovered::ID:
      return stickerSetCovered::fetch(p);
    case stickerSetMultiCovered::ID:
      return stickerSetMultiCovered::fetch(p);
    case topPeer::ID:
      return topPeer::fetch(p);
    case topPeerCategoryBotsPM::ID:
      return topPeerCategoryBotsPM::fetch(p);
    case topPeerCategoryBotsInline::ID:
      return topPeerCategoryBotsInline::fetch(p);
    case topPeerCategoryCorrespondents::ID:
      return topPeerCategoryCorrespondents::fetch(p);
    case topPeerCategoryGroups::ID:
      return topPeerCategoryGroups::fetch(p);
    case topPeerCategoryChannels::ID:
      return topPeerCategoryChannels::fetch(p);
    case topPeerCategoryPhoneCalls::ID:
      return topPeerCategoryPhoneCalls::fetch(p);
    case topPeerCategoryPeers::ID:
      return topPeerCategoryPeers::fetch(p);
    case updateNewMessage::ID:
      return updateNewMessage::fetch(p);
    case updateMessageID::ID:
      return updateMessageID::fetch(p);
    case updateDeleteMessages::ID:
      return updateDeleteMessages::fetch(p);
    case updateUserTyping::ID:
      return updateUserTyping::fetch(p);
    case updateChatUserTyping::ID:
      return updateChatUserTyping::fetch(p);
    case updateChatParticipants::ID:
      return updateChatParticipants::fetch(p);
    case updateUserStatus::ID:
      return updateUserStatus::fetch(p);
    case updateUserName::ID:
      return updateUserName::fetch(p);
    case updateUserPhoto::ID:
      return updateUserPhoto::fetch(p);
    case updateContactRegistered::ID:
      return updateContactRegistered::fetch(p);
    case updateContactLink::ID:
      return updateContactLink::fetch(p);
    case updateNewEncryptedMessage::ID:
      return updateNewEncryptedMessage::fetch(p);
    case updateEncryptedChatTyping::ID:
      return updateEncryptedChatTyping::fetch(p);
    case updateEncryption::ID:
      return updateEncryption::fetch(p);
    case updateEncryptedMessagesRead::ID:
      return updateEncryptedMessagesRead::fetch(p);
    case updateChatParticipantAdd::ID:
      return updateChatParticipantAdd::fetch(p);
    case updateChatParticipantDelete::ID:
      return updateChatParticipantDelete::fetch(p);
    case updateDcOptions::ID:
      return updateDcOptions::fetch(p);
    case updateUserBlocked::ID:
      return updateUserBlocked::fetch(p);
    case updateNotifySettings::ID:
      return updateNotifySettings::fetch(p);
    case updateServiceNotification::ID:
      return updateServiceNotification::fetch(p);
    case updatePrivacy::ID:
      return updatePrivacy::fetch(p);
    case updateUserPhone::ID:
      return updateUserPhone::fetch(p);
    case updateReadHistoryInbox::ID:
      return updateReadHistoryInbox::fetch(p);
    case updateReadHistoryOutbox::ID:
      return updateReadHistoryOutbox::fetch(p);
    case updateWebPage::ID:
      return updateWebPage::fetch(p);
    case updateReadMessagesContents::ID:
      return updateReadMessagesContents::fetch(p);
    case updateChannelTooLong::ID:
      return updateChannelTooLong::fetch(p);
    case updateChannel::ID:
      return updateChannel::fetch(p);
    case updateNewChannelMessage::ID:
      return updateNewChannelMessage::fetch(p);
    case updateReadChannelInbox::ID:
      return updateReadChannelInbox::fetch(p);
    case updateDeleteChannelMessages::ID:
      return updateDeleteChannelMessages::fetch(p);
    case updateChannelMessageViews::ID:
      return updateChannelMessageViews::fetch(p);
    case updateChatAdmins::ID:
      return updateChatAdmins::fetch(p);
    case updateChatParticipantAdmin::ID:
      return updateChatParticipantAdmin::fetch(p);
    case updateNewStickerSet::ID:
      return updateNewStickerSet::fetch(p);
    case updateStickerSetsOrder::ID:
      return updateStickerSetsOrder::fetch(p);
    case updateStickerSets::ID:
      return updateStickerSets::fetch(p);
    case updateSavedGifs::ID:
      return updateSavedGifs::fetch(p);
    case updateBotInlineQuery::ID:
      return updateBotInlineQuery::fetch(p);
    case updateBotInlineSend::ID:
      return updateBotInlineSend::fetch(p);
    case updateEditChannelMessage::ID:
      return updateEditChannelMessage::fetch(p);
    case updateChannelPinnedMessage::ID:
      return updateChannelPinnedMessage::fetch(p);
    case updateBotCallbackQuery::ID:
      return updateBotCallbackQuery::fetch(p);
    case updateEditMessage::ID:
      return updateEditMessage::fetch(p);
    case updateInlineBotCallbackQuery::ID:
      return updateInlineBotCallbackQuery::fetch(p);
    case updateReadChannelOutbox::ID:
      return updateReadChannelOutbox::fetch(p);
    case updateDraftMessage::ID:
      return updateDraftMessage::fetch(p);
    case updateReadFeaturedStickers::ID:
      return updateReadFeaturedStickers::fetch(p);
    case updateRecentStickers::ID:
      return updateRecentStickers::fetch(p);
    case updateConfig::ID:
      return updateConfig::fetch(p);
    case updatePtsChanged::ID:
      return updatePtsChanged::fetch(p);
    case updateChannelWebPage::ID:
      return updateChannelWebPage::fetch(p);
    case updateDialogPinned::ID:
      return updateDialogPinned::fetch(p);
    case updatePinnedDialogs::ID:
      return updatePinnedDialogs::fetch(p);
    case updateBotWebhookJSON::ID:
      return updateBotWebhookJSON::fetch(p);
    case updateBotWebhookJSONQuery::ID:
      return updateBotWebhookJSONQuery::fetch(p);
    case updateBotShippingQuery::ID:
      return updateBotShippingQuery::fetch(p);
    case updateBotPrecheckoutQuery::ID:
      return updateBotPrecheckoutQuery::fetch(p);
    case updatePhoneCall::ID:
      return updatePhoneCall::fetch(p);
    case updateLangPackTooLong::ID:
      return updateLangPackTooLong::fetch(p);
    case updateLangPack::ID:
      return updateLangPack::fetch(p);
    case updateFavedStickers::ID:
      return updateFavedStickers::fetch(p);
    case updateChannelReadMessagesContents::ID:
      return updateChannelReadMessagesContents::fetch(p);
    case updateContactsReset::ID:
      return updateContactsReset::fetch(p);
    case updateChannelAvailableMessages::ID:
      return updateChannelAvailableMessages::fetch(p);
    case updateDialogUnreadMark::ID:
      return updateDialogUnreadMark::fetch(p);
    case updatesTooLong::ID:
      return updatesTooLong::fetch(p);
    case updateShortMessage::ID:
      return updateShortMessage::fetch(p);
    case updateShortChatMessage::ID:
      return updateShortChatMessage::fetch(p);
    case updateShort::ID:
      return updateShort::fetch(p);
    case updatesCombined::ID:
      return updatesCombined::fetch(p);
    case updates::ID:
      return updates::fetch(p);
    case updateShortSentMessage::ID:
      return updateShortSentMessage::fetch(p);
    case userEmpty::ID:
      return userEmpty::fetch(p);
    case user::ID:
      return user::fetch(p);
    case userFull::ID:
      return userFull::fetch(p);
    case userProfilePhotoEmpty::ID:
      return userProfilePhotoEmpty::fetch(p);
    case userProfilePhoto::ID:
      return userProfilePhoto::fetch(p);
    case userStatusEmpty::ID:
      return userStatusEmpty::fetch(p);
    case userStatusOnline::ID:
      return userStatusOnline::fetch(p);
    case userStatusOffline::ID:
      return userStatusOffline::fetch(p);
    case userStatusRecently::ID:
      return userStatusRecently::fetch(p);
    case userStatusLastWeek::ID:
      return userStatusLastWeek::fetch(p);
    case userStatusLastMonth::ID:
      return userStatusLastMonth::fetch(p);
    case wallPaper::ID:
      return wallPaper::fetch(p);
    case wallPaperSolid::ID:
      return wallPaperSolid::fetch(p);
    case webAuthorization::ID:
      return webAuthorization::fetch(p);
    case webDocument::ID:
      return webDocument::fetch(p);
    case webDocumentNoProxy::ID:
      return webDocumentNoProxy::fetch(p);
    case webPageEmpty::ID:
      return webPageEmpty::fetch(p);
    case webPagePending::ID:
      return webPagePending::fetch(p);
    case webPage::ID:
      return webPage::fetch(p);
    case webPageNotModified::ID:
      return webPageNotModified::fetch(p);
    case account_authorizationForm::ID:
      return account_authorizationForm::fetch(p);
    case account_authorizations::ID:
      return account_authorizations::fetch(p);
    case account_password::ID:
      return account_password::fetch(p);
    case account_passwordSettings::ID:
      return account_passwordSettings::fetch(p);
    case account_privacyRules::ID:
      return account_privacyRules::fetch(p);
    case account_sentEmailCode::ID:
      return account_sentEmailCode::fetch(p);
    case account_takeout::ID:
      return account_takeout::fetch(p);
    case account_tmpPassword::ID:
      return account_tmpPassword::fetch(p);
    case account_webAuthorizations::ID:
      return account_webAuthorizations::fetch(p);
    case auth_authorization::ID:
      return auth_authorization::fetch(p);
    case auth_codeTypeSms::ID:
      return auth_codeTypeSms::fetch(p);
    case auth_codeTypeCall::ID:
      return auth_codeTypeCall::fetch(p);
    case auth_codeTypeFlashCall::ID:
      return auth_codeTypeFlashCall::fetch(p);
    case auth_exportedAuthorization::ID:
      return auth_exportedAuthorization::fetch(p);
    case auth_passwordRecovery::ID:
      return auth_passwordRecovery::fetch(p);
    case auth_sentCode::ID:
      return auth_sentCode::fetch(p);
    case auth_sentCodeTypeApp::ID:
      return auth_sentCodeTypeApp::fetch(p);
    case auth_sentCodeTypeSms::ID:
      return auth_sentCodeTypeSms::fetch(p);
    case auth_sentCodeTypeCall::ID:
      return auth_sentCodeTypeCall::fetch(p);
    case auth_sentCodeTypeFlashCall::ID:
      return auth_sentCodeTypeFlashCall::fetch(p);
    case channels_adminLogResults::ID:
      return channels_adminLogResults::fetch(p);
    case channels_channelParticipant::ID:
      return channels_channelParticipant::fetch(p);
    case channels_channelParticipants::ID:
      return channels_channelParticipants::fetch(p);
    case channels_channelParticipantsNotModified::ID:
      return channels_channelParticipantsNotModified::fetch(p);
    case contacts_blocked::ID:
      return contacts_blocked::fetch(p);
    case contacts_blockedSlice::ID:
      return contacts_blockedSlice::fetch(p);
    case contacts_contactsNotModified::ID:
      return contacts_contactsNotModified::fetch(p);
    case contacts_contacts::ID:
      return contacts_contacts::fetch(p);
    case contacts_found::ID:
      return contacts_found::fetch(p);
    case contacts_importedContacts::ID:
      return contacts_importedContacts::fetch(p);
    case contacts_link::ID:
      return contacts_link::fetch(p);
    case contacts_resolvedPeer::ID:
      return contacts_resolvedPeer::fetch(p);
    case contacts_topPeersNotModified::ID:
      return contacts_topPeersNotModified::fetch(p);
    case contacts_topPeers::ID:
      return contacts_topPeers::fetch(p);
    case contacts_topPeersDisabled::ID:
      return contacts_topPeersDisabled::fetch(p);
    case help_appUpdate::ID:
      return help_appUpdate::fetch(p);
    case help_noAppUpdate::ID:
      return help_noAppUpdate::fetch(p);
    case help_configSimple::ID:
      return help_configSimple::fetch(p);
    case help_deepLinkInfoEmpty::ID:
      return help_deepLinkInfoEmpty::fetch(p);
    case help_deepLinkInfo::ID:
      return help_deepLinkInfo::fetch(p);
    case help_inviteText::ID:
      return help_inviteText::fetch(p);
    case help_passportConfigNotModified::ID:
      return help_passportConfigNotModified::fetch(p);
    case help_passportConfig::ID:
      return help_passportConfig::fetch(p);
    case help_proxyDataEmpty::ID:
      return help_proxyDataEmpty::fetch(p);
    case help_proxyDataPromo::ID:
      return help_proxyDataPromo::fetch(p);
    case help_recentMeUrls::ID:
      return help_recentMeUrls::fetch(p);
    case help_support::ID:
      return help_support::fetch(p);
    case help_termsOfService::ID:
      return help_termsOfService::fetch(p);
    case help_termsOfServiceUpdateEmpty::ID:
      return help_termsOfServiceUpdateEmpty::fetch(p);
    case help_termsOfServiceUpdate::ID:
      return help_termsOfServiceUpdate::fetch(p);
    case messages_affectedHistory::ID:
      return messages_affectedHistory::fetch(p);
    case messages_affectedMessages::ID:
      return messages_affectedMessages::fetch(p);
    case messages_allStickersNotModified::ID:
      return messages_allStickersNotModified::fetch(p);
    case messages_allStickers::ID:
      return messages_allStickers::fetch(p);
    case messages_archivedStickers::ID:
      return messages_archivedStickers::fetch(p);
    case messages_botCallbackAnswer::ID:
      return messages_botCallbackAnswer::fetch(p);
    case messages_botResults::ID:
      return messages_botResults::fetch(p);
    case messages_chatFull::ID:
      return messages_chatFull::fetch(p);
    case messages_chats::ID:
      return messages_chats::fetch(p);
    case messages_chatsSlice::ID:
      return messages_chatsSlice::fetch(p);
    case messages_dhConfigNotModified::ID:
      return messages_dhConfigNotModified::fetch(p);
    case messages_dhConfig::ID:
      return messages_dhConfig::fetch(p);
    case messages_dialogs::ID:
      return messages_dialogs::fetch(p);
    case messages_dialogsSlice::ID:
      return messages_dialogsSlice::fetch(p);
    case messages_dialogsNotModified::ID:
      return messages_dialogsNotModified::fetch(p);
    case messages_favedStickersNotModified::ID:
      return messages_favedStickersNotModified::fetch(p);
    case messages_favedStickers::ID:
      return messages_favedStickers::fetch(p);
    case messages_featuredStickersNotModified::ID:
      return messages_featuredStickersNotModified::fetch(p);
    case messages_featuredStickers::ID:
      return messages_featuredStickers::fetch(p);
    case messages_foundGifs::ID:
      return messages_foundGifs::fetch(p);
    case messages_foundStickerSetsNotModified::ID:
      return messages_foundStickerSetsNotModified::fetch(p);
    case messages_foundStickerSets::ID:
      return messages_foundStickerSets::fetch(p);
    case messages_highScores::ID:
      return messages_highScores::fetch(p);
    case messages_messageEditData::ID:
      return messages_messageEditData::fetch(p);
    case messages_messages::ID:
      return messages_messages::fetch(p);
    case messages_messagesSlice::ID:
      return messages_messagesSlice::fetch(p);
    case messages_channelMessages::ID:
      return messages_channelMessages::fetch(p);
    case messages_messagesNotModified::ID:
      return messages_messagesNotModified::fetch(p);
    case messages_peerDialogs::ID:
      return messages_peerDialogs::fetch(p);
    case messages_recentStickersNotModified::ID:
      return messages_recentStickersNotModified::fetch(p);
    case messages_recentStickers::ID:
      return messages_recentStickers::fetch(p);
    case messages_savedGifsNotModified::ID:
      return messages_savedGifsNotModified::fetch(p);
    case messages_savedGifs::ID:
      return messages_savedGifs::fetch(p);
    case messages_sentEncryptedMessage::ID:
      return messages_sentEncryptedMessage::fetch(p);
    case messages_sentEncryptedFile::ID:
      return messages_sentEncryptedFile::fetch(p);
    case messages_stickerSet::ID:
      return messages_stickerSet::fetch(p);
    case messages_stickerSetInstallResultSuccess::ID:
      return messages_stickerSetInstallResultSuccess::fetch(p);
    case messages_stickerSetInstallResultArchive::ID:
      return messages_stickerSetInstallResultArchive::fetch(p);
    case messages_stickersNotModified::ID:
      return messages_stickersNotModified::fetch(p);
    case messages_stickers::ID:
      return messages_stickers::fetch(p);
    case payments_paymentForm::ID:
      return payments_paymentForm::fetch(p);
    case payments_paymentReceipt::ID:
      return payments_paymentReceipt::fetch(p);
    case payments_paymentResult::ID:
      return payments_paymentResult::fetch(p);
    case payments_paymentVerficationNeeded::ID:
      return payments_paymentVerficationNeeded::fetch(p);
    case payments_savedInfo::ID:
      return payments_savedInfo::fetch(p);
    case payments_validatedRequestedInfo::ID:
      return payments_validatedRequestedInfo::fetch(p);
    case phone_phoneCall::ID:
      return phone_phoneCall::fetch(p);
    case photos_photo::ID:
      return photos_photo::fetch(p);
    case photos_photos::ID:
      return photos_photos::fetch(p);
    case photos_photosSlice::ID:
      return photos_photosSlice::fetch(p);
    case storage_fileUnknown::ID:
      return storage_fileUnknown::fetch(p);
    case storage_filePartial::ID:
      return storage_filePartial::fetch(p);
    case storage_fileJpeg::ID:
      return storage_fileJpeg::fetch(p);
    case storage_fileGif::ID:
      return storage_fileGif::fetch(p);
    case storage_filePng::ID:
      return storage_filePng::fetch(p);
    case storage_filePdf::ID:
      return storage_filePdf::fetch(p);
    case storage_fileMp3::ID:
      return storage_fileMp3::fetch(p);
    case storage_fileMov::ID:
      return storage_fileMov::fetch(p);
    case storage_fileMp4::ID:
      return storage_fileMp4::fetch(p);
    case storage_fileWebp::ID:
      return storage_fileWebp::fetch(p);
    case updates_channelDifferenceEmpty::ID:
      return updates_channelDifferenceEmpty::fetch(p);
    case updates_channelDifferenceTooLong::ID:
      return updates_channelDifferenceTooLong::fetch(p);
    case updates_channelDifference::ID:
      return updates_channelDifference::fetch(p);
    case updates_differenceEmpty::ID:
      return updates_differenceEmpty::fetch(p);
    case updates_difference::ID:
      return updates_difference::fetch(p);
    case updates_differenceSlice::ID:
      return updates_differenceSlice::fetch(p);
    case updates_differenceTooLong::ID:
      return updates_differenceTooLong::fetch(p);
    case updates_state::ID:
      return updates_state::fetch(p);
    case upload_cdnFileReuploadNeeded::ID:
      return upload_cdnFileReuploadNeeded::fetch(p);
    case upload_cdnFile::ID:
      return upload_cdnFile::fetch(p);
    case upload_file::ID:
      return upload_file::fetch(p);
    case upload_fileCdnRedirect::ID:
      return upload_fileCdnRedirect::fetch(p);
    case upload_webFile::ID:
      return upload_webFile::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

accessPointRule::accessPointRule()
  : phone_prefix_rules_()
  , dc_id_()
  , ips_()
{}

accessPointRule::accessPointRule(std::string const &phone_prefix_rules_, std::int32_t dc_id_, std::vector<object_ptr<IpPort>> &&ips_)
  : phone_prefix_rules_(phone_prefix_rules_)
  , dc_id_(dc_id_)
  , ips_(std::move(ips_))
{}

const std::int32_t accessPointRule::ID;

accessPointRule::accessPointRule(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : phone_prefix_rules_(TlFetchString<std::string>::parse(p))
  , dc_id_(TlFetchInt::parse(p))
  , ips_(TlFetchVector<TlFetchObject<IpPort>>::parse(p))
#undef FAIL
{}

void accessPointRule::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "accessPointRule");
    s.store_field("phone_prefix_rules", phone_prefix_rules_);
    s.store_field("dc_id", dc_id_);
    { const std::vector<object_ptr<IpPort>> &v = ips_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("ips", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

accountDaysTTL::accountDaysTTL()
  : days_()
{}

accountDaysTTL::accountDaysTTL(std::int32_t days_)
  : days_(days_)
{}

const std::int32_t accountDaysTTL::ID;

accountDaysTTL::accountDaysTTL(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : days_(TlFetchInt::parse(p))
#undef FAIL
{}

void accountDaysTTL::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(days_, s);
}

void accountDaysTTL::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(days_, s);
}

void accountDaysTTL::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "accountDaysTTL");
    s.store_field("days", days_);
    s.store_class_end();
  }
}

authorization::authorization()
  : hash_()
  , flags_()
  , device_model_()
  , platform_()
  , system_version_()
  , api_id_()
  , app_name_()
  , app_version_()
  , date_created_()
  , date_active_()
  , ip_()
  , country_()
  , region_()
{}

authorization::authorization(std::int64_t hash_, std::int32_t flags_, std::string const &device_model_, std::string const &platform_, std::string const &system_version_, std::int32_t api_id_, std::string const &app_name_, std::string const &app_version_, std::int32_t date_created_, std::int32_t date_active_, std::string const &ip_, std::string const &country_, std::string const &region_)
  : hash_(hash_)
  , flags_(flags_)
  , device_model_(device_model_)
  , platform_(platform_)
  , system_version_(system_version_)
  , api_id_(api_id_)
  , app_name_(app_name_)
  , app_version_(app_version_)
  , date_created_(date_created_)
  , date_active_(date_active_)
  , ip_(ip_)
  , country_(country_)
  , region_(region_)
{}

const std::int32_t authorization::ID;

authorization::authorization(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchLong::parse(p))
  , flags_(TlFetchInt::parse(p))
  , device_model_(TlFetchString<std::string>::parse(p))
  , platform_(TlFetchString<std::string>::parse(p))
  , system_version_(TlFetchString<std::string>::parse(p))
  , api_id_(TlFetchInt::parse(p))
  , app_name_(TlFetchString<std::string>::parse(p))
  , app_version_(TlFetchString<std::string>::parse(p))
  , date_created_(TlFetchInt::parse(p))
  , date_active_(TlFetchInt::parse(p))
  , ip_(TlFetchString<std::string>::parse(p))
  , country_(TlFetchString<std::string>::parse(p))
  , region_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void authorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "authorization");
    s.store_field("hash", hash_);
    s.store_field("flags", flags_);
    s.store_field("device_model", device_model_);
    s.store_field("platform", platform_);
    s.store_field("system_version", system_version_);
    s.store_field("api_id", api_id_);
    s.store_field("app_name", app_name_);
    s.store_field("app_version", app_version_);
    s.store_field("date_created", date_created_);
    s.store_field("date_active", date_active_);
    s.store_field("ip", ip_);
    s.store_field("country", country_);
    s.store_field("region", region_);
    s.store_class_end();
  }
}

botCommand::botCommand()
  : command_()
  , description_()
{}

botCommand::botCommand(std::string const &command_, std::string const &description_)
  : command_(command_)
  , description_(description_)
{}

const std::int32_t botCommand::ID;

botCommand::botCommand(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : command_(TlFetchString<std::string>::parse(p))
  , description_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void botCommand::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botCommand");
    s.store_field("command", command_);
    s.store_field("description", description_);
    s.store_class_end();
  }
}

botInfo::botInfo()
  : user_id_()
  , description_()
  , commands_()
{}

botInfo::botInfo(std::int32_t user_id_, std::string const &description_, std::vector<object_ptr<botCommand>> &&commands_)
  : user_id_(user_id_)
  , description_(description_)
  , commands_(std::move(commands_))
{}

const std::int32_t botInfo::ID;

botInfo::botInfo(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , description_(TlFetchString<std::string>::parse(p))
  , commands_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<botCommand>, -1032140601>>, 481674261>::parse(p))
#undef FAIL
{}

void botInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botInfo");
    s.store_field("user_id", user_id_);
    s.store_field("description", description_);
    { const std::vector<object_ptr<botCommand>> &v = commands_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("commands", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<BotInlineMessage> BotInlineMessage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case botInlineMessageMediaAuto::ID:
      return botInlineMessageMediaAuto::fetch(p);
    case botInlineMessageText::ID:
      return botInlineMessageText::fetch(p);
    case botInlineMessageMediaGeo::ID:
      return botInlineMessageMediaGeo::fetch(p);
    case botInlineMessageMediaVenue::ID:
      return botInlineMessageMediaVenue::fetch(p);
    case botInlineMessageMediaContact::ID:
      return botInlineMessageMediaContact::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

botInlineMessageMediaAuto::botInlineMessageMediaAuto()
  : flags_()
  , message_()
  , entities_()
  , reply_markup_()
{}

botInlineMessageMediaAuto::botInlineMessageMediaAuto(std::int32_t flags_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , message_(message_)
  , entities_(std::move(entities_))
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t botInlineMessageMediaAuto::ID;

object_ptr<botInlineMessageMediaAuto> botInlineMessageMediaAuto::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<botInlineMessageMediaAuto> res = make_tl_object<botInlineMessageMediaAuto>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->message_ = TlFetchString<std::string>::parse(p);
  if (var0 & 2) { res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p); }
  if (var0 & 4) { res->reply_markup_ = TlFetchObject<ReplyMarkup>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void botInlineMessageMediaAuto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botInlineMessageMediaAuto");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("message", message_);
    if (var0 & 2) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

botInlineMessageText::botInlineMessageText()
  : flags_()
  , no_webpage_()
  , message_()
  , entities_()
  , reply_markup_()
{}

botInlineMessageText::botInlineMessageText(std::int32_t flags_, bool no_webpage_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , no_webpage_(no_webpage_)
  , message_(message_)
  , entities_(std::move(entities_))
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t botInlineMessageText::ID;

object_ptr<botInlineMessageText> botInlineMessageText::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<botInlineMessageText> res = make_tl_object<botInlineMessageText>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->no_webpage_ = TlFetchTrue::parse(p); }
  res->message_ = TlFetchString<std::string>::parse(p);
  if (var0 & 2) { res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p); }
  if (var0 & 4) { res->reply_markup_ = TlFetchObject<ReplyMarkup>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void botInlineMessageText::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botInlineMessageText");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("message", message_);
    if (var0 & 2) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

botInlineMessageMediaGeo::botInlineMessageMediaGeo()
  : flags_()
  , geo_()
  , period_()
  , reply_markup_()
{}

botInlineMessageMediaGeo::botInlineMessageMediaGeo(std::int32_t flags_, object_ptr<GeoPoint> &&geo_, std::int32_t period_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , geo_(std::move(geo_))
  , period_(period_)
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t botInlineMessageMediaGeo::ID;

object_ptr<botInlineMessageMediaGeo> botInlineMessageMediaGeo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<botInlineMessageMediaGeo> res = make_tl_object<botInlineMessageMediaGeo>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->geo_ = TlFetchObject<GeoPoint>::parse(p);
  res->period_ = TlFetchInt::parse(p);
  if (var0 & 4) { res->reply_markup_ = TlFetchObject<ReplyMarkup>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void botInlineMessageMediaGeo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botInlineMessageMediaGeo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (geo_ == nullptr) { s.store_field("geo", "null"); } else { geo_->store(s, "geo"); }
    s.store_field("period", period_);
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

botInlineMessageMediaVenue::botInlineMessageMediaVenue()
  : flags_()
  , geo_()
  , title_()
  , address_()
  , provider_()
  , venue_id_()
  , venue_type_()
  , reply_markup_()
{}

botInlineMessageMediaVenue::botInlineMessageMediaVenue(std::int32_t flags_, object_ptr<GeoPoint> &&geo_, std::string const &title_, std::string const &address_, std::string const &provider_, std::string const &venue_id_, std::string const &venue_type_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , geo_(std::move(geo_))
  , title_(title_)
  , address_(address_)
  , provider_(provider_)
  , venue_id_(venue_id_)
  , venue_type_(venue_type_)
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t botInlineMessageMediaVenue::ID;

object_ptr<botInlineMessageMediaVenue> botInlineMessageMediaVenue::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<botInlineMessageMediaVenue> res = make_tl_object<botInlineMessageMediaVenue>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->geo_ = TlFetchObject<GeoPoint>::parse(p);
  res->title_ = TlFetchString<std::string>::parse(p);
  res->address_ = TlFetchString<std::string>::parse(p);
  res->provider_ = TlFetchString<std::string>::parse(p);
  res->venue_id_ = TlFetchString<std::string>::parse(p);
  res->venue_type_ = TlFetchString<std::string>::parse(p);
  if (var0 & 4) { res->reply_markup_ = TlFetchObject<ReplyMarkup>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void botInlineMessageMediaVenue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botInlineMessageMediaVenue");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (geo_ == nullptr) { s.store_field("geo", "null"); } else { geo_->store(s, "geo"); }
    s.store_field("title", title_);
    s.store_field("address", address_);
    s.store_field("provider", provider_);
    s.store_field("venue_id", venue_id_);
    s.store_field("venue_type", venue_type_);
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

botInlineMessageMediaContact::botInlineMessageMediaContact()
  : flags_()
  , phone_number_()
  , first_name_()
  , last_name_()
  , vcard_()
  , reply_markup_()
{}

botInlineMessageMediaContact::botInlineMessageMediaContact(std::int32_t flags_, std::string const &phone_number_, std::string const &first_name_, std::string const &last_name_, std::string const &vcard_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , phone_number_(phone_number_)
  , first_name_(first_name_)
  , last_name_(last_name_)
  , vcard_(vcard_)
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t botInlineMessageMediaContact::ID;

object_ptr<botInlineMessageMediaContact> botInlineMessageMediaContact::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<botInlineMessageMediaContact> res = make_tl_object<botInlineMessageMediaContact>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->phone_number_ = TlFetchString<std::string>::parse(p);
  res->first_name_ = TlFetchString<std::string>::parse(p);
  res->last_name_ = TlFetchString<std::string>::parse(p);
  res->vcard_ = TlFetchString<std::string>::parse(p);
  if (var0 & 4) { res->reply_markup_ = TlFetchObject<ReplyMarkup>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void botInlineMessageMediaContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botInlineMessageMediaContact");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("phone_number", phone_number_);
    s.store_field("first_name", first_name_);
    s.store_field("last_name", last_name_);
    s.store_field("vcard", vcard_);
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

object_ptr<BotInlineResult> BotInlineResult::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case botInlineResult::ID:
      return botInlineResult::fetch(p);
    case botInlineMediaResult::ID:
      return botInlineMediaResult::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

botInlineResult::botInlineResult()
  : flags_()
  , id_()
  , type_()
  , title_()
  , description_()
  , url_()
  , thumb_()
  , content_()
  , send_message_()
{}

botInlineResult::botInlineResult(std::int32_t flags_, std::string const &id_, std::string const &type_, std::string const &title_, std::string const &description_, std::string const &url_, object_ptr<WebDocument> &&thumb_, object_ptr<WebDocument> &&content_, object_ptr<BotInlineMessage> &&send_message_)
  : flags_(flags_)
  , id_(id_)
  , type_(type_)
  , title_(title_)
  , description_(description_)
  , url_(url_)
  , thumb_(std::move(thumb_))
  , content_(std::move(content_))
  , send_message_(std::move(send_message_))
{}

const std::int32_t botInlineResult::ID;

object_ptr<botInlineResult> botInlineResult::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<botInlineResult> res = make_tl_object<botInlineResult>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->id_ = TlFetchString<std::string>::parse(p);
  res->type_ = TlFetchString<std::string>::parse(p);
  if (var0 & 2) { res->title_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->description_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 8) { res->url_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16) { res->thumb_ = TlFetchObject<WebDocument>::parse(p); }
  if (var0 & 32) { res->content_ = TlFetchObject<WebDocument>::parse(p); }
  res->send_message_ = TlFetchObject<BotInlineMessage>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void botInlineResult::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botInlineResult");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("id", id_);
    s.store_field("type", type_);
    if (var0 & 2) { s.store_field("title", title_); }
    if (var0 & 4) { s.store_field("description", description_); }
    if (var0 & 8) { s.store_field("url", url_); }
    if (var0 & 16) { if (thumb_ == nullptr) { s.store_field("thumb", "null"); } else { thumb_->store(s, "thumb"); } }
    if (var0 & 32) { if (content_ == nullptr) { s.store_field("content", "null"); } else { content_->store(s, "content"); } }
    if (send_message_ == nullptr) { s.store_field("send_message", "null"); } else { send_message_->store(s, "send_message"); }
    s.store_class_end();
  }
}

botInlineMediaResult::botInlineMediaResult()
  : flags_()
  , id_()
  , type_()
  , photo_()
  , document_()
  , title_()
  , description_()
  , send_message_()
{}

botInlineMediaResult::botInlineMediaResult(std::int32_t flags_, std::string const &id_, std::string const &type_, object_ptr<Photo> &&photo_, object_ptr<Document> &&document_, std::string const &title_, std::string const &description_, object_ptr<BotInlineMessage> &&send_message_)
  : flags_(flags_)
  , id_(id_)
  , type_(type_)
  , photo_(std::move(photo_))
  , document_(std::move(document_))
  , title_(title_)
  , description_(description_)
  , send_message_(std::move(send_message_))
{}

const std::int32_t botInlineMediaResult::ID;

object_ptr<botInlineMediaResult> botInlineMediaResult::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<botInlineMediaResult> res = make_tl_object<botInlineMediaResult>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->id_ = TlFetchString<std::string>::parse(p);
  res->type_ = TlFetchString<std::string>::parse(p);
  if (var0 & 1) { res->photo_ = TlFetchObject<Photo>::parse(p); }
  if (var0 & 2) { res->document_ = TlFetchObject<Document>::parse(p); }
  if (var0 & 4) { res->title_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 8) { res->description_ = TlFetchString<std::string>::parse(p); }
  res->send_message_ = TlFetchObject<BotInlineMessage>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void botInlineMediaResult::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "botInlineMediaResult");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("id", id_);
    s.store_field("type", type_);
    if (var0 & 1) { if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); } }
    if (var0 & 2) { if (document_ == nullptr) { s.store_field("document", "null"); } else { document_->store(s, "document"); } }
    if (var0 & 4) { s.store_field("title", title_); }
    if (var0 & 8) { s.store_field("description", description_); }
    if (send_message_ == nullptr) { s.store_field("send_message", "null"); } else { send_message_->store(s, "send_message"); }
    s.store_class_end();
  }
}

cdnConfig::cdnConfig()
  : public_keys_()
{}

cdnConfig::cdnConfig(std::vector<object_ptr<cdnPublicKey>> &&public_keys_)
  : public_keys_(std::move(public_keys_))
{}

const std::int32_t cdnConfig::ID;

cdnConfig::cdnConfig(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : public_keys_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<cdnPublicKey>, -914167110>>, 481674261>::parse(p))
#undef FAIL
{}

void cdnConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "cdnConfig");
    { const std::vector<object_ptr<cdnPublicKey>> &v = public_keys_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("public_keys", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

cdnPublicKey::cdnPublicKey()
  : dc_id_()
  , public_key_()
{}

cdnPublicKey::cdnPublicKey(std::int32_t dc_id_, std::string const &public_key_)
  : dc_id_(dc_id_)
  , public_key_(public_key_)
{}

const std::int32_t cdnPublicKey::ID;

cdnPublicKey::cdnPublicKey(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : dc_id_(TlFetchInt::parse(p))
  , public_key_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void cdnPublicKey::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "cdnPublicKey");
    s.store_field("dc_id", dc_id_);
    s.store_field("public_key", public_key_);
    s.store_class_end();
  }
}

channelAdminLogEvent::channelAdminLogEvent()
  : id_()
  , date_()
  , user_id_()
  , action_()
{}

channelAdminLogEvent::channelAdminLogEvent(std::int64_t id_, std::int32_t date_, std::int32_t user_id_, object_ptr<ChannelAdminLogEventAction> &&action_)
  : id_(id_)
  , date_(date_)
  , user_id_(user_id_)
  , action_(std::move(action_))
{}

const std::int32_t channelAdminLogEvent::ID;

channelAdminLogEvent::channelAdminLogEvent(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
  , user_id_(TlFetchInt::parse(p))
  , action_(TlFetchObject<ChannelAdminLogEventAction>::parse(p))
#undef FAIL
{}

void channelAdminLogEvent::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEvent");
    s.store_field("id", id_);
    s.store_field("date", date_);
    s.store_field("user_id", user_id_);
    if (action_ == nullptr) { s.store_field("action", "null"); } else { action_->store(s, "action"); }
    s.store_class_end();
  }
}

object_ptr<ChannelAdminLogEventAction> ChannelAdminLogEventAction::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case channelAdminLogEventActionChangeTitle::ID:
      return channelAdminLogEventActionChangeTitle::fetch(p);
    case channelAdminLogEventActionChangeAbout::ID:
      return channelAdminLogEventActionChangeAbout::fetch(p);
    case channelAdminLogEventActionChangeUsername::ID:
      return channelAdminLogEventActionChangeUsername::fetch(p);
    case channelAdminLogEventActionChangePhoto::ID:
      return channelAdminLogEventActionChangePhoto::fetch(p);
    case channelAdminLogEventActionToggleInvites::ID:
      return channelAdminLogEventActionToggleInvites::fetch(p);
    case channelAdminLogEventActionToggleSignatures::ID:
      return channelAdminLogEventActionToggleSignatures::fetch(p);
    case channelAdminLogEventActionUpdatePinned::ID:
      return channelAdminLogEventActionUpdatePinned::fetch(p);
    case channelAdminLogEventActionEditMessage::ID:
      return channelAdminLogEventActionEditMessage::fetch(p);
    case channelAdminLogEventActionDeleteMessage::ID:
      return channelAdminLogEventActionDeleteMessage::fetch(p);
    case channelAdminLogEventActionParticipantJoin::ID:
      return channelAdminLogEventActionParticipantJoin::fetch(p);
    case channelAdminLogEventActionParticipantLeave::ID:
      return channelAdminLogEventActionParticipantLeave::fetch(p);
    case channelAdminLogEventActionParticipantInvite::ID:
      return channelAdminLogEventActionParticipantInvite::fetch(p);
    case channelAdminLogEventActionParticipantToggleBan::ID:
      return channelAdminLogEventActionParticipantToggleBan::fetch(p);
    case channelAdminLogEventActionParticipantToggleAdmin::ID:
      return channelAdminLogEventActionParticipantToggleAdmin::fetch(p);
    case channelAdminLogEventActionChangeStickerSet::ID:
      return channelAdminLogEventActionChangeStickerSet::fetch(p);
    case channelAdminLogEventActionTogglePreHistoryHidden::ID:
      return channelAdminLogEventActionTogglePreHistoryHidden::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

channelAdminLogEventActionChangeTitle::channelAdminLogEventActionChangeTitle()
  : prev_value_()
  , new_value_()
{}

channelAdminLogEventActionChangeTitle::channelAdminLogEventActionChangeTitle(std::string const &prev_value_, std::string const &new_value_)
  : prev_value_(prev_value_)
  , new_value_(new_value_)
{}

const std::int32_t channelAdminLogEventActionChangeTitle::ID;

channelAdminLogEventActionChangeTitle::channelAdminLogEventActionChangeTitle(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : prev_value_(TlFetchString<std::string>::parse(p))
  , new_value_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionChangeTitle::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionChangeTitle");
    s.store_field("prev_value", prev_value_);
    s.store_field("new_value", new_value_);
    s.store_class_end();
  }
}

channelAdminLogEventActionChangeAbout::channelAdminLogEventActionChangeAbout()
  : prev_value_()
  , new_value_()
{}

channelAdminLogEventActionChangeAbout::channelAdminLogEventActionChangeAbout(std::string const &prev_value_, std::string const &new_value_)
  : prev_value_(prev_value_)
  , new_value_(new_value_)
{}

const std::int32_t channelAdminLogEventActionChangeAbout::ID;

channelAdminLogEventActionChangeAbout::channelAdminLogEventActionChangeAbout(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : prev_value_(TlFetchString<std::string>::parse(p))
  , new_value_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionChangeAbout::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionChangeAbout");
    s.store_field("prev_value", prev_value_);
    s.store_field("new_value", new_value_);
    s.store_class_end();
  }
}

channelAdminLogEventActionChangeUsername::channelAdminLogEventActionChangeUsername()
  : prev_value_()
  , new_value_()
{}

channelAdminLogEventActionChangeUsername::channelAdminLogEventActionChangeUsername(std::string const &prev_value_, std::string const &new_value_)
  : prev_value_(prev_value_)
  , new_value_(new_value_)
{}

const std::int32_t channelAdminLogEventActionChangeUsername::ID;

channelAdminLogEventActionChangeUsername::channelAdminLogEventActionChangeUsername(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : prev_value_(TlFetchString<std::string>::parse(p))
  , new_value_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionChangeUsername::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionChangeUsername");
    s.store_field("prev_value", prev_value_);
    s.store_field("new_value", new_value_);
    s.store_class_end();
  }
}

channelAdminLogEventActionChangePhoto::channelAdminLogEventActionChangePhoto()
  : prev_photo_()
  , new_photo_()
{}

channelAdminLogEventActionChangePhoto::channelAdminLogEventActionChangePhoto(object_ptr<ChatPhoto> &&prev_photo_, object_ptr<ChatPhoto> &&new_photo_)
  : prev_photo_(std::move(prev_photo_))
  , new_photo_(std::move(new_photo_))
{}

const std::int32_t channelAdminLogEventActionChangePhoto::ID;

channelAdminLogEventActionChangePhoto::channelAdminLogEventActionChangePhoto(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : prev_photo_(TlFetchObject<ChatPhoto>::parse(p))
  , new_photo_(TlFetchObject<ChatPhoto>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionChangePhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionChangePhoto");
    if (prev_photo_ == nullptr) { s.store_field("prev_photo", "null"); } else { prev_photo_->store(s, "prev_photo"); }
    if (new_photo_ == nullptr) { s.store_field("new_photo", "null"); } else { new_photo_->store(s, "new_photo"); }
    s.store_class_end();
  }
}

channelAdminLogEventActionToggleInvites::channelAdminLogEventActionToggleInvites()
  : new_value_()
{}

channelAdminLogEventActionToggleInvites::channelAdminLogEventActionToggleInvites(bool new_value_)
  : new_value_(new_value_)
{}

const std::int32_t channelAdminLogEventActionToggleInvites::ID;

channelAdminLogEventActionToggleInvites::channelAdminLogEventActionToggleInvites(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : new_value_(TlFetchBool::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionToggleInvites::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionToggleInvites");
    s.store_field("new_value", new_value_);
    s.store_class_end();
  }
}

channelAdminLogEventActionToggleSignatures::channelAdminLogEventActionToggleSignatures()
  : new_value_()
{}

channelAdminLogEventActionToggleSignatures::channelAdminLogEventActionToggleSignatures(bool new_value_)
  : new_value_(new_value_)
{}

const std::int32_t channelAdminLogEventActionToggleSignatures::ID;

channelAdminLogEventActionToggleSignatures::channelAdminLogEventActionToggleSignatures(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : new_value_(TlFetchBool::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionToggleSignatures::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionToggleSignatures");
    s.store_field("new_value", new_value_);
    s.store_class_end();
  }
}

channelAdminLogEventActionUpdatePinned::channelAdminLogEventActionUpdatePinned()
  : message_()
{}

channelAdminLogEventActionUpdatePinned::channelAdminLogEventActionUpdatePinned(object_ptr<Message> &&message_)
  : message_(std::move(message_))
{}

const std::int32_t channelAdminLogEventActionUpdatePinned::ID;

channelAdminLogEventActionUpdatePinned::channelAdminLogEventActionUpdatePinned(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchObject<Message>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionUpdatePinned::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionUpdatePinned");
    if (message_ == nullptr) { s.store_field("message", "null"); } else { message_->store(s, "message"); }
    s.store_class_end();
  }
}

channelAdminLogEventActionEditMessage::channelAdminLogEventActionEditMessage()
  : prev_message_()
  , new_message_()
{}

channelAdminLogEventActionEditMessage::channelAdminLogEventActionEditMessage(object_ptr<Message> &&prev_message_, object_ptr<Message> &&new_message_)
  : prev_message_(std::move(prev_message_))
  , new_message_(std::move(new_message_))
{}

const std::int32_t channelAdminLogEventActionEditMessage::ID;

channelAdminLogEventActionEditMessage::channelAdminLogEventActionEditMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : prev_message_(TlFetchObject<Message>::parse(p))
  , new_message_(TlFetchObject<Message>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionEditMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionEditMessage");
    if (prev_message_ == nullptr) { s.store_field("prev_message", "null"); } else { prev_message_->store(s, "prev_message"); }
    if (new_message_ == nullptr) { s.store_field("new_message", "null"); } else { new_message_->store(s, "new_message"); }
    s.store_class_end();
  }
}

channelAdminLogEventActionDeleteMessage::channelAdminLogEventActionDeleteMessage()
  : message_()
{}

channelAdminLogEventActionDeleteMessage::channelAdminLogEventActionDeleteMessage(object_ptr<Message> &&message_)
  : message_(std::move(message_))
{}

const std::int32_t channelAdminLogEventActionDeleteMessage::ID;

channelAdminLogEventActionDeleteMessage::channelAdminLogEventActionDeleteMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchObject<Message>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionDeleteMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionDeleteMessage");
    if (message_ == nullptr) { s.store_field("message", "null"); } else { message_->store(s, "message"); }
    s.store_class_end();
  }
}

channelAdminLogEventActionParticipantJoin::channelAdminLogEventActionParticipantJoin() {
}

const std::int32_t channelAdminLogEventActionParticipantJoin::ID;

channelAdminLogEventActionParticipantJoin::channelAdminLogEventActionParticipantJoin(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void channelAdminLogEventActionParticipantJoin::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionParticipantJoin");
    s.store_class_end();
  }
}

channelAdminLogEventActionParticipantLeave::channelAdminLogEventActionParticipantLeave() {
}

const std::int32_t channelAdminLogEventActionParticipantLeave::ID;

channelAdminLogEventActionParticipantLeave::channelAdminLogEventActionParticipantLeave(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void channelAdminLogEventActionParticipantLeave::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionParticipantLeave");
    s.store_class_end();
  }
}

channelAdminLogEventActionParticipantInvite::channelAdminLogEventActionParticipantInvite()
  : participant_()
{}

channelAdminLogEventActionParticipantInvite::channelAdminLogEventActionParticipantInvite(object_ptr<ChannelParticipant> &&participant_)
  : participant_(std::move(participant_))
{}

const std::int32_t channelAdminLogEventActionParticipantInvite::ID;

channelAdminLogEventActionParticipantInvite::channelAdminLogEventActionParticipantInvite(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : participant_(TlFetchObject<ChannelParticipant>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionParticipantInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionParticipantInvite");
    if (participant_ == nullptr) { s.store_field("participant", "null"); } else { participant_->store(s, "participant"); }
    s.store_class_end();
  }
}

channelAdminLogEventActionParticipantToggleBan::channelAdminLogEventActionParticipantToggleBan()
  : prev_participant_()
  , new_participant_()
{}

channelAdminLogEventActionParticipantToggleBan::channelAdminLogEventActionParticipantToggleBan(object_ptr<ChannelParticipant> &&prev_participant_, object_ptr<ChannelParticipant> &&new_participant_)
  : prev_participant_(std::move(prev_participant_))
  , new_participant_(std::move(new_participant_))
{}

const std::int32_t channelAdminLogEventActionParticipantToggleBan::ID;

channelAdminLogEventActionParticipantToggleBan::channelAdminLogEventActionParticipantToggleBan(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : prev_participant_(TlFetchObject<ChannelParticipant>::parse(p))
  , new_participant_(TlFetchObject<ChannelParticipant>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionParticipantToggleBan::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionParticipantToggleBan");
    if (prev_participant_ == nullptr) { s.store_field("prev_participant", "null"); } else { prev_participant_->store(s, "prev_participant"); }
    if (new_participant_ == nullptr) { s.store_field("new_participant", "null"); } else { new_participant_->store(s, "new_participant"); }
    s.store_class_end();
  }
}

channelAdminLogEventActionParticipantToggleAdmin::channelAdminLogEventActionParticipantToggleAdmin()
  : prev_participant_()
  , new_participant_()
{}

channelAdminLogEventActionParticipantToggleAdmin::channelAdminLogEventActionParticipantToggleAdmin(object_ptr<ChannelParticipant> &&prev_participant_, object_ptr<ChannelParticipant> &&new_participant_)
  : prev_participant_(std::move(prev_participant_))
  , new_participant_(std::move(new_participant_))
{}

const std::int32_t channelAdminLogEventActionParticipantToggleAdmin::ID;

channelAdminLogEventActionParticipantToggleAdmin::channelAdminLogEventActionParticipantToggleAdmin(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : prev_participant_(TlFetchObject<ChannelParticipant>::parse(p))
  , new_participant_(TlFetchObject<ChannelParticipant>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionParticipantToggleAdmin::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionParticipantToggleAdmin");
    if (prev_participant_ == nullptr) { s.store_field("prev_participant", "null"); } else { prev_participant_->store(s, "prev_participant"); }
    if (new_participant_ == nullptr) { s.store_field("new_participant", "null"); } else { new_participant_->store(s, "new_participant"); }
    s.store_class_end();
  }
}

channelAdminLogEventActionChangeStickerSet::channelAdminLogEventActionChangeStickerSet()
  : prev_stickerset_()
  , new_stickerset_()
{}

channelAdminLogEventActionChangeStickerSet::channelAdminLogEventActionChangeStickerSet(object_ptr<InputStickerSet> &&prev_stickerset_, object_ptr<InputStickerSet> &&new_stickerset_)
  : prev_stickerset_(std::move(prev_stickerset_))
  , new_stickerset_(std::move(new_stickerset_))
{}

const std::int32_t channelAdminLogEventActionChangeStickerSet::ID;

channelAdminLogEventActionChangeStickerSet::channelAdminLogEventActionChangeStickerSet(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : prev_stickerset_(TlFetchObject<InputStickerSet>::parse(p))
  , new_stickerset_(TlFetchObject<InputStickerSet>::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionChangeStickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionChangeStickerSet");
    if (prev_stickerset_ == nullptr) { s.store_field("prev_stickerset", "null"); } else { prev_stickerset_->store(s, "prev_stickerset"); }
    if (new_stickerset_ == nullptr) { s.store_field("new_stickerset", "null"); } else { new_stickerset_->store(s, "new_stickerset"); }
    s.store_class_end();
  }
}

channelAdminLogEventActionTogglePreHistoryHidden::channelAdminLogEventActionTogglePreHistoryHidden()
  : new_value_()
{}

channelAdminLogEventActionTogglePreHistoryHidden::channelAdminLogEventActionTogglePreHistoryHidden(bool new_value_)
  : new_value_(new_value_)
{}

const std::int32_t channelAdminLogEventActionTogglePreHistoryHidden::ID;

channelAdminLogEventActionTogglePreHistoryHidden::channelAdminLogEventActionTogglePreHistoryHidden(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : new_value_(TlFetchBool::parse(p))
#undef FAIL
{}

void channelAdminLogEventActionTogglePreHistoryHidden::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventActionTogglePreHistoryHidden");
    s.store_field("new_value", new_value_);
    s.store_class_end();
  }
}

channelAdminLogEventsFilter::channelAdminLogEventsFilter()
  : flags_()
  , join_()
  , leave_()
  , invite_()
  , ban_()
  , unban_()
  , kick_()
  , unkick_()
  , promote_()
  , demote_()
  , info_()
  , settings_()
  , pinned_()
  , edit_()
  , delete_()
{}

channelAdminLogEventsFilter::channelAdminLogEventsFilter(std::int32_t flags_, bool join_, bool leave_, bool invite_, bool ban_, bool unban_, bool kick_, bool unkick_, bool promote_, bool demote_, bool info_, bool settings_, bool pinned_, bool edit_, bool delete_)
  : flags_(flags_)
  , join_(join_)
  , leave_(leave_)
  , invite_(invite_)
  , ban_(ban_)
  , unban_(unban_)
  , kick_(kick_)
  , unkick_(unkick_)
  , promote_(promote_)
  , demote_(demote_)
  , info_(info_)
  , settings_(settings_)
  , pinned_(pinned_)
  , edit_(edit_)
  , delete_(delete_)
{}

const std::int32_t channelAdminLogEventsFilter::ID;

void channelAdminLogEventsFilter::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(join_, s); }
  if (var0 & 2) { TlStoreTrue::store(leave_, s); }
  if (var0 & 4) { TlStoreTrue::store(invite_, s); }
  if (var0 & 8) { TlStoreTrue::store(ban_, s); }
  if (var0 & 16) { TlStoreTrue::store(unban_, s); }
  if (var0 & 32) { TlStoreTrue::store(kick_, s); }
  if (var0 & 64) { TlStoreTrue::store(unkick_, s); }
  if (var0 & 128) { TlStoreTrue::store(promote_, s); }
  if (var0 & 256) { TlStoreTrue::store(demote_, s); }
  if (var0 & 512) { TlStoreTrue::store(info_, s); }
  if (var0 & 1024) { TlStoreTrue::store(settings_, s); }
  if (var0 & 2048) { TlStoreTrue::store(pinned_, s); }
  if (var0 & 4096) { TlStoreTrue::store(edit_, s); }
  if (var0 & 8192) { TlStoreTrue::store(delete_, s); }
}

void channelAdminLogEventsFilter::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(join_, s); }
  if (var0 & 2) { TlStoreTrue::store(leave_, s); }
  if (var0 & 4) { TlStoreTrue::store(invite_, s); }
  if (var0 & 8) { TlStoreTrue::store(ban_, s); }
  if (var0 & 16) { TlStoreTrue::store(unban_, s); }
  if (var0 & 32) { TlStoreTrue::store(kick_, s); }
  if (var0 & 64) { TlStoreTrue::store(unkick_, s); }
  if (var0 & 128) { TlStoreTrue::store(promote_, s); }
  if (var0 & 256) { TlStoreTrue::store(demote_, s); }
  if (var0 & 512) { TlStoreTrue::store(info_, s); }
  if (var0 & 1024) { TlStoreTrue::store(settings_, s); }
  if (var0 & 2048) { TlStoreTrue::store(pinned_, s); }
  if (var0 & 4096) { TlStoreTrue::store(edit_, s); }
  if (var0 & 8192) { TlStoreTrue::store(delete_, s); }
}

void channelAdminLogEventsFilter::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminLogEventsFilter");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    if (var0 & 256) {  }
    if (var0 & 512) {  }
    if (var0 & 1024) {  }
    if (var0 & 2048) {  }
    if (var0 & 4096) {  }
    if (var0 & 8192) {  }
    s.store_class_end();
  }
}

channelAdminRights::channelAdminRights()
  : flags_()
  , change_info_()
  , post_messages_()
  , edit_messages_()
  , delete_messages_()
  , ban_users_()
  , invite_users_()
  , invite_link_()
  , pin_messages_()
  , add_admins_()
{}

channelAdminRights::channelAdminRights(std::int32_t flags_, bool change_info_, bool post_messages_, bool edit_messages_, bool delete_messages_, bool ban_users_, bool invite_users_, bool invite_link_, bool pin_messages_, bool add_admins_)
  : flags_(flags_)
  , change_info_(change_info_)
  , post_messages_(post_messages_)
  , edit_messages_(edit_messages_)
  , delete_messages_(delete_messages_)
  , ban_users_(ban_users_)
  , invite_users_(invite_users_)
  , invite_link_(invite_link_)
  , pin_messages_(pin_messages_)
  , add_admins_(add_admins_)
{}

const std::int32_t channelAdminRights::ID;

object_ptr<channelAdminRights> channelAdminRights::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<channelAdminRights> res = make_tl_object<channelAdminRights>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->change_info_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->post_messages_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->edit_messages_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->delete_messages_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->ban_users_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->invite_users_ = TlFetchTrue::parse(p); }
  if (var0 & 64) { res->invite_link_ = TlFetchTrue::parse(p); }
  if (var0 & 128) { res->pin_messages_ = TlFetchTrue::parse(p); }
  if (var0 & 512) { res->add_admins_ = TlFetchTrue::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void channelAdminRights::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(change_info_, s); }
  if (var0 & 2) { TlStoreTrue::store(post_messages_, s); }
  if (var0 & 4) { TlStoreTrue::store(edit_messages_, s); }
  if (var0 & 8) { TlStoreTrue::store(delete_messages_, s); }
  if (var0 & 16) { TlStoreTrue::store(ban_users_, s); }
  if (var0 & 32) { TlStoreTrue::store(invite_users_, s); }
  if (var0 & 64) { TlStoreTrue::store(invite_link_, s); }
  if (var0 & 128) { TlStoreTrue::store(pin_messages_, s); }
  if (var0 & 512) { TlStoreTrue::store(add_admins_, s); }
}

void channelAdminRights::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(change_info_, s); }
  if (var0 & 2) { TlStoreTrue::store(post_messages_, s); }
  if (var0 & 4) { TlStoreTrue::store(edit_messages_, s); }
  if (var0 & 8) { TlStoreTrue::store(delete_messages_, s); }
  if (var0 & 16) { TlStoreTrue::store(ban_users_, s); }
  if (var0 & 32) { TlStoreTrue::store(invite_users_, s); }
  if (var0 & 64) { TlStoreTrue::store(invite_link_, s); }
  if (var0 & 128) { TlStoreTrue::store(pin_messages_, s); }
  if (var0 & 512) { TlStoreTrue::store(add_admins_, s); }
}

void channelAdminRights::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelAdminRights");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    if (var0 & 512) {  }
    s.store_class_end();
  }
}

channelBannedRights::channelBannedRights()
  : flags_()
  , view_messages_()
  , send_messages_()
  , send_media_()
  , send_stickers_()
  , send_gifs_()
  , send_games_()
  , send_inline_()
  , embed_links_()
  , until_date_()
{}

channelBannedRights::channelBannedRights(std::int32_t flags_, bool view_messages_, bool send_messages_, bool send_media_, bool send_stickers_, bool send_gifs_, bool send_games_, bool send_inline_, bool embed_links_, std::int32_t until_date_)
  : flags_(flags_)
  , view_messages_(view_messages_)
  , send_messages_(send_messages_)
  , send_media_(send_media_)
  , send_stickers_(send_stickers_)
  , send_gifs_(send_gifs_)
  , send_games_(send_games_)
  , send_inline_(send_inline_)
  , embed_links_(embed_links_)
  , until_date_(until_date_)
{}

const std::int32_t channelBannedRights::ID;

object_ptr<channelBannedRights> channelBannedRights::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<channelBannedRights> res = make_tl_object<channelBannedRights>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->view_messages_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->send_messages_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->send_media_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->send_stickers_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->send_gifs_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->send_games_ = TlFetchTrue::parse(p); }
  if (var0 & 64) { res->send_inline_ = TlFetchTrue::parse(p); }
  if (var0 & 128) { res->embed_links_ = TlFetchTrue::parse(p); }
  res->until_date_ = TlFetchInt::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void channelBannedRights::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(view_messages_, s); }
  if (var0 & 2) { TlStoreTrue::store(send_messages_, s); }
  if (var0 & 4) { TlStoreTrue::store(send_media_, s); }
  if (var0 & 8) { TlStoreTrue::store(send_stickers_, s); }
  if (var0 & 16) { TlStoreTrue::store(send_gifs_, s); }
  if (var0 & 32) { TlStoreTrue::store(send_games_, s); }
  if (var0 & 64) { TlStoreTrue::store(send_inline_, s); }
  if (var0 & 128) { TlStoreTrue::store(embed_links_, s); }
  TlStoreBinary::store(until_date_, s);
}

void channelBannedRights::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(view_messages_, s); }
  if (var0 & 2) { TlStoreTrue::store(send_messages_, s); }
  if (var0 & 4) { TlStoreTrue::store(send_media_, s); }
  if (var0 & 8) { TlStoreTrue::store(send_stickers_, s); }
  if (var0 & 16) { TlStoreTrue::store(send_gifs_, s); }
  if (var0 & 32) { TlStoreTrue::store(send_games_, s); }
  if (var0 & 64) { TlStoreTrue::store(send_inline_, s); }
  if (var0 & 128) { TlStoreTrue::store(embed_links_, s); }
  TlStoreBinary::store(until_date_, s);
}

void channelBannedRights::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelBannedRights");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    s.store_field("until_date", until_date_);
    s.store_class_end();
  }
}

channelMessagesFilterEmpty::channelMessagesFilterEmpty() {
}

const std::int32_t channelMessagesFilterEmpty::ID;

void channelMessagesFilterEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void channelMessagesFilterEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void channelMessagesFilterEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelMessagesFilterEmpty");
    s.store_class_end();
  }
}

channelMessagesFilter::channelMessagesFilter()
  : flags_()
  , exclude_new_messages_()
  , ranges_()
{}

channelMessagesFilter::channelMessagesFilter(std::int32_t flags_, bool exclude_new_messages_, std::vector<object_ptr<messageRange>> &&ranges_)
  : flags_(flags_)
  , exclude_new_messages_(exclude_new_messages_)
  , ranges_(std::move(ranges_))
{}

const std::int32_t channelMessagesFilter::ID;

void channelMessagesFilter::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(exclude_new_messages_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 182649427>>, 481674261>::store(ranges_, s);
}

void channelMessagesFilter::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(exclude_new_messages_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 182649427>>, 481674261>::store(ranges_, s);
}

void channelMessagesFilter::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelMessagesFilter");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    { const std::vector<object_ptr<messageRange>> &v = ranges_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("ranges", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<ChannelParticipant> ChannelParticipant::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case channelParticipant::ID:
      return channelParticipant::fetch(p);
    case channelParticipantSelf::ID:
      return channelParticipantSelf::fetch(p);
    case channelParticipantCreator::ID:
      return channelParticipantCreator::fetch(p);
    case channelParticipantAdmin::ID:
      return channelParticipantAdmin::fetch(p);
    case channelParticipantBanned::ID:
      return channelParticipantBanned::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

channelParticipant::channelParticipant()
  : user_id_()
  , date_()
{}

channelParticipant::channelParticipant(std::int32_t user_id_, std::int32_t date_)
  : user_id_(user_id_)
  , date_(date_)
{}

const std::int32_t channelParticipant::ID;

channelParticipant::channelParticipant(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void channelParticipant::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipant");
    s.store_field("user_id", user_id_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

channelParticipantSelf::channelParticipantSelf()
  : user_id_()
  , inviter_id_()
  , date_()
{}

channelParticipantSelf::channelParticipantSelf(std::int32_t user_id_, std::int32_t inviter_id_, std::int32_t date_)
  : user_id_(user_id_)
  , inviter_id_(inviter_id_)
  , date_(date_)
{}

const std::int32_t channelParticipantSelf::ID;

channelParticipantSelf::channelParticipantSelf(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , inviter_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void channelParticipantSelf::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantSelf");
    s.store_field("user_id", user_id_);
    s.store_field("inviter_id", inviter_id_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

channelParticipantCreator::channelParticipantCreator()
  : user_id_()
{}

channelParticipantCreator::channelParticipantCreator(std::int32_t user_id_)
  : user_id_(user_id_)
{}

const std::int32_t channelParticipantCreator::ID;

channelParticipantCreator::channelParticipantCreator(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void channelParticipantCreator::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantCreator");
    s.store_field("user_id", user_id_);
    s.store_class_end();
  }
}

channelParticipantAdmin::channelParticipantAdmin()
  : flags_()
  , can_edit_()
  , user_id_()
  , inviter_id_()
  , promoted_by_()
  , date_()
  , admin_rights_()
{}

channelParticipantAdmin::channelParticipantAdmin(std::int32_t flags_, bool can_edit_, std::int32_t user_id_, std::int32_t inviter_id_, std::int32_t promoted_by_, std::int32_t date_, object_ptr<channelAdminRights> &&admin_rights_)
  : flags_(flags_)
  , can_edit_(can_edit_)
  , user_id_(user_id_)
  , inviter_id_(inviter_id_)
  , promoted_by_(promoted_by_)
  , date_(date_)
  , admin_rights_(std::move(admin_rights_))
{}

const std::int32_t channelParticipantAdmin::ID;

object_ptr<channelParticipantAdmin> channelParticipantAdmin::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<channelParticipantAdmin> res = make_tl_object<channelParticipantAdmin>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->can_edit_ = TlFetchTrue::parse(p); }
  res->user_id_ = TlFetchInt::parse(p);
  res->inviter_id_ = TlFetchInt::parse(p);
  res->promoted_by_ = TlFetchInt::parse(p);
  res->date_ = TlFetchInt::parse(p);
  res->admin_rights_ = TlFetchBoxed<TlFetchObject<channelAdminRights>, 1568467877>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void channelParticipantAdmin::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantAdmin");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("user_id", user_id_);
    s.store_field("inviter_id", inviter_id_);
    s.store_field("promoted_by", promoted_by_);
    s.store_field("date", date_);
    if (admin_rights_ == nullptr) { s.store_field("admin_rights", "null"); } else { admin_rights_->store(s, "admin_rights"); }
    s.store_class_end();
  }
}

channelParticipantBanned::channelParticipantBanned()
  : flags_()
  , left_()
  , user_id_()
  , kicked_by_()
  , date_()
  , banned_rights_()
{}

channelParticipantBanned::channelParticipantBanned(std::int32_t flags_, bool left_, std::int32_t user_id_, std::int32_t kicked_by_, std::int32_t date_, object_ptr<channelBannedRights> &&banned_rights_)
  : flags_(flags_)
  , left_(left_)
  , user_id_(user_id_)
  , kicked_by_(kicked_by_)
  , date_(date_)
  , banned_rights_(std::move(banned_rights_))
{}

const std::int32_t channelParticipantBanned::ID;

object_ptr<channelParticipantBanned> channelParticipantBanned::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<channelParticipantBanned> res = make_tl_object<channelParticipantBanned>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->left_ = TlFetchTrue::parse(p); }
  res->user_id_ = TlFetchInt::parse(p);
  res->kicked_by_ = TlFetchInt::parse(p);
  res->date_ = TlFetchInt::parse(p);
  res->banned_rights_ = TlFetchBoxed<TlFetchObject<channelBannedRights>, 1489977929>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void channelParticipantBanned::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantBanned");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("user_id", user_id_);
    s.store_field("kicked_by", kicked_by_);
    s.store_field("date", date_);
    if (banned_rights_ == nullptr) { s.store_field("banned_rights", "null"); } else { banned_rights_->store(s, "banned_rights"); }
    s.store_class_end();
  }
}

channelParticipantsRecent::channelParticipantsRecent() {
}

const std::int32_t channelParticipantsRecent::ID;

void channelParticipantsRecent::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void channelParticipantsRecent::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void channelParticipantsRecent::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantsRecent");
    s.store_class_end();
  }
}

channelParticipantsAdmins::channelParticipantsAdmins() {
}

const std::int32_t channelParticipantsAdmins::ID;

void channelParticipantsAdmins::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void channelParticipantsAdmins::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void channelParticipantsAdmins::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantsAdmins");
    s.store_class_end();
  }
}

channelParticipantsKicked::channelParticipantsKicked()
  : q_()
{}

channelParticipantsKicked::channelParticipantsKicked(std::string const &q_)
  : q_(q_)
{}

const std::int32_t channelParticipantsKicked::ID;

void channelParticipantsKicked::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(q_, s);
}

void channelParticipantsKicked::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(q_, s);
}

void channelParticipantsKicked::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantsKicked");
    s.store_field("q", q_);
    s.store_class_end();
  }
}

channelParticipantsBots::channelParticipantsBots() {
}

const std::int32_t channelParticipantsBots::ID;

void channelParticipantsBots::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void channelParticipantsBots::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void channelParticipantsBots::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantsBots");
    s.store_class_end();
  }
}

channelParticipantsBanned::channelParticipantsBanned()
  : q_()
{}

channelParticipantsBanned::channelParticipantsBanned(std::string const &q_)
  : q_(q_)
{}

const std::int32_t channelParticipantsBanned::ID;

void channelParticipantsBanned::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(q_, s);
}

void channelParticipantsBanned::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(q_, s);
}

void channelParticipantsBanned::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantsBanned");
    s.store_field("q", q_);
    s.store_class_end();
  }
}

channelParticipantsSearch::channelParticipantsSearch()
  : q_()
{}

channelParticipantsSearch::channelParticipantsSearch(std::string const &q_)
  : q_(q_)
{}

const std::int32_t channelParticipantsSearch::ID;

void channelParticipantsSearch::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(q_, s);
}

void channelParticipantsSearch::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(q_, s);
}

void channelParticipantsSearch::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelParticipantsSearch");
    s.store_field("q", q_);
    s.store_class_end();
  }
}

object_ptr<Chat> Chat::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case chatEmpty::ID:
      return chatEmpty::fetch(p);
    case chat::ID:
      return chat::fetch(p);
    case chatForbidden::ID:
      return chatForbidden::fetch(p);
    case channel::ID:
      return channel::fetch(p);
    case channelForbidden::ID:
      return channelForbidden::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

chatEmpty::chatEmpty()
  : id_()
{}

chatEmpty::chatEmpty(std::int32_t id_)
  : id_(id_)
{}

const std::int32_t chatEmpty::ID;

chatEmpty::chatEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
#undef FAIL
{}

void chatEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatEmpty");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

chat::chat()
  : flags_()
  , creator_()
  , kicked_()
  , left_()
  , admins_enabled_()
  , admin_()
  , deactivated_()
  , id_()
  , title_()
  , photo_()
  , participants_count_()
  , date_()
  , version_()
  , migrated_to_()
{}

chat::chat(std::int32_t flags_, bool creator_, bool kicked_, bool left_, bool admins_enabled_, bool admin_, bool deactivated_, std::int32_t id_, std::string const &title_, object_ptr<ChatPhoto> &&photo_, std::int32_t participants_count_, std::int32_t date_, std::int32_t version_, object_ptr<InputChannel> &&migrated_to_)
  : flags_(flags_)
  , creator_(creator_)
  , kicked_(kicked_)
  , left_(left_)
  , admins_enabled_(admins_enabled_)
  , admin_(admin_)
  , deactivated_(deactivated_)
  , id_(id_)
  , title_(title_)
  , photo_(std::move(photo_))
  , participants_count_(participants_count_)
  , date_(date_)
  , version_(version_)
  , migrated_to_(std::move(migrated_to_))
{}

const std::int32_t chat::ID;

object_ptr<chat> chat::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<chat> res = make_tl_object<chat>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->creator_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->kicked_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->left_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->admins_enabled_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->admin_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->deactivated_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  res->title_ = TlFetchString<std::string>::parse(p);
  res->photo_ = TlFetchObject<ChatPhoto>::parse(p);
  res->participants_count_ = TlFetchInt::parse(p);
  res->date_ = TlFetchInt::parse(p);
  res->version_ = TlFetchInt::parse(p);
  if (var0 & 64) { res->migrated_to_ = TlFetchObject<InputChannel>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void chat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chat");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    s.store_field("id", id_);
    s.store_field("title", title_);
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    s.store_field("participants_count", participants_count_);
    s.store_field("date", date_);
    s.store_field("version", version_);
    if (var0 & 64) { if (migrated_to_ == nullptr) { s.store_field("migrated_to", "null"); } else { migrated_to_->store(s, "migrated_to"); } }
    s.store_class_end();
  }
}

chatForbidden::chatForbidden()
  : id_()
  , title_()
{}

chatForbidden::chatForbidden(std::int32_t id_, std::string const &title_)
  : id_(id_)
  , title_(title_)
{}

const std::int32_t chatForbidden::ID;

chatForbidden::chatForbidden(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , title_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void chatForbidden::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatForbidden");
    s.store_field("id", id_);
    s.store_field("title", title_);
    s.store_class_end();
  }
}

channel::channel()
  : flags_()
  , creator_()
  , left_()
  , editor_()
  , broadcast_()
  , verified_()
  , megagroup_()
  , restricted_()
  , democracy_()
  , signatures_()
  , min_()
  , id_()
  , access_hash_()
  , title_()
  , username_()
  , photo_()
  , date_()
  , version_()
  , restriction_reason_()
  , admin_rights_()
  , banned_rights_()
  , participants_count_()
{}

channel::channel(std::int32_t flags_, bool creator_, bool left_, bool editor_, bool broadcast_, bool verified_, bool megagroup_, bool restricted_, bool democracy_, bool signatures_, bool min_, std::int32_t id_, std::int64_t access_hash_, std::string const &title_, std::string const &username_, object_ptr<ChatPhoto> &&photo_, std::int32_t date_, std::int32_t version_, std::string const &restriction_reason_, object_ptr<channelAdminRights> &&admin_rights_, object_ptr<channelBannedRights> &&banned_rights_, std::int32_t participants_count_)
  : flags_(flags_)
  , creator_(creator_)
  , left_(left_)
  , editor_(editor_)
  , broadcast_(broadcast_)
  , verified_(verified_)
  , megagroup_(megagroup_)
  , restricted_(restricted_)
  , democracy_(democracy_)
  , signatures_(signatures_)
  , min_(min_)
  , id_(id_)
  , access_hash_(access_hash_)
  , title_(title_)
  , username_(username_)
  , photo_(std::move(photo_))
  , date_(date_)
  , version_(version_)
  , restriction_reason_(restriction_reason_)
  , admin_rights_(std::move(admin_rights_))
  , banned_rights_(std::move(banned_rights_))
  , participants_count_(participants_count_)
{}

const std::int32_t channel::ID;

object_ptr<channel> channel::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<channel> res = make_tl_object<channel>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->creator_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->left_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->editor_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->broadcast_ = TlFetchTrue::parse(p); }
  if (var0 & 128) { res->verified_ = TlFetchTrue::parse(p); }
  if (var0 & 256) { res->megagroup_ = TlFetchTrue::parse(p); }
  if (var0 & 512) { res->restricted_ = TlFetchTrue::parse(p); }
  if (var0 & 1024) { res->democracy_ = TlFetchTrue::parse(p); }
  if (var0 & 2048) { res->signatures_ = TlFetchTrue::parse(p); }
  if (var0 & 4096) { res->min_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  if (var0 & 8192) { res->access_hash_ = TlFetchLong::parse(p); }
  res->title_ = TlFetchString<std::string>::parse(p);
  if (var0 & 64) { res->username_ = TlFetchString<std::string>::parse(p); }
  res->photo_ = TlFetchObject<ChatPhoto>::parse(p);
  res->date_ = TlFetchInt::parse(p);
  res->version_ = TlFetchInt::parse(p);
  if (var0 & 512) { res->restriction_reason_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16384) { res->admin_rights_ = TlFetchBoxed<TlFetchObject<channelAdminRights>, 1568467877>::parse(p); }
  if (var0 & 32768) { res->banned_rights_ = TlFetchBoxed<TlFetchObject<channelBannedRights>, 1489977929>::parse(p); }
  if (var0 & 131072) { res->participants_count_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void channel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channel");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 32) {  }
    if (var0 & 128) {  }
    if (var0 & 256) {  }
    if (var0 & 512) {  }
    if (var0 & 1024) {  }
    if (var0 & 2048) {  }
    if (var0 & 4096) {  }
    s.store_field("id", id_);
    if (var0 & 8192) { s.store_field("access_hash", access_hash_); }
    s.store_field("title", title_);
    if (var0 & 64) { s.store_field("username", username_); }
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    s.store_field("date", date_);
    s.store_field("version", version_);
    if (var0 & 512) { s.store_field("restriction_reason", restriction_reason_); }
    if (var0 & 16384) { if (admin_rights_ == nullptr) { s.store_field("admin_rights", "null"); } else { admin_rights_->store(s, "admin_rights"); } }
    if (var0 & 32768) { if (banned_rights_ == nullptr) { s.store_field("banned_rights", "null"); } else { banned_rights_->store(s, "banned_rights"); } }
    if (var0 & 131072) { s.store_field("participants_count", participants_count_); }
    s.store_class_end();
  }
}

channelForbidden::channelForbidden()
  : flags_()
  , broadcast_()
  , megagroup_()
  , id_()
  , access_hash_()
  , title_()
  , until_date_()
{}

channelForbidden::channelForbidden(std::int32_t flags_, bool broadcast_, bool megagroup_, std::int32_t id_, std::int64_t access_hash_, std::string const &title_, std::int32_t until_date_)
  : flags_(flags_)
  , broadcast_(broadcast_)
  , megagroup_(megagroup_)
  , id_(id_)
  , access_hash_(access_hash_)
  , title_(title_)
  , until_date_(until_date_)
{}

const std::int32_t channelForbidden::ID;

object_ptr<channelForbidden> channelForbidden::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<channelForbidden> res = make_tl_object<channelForbidden>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 32) { res->broadcast_ = TlFetchTrue::parse(p); }
  if (var0 & 256) { res->megagroup_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  res->access_hash_ = TlFetchLong::parse(p);
  res->title_ = TlFetchString<std::string>::parse(p);
  if (var0 & 65536) { res->until_date_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void channelForbidden::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelForbidden");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 32) {  }
    if (var0 & 256) {  }
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("title", title_);
    if (var0 & 65536) { s.store_field("until_date", until_date_); }
    s.store_class_end();
  }
}

object_ptr<ChatFull> ChatFull::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case chatFull::ID:
      return chatFull::fetch(p);
    case channelFull::ID:
      return channelFull::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

chatFull::chatFull()
  : id_()
  , participants_()
  , chat_photo_()
  , notify_settings_()
  , exported_invite_()
  , bot_info_()
{}

chatFull::chatFull(std::int32_t id_, object_ptr<ChatParticipants> &&participants_, object_ptr<Photo> &&chat_photo_, object_ptr<peerNotifySettings> &&notify_settings_, object_ptr<ExportedChatInvite> &&exported_invite_, std::vector<object_ptr<botInfo>> &&bot_info_)
  : id_(id_)
  , participants_(std::move(participants_))
  , chat_photo_(std::move(chat_photo_))
  , notify_settings_(std::move(notify_settings_))
  , exported_invite_(std::move(exported_invite_))
  , bot_info_(std::move(bot_info_))
{}

const std::int32_t chatFull::ID;

chatFull::chatFull(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , participants_(TlFetchObject<ChatParticipants>::parse(p))
  , chat_photo_(TlFetchObject<Photo>::parse(p))
  , notify_settings_(TlFetchBoxed<TlFetchObject<peerNotifySettings>, -1353671392>::parse(p))
  , exported_invite_(TlFetchObject<ExportedChatInvite>::parse(p))
  , bot_info_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<botInfo>, -1729618630>>, 481674261>::parse(p))
#undef FAIL
{}

void chatFull::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatFull");
    s.store_field("id", id_);
    if (participants_ == nullptr) { s.store_field("participants", "null"); } else { participants_->store(s, "participants"); }
    if (chat_photo_ == nullptr) { s.store_field("chat_photo", "null"); } else { chat_photo_->store(s, "chat_photo"); }
    if (notify_settings_ == nullptr) { s.store_field("notify_settings", "null"); } else { notify_settings_->store(s, "notify_settings"); }
    if (exported_invite_ == nullptr) { s.store_field("exported_invite", "null"); } else { exported_invite_->store(s, "exported_invite"); }
    { const std::vector<object_ptr<botInfo>> &v = bot_info_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("bot_info", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

channelFull::channelFull()
  : flags_()
  , can_view_participants_()
  , can_set_username_()
  , can_set_stickers_()
  , hidden_prehistory_()
  , id_()
  , about_()
  , participants_count_()
  , admins_count_()
  , kicked_count_()
  , banned_count_()
  , read_inbox_max_id_()
  , read_outbox_max_id_()
  , unread_count_()
  , chat_photo_()
  , notify_settings_()
  , exported_invite_()
  , bot_info_()
  , migrated_from_chat_id_()
  , migrated_from_max_id_()
  , pinned_msg_id_()
  , stickerset_()
  , available_min_id_()
{}

channelFull::channelFull(std::int32_t flags_, bool can_view_participants_, bool can_set_username_, bool can_set_stickers_, bool hidden_prehistory_, std::int32_t id_, std::string const &about_, std::int32_t participants_count_, std::int32_t admins_count_, std::int32_t kicked_count_, std::int32_t banned_count_, std::int32_t read_inbox_max_id_, std::int32_t read_outbox_max_id_, std::int32_t unread_count_, object_ptr<Photo> &&chat_photo_, object_ptr<peerNotifySettings> &&notify_settings_, object_ptr<ExportedChatInvite> &&exported_invite_, std::vector<object_ptr<botInfo>> &&bot_info_, std::int32_t migrated_from_chat_id_, std::int32_t migrated_from_max_id_, std::int32_t pinned_msg_id_, object_ptr<stickerSet> &&stickerset_, std::int32_t available_min_id_)
  : flags_(flags_)
  , can_view_participants_(can_view_participants_)
  , can_set_username_(can_set_username_)
  , can_set_stickers_(can_set_stickers_)
  , hidden_prehistory_(hidden_prehistory_)
  , id_(id_)
  , about_(about_)
  , participants_count_(participants_count_)
  , admins_count_(admins_count_)
  , kicked_count_(kicked_count_)
  , banned_count_(banned_count_)
  , read_inbox_max_id_(read_inbox_max_id_)
  , read_outbox_max_id_(read_outbox_max_id_)
  , unread_count_(unread_count_)
  , chat_photo_(std::move(chat_photo_))
  , notify_settings_(std::move(notify_settings_))
  , exported_invite_(std::move(exported_invite_))
  , bot_info_(std::move(bot_info_))
  , migrated_from_chat_id_(migrated_from_chat_id_)
  , migrated_from_max_id_(migrated_from_max_id_)
  , pinned_msg_id_(pinned_msg_id_)
  , stickerset_(std::move(stickerset_))
  , available_min_id_(available_min_id_)
{}

const std::int32_t channelFull::ID;

object_ptr<channelFull> channelFull::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<channelFull> res = make_tl_object<channelFull>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 8) { res->can_view_participants_ = TlFetchTrue::parse(p); }
  if (var0 & 64) { res->can_set_username_ = TlFetchTrue::parse(p); }
  if (var0 & 128) { res->can_set_stickers_ = TlFetchTrue::parse(p); }
  if (var0 & 1024) { res->hidden_prehistory_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  res->about_ = TlFetchString<std::string>::parse(p);
  if (var0 & 1) { res->participants_count_ = TlFetchInt::parse(p); }
  if (var0 & 2) { res->admins_count_ = TlFetchInt::parse(p); }
  if (var0 & 4) { res->kicked_count_ = TlFetchInt::parse(p); }
  if (var0 & 4) { res->banned_count_ = TlFetchInt::parse(p); }
  res->read_inbox_max_id_ = TlFetchInt::parse(p);
  res->read_outbox_max_id_ = TlFetchInt::parse(p);
  res->unread_count_ = TlFetchInt::parse(p);
  res->chat_photo_ = TlFetchObject<Photo>::parse(p);
  res->notify_settings_ = TlFetchBoxed<TlFetchObject<peerNotifySettings>, -1353671392>::parse(p);
  res->exported_invite_ = TlFetchObject<ExportedChatInvite>::parse(p);
  res->bot_info_ = TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<botInfo>, -1729618630>>, 481674261>::parse(p);
  if (var0 & 16) { res->migrated_from_chat_id_ = TlFetchInt::parse(p); }
  if (var0 & 16) { res->migrated_from_max_id_ = TlFetchInt::parse(p); }
  if (var0 & 32) { res->pinned_msg_id_ = TlFetchInt::parse(p); }
  if (var0 & 256) { res->stickerset_ = TlFetchBoxed<TlFetchObject<stickerSet>, 1434820921>::parse(p); }
  if (var0 & 512) { res->available_min_id_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void channelFull::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channelFull");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 8) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    if (var0 & 1024) {  }
    s.store_field("id", id_);
    s.store_field("about", about_);
    if (var0 & 1) { s.store_field("participants_count", participants_count_); }
    if (var0 & 2) { s.store_field("admins_count", admins_count_); }
    if (var0 & 4) { s.store_field("kicked_count", kicked_count_); }
    if (var0 & 4) { s.store_field("banned_count", banned_count_); }
    s.store_field("read_inbox_max_id", read_inbox_max_id_);
    s.store_field("read_outbox_max_id", read_outbox_max_id_);
    s.store_field("unread_count", unread_count_);
    if (chat_photo_ == nullptr) { s.store_field("chat_photo", "null"); } else { chat_photo_->store(s, "chat_photo"); }
    if (notify_settings_ == nullptr) { s.store_field("notify_settings", "null"); } else { notify_settings_->store(s, "notify_settings"); }
    if (exported_invite_ == nullptr) { s.store_field("exported_invite", "null"); } else { exported_invite_->store(s, "exported_invite"); }
    { const std::vector<object_ptr<botInfo>> &v = bot_info_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("bot_info", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (var0 & 16) { s.store_field("migrated_from_chat_id", migrated_from_chat_id_); }
    if (var0 & 16) { s.store_field("migrated_from_max_id", migrated_from_max_id_); }
    if (var0 & 32) { s.store_field("pinned_msg_id", pinned_msg_id_); }
    if (var0 & 256) { if (stickerset_ == nullptr) { s.store_field("stickerset", "null"); } else { stickerset_->store(s, "stickerset"); } }
    if (var0 & 512) { s.store_field("available_min_id", available_min_id_); }
    s.store_class_end();
  }
}

object_ptr<ChatInvite> ChatInvite::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case chatInviteAlready::ID:
      return chatInviteAlready::fetch(p);
    case chatInvite::ID:
      return chatInvite::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

chatInviteAlready::chatInviteAlready()
  : chat_()
{}

chatInviteAlready::chatInviteAlready(object_ptr<Chat> &&chat_)
  : chat_(std::move(chat_))
{}

const std::int32_t chatInviteAlready::ID;

chatInviteAlready::chatInviteAlready(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_(TlFetchObject<Chat>::parse(p))
#undef FAIL
{}

void chatInviteAlready::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatInviteAlready");
    if (chat_ == nullptr) { s.store_field("chat", "null"); } else { chat_->store(s, "chat"); }
    s.store_class_end();
  }
}

chatInvite::chatInvite()
  : flags_()
  , channel_()
  , broadcast_()
  , public_()
  , megagroup_()
  , title_()
  , photo_()
  , participants_count_()
  , participants_()
{}

chatInvite::chatInvite(std::int32_t flags_, bool channel_, bool broadcast_, bool public_, bool megagroup_, std::string const &title_, object_ptr<ChatPhoto> &&photo_, std::int32_t participants_count_, std::vector<object_ptr<User>> &&participants_)
  : flags_(flags_)
  , channel_(channel_)
  , broadcast_(broadcast_)
  , public_(public_)
  , megagroup_(megagroup_)
  , title_(title_)
  , photo_(std::move(photo_))
  , participants_count_(participants_count_)
  , participants_(std::move(participants_))
{}

const std::int32_t chatInvite::ID;

object_ptr<chatInvite> chatInvite::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<chatInvite> res = make_tl_object<chatInvite>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->channel_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->broadcast_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->public_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->megagroup_ = TlFetchTrue::parse(p); }
  res->title_ = TlFetchString<std::string>::parse(p);
  res->photo_ = TlFetchObject<ChatPhoto>::parse(p);
  res->participants_count_ = TlFetchInt::parse(p);
  if (var0 & 16) { res->participants_ = TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void chatInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatInvite");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    s.store_field("title", title_);
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    s.store_field("participants_count", participants_count_);
    if (var0 & 16) { { const std::vector<object_ptr<User>> &v = participants_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("participants", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

object_ptr<ChatParticipant> ChatParticipant::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case chatParticipant::ID:
      return chatParticipant::fetch(p);
    case chatParticipantCreator::ID:
      return chatParticipantCreator::fetch(p);
    case chatParticipantAdmin::ID:
      return chatParticipantAdmin::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

chatParticipant::chatParticipant()
  : user_id_()
  , inviter_id_()
  , date_()
{}

chatParticipant::chatParticipant(std::int32_t user_id_, std::int32_t inviter_id_, std::int32_t date_)
  : user_id_(user_id_)
  , inviter_id_(inviter_id_)
  , date_(date_)
{}

const std::int32_t chatParticipant::ID;

chatParticipant::chatParticipant(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , inviter_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void chatParticipant::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatParticipant");
    s.store_field("user_id", user_id_);
    s.store_field("inviter_id", inviter_id_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

chatParticipantCreator::chatParticipantCreator()
  : user_id_()
{}

chatParticipantCreator::chatParticipantCreator(std::int32_t user_id_)
  : user_id_(user_id_)
{}

const std::int32_t chatParticipantCreator::ID;

chatParticipantCreator::chatParticipantCreator(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void chatParticipantCreator::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatParticipantCreator");
    s.store_field("user_id", user_id_);
    s.store_class_end();
  }
}

chatParticipantAdmin::chatParticipantAdmin()
  : user_id_()
  , inviter_id_()
  , date_()
{}

chatParticipantAdmin::chatParticipantAdmin(std::int32_t user_id_, std::int32_t inviter_id_, std::int32_t date_)
  : user_id_(user_id_)
  , inviter_id_(inviter_id_)
  , date_(date_)
{}

const std::int32_t chatParticipantAdmin::ID;

chatParticipantAdmin::chatParticipantAdmin(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , inviter_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void chatParticipantAdmin::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatParticipantAdmin");
    s.store_field("user_id", user_id_);
    s.store_field("inviter_id", inviter_id_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

object_ptr<ChatParticipants> ChatParticipants::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case chatParticipantsForbidden::ID:
      return chatParticipantsForbidden::fetch(p);
    case chatParticipants::ID:
      return chatParticipants::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

chatParticipantsForbidden::chatParticipantsForbidden()
  : flags_()
  , chat_id_()
  , self_participant_()
{}

chatParticipantsForbidden::chatParticipantsForbidden(std::int32_t flags_, std::int32_t chat_id_, object_ptr<ChatParticipant> &&self_participant_)
  : flags_(flags_)
  , chat_id_(chat_id_)
  , self_participant_(std::move(self_participant_))
{}

const std::int32_t chatParticipantsForbidden::ID;

object_ptr<chatParticipantsForbidden> chatParticipantsForbidden::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<chatParticipantsForbidden> res = make_tl_object<chatParticipantsForbidden>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->chat_id_ = TlFetchInt::parse(p);
  if (var0 & 1) { res->self_participant_ = TlFetchObject<ChatParticipant>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void chatParticipantsForbidden::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatParticipantsForbidden");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("chat_id", chat_id_);
    if (var0 & 1) { if (self_participant_ == nullptr) { s.store_field("self_participant", "null"); } else { self_participant_->store(s, "self_participant"); } }
    s.store_class_end();
  }
}

chatParticipants::chatParticipants()
  : chat_id_()
  , participants_()
  , version_()
{}

chatParticipants::chatParticipants(std::int32_t chat_id_, std::vector<object_ptr<ChatParticipant>> &&participants_, std::int32_t version_)
  : chat_id_(chat_id_)
  , participants_(std::move(participants_))
  , version_(version_)
{}

const std::int32_t chatParticipants::ID;

chatParticipants::chatParticipants(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
  , participants_(TlFetchBoxed<TlFetchVector<TlFetchObject<ChatParticipant>>, 481674261>::parse(p))
  , version_(TlFetchInt::parse(p))
#undef FAIL
{}

void chatParticipants::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatParticipants");
    s.store_field("chat_id", chat_id_);
    { const std::vector<object_ptr<ChatParticipant>> &v = participants_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("participants", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("version", version_);
    s.store_class_end();
  }
}

object_ptr<ChatPhoto> ChatPhoto::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case chatPhotoEmpty::ID:
      return chatPhotoEmpty::fetch(p);
    case chatPhoto::ID:
      return chatPhoto::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

chatPhotoEmpty::chatPhotoEmpty() {
}

const std::int32_t chatPhotoEmpty::ID;

chatPhotoEmpty::chatPhotoEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void chatPhotoEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatPhotoEmpty");
    s.store_class_end();
  }
}

chatPhoto::chatPhoto()
  : photo_small_()
  , photo_big_()
{}

chatPhoto::chatPhoto(object_ptr<FileLocation> &&photo_small_, object_ptr<FileLocation> &&photo_big_)
  : photo_small_(std::move(photo_small_))
  , photo_big_(std::move(photo_big_))
{}

const std::int32_t chatPhoto::ID;

chatPhoto::chatPhoto(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : photo_small_(TlFetchObject<FileLocation>::parse(p))
  , photo_big_(TlFetchObject<FileLocation>::parse(p))
#undef FAIL
{}

void chatPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatPhoto");
    if (photo_small_ == nullptr) { s.store_field("photo_small", "null"); } else { photo_small_->store(s, "photo_small"); }
    if (photo_big_ == nullptr) { s.store_field("photo_big", "null"); } else { photo_big_->store(s, "photo_big"); }
    s.store_class_end();
  }
}

config::config()
  : flags_()
  , phonecalls_enabled_()
  , default_p2p_contacts_()
  , preload_featured_stickers_()
  , ignore_phone_entities_()
  , revoke_pm_inbox_()
  , blocked_mode_()
  , date_()
  , expires_()
  , test_mode_()
  , this_dc_()
  , dc_options_()
  , dc_txt_domain_name_()
  , chat_size_max_()
  , megagroup_size_max_()
  , forwarded_count_max_()
  , online_update_period_ms_()
  , offline_blur_timeout_ms_()
  , offline_idle_timeout_ms_()
  , online_cloud_timeout_ms_()
  , notify_cloud_delay_ms_()
  , notify_default_delay_ms_()
  , push_chat_period_ms_()
  , push_chat_limit_()
  , saved_gifs_limit_()
  , edit_time_limit_()
  , revoke_time_limit_()
  , revoke_pm_time_limit_()
  , rating_e_decay_()
  , stickers_recent_limit_()
  , stickers_faved_limit_()
  , channels_read_media_period_()
  , tmp_sessions_()
  , pinned_dialogs_count_max_()
  , call_receive_timeout_ms_()
  , call_ring_timeout_ms_()
  , call_connect_timeout_ms_()
  , call_packet_timeout_ms_()
  , me_url_prefix_()
  , autoupdate_url_prefix_()
  , gif_search_username_()
  , venue_search_username_()
  , img_search_username_()
  , static_maps_provider_()
  , caption_length_max_()
  , message_length_max_()
  , webfile_dc_id_()
  , suggested_lang_code_()
  , lang_pack_version_()
{}

config::config(std::int32_t flags_, bool phonecalls_enabled_, bool default_p2p_contacts_, bool preload_featured_stickers_, bool ignore_phone_entities_, bool revoke_pm_inbox_, bool blocked_mode_, std::int32_t date_, std::int32_t expires_, bool test_mode_, std::int32_t this_dc_, std::vector<object_ptr<dcOption>> &&dc_options_, std::string const &dc_txt_domain_name_, std::int32_t chat_size_max_, std::int32_t megagroup_size_max_, std::int32_t forwarded_count_max_, std::int32_t online_update_period_ms_, std::int32_t offline_blur_timeout_ms_, std::int32_t offline_idle_timeout_ms_, std::int32_t online_cloud_timeout_ms_, std::int32_t notify_cloud_delay_ms_, std::int32_t notify_default_delay_ms_, std::int32_t push_chat_period_ms_, std::int32_t push_chat_limit_, std::int32_t saved_gifs_limit_, std::int32_t edit_time_limit_, std::int32_t revoke_time_limit_, std::int32_t revoke_pm_time_limit_, std::int32_t rating_e_decay_, std::int32_t stickers_recent_limit_, std::int32_t stickers_faved_limit_, std::int32_t channels_read_media_period_, std::int32_t tmp_sessions_, std::int32_t pinned_dialogs_count_max_, std::int32_t call_receive_timeout_ms_, std::int32_t call_ring_timeout_ms_, std::int32_t call_connect_timeout_ms_, std::int32_t call_packet_timeout_ms_, std::string const &me_url_prefix_, std::string const &autoupdate_url_prefix_, std::string const &gif_search_username_, std::string const &venue_search_username_, std::string const &img_search_username_, std::string const &static_maps_provider_, std::int32_t caption_length_max_, std::int32_t message_length_max_, std::int32_t webfile_dc_id_, std::string const &suggested_lang_code_, std::int32_t lang_pack_version_)
  : flags_(flags_)
  , phonecalls_enabled_(phonecalls_enabled_)
  , default_p2p_contacts_(default_p2p_contacts_)
  , preload_featured_stickers_(preload_featured_stickers_)
  , ignore_phone_entities_(ignore_phone_entities_)
  , revoke_pm_inbox_(revoke_pm_inbox_)
  , blocked_mode_(blocked_mode_)
  , date_(date_)
  , expires_(expires_)
  , test_mode_(test_mode_)
  , this_dc_(this_dc_)
  , dc_options_(std::move(dc_options_))
  , dc_txt_domain_name_(dc_txt_domain_name_)
  , chat_size_max_(chat_size_max_)
  , megagroup_size_max_(megagroup_size_max_)
  , forwarded_count_max_(forwarded_count_max_)
  , online_update_period_ms_(online_update_period_ms_)
  , offline_blur_timeout_ms_(offline_blur_timeout_ms_)
  , offline_idle_timeout_ms_(offline_idle_timeout_ms_)
  , online_cloud_timeout_ms_(online_cloud_timeout_ms_)
  , notify_cloud_delay_ms_(notify_cloud_delay_ms_)
  , notify_default_delay_ms_(notify_default_delay_ms_)
  , push_chat_period_ms_(push_chat_period_ms_)
  , push_chat_limit_(push_chat_limit_)
  , saved_gifs_limit_(saved_gifs_limit_)
  , edit_time_limit_(edit_time_limit_)
  , revoke_time_limit_(revoke_time_limit_)
  , revoke_pm_time_limit_(revoke_pm_time_limit_)
  , rating_e_decay_(rating_e_decay_)
  , stickers_recent_limit_(stickers_recent_limit_)
  , stickers_faved_limit_(stickers_faved_limit_)
  , channels_read_media_period_(channels_read_media_period_)
  , tmp_sessions_(tmp_sessions_)
  , pinned_dialogs_count_max_(pinned_dialogs_count_max_)
  , call_receive_timeout_ms_(call_receive_timeout_ms_)
  , call_ring_timeout_ms_(call_ring_timeout_ms_)
  , call_connect_timeout_ms_(call_connect_timeout_ms_)
  , call_packet_timeout_ms_(call_packet_timeout_ms_)
  , me_url_prefix_(me_url_prefix_)
  , autoupdate_url_prefix_(autoupdate_url_prefix_)
  , gif_search_username_(gif_search_username_)
  , venue_search_username_(venue_search_username_)
  , img_search_username_(img_search_username_)
  , static_maps_provider_(static_maps_provider_)
  , caption_length_max_(caption_length_max_)
  , message_length_max_(message_length_max_)
  , webfile_dc_id_(webfile_dc_id_)
  , suggested_lang_code_(suggested_lang_code_)
  , lang_pack_version_(lang_pack_version_)
{}

const std::int32_t config::ID;

object_ptr<config> config::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<config> res = make_tl_object<config>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->phonecalls_enabled_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->default_p2p_contacts_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->preload_featured_stickers_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->ignore_phone_entities_ = TlFetchTrue::parse(p); }
  if (var0 & 64) { res->revoke_pm_inbox_ = TlFetchTrue::parse(p); }
  if (var0 & 256) { res->blocked_mode_ = TlFetchTrue::parse(p); }
  res->date_ = TlFetchInt::parse(p);
  res->expires_ = TlFetchInt::parse(p);
  res->test_mode_ = TlFetchBool::parse(p);
  res->this_dc_ = TlFetchInt::parse(p);
  res->dc_options_ = TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<dcOption>, 414687501>>, 481674261>::parse(p);
  res->dc_txt_domain_name_ = TlFetchString<std::string>::parse(p);
  res->chat_size_max_ = TlFetchInt::parse(p);
  res->megagroup_size_max_ = TlFetchInt::parse(p);
  res->forwarded_count_max_ = TlFetchInt::parse(p);
  res->online_update_period_ms_ = TlFetchInt::parse(p);
  res->offline_blur_timeout_ms_ = TlFetchInt::parse(p);
  res->offline_idle_timeout_ms_ = TlFetchInt::parse(p);
  res->online_cloud_timeout_ms_ = TlFetchInt::parse(p);
  res->notify_cloud_delay_ms_ = TlFetchInt::parse(p);
  res->notify_default_delay_ms_ = TlFetchInt::parse(p);
  res->push_chat_period_ms_ = TlFetchInt::parse(p);
  res->push_chat_limit_ = TlFetchInt::parse(p);
  res->saved_gifs_limit_ = TlFetchInt::parse(p);
  res->edit_time_limit_ = TlFetchInt::parse(p);
  res->revoke_time_limit_ = TlFetchInt::parse(p);
  res->revoke_pm_time_limit_ = TlFetchInt::parse(p);
  res->rating_e_decay_ = TlFetchInt::parse(p);
  res->stickers_recent_limit_ = TlFetchInt::parse(p);
  res->stickers_faved_limit_ = TlFetchInt::parse(p);
  res->channels_read_media_period_ = TlFetchInt::parse(p);
  if (var0 & 1) { res->tmp_sessions_ = TlFetchInt::parse(p); }
  res->pinned_dialogs_count_max_ = TlFetchInt::parse(p);
  res->call_receive_timeout_ms_ = TlFetchInt::parse(p);
  res->call_ring_timeout_ms_ = TlFetchInt::parse(p);
  res->call_connect_timeout_ms_ = TlFetchInt::parse(p);
  res->call_packet_timeout_ms_ = TlFetchInt::parse(p);
  res->me_url_prefix_ = TlFetchString<std::string>::parse(p);
  if (var0 & 128) { res->autoupdate_url_prefix_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 512) { res->gif_search_username_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 1024) { res->venue_search_username_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 2048) { res->img_search_username_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4096) { res->static_maps_provider_ = TlFetchString<std::string>::parse(p); }
  res->caption_length_max_ = TlFetchInt::parse(p);
  res->message_length_max_ = TlFetchInt::parse(p);
  res->webfile_dc_id_ = TlFetchInt::parse(p);
  if (var0 & 4) { res->suggested_lang_code_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->lang_pack_version_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void config::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "config");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 256) {  }
    s.store_field("date", date_);
    s.store_field("expires", expires_);
    s.store_field("test_mode", test_mode_);
    s.store_field("this_dc", this_dc_);
    { const std::vector<object_ptr<dcOption>> &v = dc_options_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("dc_options", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("dc_txt_domain_name", dc_txt_domain_name_);
    s.store_field("chat_size_max", chat_size_max_);
    s.store_field("megagroup_size_max", megagroup_size_max_);
    s.store_field("forwarded_count_max", forwarded_count_max_);
    s.store_field("online_update_period_ms", online_update_period_ms_);
    s.store_field("offline_blur_timeout_ms", offline_blur_timeout_ms_);
    s.store_field("offline_idle_timeout_ms", offline_idle_timeout_ms_);
    s.store_field("online_cloud_timeout_ms", online_cloud_timeout_ms_);
    s.store_field("notify_cloud_delay_ms", notify_cloud_delay_ms_);
    s.store_field("notify_default_delay_ms", notify_default_delay_ms_);
    s.store_field("push_chat_period_ms", push_chat_period_ms_);
    s.store_field("push_chat_limit", push_chat_limit_);
    s.store_field("saved_gifs_limit", saved_gifs_limit_);
    s.store_field("edit_time_limit", edit_time_limit_);
    s.store_field("revoke_time_limit", revoke_time_limit_);
    s.store_field("revoke_pm_time_limit", revoke_pm_time_limit_);
    s.store_field("rating_e_decay", rating_e_decay_);
    s.store_field("stickers_recent_limit", stickers_recent_limit_);
    s.store_field("stickers_faved_limit", stickers_faved_limit_);
    s.store_field("channels_read_media_period", channels_read_media_period_);
    if (var0 & 1) { s.store_field("tmp_sessions", tmp_sessions_); }
    s.store_field("pinned_dialogs_count_max", pinned_dialogs_count_max_);
    s.store_field("call_receive_timeout_ms", call_receive_timeout_ms_);
    s.store_field("call_ring_timeout_ms", call_ring_timeout_ms_);
    s.store_field("call_connect_timeout_ms", call_connect_timeout_ms_);
    s.store_field("call_packet_timeout_ms", call_packet_timeout_ms_);
    s.store_field("me_url_prefix", me_url_prefix_);
    if (var0 & 128) { s.store_field("autoupdate_url_prefix", autoupdate_url_prefix_); }
    if (var0 & 512) { s.store_field("gif_search_username", gif_search_username_); }
    if (var0 & 1024) { s.store_field("venue_search_username", venue_search_username_); }
    if (var0 & 2048) { s.store_field("img_search_username", img_search_username_); }
    if (var0 & 4096) { s.store_field("static_maps_provider", static_maps_provider_); }
    s.store_field("caption_length_max", caption_length_max_);
    s.store_field("message_length_max", message_length_max_);
    s.store_field("webfile_dc_id", webfile_dc_id_);
    if (var0 & 4) { s.store_field("suggested_lang_code", suggested_lang_code_); }
    if (var0 & 4) { s.store_field("lang_pack_version", lang_pack_version_); }
    s.store_class_end();
  }
}

contact::contact()
  : user_id_()
  , mutual_()
{}

contact::contact(std::int32_t user_id_, bool mutual_)
  : user_id_(user_id_)
  , mutual_(mutual_)
{}

const std::int32_t contact::ID;

contact::contact(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , mutual_(TlFetchBool::parse(p))
#undef FAIL
{}

void contact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contact");
    s.store_field("user_id", user_id_);
    s.store_field("mutual", mutual_);
    s.store_class_end();
  }
}

contactBlocked::contactBlocked()
  : user_id_()
  , date_()
{}

contactBlocked::contactBlocked(std::int32_t user_id_, std::int32_t date_)
  : user_id_(user_id_)
  , date_(date_)
{}

const std::int32_t contactBlocked::ID;

contactBlocked::contactBlocked(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void contactBlocked::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contactBlocked");
    s.store_field("user_id", user_id_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

object_ptr<ContactLink> ContactLink::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case contactLinkUnknown::ID:
      return contactLinkUnknown::fetch(p);
    case contactLinkNone::ID:
      return contactLinkNone::fetch(p);
    case contactLinkHasPhone::ID:
      return contactLinkHasPhone::fetch(p);
    case contactLinkContact::ID:
      return contactLinkContact::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

contactLinkUnknown::contactLinkUnknown() {
}

const std::int32_t contactLinkUnknown::ID;

contactLinkUnknown::contactLinkUnknown(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void contactLinkUnknown::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contactLinkUnknown");
    s.store_class_end();
  }
}

contactLinkNone::contactLinkNone() {
}

const std::int32_t contactLinkNone::ID;

contactLinkNone::contactLinkNone(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void contactLinkNone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contactLinkNone");
    s.store_class_end();
  }
}

contactLinkHasPhone::contactLinkHasPhone() {
}

const std::int32_t contactLinkHasPhone::ID;

contactLinkHasPhone::contactLinkHasPhone(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void contactLinkHasPhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contactLinkHasPhone");
    s.store_class_end();
  }
}

contactLinkContact::contactLinkContact() {
}

const std::int32_t contactLinkContact::ID;

contactLinkContact::contactLinkContact(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void contactLinkContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contactLinkContact");
    s.store_class_end();
  }
}

contactStatus::contactStatus()
  : user_id_()
  , status_()
{}

contactStatus::contactStatus(std::int32_t user_id_, object_ptr<UserStatus> &&status_)
  : user_id_(user_id_)
  , status_(std::move(status_))
{}

const std::int32_t contactStatus::ID;

contactStatus::contactStatus(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , status_(TlFetchObject<UserStatus>::parse(p))
#undef FAIL
{}

void contactStatus::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contactStatus");
    s.store_field("user_id", user_id_);
    if (status_ == nullptr) { s.store_field("status", "null"); } else { status_->store(s, "status"); }
    s.store_class_end();
  }
}

dataJSON::dataJSON()
  : data_()
{}

dataJSON::dataJSON(std::string const &data_)
  : data_(data_)
{}

const std::int32_t dataJSON::ID;

dataJSON::dataJSON(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : data_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void dataJSON::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(data_, s);
}

void dataJSON::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(data_, s);
}

void dataJSON::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "dataJSON");
    s.store_field("data", data_);
    s.store_class_end();
  }
}

dcOption::dcOption()
  : flags_()
  , ipv6_()
  , media_only_()
  , tcpo_only_()
  , cdn_()
  , static_()
  , id_()
  , ip_address_()
  , port_()
  , secret_()
{}

dcOption::dcOption(std::int32_t flags_, bool ipv6_, bool media_only_, bool tcpo_only_, bool cdn_, bool static_, std::int32_t id_, std::string const &ip_address_, std::int32_t port_, BufferSlice &&secret_)
  : flags_(flags_)
  , ipv6_(ipv6_)
  , media_only_(media_only_)
  , tcpo_only_(tcpo_only_)
  , cdn_(cdn_)
  , static_(static_)
  , id_(id_)
  , ip_address_(ip_address_)
  , port_(port_)
  , secret_(std::move(secret_))
{}

const std::int32_t dcOption::ID;

object_ptr<dcOption> dcOption::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<dcOption> res = make_tl_object<dcOption>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->ipv6_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->media_only_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->tcpo_only_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->cdn_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->static_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  res->ip_address_ = TlFetchString<std::string>::parse(p);
  res->port_ = TlFetchInt::parse(p);
  if (var0 & 1024) { res->secret_ = TlFetchBytes<BufferSlice>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void dcOption::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "dcOption");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    s.store_field("id", id_);
    s.store_field("ip_address", ip_address_);
    s.store_field("port", port_);
    if (var0 & 1024) { s.store_bytes_field("secret", secret_); }
    s.store_class_end();
  }
}

dialog::dialog()
  : flags_()
  , pinned_()
  , unread_mark_()
  , peer_()
  , top_message_()
  , read_inbox_max_id_()
  , read_outbox_max_id_()
  , unread_count_()
  , unread_mentions_count_()
  , notify_settings_()
  , pts_()
  , draft_()
{}

dialog::dialog(std::int32_t flags_, bool pinned_, bool unread_mark_, object_ptr<Peer> &&peer_, std::int32_t top_message_, std::int32_t read_inbox_max_id_, std::int32_t read_outbox_max_id_, std::int32_t unread_count_, std::int32_t unread_mentions_count_, object_ptr<peerNotifySettings> &&notify_settings_, std::int32_t pts_, object_ptr<DraftMessage> &&draft_)
  : flags_(flags_)
  , pinned_(pinned_)
  , unread_mark_(unread_mark_)
  , peer_(std::move(peer_))
  , top_message_(top_message_)
  , read_inbox_max_id_(read_inbox_max_id_)
  , read_outbox_max_id_(read_outbox_max_id_)
  , unread_count_(unread_count_)
  , unread_mentions_count_(unread_mentions_count_)
  , notify_settings_(std::move(notify_settings_))
  , pts_(pts_)
  , draft_(std::move(draft_))
{}

const std::int32_t dialog::ID;

object_ptr<dialog> dialog::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<dialog> res = make_tl_object<dialog>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 4) { res->pinned_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->unread_mark_ = TlFetchTrue::parse(p); }
  res->peer_ = TlFetchObject<Peer>::parse(p);
  res->top_message_ = TlFetchInt::parse(p);
  res->read_inbox_max_id_ = TlFetchInt::parse(p);
  res->read_outbox_max_id_ = TlFetchInt::parse(p);
  res->unread_count_ = TlFetchInt::parse(p);
  res->unread_mentions_count_ = TlFetchInt::parse(p);
  res->notify_settings_ = TlFetchBoxed<TlFetchObject<peerNotifySettings>, -1353671392>::parse(p);
  if (var0 & 1) { res->pts_ = TlFetchInt::parse(p); }
  if (var0 & 2) { res->draft_ = TlFetchObject<DraftMessage>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void dialog::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "dialog");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("top_message", top_message_);
    s.store_field("read_inbox_max_id", read_inbox_max_id_);
    s.store_field("read_outbox_max_id", read_outbox_max_id_);
    s.store_field("unread_count", unread_count_);
    s.store_field("unread_mentions_count", unread_mentions_count_);
    if (notify_settings_ == nullptr) { s.store_field("notify_settings", "null"); } else { notify_settings_->store(s, "notify_settings"); }
    if (var0 & 1) { s.store_field("pts", pts_); }
    if (var0 & 2) { if (draft_ == nullptr) { s.store_field("draft", "null"); } else { draft_->store(s, "draft"); } }
    s.store_class_end();
  }
}

dialogPeer::dialogPeer()
  : peer_()
{}

dialogPeer::dialogPeer(object_ptr<Peer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t dialogPeer::ID;

dialogPeer::dialogPeer(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : peer_(TlFetchObject<Peer>::parse(p))
#undef FAIL
{}

void dialogPeer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "dialogPeer");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

object_ptr<Document> Document::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case documentEmpty::ID:
      return documentEmpty::fetch(p);
    case document::ID:
      return document::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

documentEmpty::documentEmpty()
  : id_()
{}

documentEmpty::documentEmpty(std::int64_t id_)
  : id_(id_)
{}

const std::int32_t documentEmpty::ID;

documentEmpty::documentEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
#undef FAIL
{}

void documentEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "documentEmpty");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

document::document()
  : id_()
  , access_hash_()
  , date_()
  , mime_type_()
  , size_()
  , thumb_()
  , dc_id_()
  , version_()
  , attributes_()
{}

document::document(std::int64_t id_, std::int64_t access_hash_, std::int32_t date_, std::string const &mime_type_, std::int32_t size_, object_ptr<PhotoSize> &&thumb_, std::int32_t dc_id_, std::int32_t version_, std::vector<object_ptr<DocumentAttribute>> &&attributes_)
  : id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , mime_type_(mime_type_)
  , size_(size_)
  , thumb_(std::move(thumb_))
  , dc_id_(dc_id_)
  , version_(version_)
  , attributes_(std::move(attributes_))
{}

const std::int32_t document::ID;

document::document(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
  , mime_type_(TlFetchString<std::string>::parse(p))
  , size_(TlFetchInt::parse(p))
  , thumb_(TlFetchObject<PhotoSize>::parse(p))
  , dc_id_(TlFetchInt::parse(p))
  , version_(TlFetchInt::parse(p))
  , attributes_(TlFetchBoxed<TlFetchVector<TlFetchObject<DocumentAttribute>>, 481674261>::parse(p))
#undef FAIL
{}

void document::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "document");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    s.store_field("mime_type", mime_type_);
    s.store_field("size", size_);
    if (thumb_ == nullptr) { s.store_field("thumb", "null"); } else { thumb_->store(s, "thumb"); }
    s.store_field("dc_id", dc_id_);
    s.store_field("version", version_);
    { const std::vector<object_ptr<DocumentAttribute>> &v = attributes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("attributes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<DocumentAttribute> DocumentAttribute::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case documentAttributeImageSize::ID:
      return documentAttributeImageSize::fetch(p);
    case documentAttributeAnimated::ID:
      return documentAttributeAnimated::fetch(p);
    case documentAttributeSticker::ID:
      return documentAttributeSticker::fetch(p);
    case documentAttributeVideo::ID:
      return documentAttributeVideo::fetch(p);
    case documentAttributeAudio::ID:
      return documentAttributeAudio::fetch(p);
    case documentAttributeFilename::ID:
      return documentAttributeFilename::fetch(p);
    case documentAttributeHasStickers::ID:
      return documentAttributeHasStickers::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

documentAttributeImageSize::documentAttributeImageSize()
  : w_()
  , h_()
{}

documentAttributeImageSize::documentAttributeImageSize(std::int32_t w_, std::int32_t h_)
  : w_(w_)
  , h_(h_)
{}

const std::int32_t documentAttributeImageSize::ID;

documentAttributeImageSize::documentAttributeImageSize(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : w_(TlFetchInt::parse(p))
  , h_(TlFetchInt::parse(p))
#undef FAIL
{}

void documentAttributeImageSize::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(w_, s);
  TlStoreBinary::store(h_, s);
}

void documentAttributeImageSize::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(w_, s);
  TlStoreBinary::store(h_, s);
}

void documentAttributeImageSize::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "documentAttributeImageSize");
    s.store_field("w", w_);
    s.store_field("h", h_);
    s.store_class_end();
  }
}

documentAttributeAnimated::documentAttributeAnimated() {
}

const std::int32_t documentAttributeAnimated::ID;

documentAttributeAnimated::documentAttributeAnimated(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void documentAttributeAnimated::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void documentAttributeAnimated::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void documentAttributeAnimated::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "documentAttributeAnimated");
    s.store_class_end();
  }
}

documentAttributeSticker::documentAttributeSticker()
  : flags_()
  , mask_()
  , alt_()
  , stickerset_()
  , mask_coords_()
{}

documentAttributeSticker::documentAttributeSticker(std::int32_t flags_, bool mask_, std::string const &alt_, object_ptr<InputStickerSet> &&stickerset_, object_ptr<maskCoords> &&mask_coords_)
  : flags_(flags_)
  , mask_(mask_)
  , alt_(alt_)
  , stickerset_(std::move(stickerset_))
  , mask_coords_(std::move(mask_coords_))
{}

const std::int32_t documentAttributeSticker::ID;

object_ptr<documentAttributeSticker> documentAttributeSticker::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<documentAttributeSticker> res = make_tl_object<documentAttributeSticker>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->mask_ = TlFetchTrue::parse(p); }
  res->alt_ = TlFetchString<std::string>::parse(p);
  res->stickerset_ = TlFetchObject<InputStickerSet>::parse(p);
  if (var0 & 1) { res->mask_coords_ = TlFetchBoxed<TlFetchObject<maskCoords>, -1361650766>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void documentAttributeSticker::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(mask_, s); }
  TlStoreString::store(alt_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -1361650766>::store(mask_coords_, s); }
}

void documentAttributeSticker::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(mask_, s); }
  TlStoreString::store(alt_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -1361650766>::store(mask_coords_, s); }
}

void documentAttributeSticker::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "documentAttributeSticker");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    s.store_field("alt", alt_);
    if (stickerset_ == nullptr) { s.store_field("stickerset", "null"); } else { stickerset_->store(s, "stickerset"); }
    if (var0 & 1) { if (mask_coords_ == nullptr) { s.store_field("mask_coords", "null"); } else { mask_coords_->store(s, "mask_coords"); } }
    s.store_class_end();
  }
}

documentAttributeVideo::documentAttributeVideo()
  : flags_()
  , round_message_()
  , supports_streaming_()
  , duration_()
  , w_()
  , h_()
{}

documentAttributeVideo::documentAttributeVideo(std::int32_t flags_, bool round_message_, bool supports_streaming_, std::int32_t duration_, std::int32_t w_, std::int32_t h_)
  : flags_(flags_)
  , round_message_(round_message_)
  , supports_streaming_(supports_streaming_)
  , duration_(duration_)
  , w_(w_)
  , h_(h_)
{}

const std::int32_t documentAttributeVideo::ID;

object_ptr<documentAttributeVideo> documentAttributeVideo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<documentAttributeVideo> res = make_tl_object<documentAttributeVideo>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->round_message_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->supports_streaming_ = TlFetchTrue::parse(p); }
  res->duration_ = TlFetchInt::parse(p);
  res->w_ = TlFetchInt::parse(p);
  res->h_ = TlFetchInt::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void documentAttributeVideo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(round_message_, s); }
  if (var0 & 2) { TlStoreTrue::store(supports_streaming_, s); }
  TlStoreBinary::store(duration_, s);
  TlStoreBinary::store(w_, s);
  TlStoreBinary::store(h_, s);
}

void documentAttributeVideo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(round_message_, s); }
  if (var0 & 2) { TlStoreTrue::store(supports_streaming_, s); }
  TlStoreBinary::store(duration_, s);
  TlStoreBinary::store(w_, s);
  TlStoreBinary::store(h_, s);
}

void documentAttributeVideo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "documentAttributeVideo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    s.store_field("duration", duration_);
    s.store_field("w", w_);
    s.store_field("h", h_);
    s.store_class_end();
  }
}

documentAttributeAudio::documentAttributeAudio()
  : flags_()
  , voice_()
  , duration_()
  , title_()
  , performer_()
  , waveform_()
{}

documentAttributeAudio::documentAttributeAudio(std::int32_t flags_, bool voice_, std::int32_t duration_, std::string const &title_, std::string const &performer_, BufferSlice &&waveform_)
  : flags_(flags_)
  , voice_(voice_)
  , duration_(duration_)
  , title_(title_)
  , performer_(performer_)
  , waveform_(std::move(waveform_))
{}

const std::int32_t documentAttributeAudio::ID;

object_ptr<documentAttributeAudio> documentAttributeAudio::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<documentAttributeAudio> res = make_tl_object<documentAttributeAudio>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1024) { res->voice_ = TlFetchTrue::parse(p); }
  res->duration_ = TlFetchInt::parse(p);
  if (var0 & 1) { res->title_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 2) { res->performer_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->waveform_ = TlFetchBytes<BufferSlice>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void documentAttributeAudio::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1024) { TlStoreTrue::store(voice_, s); }
  TlStoreBinary::store(duration_, s);
  if (var0 & 1) { TlStoreString::store(title_, s); }
  if (var0 & 2) { TlStoreString::store(performer_, s); }
  if (var0 & 4) { TlStoreString::store(waveform_, s); }
}

void documentAttributeAudio::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1024) { TlStoreTrue::store(voice_, s); }
  TlStoreBinary::store(duration_, s);
  if (var0 & 1) { TlStoreString::store(title_, s); }
  if (var0 & 2) { TlStoreString::store(performer_, s); }
  if (var0 & 4) { TlStoreString::store(waveform_, s); }
}

void documentAttributeAudio::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "documentAttributeAudio");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1024) {  }
    s.store_field("duration", duration_);
    if (var0 & 1) { s.store_field("title", title_); }
    if (var0 & 2) { s.store_field("performer", performer_); }
    if (var0 & 4) { s.store_bytes_field("waveform", waveform_); }
    s.store_class_end();
  }
}

documentAttributeFilename::documentAttributeFilename()
  : file_name_()
{}

documentAttributeFilename::documentAttributeFilename(std::string const &file_name_)
  : file_name_(file_name_)
{}

const std::int32_t documentAttributeFilename::ID;

documentAttributeFilename::documentAttributeFilename(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : file_name_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void documentAttributeFilename::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(file_name_, s);
}

void documentAttributeFilename::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(file_name_, s);
}

void documentAttributeFilename::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "documentAttributeFilename");
    s.store_field("file_name", file_name_);
    s.store_class_end();
  }
}

documentAttributeHasStickers::documentAttributeHasStickers() {
}

const std::int32_t documentAttributeHasStickers::ID;

documentAttributeHasStickers::documentAttributeHasStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void documentAttributeHasStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void documentAttributeHasStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void documentAttributeHasStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "documentAttributeHasStickers");
    s.store_class_end();
  }
}

object_ptr<DraftMessage> DraftMessage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case draftMessageEmpty::ID:
      return draftMessageEmpty::fetch(p);
    case draftMessage::ID:
      return draftMessage::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

draftMessageEmpty::draftMessageEmpty()
  : flags_()
  , date_()
{}

draftMessageEmpty::draftMessageEmpty(std::int32_t flags_, std::int32_t date_)
  : flags_(flags_)
  , date_(date_)
{}

const std::int32_t draftMessageEmpty::ID;

object_ptr<draftMessageEmpty> draftMessageEmpty::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<draftMessageEmpty> res = make_tl_object<draftMessageEmpty>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->date_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void draftMessageEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "draftMessageEmpty");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("date", date_); }
    s.store_class_end();
  }
}

draftMessage::draftMessage()
  : flags_()
  , no_webpage_()
  , reply_to_msg_id_()
  , message_()
  , entities_()
  , date_()
{}

draftMessage::draftMessage(std::int32_t flags_, bool no_webpage_, std::int32_t reply_to_msg_id_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_, std::int32_t date_)
  : flags_(flags_)
  , no_webpage_(no_webpage_)
  , reply_to_msg_id_(reply_to_msg_id_)
  , message_(message_)
  , entities_(std::move(entities_))
  , date_(date_)
{}

const std::int32_t draftMessage::ID;

object_ptr<draftMessage> draftMessage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<draftMessage> res = make_tl_object<draftMessage>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->no_webpage_ = TlFetchTrue::parse(p); }
  if (var0 & 1) { res->reply_to_msg_id_ = TlFetchInt::parse(p); }
  res->message_ = TlFetchString<std::string>::parse(p);
  if (var0 & 8) { res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p); }
  res->date_ = TlFetchInt::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void draftMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "draftMessage");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 1) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    s.store_field("message", message_);
    if (var0 & 8) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_field("date", date_);
    s.store_class_end();
  }
}

object_ptr<EncryptedChat> EncryptedChat::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case encryptedChatEmpty::ID:
      return encryptedChatEmpty::fetch(p);
    case encryptedChatWaiting::ID:
      return encryptedChatWaiting::fetch(p);
    case encryptedChatRequested::ID:
      return encryptedChatRequested::fetch(p);
    case encryptedChat::ID:
      return encryptedChat::fetch(p);
    case encryptedChatDiscarded::ID:
      return encryptedChatDiscarded::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

encryptedChatEmpty::encryptedChatEmpty()
  : id_()
{}

encryptedChatEmpty::encryptedChatEmpty(std::int32_t id_)
  : id_(id_)
{}

const std::int32_t encryptedChatEmpty::ID;

encryptedChatEmpty::encryptedChatEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
#undef FAIL
{}

void encryptedChatEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedChatEmpty");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

encryptedChatWaiting::encryptedChatWaiting()
  : id_()
  , access_hash_()
  , date_()
  , admin_id_()
  , participant_id_()
{}

encryptedChatWaiting::encryptedChatWaiting(std::int32_t id_, std::int64_t access_hash_, std::int32_t date_, std::int32_t admin_id_, std::int32_t participant_id_)
  : id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , admin_id_(admin_id_)
  , participant_id_(participant_id_)
{}

const std::int32_t encryptedChatWaiting::ID;

encryptedChatWaiting::encryptedChatWaiting(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
  , admin_id_(TlFetchInt::parse(p))
  , participant_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void encryptedChatWaiting::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedChatWaiting");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    s.store_field("admin_id", admin_id_);
    s.store_field("participant_id", participant_id_);
    s.store_class_end();
  }
}

encryptedChatRequested::encryptedChatRequested()
  : id_()
  , access_hash_()
  , date_()
  , admin_id_()
  , participant_id_()
  , g_a_()
{}

encryptedChatRequested::encryptedChatRequested(std::int32_t id_, std::int64_t access_hash_, std::int32_t date_, std::int32_t admin_id_, std::int32_t participant_id_, BufferSlice &&g_a_)
  : id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , admin_id_(admin_id_)
  , participant_id_(participant_id_)
  , g_a_(std::move(g_a_))
{}

const std::int32_t encryptedChatRequested::ID;

encryptedChatRequested::encryptedChatRequested(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
  , admin_id_(TlFetchInt::parse(p))
  , participant_id_(TlFetchInt::parse(p))
  , g_a_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void encryptedChatRequested::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedChatRequested");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    s.store_field("admin_id", admin_id_);
    s.store_field("participant_id", participant_id_);
    s.store_bytes_field("g_a", g_a_);
    s.store_class_end();
  }
}

encryptedChat::encryptedChat()
  : id_()
  , access_hash_()
  , date_()
  , admin_id_()
  , participant_id_()
  , g_a_or_b_()
  , key_fingerprint_()
{}

encryptedChat::encryptedChat(std::int32_t id_, std::int64_t access_hash_, std::int32_t date_, std::int32_t admin_id_, std::int32_t participant_id_, BufferSlice &&g_a_or_b_, std::int64_t key_fingerprint_)
  : id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , admin_id_(admin_id_)
  , participant_id_(participant_id_)
  , g_a_or_b_(std::move(g_a_or_b_))
  , key_fingerprint_(key_fingerprint_)
{}

const std::int32_t encryptedChat::ID;

encryptedChat::encryptedChat(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
  , admin_id_(TlFetchInt::parse(p))
  , participant_id_(TlFetchInt::parse(p))
  , g_a_or_b_(TlFetchBytes<BufferSlice>::parse(p))
  , key_fingerprint_(TlFetchLong::parse(p))
#undef FAIL
{}

void encryptedChat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedChat");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    s.store_field("admin_id", admin_id_);
    s.store_field("participant_id", participant_id_);
    s.store_bytes_field("g_a_or_b", g_a_or_b_);
    s.store_field("key_fingerprint", key_fingerprint_);
    s.store_class_end();
  }
}

encryptedChatDiscarded::encryptedChatDiscarded()
  : id_()
{}

encryptedChatDiscarded::encryptedChatDiscarded(std::int32_t id_)
  : id_(id_)
{}

const std::int32_t encryptedChatDiscarded::ID;

encryptedChatDiscarded::encryptedChatDiscarded(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
#undef FAIL
{}

void encryptedChatDiscarded::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedChatDiscarded");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

object_ptr<EncryptedFile> EncryptedFile::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case encryptedFileEmpty::ID:
      return encryptedFileEmpty::fetch(p);
    case encryptedFile::ID:
      return encryptedFile::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

encryptedFileEmpty::encryptedFileEmpty() {
}

const std::int32_t encryptedFileEmpty::ID;

encryptedFileEmpty::encryptedFileEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void encryptedFileEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedFileEmpty");
    s.store_class_end();
  }
}

encryptedFile::encryptedFile()
  : id_()
  , access_hash_()
  , size_()
  , dc_id_()
  , key_fingerprint_()
{}

encryptedFile::encryptedFile(std::int64_t id_, std::int64_t access_hash_, std::int32_t size_, std::int32_t dc_id_, std::int32_t key_fingerprint_)
  : id_(id_)
  , access_hash_(access_hash_)
  , size_(size_)
  , dc_id_(dc_id_)
  , key_fingerprint_(key_fingerprint_)
{}

const std::int32_t encryptedFile::ID;

encryptedFile::encryptedFile(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , size_(TlFetchInt::parse(p))
  , dc_id_(TlFetchInt::parse(p))
  , key_fingerprint_(TlFetchInt::parse(p))
#undef FAIL
{}

void encryptedFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedFile");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("size", size_);
    s.store_field("dc_id", dc_id_);
    s.store_field("key_fingerprint", key_fingerprint_);
    s.store_class_end();
  }
}

object_ptr<EncryptedMessage> EncryptedMessage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case encryptedMessage::ID:
      return encryptedMessage::fetch(p);
    case encryptedMessageService::ID:
      return encryptedMessageService::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

encryptedMessage::encryptedMessage()
  : random_id_()
  , chat_id_()
  , date_()
  , bytes_()
  , file_()
{}

encryptedMessage::encryptedMessage(std::int64_t random_id_, std::int32_t chat_id_, std::int32_t date_, BufferSlice &&bytes_, object_ptr<EncryptedFile> &&file_)
  : random_id_(random_id_)
  , chat_id_(chat_id_)
  , date_(date_)
  , bytes_(std::move(bytes_))
  , file_(std::move(file_))
{}

const std::int32_t encryptedMessage::ID;

encryptedMessage::encryptedMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : random_id_(TlFetchLong::parse(p))
  , chat_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
  , bytes_(TlFetchBytes<BufferSlice>::parse(p))
  , file_(TlFetchObject<EncryptedFile>::parse(p))
#undef FAIL
{}

void encryptedMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedMessage");
    s.store_field("random_id", random_id_);
    s.store_field("chat_id", chat_id_);
    s.store_field("date", date_);
    s.store_bytes_field("bytes", bytes_);
    if (file_ == nullptr) { s.store_field("file", "null"); } else { file_->store(s, "file"); }
    s.store_class_end();
  }
}

encryptedMessageService::encryptedMessageService()
  : random_id_()
  , chat_id_()
  , date_()
  , bytes_()
{}

encryptedMessageService::encryptedMessageService(std::int64_t random_id_, std::int32_t chat_id_, std::int32_t date_, BufferSlice &&bytes_)
  : random_id_(random_id_)
  , chat_id_(chat_id_)
  , date_(date_)
  , bytes_(std::move(bytes_))
{}

const std::int32_t encryptedMessageService::ID;

encryptedMessageService::encryptedMessageService(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : random_id_(TlFetchLong::parse(p))
  , chat_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
  , bytes_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void encryptedMessageService::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "encryptedMessageService");
    s.store_field("random_id", random_id_);
    s.store_field("chat_id", chat_id_);
    s.store_field("date", date_);
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

error::error()
  : code_()
  , text_()
{}

error::error(std::int32_t code_, std::string const &text_)
  : code_(code_)
  , text_(text_)
{}

const std::int32_t error::ID;

error::error(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : code_(TlFetchInt::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void error::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "error");
    s.store_field("code", code_);
    s.store_field("text", text_);
    s.store_class_end();
  }
}

object_ptr<ExportedChatInvite> ExportedChatInvite::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case chatInviteEmpty::ID:
      return chatInviteEmpty::fetch(p);
    case chatInviteExported::ID:
      return chatInviteExported::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

chatInviteEmpty::chatInviteEmpty() {
}

const std::int32_t chatInviteEmpty::ID;

chatInviteEmpty::chatInviteEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void chatInviteEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatInviteEmpty");
    s.store_class_end();
  }
}

chatInviteExported::chatInviteExported()
  : link_()
{}

chatInviteExported::chatInviteExported(std::string const &link_)
  : link_(link_)
{}

const std::int32_t chatInviteExported::ID;

chatInviteExported::chatInviteExported(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : link_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void chatInviteExported::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "chatInviteExported");
    s.store_field("link", link_);
    s.store_class_end();
  }
}

exportedMessageLink::exportedMessageLink()
  : link_()
  , html_()
{}

exportedMessageLink::exportedMessageLink(std::string const &link_, std::string const &html_)
  : link_(link_)
  , html_(html_)
{}

const std::int32_t exportedMessageLink::ID;

exportedMessageLink::exportedMessageLink(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : link_(TlFetchString<std::string>::parse(p))
  , html_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void exportedMessageLink::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "exportedMessageLink");
    s.store_field("link", link_);
    s.store_field("html", html_);
    s.store_class_end();
  }
}

fileHash::fileHash()
  : offset_()
  , limit_()
  , hash_()
{}

fileHash::fileHash(std::int32_t offset_, std::int32_t limit_, BufferSlice &&hash_)
  : offset_(offset_)
  , limit_(limit_)
  , hash_(std::move(hash_))
{}

const std::int32_t fileHash::ID;

fileHash::fileHash(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , limit_(TlFetchInt::parse(p))
  , hash_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void fileHash::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "fileHash");
    s.store_field("offset", offset_);
    s.store_field("limit", limit_);
    s.store_bytes_field("hash", hash_);
    s.store_class_end();
  }
}

object_ptr<FileLocation> FileLocation::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case fileLocationUnavailable::ID:
      return fileLocationUnavailable::fetch(p);
    case fileLocation::ID:
      return fileLocation::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

fileLocationUnavailable::fileLocationUnavailable()
  : volume_id_()
  , local_id_()
  , secret_()
{}

fileLocationUnavailable::fileLocationUnavailable(std::int64_t volume_id_, std::int32_t local_id_, std::int64_t secret_)
  : volume_id_(volume_id_)
  , local_id_(local_id_)
  , secret_(secret_)
{}

const std::int32_t fileLocationUnavailable::ID;

fileLocationUnavailable::fileLocationUnavailable(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : volume_id_(TlFetchLong::parse(p))
  , local_id_(TlFetchInt::parse(p))
  , secret_(TlFetchLong::parse(p))
#undef FAIL
{}

void fileLocationUnavailable::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "fileLocationUnavailable");
    s.store_field("volume_id", volume_id_);
    s.store_field("local_id", local_id_);
    s.store_field("secret", secret_);
    s.store_class_end();
  }
}

fileLocation::fileLocation()
  : dc_id_()
  , volume_id_()
  , local_id_()
  , secret_()
{}

fileLocation::fileLocation(std::int32_t dc_id_, std::int64_t volume_id_, std::int32_t local_id_, std::int64_t secret_)
  : dc_id_(dc_id_)
  , volume_id_(volume_id_)
  , local_id_(local_id_)
  , secret_(secret_)
{}

const std::int32_t fileLocation::ID;

fileLocation::fileLocation(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : dc_id_(TlFetchInt::parse(p))
  , volume_id_(TlFetchLong::parse(p))
  , local_id_(TlFetchInt::parse(p))
  , secret_(TlFetchLong::parse(p))
#undef FAIL
{}

void fileLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "fileLocation");
    s.store_field("dc_id", dc_id_);
    s.store_field("volume_id", volume_id_);
    s.store_field("local_id", local_id_);
    s.store_field("secret", secret_);
    s.store_class_end();
  }
}

object_ptr<FoundGif> FoundGif::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case foundGif::ID:
      return foundGif::fetch(p);
    case foundGifCached::ID:
      return foundGifCached::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

foundGif::foundGif()
  : url_()
  , thumb_url_()
  , content_url_()
  , content_type_()
  , w_()
  , h_()
{}

foundGif::foundGif(std::string const &url_, std::string const &thumb_url_, std::string const &content_url_, std::string const &content_type_, std::int32_t w_, std::int32_t h_)
  : url_(url_)
  , thumb_url_(thumb_url_)
  , content_url_(content_url_)
  , content_type_(content_type_)
  , w_(w_)
  , h_(h_)
{}

const std::int32_t foundGif::ID;

foundGif::foundGif(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , thumb_url_(TlFetchString<std::string>::parse(p))
  , content_url_(TlFetchString<std::string>::parse(p))
  , content_type_(TlFetchString<std::string>::parse(p))
  , w_(TlFetchInt::parse(p))
  , h_(TlFetchInt::parse(p))
#undef FAIL
{}

void foundGif::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "foundGif");
    s.store_field("url", url_);
    s.store_field("thumb_url", thumb_url_);
    s.store_field("content_url", content_url_);
    s.store_field("content_type", content_type_);
    s.store_field("w", w_);
    s.store_field("h", h_);
    s.store_class_end();
  }
}

foundGifCached::foundGifCached()
  : url_()
  , photo_()
  , document_()
{}

foundGifCached::foundGifCached(std::string const &url_, object_ptr<Photo> &&photo_, object_ptr<Document> &&document_)
  : url_(url_)
  , photo_(std::move(photo_))
  , document_(std::move(document_))
{}

const std::int32_t foundGifCached::ID;

foundGifCached::foundGifCached(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , photo_(TlFetchObject<Photo>::parse(p))
  , document_(TlFetchObject<Document>::parse(p))
#undef FAIL
{}

void foundGifCached::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "foundGifCached");
    s.store_field("url", url_);
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    if (document_ == nullptr) { s.store_field("document", "null"); } else { document_->store(s, "document"); }
    s.store_class_end();
  }
}

game::game()
  : flags_()
  , id_()
  , access_hash_()
  , short_name_()
  , title_()
  , description_()
  , photo_()
  , document_()
{}

game::game(std::int32_t flags_, std::int64_t id_, std::int64_t access_hash_, std::string const &short_name_, std::string const &title_, std::string const &description_, object_ptr<Photo> &&photo_, object_ptr<Document> &&document_)
  : flags_(flags_)
  , id_(id_)
  , access_hash_(access_hash_)
  , short_name_(short_name_)
  , title_(title_)
  , description_(description_)
  , photo_(std::move(photo_))
  , document_(std::move(document_))
{}

const std::int32_t game::ID;

object_ptr<game> game::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<game> res = make_tl_object<game>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->id_ = TlFetchLong::parse(p);
  res->access_hash_ = TlFetchLong::parse(p);
  res->short_name_ = TlFetchString<std::string>::parse(p);
  res->title_ = TlFetchString<std::string>::parse(p);
  res->description_ = TlFetchString<std::string>::parse(p);
  res->photo_ = TlFetchObject<Photo>::parse(p);
  if (var0 & 1) { res->document_ = TlFetchObject<Document>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void game::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "game");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("short_name", short_name_);
    s.store_field("title", title_);
    s.store_field("description", description_);
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    if (var0 & 1) { if (document_ == nullptr) { s.store_field("document", "null"); } else { document_->store(s, "document"); } }
    s.store_class_end();
  }
}

object_ptr<GeoPoint> GeoPoint::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case geoPointEmpty::ID:
      return geoPointEmpty::fetch(p);
    case geoPoint::ID:
      return geoPoint::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

geoPointEmpty::geoPointEmpty() {
}

const std::int32_t geoPointEmpty::ID;

geoPointEmpty::geoPointEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void geoPointEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "geoPointEmpty");
    s.store_class_end();
  }
}

geoPoint::geoPoint()
  : long_()
  , lat_()
  , access_hash_()
{}

geoPoint::geoPoint(double long_, double lat_, std::int64_t access_hash_)
  : long_(long_)
  , lat_(lat_)
  , access_hash_(access_hash_)
{}

const std::int32_t geoPoint::ID;

geoPoint::geoPoint(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : long_(TlFetchDouble::parse(p))
  , lat_(TlFetchDouble::parse(p))
  , access_hash_(TlFetchLong::parse(p))
#undef FAIL
{}

void geoPoint::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "geoPoint");
    s.store_field("long", long_);
    s.store_field("lat", lat_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

highScore::highScore()
  : pos_()
  , user_id_()
  , score_()
{}

highScore::highScore(std::int32_t pos_, std::int32_t user_id_, std::int32_t score_)
  : pos_(pos_)
  , user_id_(user_id_)
  , score_(score_)
{}

const std::int32_t highScore::ID;

highScore::highScore(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : pos_(TlFetchInt::parse(p))
  , user_id_(TlFetchInt::parse(p))
  , score_(TlFetchInt::parse(p))
#undef FAIL
{}

void highScore::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "highScore");
    s.store_field("pos", pos_);
    s.store_field("user_id", user_id_);
    s.store_field("score", score_);
    s.store_class_end();
  }
}

importedContact::importedContact()
  : user_id_()
  , client_id_()
{}

importedContact::importedContact(std::int32_t user_id_, std::int64_t client_id_)
  : user_id_(user_id_)
  , client_id_(client_id_)
{}

const std::int32_t importedContact::ID;

importedContact::importedContact(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , client_id_(TlFetchLong::parse(p))
#undef FAIL
{}

void importedContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "importedContact");
    s.store_field("user_id", user_id_);
    s.store_field("client_id", client_id_);
    s.store_class_end();
  }
}

inlineBotSwitchPM::inlineBotSwitchPM()
  : text_()
  , start_param_()
{}

inlineBotSwitchPM::inlineBotSwitchPM(std::string const &text_, std::string const &start_param_)
  : text_(text_)
  , start_param_(start_param_)
{}

const std::int32_t inlineBotSwitchPM::ID;

inlineBotSwitchPM::inlineBotSwitchPM(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
  , start_param_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void inlineBotSwitchPM::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
  TlStoreString::store(start_param_, s);
}

void inlineBotSwitchPM::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
  TlStoreString::store(start_param_, s);
}

void inlineBotSwitchPM::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inlineBotSwitchPM");
    s.store_field("text", text_);
    s.store_field("start_param", start_param_);
    s.store_class_end();
  }
}

inputAppEvent::inputAppEvent()
  : time_()
  , type_()
  , peer_()
  , data_()
{}

inputAppEvent::inputAppEvent(double time_, std::string const &type_, std::int64_t peer_, std::string const &data_)
  : time_(time_)
  , type_(type_)
  , peer_(peer_)
  , data_(data_)
{}

const std::int32_t inputAppEvent::ID;

void inputAppEvent::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(time_, s);
  TlStoreString::store(type_, s);
  TlStoreBinary::store(peer_, s);
  TlStoreString::store(data_, s);
}

void inputAppEvent::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(time_, s);
  TlStoreString::store(type_, s);
  TlStoreBinary::store(peer_, s);
  TlStoreString::store(data_, s);
}

void inputAppEvent::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputAppEvent");
    s.store_field("time", time_);
    s.store_field("type", type_);
    s.store_field("peer", peer_);
    s.store_field("data", data_);
    s.store_class_end();
  }
}

inputBotInlineMessageMediaAuto::inputBotInlineMessageMediaAuto()
  : flags_()
  , message_()
  , entities_()
  , reply_markup_()
{}

inputBotInlineMessageMediaAuto::inputBotInlineMessageMediaAuto(std::int32_t flags_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , message_(message_)
  , entities_(std::move(entities_))
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t inputBotInlineMessageMediaAuto::ID;

void inputBotInlineMessageMediaAuto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(message_, s);
  if (var0 & 2) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageMediaAuto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(message_, s);
  if (var0 & 2) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageMediaAuto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineMessageMediaAuto");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("message", message_);
    if (var0 & 2) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

inputBotInlineMessageText::inputBotInlineMessageText()
  : flags_()
  , no_webpage_()
  , message_()
  , entities_()
  , reply_markup_()
{}

inputBotInlineMessageText::inputBotInlineMessageText(std::int32_t flags_, bool no_webpage_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , no_webpage_(no_webpage_)
  , message_(message_)
  , entities_(std::move(entities_))
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t inputBotInlineMessageText::ID;

void inputBotInlineMessageText::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(no_webpage_, s); }
  TlStoreString::store(message_, s);
  if (var0 & 2) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageText::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(no_webpage_, s); }
  TlStoreString::store(message_, s);
  if (var0 & 2) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageText::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineMessageText");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("message", message_);
    if (var0 & 2) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

inputBotInlineMessageMediaGeo::inputBotInlineMessageMediaGeo()
  : flags_()
  , geo_point_()
  , period_()
  , reply_markup_()
{}

inputBotInlineMessageMediaGeo::inputBotInlineMessageMediaGeo(std::int32_t flags_, object_ptr<InputGeoPoint> &&geo_point_, std::int32_t period_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , geo_point_(std::move(geo_point_))
  , period_(period_)
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t inputBotInlineMessageMediaGeo::ID;

void inputBotInlineMessageMediaGeo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreBinary::store(period_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageMediaGeo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreBinary::store(period_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageMediaGeo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineMessageMediaGeo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); }
    s.store_field("period", period_);
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

inputBotInlineMessageMediaVenue::inputBotInlineMessageMediaVenue()
  : flags_()
  , geo_point_()
  , title_()
  , address_()
  , provider_()
  , venue_id_()
  , venue_type_()
  , reply_markup_()
{}

inputBotInlineMessageMediaVenue::inputBotInlineMessageMediaVenue(std::int32_t flags_, object_ptr<InputGeoPoint> &&geo_point_, std::string const &title_, std::string const &address_, std::string const &provider_, std::string const &venue_id_, std::string const &venue_type_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , geo_point_(std::move(geo_point_))
  , title_(title_)
  , address_(address_)
  , provider_(provider_)
  , venue_id_(venue_id_)
  , venue_type_(venue_type_)
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t inputBotInlineMessageMediaVenue::ID;

void inputBotInlineMessageMediaVenue::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreString::store(title_, s);
  TlStoreString::store(address_, s);
  TlStoreString::store(provider_, s);
  TlStoreString::store(venue_id_, s);
  TlStoreString::store(venue_type_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageMediaVenue::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreString::store(title_, s);
  TlStoreString::store(address_, s);
  TlStoreString::store(provider_, s);
  TlStoreString::store(venue_id_, s);
  TlStoreString::store(venue_type_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageMediaVenue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineMessageMediaVenue");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); }
    s.store_field("title", title_);
    s.store_field("address", address_);
    s.store_field("provider", provider_);
    s.store_field("venue_id", venue_id_);
    s.store_field("venue_type", venue_type_);
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

inputBotInlineMessageMediaContact::inputBotInlineMessageMediaContact()
  : flags_()
  , phone_number_()
  , first_name_()
  , last_name_()
  , vcard_()
  , reply_markup_()
{}

inputBotInlineMessageMediaContact::inputBotInlineMessageMediaContact(std::int32_t flags_, std::string const &phone_number_, std::string const &first_name_, std::string const &last_name_, std::string const &vcard_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , phone_number_(phone_number_)
  , first_name_(first_name_)
  , last_name_(last_name_)
  , vcard_(vcard_)
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t inputBotInlineMessageMediaContact::ID;

void inputBotInlineMessageMediaContact::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(first_name_, s);
  TlStoreString::store(last_name_, s);
  TlStoreString::store(vcard_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageMediaContact::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(first_name_, s);
  TlStoreString::store(last_name_, s);
  TlStoreString::store(vcard_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageMediaContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineMessageMediaContact");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("phone_number", phone_number_);
    s.store_field("first_name", first_name_);
    s.store_field("last_name", last_name_);
    s.store_field("vcard", vcard_);
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

inputBotInlineMessageGame::inputBotInlineMessageGame()
  : flags_()
  , reply_markup_()
{}

inputBotInlineMessageGame::inputBotInlineMessageGame(std::int32_t flags_, object_ptr<ReplyMarkup> &&reply_markup_)
  : flags_(flags_)
  , reply_markup_(std::move(reply_markup_))
{}

const std::int32_t inputBotInlineMessageGame::ID;

void inputBotInlineMessageGame::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageGame::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
}

void inputBotInlineMessageGame::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineMessageGame");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    s.store_class_end();
  }
}

inputBotInlineMessageID::inputBotInlineMessageID()
  : dc_id_()
  , id_()
  , access_hash_()
{}

inputBotInlineMessageID::inputBotInlineMessageID(std::int32_t dc_id_, std::int64_t id_, std::int64_t access_hash_)
  : dc_id_(dc_id_)
  , id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputBotInlineMessageID::ID;

inputBotInlineMessageID::inputBotInlineMessageID(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : dc_id_(TlFetchInt::parse(p))
  , id_(TlFetchLong::parse(p))
  , access_hash_(TlFetchLong::parse(p))
#undef FAIL
{}

void inputBotInlineMessageID::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(dc_id_, s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputBotInlineMessageID::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(dc_id_, s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputBotInlineMessageID::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineMessageID");
    s.store_field("dc_id", dc_id_);
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputBotInlineResult::inputBotInlineResult()
  : flags_()
  , id_()
  , type_()
  , title_()
  , description_()
  , url_()
  , thumb_()
  , content_()
  , send_message_()
{}

inputBotInlineResult::inputBotInlineResult(std::int32_t flags_, std::string const &id_, std::string const &type_, std::string const &title_, std::string const &description_, std::string const &url_, object_ptr<inputWebDocument> &&thumb_, object_ptr<inputWebDocument> &&content_, object_ptr<InputBotInlineMessage> &&send_message_)
  : flags_(flags_)
  , id_(id_)
  , type_(type_)
  , title_(title_)
  , description_(description_)
  , url_(url_)
  , thumb_(std::move(thumb_))
  , content_(std::move(content_))
  , send_message_(std::move(send_message_))
{}

const std::int32_t inputBotInlineResult::ID;

void inputBotInlineResult::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(id_, s);
  TlStoreString::store(type_, s);
  if (var0 & 2) { TlStoreString::store(title_, s); }
  if (var0 & 4) { TlStoreString::store(description_, s); }
  if (var0 & 8) { TlStoreString::store(url_, s); }
  if (var0 & 16) { TlStoreBoxed<TlStoreObject, -1678949555>::store(thumb_, s); }
  if (var0 & 32) { TlStoreBoxed<TlStoreObject, -1678949555>::store(content_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(send_message_, s);
}

void inputBotInlineResult::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(id_, s);
  TlStoreString::store(type_, s);
  if (var0 & 2) { TlStoreString::store(title_, s); }
  if (var0 & 4) { TlStoreString::store(description_, s); }
  if (var0 & 8) { TlStoreString::store(url_, s); }
  if (var0 & 16) { TlStoreBoxed<TlStoreObject, -1678949555>::store(thumb_, s); }
  if (var0 & 32) { TlStoreBoxed<TlStoreObject, -1678949555>::store(content_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(send_message_, s);
}

void inputBotInlineResult::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineResult");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("id", id_);
    s.store_field("type", type_);
    if (var0 & 2) { s.store_field("title", title_); }
    if (var0 & 4) { s.store_field("description", description_); }
    if (var0 & 8) { s.store_field("url", url_); }
    if (var0 & 16) { if (thumb_ == nullptr) { s.store_field("thumb", "null"); } else { thumb_->store(s, "thumb"); } }
    if (var0 & 32) { if (content_ == nullptr) { s.store_field("content", "null"); } else { content_->store(s, "content"); } }
    if (send_message_ == nullptr) { s.store_field("send_message", "null"); } else { send_message_->store(s, "send_message"); }
    s.store_class_end();
  }
}

inputBotInlineResultPhoto::inputBotInlineResultPhoto()
  : id_()
  , type_()
  , photo_()
  , send_message_()
{}

inputBotInlineResultPhoto::inputBotInlineResultPhoto(std::string const &id_, std::string const &type_, object_ptr<InputPhoto> &&photo_, object_ptr<InputBotInlineMessage> &&send_message_)
  : id_(id_)
  , type_(type_)
  , photo_(std::move(photo_))
  , send_message_(std::move(send_message_))
{}

const std::int32_t inputBotInlineResultPhoto::ID;

void inputBotInlineResultPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(id_, s);
  TlStoreString::store(type_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(photo_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(send_message_, s);
}

void inputBotInlineResultPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(id_, s);
  TlStoreString::store(type_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(photo_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(send_message_, s);
}

void inputBotInlineResultPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineResultPhoto");
    s.store_field("id", id_);
    s.store_field("type", type_);
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    if (send_message_ == nullptr) { s.store_field("send_message", "null"); } else { send_message_->store(s, "send_message"); }
    s.store_class_end();
  }
}

inputBotInlineResultDocument::inputBotInlineResultDocument()
  : flags_()
  , id_()
  , type_()
  , title_()
  , description_()
  , document_()
  , send_message_()
{}

inputBotInlineResultDocument::inputBotInlineResultDocument(std::int32_t flags_, std::string const &id_, std::string const &type_, std::string const &title_, std::string const &description_, object_ptr<InputDocument> &&document_, object_ptr<InputBotInlineMessage> &&send_message_)
  : flags_(flags_)
  , id_(id_)
  , type_(type_)
  , title_(title_)
  , description_(description_)
  , document_(std::move(document_))
  , send_message_(std::move(send_message_))
{}

const std::int32_t inputBotInlineResultDocument::ID;

void inputBotInlineResultDocument::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(id_, s);
  TlStoreString::store(type_, s);
  if (var0 & 2) { TlStoreString::store(title_, s); }
  if (var0 & 4) { TlStoreString::store(description_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(document_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(send_message_, s);
}

void inputBotInlineResultDocument::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(id_, s);
  TlStoreString::store(type_, s);
  if (var0 & 2) { TlStoreString::store(title_, s); }
  if (var0 & 4) { TlStoreString::store(description_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(document_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(send_message_, s);
}

void inputBotInlineResultDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineResultDocument");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("id", id_);
    s.store_field("type", type_);
    if (var0 & 2) { s.store_field("title", title_); }
    if (var0 & 4) { s.store_field("description", description_); }
    if (document_ == nullptr) { s.store_field("document", "null"); } else { document_->store(s, "document"); }
    if (send_message_ == nullptr) { s.store_field("send_message", "null"); } else { send_message_->store(s, "send_message"); }
    s.store_class_end();
  }
}

inputBotInlineResultGame::inputBotInlineResultGame()
  : id_()
  , short_name_()
  , send_message_()
{}

inputBotInlineResultGame::inputBotInlineResultGame(std::string const &id_, std::string const &short_name_, object_ptr<InputBotInlineMessage> &&send_message_)
  : id_(id_)
  , short_name_(short_name_)
  , send_message_(std::move(send_message_))
{}

const std::int32_t inputBotInlineResultGame::ID;

void inputBotInlineResultGame::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(id_, s);
  TlStoreString::store(short_name_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(send_message_, s);
}

void inputBotInlineResultGame::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(id_, s);
  TlStoreString::store(short_name_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(send_message_, s);
}

void inputBotInlineResultGame::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputBotInlineResultGame");
    s.store_field("id", id_);
    s.store_field("short_name", short_name_);
    if (send_message_ == nullptr) { s.store_field("send_message", "null"); } else { send_message_->store(s, "send_message"); }
    s.store_class_end();
  }
}

object_ptr<InputChannel> InputChannel::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case inputChannelEmpty::ID:
      return inputChannelEmpty::fetch(p);
    case inputChannel::ID:
      return inputChannel::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

inputChannelEmpty::inputChannelEmpty() {
}

const std::int32_t inputChannelEmpty::ID;

inputChannelEmpty::inputChannelEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void inputChannelEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputChannelEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputChannelEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputChannelEmpty");
    s.store_class_end();
  }
}

inputChannel::inputChannel()
  : channel_id_()
  , access_hash_()
{}

inputChannel::inputChannel(std::int32_t channel_id_, std::int64_t access_hash_)
  : channel_id_(channel_id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputChannel::ID;

inputChannel::inputChannel(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , access_hash_(TlFetchLong::parse(p))
#undef FAIL
{}

void inputChannel::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(channel_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputChannel::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(channel_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputChannel");
    s.store_field("channel_id", channel_id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputChatPhotoEmpty::inputChatPhotoEmpty() {
}

const std::int32_t inputChatPhotoEmpty::ID;

void inputChatPhotoEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputChatPhotoEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputChatPhotoEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputChatPhotoEmpty");
    s.store_class_end();
  }
}

inputChatUploadedPhoto::inputChatUploadedPhoto()
  : file_()
{}

inputChatUploadedPhoto::inputChatUploadedPhoto(object_ptr<InputFile> &&file_)
  : file_(std::move(file_))
{}

const std::int32_t inputChatUploadedPhoto::ID;

void inputChatUploadedPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
}

void inputChatUploadedPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
}

void inputChatUploadedPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputChatUploadedPhoto");
    if (file_ == nullptr) { s.store_field("file", "null"); } else { file_->store(s, "file"); }
    s.store_class_end();
  }
}

inputChatPhoto::inputChatPhoto()
  : id_()
{}

inputChatPhoto::inputChatPhoto(object_ptr<InputPhoto> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t inputChatPhoto::ID;

void inputChatPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void inputChatPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void inputChatPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputChatPhoto");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

inputCheckPasswordEmpty::inputCheckPasswordEmpty() {
}

const std::int32_t inputCheckPasswordEmpty::ID;

void inputCheckPasswordEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputCheckPasswordEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputCheckPasswordEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputCheckPasswordEmpty");
    s.store_class_end();
  }
}

inputCheckPasswordSRP::inputCheckPasswordSRP()
  : srp_id_()
  , A_()
  , M1_()
{}

inputCheckPasswordSRP::inputCheckPasswordSRP(std::int64_t srp_id_, BufferSlice &&A_, BufferSlice &&M1_)
  : srp_id_(srp_id_)
  , A_(std::move(A_))
  , M1_(std::move(M1_))
{}

const std::int32_t inputCheckPasswordSRP::ID;

void inputCheckPasswordSRP::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(srp_id_, s);
  TlStoreString::store(A_, s);
  TlStoreString::store(M1_, s);
}

void inputCheckPasswordSRP::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(srp_id_, s);
  TlStoreString::store(A_, s);
  TlStoreString::store(M1_, s);
}

void inputCheckPasswordSRP::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputCheckPasswordSRP");
    s.store_field("srp_id", srp_id_);
    s.store_bytes_field("A", A_);
    s.store_bytes_field("M1", M1_);
    s.store_class_end();
  }
}

inputClientProxy::inputClientProxy()
  : address_()
  , port_()
{}

inputClientProxy::inputClientProxy(std::string const &address_, std::int32_t port_)
  : address_(address_)
  , port_(port_)
{}

const std::int32_t inputClientProxy::ID;

void inputClientProxy::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputClientProxy");
    s.store_field("address", address_);
    s.store_field("port", port_);
    s.store_class_end();
  }
}

inputPhoneContact::inputPhoneContact()
  : client_id_()
  , phone_()
  , first_name_()
  , last_name_()
{}

inputPhoneContact::inputPhoneContact(std::int64_t client_id_, std::string const &phone_, std::string const &first_name_, std::string const &last_name_)
  : client_id_(client_id_)
  , phone_(phone_)
  , first_name_(first_name_)
  , last_name_(last_name_)
{}

const std::int32_t inputPhoneContact::ID;

void inputPhoneContact::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(client_id_, s);
  TlStoreString::store(phone_, s);
  TlStoreString::store(first_name_, s);
  TlStoreString::store(last_name_, s);
}

void inputPhoneContact::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(client_id_, s);
  TlStoreString::store(phone_, s);
  TlStoreString::store(first_name_, s);
  TlStoreString::store(last_name_, s);
}

void inputPhoneContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPhoneContact");
    s.store_field("client_id", client_id_);
    s.store_field("phone", phone_);
    s.store_field("first_name", first_name_);
    s.store_field("last_name", last_name_);
    s.store_class_end();
  }
}

inputDialogPeer::inputDialogPeer()
  : peer_()
{}

inputDialogPeer::inputDialogPeer(object_ptr<InputPeer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t inputDialogPeer::ID;

void inputDialogPeer::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void inputDialogPeer::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void inputDialogPeer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputDialogPeer");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

inputDocumentEmpty::inputDocumentEmpty() {
}

const std::int32_t inputDocumentEmpty::ID;

void inputDocumentEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputDocumentEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputDocumentEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputDocumentEmpty");
    s.store_class_end();
  }
}

inputDocument::inputDocument()
  : id_()
  , access_hash_()
{}

inputDocument::inputDocument(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputDocument::ID;

void inputDocument::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputDocument::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputDocument");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputEncryptedChat::inputEncryptedChat()
  : chat_id_()
  , access_hash_()
{}

inputEncryptedChat::inputEncryptedChat(std::int32_t chat_id_, std::int64_t access_hash_)
  : chat_id_(chat_id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputEncryptedChat::ID;

void inputEncryptedChat::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputEncryptedChat::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputEncryptedChat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputEncryptedChat");
    s.store_field("chat_id", chat_id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputEncryptedFileEmpty::inputEncryptedFileEmpty() {
}

const std::int32_t inputEncryptedFileEmpty::ID;

void inputEncryptedFileEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputEncryptedFileEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputEncryptedFileEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputEncryptedFileEmpty");
    s.store_class_end();
  }
}

inputEncryptedFileUploaded::inputEncryptedFileUploaded()
  : id_()
  , parts_()
  , md5_checksum_()
  , key_fingerprint_()
{}

inputEncryptedFileUploaded::inputEncryptedFileUploaded(std::int64_t id_, std::int32_t parts_, std::string const &md5_checksum_, std::int32_t key_fingerprint_)
  : id_(id_)
  , parts_(parts_)
  , md5_checksum_(md5_checksum_)
  , key_fingerprint_(key_fingerprint_)
{}

const std::int32_t inputEncryptedFileUploaded::ID;

void inputEncryptedFileUploaded::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreString::store(md5_checksum_, s);
  TlStoreBinary::store(key_fingerprint_, s);
}

void inputEncryptedFileUploaded::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreString::store(md5_checksum_, s);
  TlStoreBinary::store(key_fingerprint_, s);
}

void inputEncryptedFileUploaded::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputEncryptedFileUploaded");
    s.store_field("id", id_);
    s.store_field("parts", parts_);
    s.store_field("md5_checksum", md5_checksum_);
    s.store_field("key_fingerprint", key_fingerprint_);
    s.store_class_end();
  }
}

inputEncryptedFile::inputEncryptedFile()
  : id_()
  , access_hash_()
{}

inputEncryptedFile::inputEncryptedFile(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputEncryptedFile::ID;

void inputEncryptedFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputEncryptedFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputEncryptedFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputEncryptedFile");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputEncryptedFileBigUploaded::inputEncryptedFileBigUploaded()
  : id_()
  , parts_()
  , key_fingerprint_()
{}

inputEncryptedFileBigUploaded::inputEncryptedFileBigUploaded(std::int64_t id_, std::int32_t parts_, std::int32_t key_fingerprint_)
  : id_(id_)
  , parts_(parts_)
  , key_fingerprint_(key_fingerprint_)
{}

const std::int32_t inputEncryptedFileBigUploaded::ID;

void inputEncryptedFileBigUploaded::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreBinary::store(key_fingerprint_, s);
}

void inputEncryptedFileBigUploaded::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreBinary::store(key_fingerprint_, s);
}

void inputEncryptedFileBigUploaded::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputEncryptedFileBigUploaded");
    s.store_field("id", id_);
    s.store_field("parts", parts_);
    s.store_field("key_fingerprint", key_fingerprint_);
    s.store_class_end();
  }
}

inputFile::inputFile()
  : id_()
  , parts_()
  , name_()
  , md5_checksum_()
{}

inputFile::inputFile(std::int64_t id_, std::int32_t parts_, std::string const &name_, std::string const &md5_checksum_)
  : id_(id_)
  , parts_(parts_)
  , name_(name_)
  , md5_checksum_(md5_checksum_)
{}

const std::int32_t inputFile::ID;

void inputFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreString::store(name_, s);
  TlStoreString::store(md5_checksum_, s);
}

void inputFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreString::store(name_, s);
  TlStoreString::store(md5_checksum_, s);
}

void inputFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputFile");
    s.store_field("id", id_);
    s.store_field("parts", parts_);
    s.store_field("name", name_);
    s.store_field("md5_checksum", md5_checksum_);
    s.store_class_end();
  }
}

inputFileBig::inputFileBig()
  : id_()
  , parts_()
  , name_()
{}

inputFileBig::inputFileBig(std::int64_t id_, std::int32_t parts_, std::string const &name_)
  : id_(id_)
  , parts_(parts_)
  , name_(name_)
{}

const std::int32_t inputFileBig::ID;

void inputFileBig::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreString::store(name_, s);
}

void inputFileBig::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreString::store(name_, s);
}

void inputFileBig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputFileBig");
    s.store_field("id", id_);
    s.store_field("parts", parts_);
    s.store_field("name", name_);
    s.store_class_end();
  }
}

inputFileLocation::inputFileLocation()
  : volume_id_()
  , local_id_()
  , secret_()
{}

inputFileLocation::inputFileLocation(std::int64_t volume_id_, std::int32_t local_id_, std::int64_t secret_)
  : volume_id_(volume_id_)
  , local_id_(local_id_)
  , secret_(secret_)
{}

const std::int32_t inputFileLocation::ID;

void inputFileLocation::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(volume_id_, s);
  TlStoreBinary::store(local_id_, s);
  TlStoreBinary::store(secret_, s);
}

void inputFileLocation::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(volume_id_, s);
  TlStoreBinary::store(local_id_, s);
  TlStoreBinary::store(secret_, s);
}

void inputFileLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputFileLocation");
    s.store_field("volume_id", volume_id_);
    s.store_field("local_id", local_id_);
    s.store_field("secret", secret_);
    s.store_class_end();
  }
}

inputEncryptedFileLocation::inputEncryptedFileLocation()
  : id_()
  , access_hash_()
{}

inputEncryptedFileLocation::inputEncryptedFileLocation(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputEncryptedFileLocation::ID;

void inputEncryptedFileLocation::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputEncryptedFileLocation::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputEncryptedFileLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputEncryptedFileLocation");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputDocumentFileLocation::inputDocumentFileLocation()
  : id_()
  , access_hash_()
  , version_()
{}

inputDocumentFileLocation::inputDocumentFileLocation(std::int64_t id_, std::int64_t access_hash_, std::int32_t version_)
  : id_(id_)
  , access_hash_(access_hash_)
  , version_(version_)
{}

const std::int32_t inputDocumentFileLocation::ID;

void inputDocumentFileLocation::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
  TlStoreBinary::store(version_, s);
}

void inputDocumentFileLocation::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
  TlStoreBinary::store(version_, s);
}

void inputDocumentFileLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputDocumentFileLocation");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("version", version_);
    s.store_class_end();
  }
}

inputSecureFileLocation::inputSecureFileLocation()
  : id_()
  , access_hash_()
{}

inputSecureFileLocation::inputSecureFileLocation(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputSecureFileLocation::ID;

void inputSecureFileLocation::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputSecureFileLocation::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputSecureFileLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputSecureFileLocation");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputTakeoutFileLocation::inputTakeoutFileLocation() {
}

const std::int32_t inputTakeoutFileLocation::ID;

void inputTakeoutFileLocation::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputTakeoutFileLocation::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputTakeoutFileLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputTakeoutFileLocation");
    s.store_class_end();
  }
}

inputGameID::inputGameID()
  : id_()
  , access_hash_()
{}

inputGameID::inputGameID(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputGameID::ID;

void inputGameID::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputGameID::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputGameID::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputGameID");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputGameShortName::inputGameShortName()
  : bot_id_()
  , short_name_()
{}

inputGameShortName::inputGameShortName(object_ptr<InputUser> &&bot_id_, std::string const &short_name_)
  : bot_id_(std::move(bot_id_))
  , short_name_(short_name_)
{}

const std::int32_t inputGameShortName::ID;

void inputGameShortName::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(bot_id_, s);
  TlStoreString::store(short_name_, s);
}

void inputGameShortName::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(bot_id_, s);
  TlStoreString::store(short_name_, s);
}

void inputGameShortName::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputGameShortName");
    if (bot_id_ == nullptr) { s.store_field("bot_id", "null"); } else { bot_id_->store(s, "bot_id"); }
    s.store_field("short_name", short_name_);
    s.store_class_end();
  }
}

inputGeoPointEmpty::inputGeoPointEmpty() {
}

const std::int32_t inputGeoPointEmpty::ID;

void inputGeoPointEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputGeoPointEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputGeoPointEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputGeoPointEmpty");
    s.store_class_end();
  }
}

inputGeoPoint::inputGeoPoint()
  : lat_()
  , long_()
{}

inputGeoPoint::inputGeoPoint(double lat_, double long_)
  : lat_(lat_)
  , long_(long_)
{}

const std::int32_t inputGeoPoint::ID;

void inputGeoPoint::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(lat_, s);
  TlStoreBinary::store(long_, s);
}

void inputGeoPoint::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(lat_, s);
  TlStoreBinary::store(long_, s);
}

void inputGeoPoint::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputGeoPoint");
    s.store_field("lat", lat_);
    s.store_field("long", long_);
    s.store_class_end();
  }
}

inputMediaEmpty::inputMediaEmpty() {
}

const std::int32_t inputMediaEmpty::ID;

void inputMediaEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMediaEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMediaEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaEmpty");
    s.store_class_end();
  }
}

inputMediaUploadedPhoto::inputMediaUploadedPhoto()
  : flags_()
  , file_()
  , stickers_()
  , ttl_seconds_()
{}

inputMediaUploadedPhoto::inputMediaUploadedPhoto(std::int32_t flags_, object_ptr<InputFile> &&file_, std::vector<object_ptr<InputDocument>> &&stickers_, std::int32_t ttl_seconds_)
  : flags_(flags_)
  , file_(std::move(file_))
  , stickers_(std::move(stickers_))
  , ttl_seconds_(ttl_seconds_)
{}

const std::int32_t inputMediaUploadedPhoto::ID;

void inputMediaUploadedPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(stickers_, s); }
  if (var0 & 2) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaUploadedPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(stickers_, s); }
  if (var0 & 2) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaUploadedPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaUploadedPhoto");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (file_ == nullptr) { s.store_field("file", "null"); } else { file_->store(s, "file"); }
    if (var0 & 1) { { const std::vector<object_ptr<InputDocument>> &v = stickers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("stickers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 2) { s.store_field("ttl_seconds", ttl_seconds_); }
    s.store_class_end();
  }
}

inputMediaPhoto::inputMediaPhoto()
  : flags_()
  , id_()
  , ttl_seconds_()
{}

inputMediaPhoto::inputMediaPhoto(std::int32_t flags_, object_ptr<InputPhoto> &&id_, std::int32_t ttl_seconds_)
  : flags_(flags_)
  , id_(std::move(id_))
  , ttl_seconds_(ttl_seconds_)
{}

const std::int32_t inputMediaPhoto::ID;

void inputMediaPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  if (var0 & 1) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  if (var0 & 1) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaPhoto");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    if (var0 & 1) { s.store_field("ttl_seconds", ttl_seconds_); }
    s.store_class_end();
  }
}

inputMediaGeoPoint::inputMediaGeoPoint()
  : geo_point_()
{}

inputMediaGeoPoint::inputMediaGeoPoint(object_ptr<InputGeoPoint> &&geo_point_)
  : geo_point_(std::move(geo_point_))
{}

const std::int32_t inputMediaGeoPoint::ID;

void inputMediaGeoPoint::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
}

void inputMediaGeoPoint::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
}

void inputMediaGeoPoint::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaGeoPoint");
    if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); }
    s.store_class_end();
  }
}

inputMediaContact::inputMediaContact()
  : phone_number_()
  , first_name_()
  , last_name_()
  , vcard_()
{}

inputMediaContact::inputMediaContact(std::string const &phone_number_, std::string const &first_name_, std::string const &last_name_, std::string const &vcard_)
  : phone_number_(phone_number_)
  , first_name_(first_name_)
  , last_name_(last_name_)
  , vcard_(vcard_)
{}

const std::int32_t inputMediaContact::ID;

void inputMediaContact::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(first_name_, s);
  TlStoreString::store(last_name_, s);
  TlStoreString::store(vcard_, s);
}

void inputMediaContact::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(first_name_, s);
  TlStoreString::store(last_name_, s);
  TlStoreString::store(vcard_, s);
}

void inputMediaContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaContact");
    s.store_field("phone_number", phone_number_);
    s.store_field("first_name", first_name_);
    s.store_field("last_name", last_name_);
    s.store_field("vcard", vcard_);
    s.store_class_end();
  }
}

inputMediaUploadedDocument::inputMediaUploadedDocument()
  : flags_()
  , nosound_video_()
  , file_()
  , thumb_()
  , mime_type_()
  , attributes_()
  , stickers_()
  , ttl_seconds_()
{}

inputMediaUploadedDocument::inputMediaUploadedDocument(std::int32_t flags_, bool nosound_video_, object_ptr<InputFile> &&file_, object_ptr<InputFile> &&thumb_, std::string const &mime_type_, std::vector<object_ptr<DocumentAttribute>> &&attributes_, std::vector<object_ptr<InputDocument>> &&stickers_, std::int32_t ttl_seconds_)
  : flags_(flags_)
  , nosound_video_(nosound_video_)
  , file_(std::move(file_))
  , thumb_(std::move(thumb_))
  , mime_type_(mime_type_)
  , attributes_(std::move(attributes_))
  , stickers_(std::move(stickers_))
  , ttl_seconds_(ttl_seconds_)
{}

const std::int32_t inputMediaUploadedDocument::ID;

void inputMediaUploadedDocument::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 8) { TlStoreTrue::store(nosound_video_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(thumb_, s); }
  TlStoreString::store(mime_type_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(attributes_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(stickers_, s); }
  if (var0 & 2) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaUploadedDocument::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 8) { TlStoreTrue::store(nosound_video_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(thumb_, s); }
  TlStoreString::store(mime_type_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(attributes_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(stickers_, s); }
  if (var0 & 2) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaUploadedDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaUploadedDocument");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 8) {  }
    if (file_ == nullptr) { s.store_field("file", "null"); } else { file_->store(s, "file"); }
    if (var0 & 4) { if (thumb_ == nullptr) { s.store_field("thumb", "null"); } else { thumb_->store(s, "thumb"); } }
    s.store_field("mime_type", mime_type_);
    { const std::vector<object_ptr<DocumentAttribute>> &v = attributes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("attributes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (var0 & 1) { { const std::vector<object_ptr<InputDocument>> &v = stickers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("stickers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 2) { s.store_field("ttl_seconds", ttl_seconds_); }
    s.store_class_end();
  }
}

inputMediaDocument::inputMediaDocument()
  : flags_()
  , id_()
  , ttl_seconds_()
{}

inputMediaDocument::inputMediaDocument(std::int32_t flags_, object_ptr<InputDocument> &&id_, std::int32_t ttl_seconds_)
  : flags_(flags_)
  , id_(std::move(id_))
  , ttl_seconds_(ttl_seconds_)
{}

const std::int32_t inputMediaDocument::ID;

void inputMediaDocument::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  if (var0 & 1) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaDocument::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  if (var0 & 1) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaDocument");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    if (var0 & 1) { s.store_field("ttl_seconds", ttl_seconds_); }
    s.store_class_end();
  }
}

inputMediaVenue::inputMediaVenue()
  : geo_point_()
  , title_()
  , address_()
  , provider_()
  , venue_id_()
  , venue_type_()
{}

inputMediaVenue::inputMediaVenue(object_ptr<InputGeoPoint> &&geo_point_, std::string const &title_, std::string const &address_, std::string const &provider_, std::string const &venue_id_, std::string const &venue_type_)
  : geo_point_(std::move(geo_point_))
  , title_(title_)
  , address_(address_)
  , provider_(provider_)
  , venue_id_(venue_id_)
  , venue_type_(venue_type_)
{}

const std::int32_t inputMediaVenue::ID;

void inputMediaVenue::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreString::store(title_, s);
  TlStoreString::store(address_, s);
  TlStoreString::store(provider_, s);
  TlStoreString::store(venue_id_, s);
  TlStoreString::store(venue_type_, s);
}

void inputMediaVenue::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreString::store(title_, s);
  TlStoreString::store(address_, s);
  TlStoreString::store(provider_, s);
  TlStoreString::store(venue_id_, s);
  TlStoreString::store(venue_type_, s);
}

void inputMediaVenue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaVenue");
    if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); }
    s.store_field("title", title_);
    s.store_field("address", address_);
    s.store_field("provider", provider_);
    s.store_field("venue_id", venue_id_);
    s.store_field("venue_type", venue_type_);
    s.store_class_end();
  }
}

inputMediaGifExternal::inputMediaGifExternal()
  : url_()
  , q_()
{}

inputMediaGifExternal::inputMediaGifExternal(std::string const &url_, std::string const &q_)
  : url_(url_)
  , q_(q_)
{}

const std::int32_t inputMediaGifExternal::ID;

void inputMediaGifExternal::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(url_, s);
  TlStoreString::store(q_, s);
}

void inputMediaGifExternal::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(url_, s);
  TlStoreString::store(q_, s);
}

void inputMediaGifExternal::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaGifExternal");
    s.store_field("url", url_);
    s.store_field("q", q_);
    s.store_class_end();
  }
}

inputMediaPhotoExternal::inputMediaPhotoExternal()
  : flags_()
  , url_()
  , ttl_seconds_()
{}

inputMediaPhotoExternal::inputMediaPhotoExternal(std::int32_t flags_, std::string const &url_, std::int32_t ttl_seconds_)
  : flags_(flags_)
  , url_(url_)
  , ttl_seconds_(ttl_seconds_)
{}

const std::int32_t inputMediaPhotoExternal::ID;

void inputMediaPhotoExternal::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(url_, s);
  if (var0 & 1) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaPhotoExternal::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(url_, s);
  if (var0 & 1) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaPhotoExternal::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaPhotoExternal");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("url", url_);
    if (var0 & 1) { s.store_field("ttl_seconds", ttl_seconds_); }
    s.store_class_end();
  }
}

inputMediaDocumentExternal::inputMediaDocumentExternal()
  : flags_()
  , url_()
  , ttl_seconds_()
{}

inputMediaDocumentExternal::inputMediaDocumentExternal(std::int32_t flags_, std::string const &url_, std::int32_t ttl_seconds_)
  : flags_(flags_)
  , url_(url_)
  , ttl_seconds_(ttl_seconds_)
{}

const std::int32_t inputMediaDocumentExternal::ID;

void inputMediaDocumentExternal::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(url_, s);
  if (var0 & 1) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaDocumentExternal::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(url_, s);
  if (var0 & 1) { TlStoreBinary::store(ttl_seconds_, s); }
}

void inputMediaDocumentExternal::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaDocumentExternal");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("url", url_);
    if (var0 & 1) { s.store_field("ttl_seconds", ttl_seconds_); }
    s.store_class_end();
  }
}

inputMediaGame::inputMediaGame()
  : id_()
{}

inputMediaGame::inputMediaGame(object_ptr<InputGame> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t inputMediaGame::ID;

void inputMediaGame::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void inputMediaGame::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void inputMediaGame::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaGame");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

inputMediaInvoice::inputMediaInvoice()
  : flags_()
  , title_()
  , description_()
  , photo_()
  , invoice_()
  , payload_()
  , provider_()
  , provider_data_()
  , start_param_()
{}

inputMediaInvoice::inputMediaInvoice(std::int32_t flags_, std::string const &title_, std::string const &description_, object_ptr<inputWebDocument> &&photo_, object_ptr<invoice> &&invoice_, BufferSlice &&payload_, std::string const &provider_, object_ptr<dataJSON> &&provider_data_, std::string const &start_param_)
  : flags_(flags_)
  , title_(title_)
  , description_(description_)
  , photo_(std::move(photo_))
  , invoice_(std::move(invoice_))
  , payload_(std::move(payload_))
  , provider_(provider_)
  , provider_data_(std::move(provider_data_))
  , start_param_(start_param_)
{}

const std::int32_t inputMediaInvoice::ID;

void inputMediaInvoice::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(title_, s);
  TlStoreString::store(description_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -1678949555>::store(photo_, s); }
  TlStoreBoxed<TlStoreObject, -1022713000>::store(invoice_, s);
  TlStoreString::store(payload_, s);
  TlStoreString::store(provider_, s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(provider_data_, s);
  TlStoreString::store(start_param_, s);
}

void inputMediaInvoice::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(title_, s);
  TlStoreString::store(description_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -1678949555>::store(photo_, s); }
  TlStoreBoxed<TlStoreObject, -1022713000>::store(invoice_, s);
  TlStoreString::store(payload_, s);
  TlStoreString::store(provider_, s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(provider_data_, s);
  TlStoreString::store(start_param_, s);
}

void inputMediaInvoice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaInvoice");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("title", title_);
    s.store_field("description", description_);
    if (var0 & 1) { if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); } }
    if (invoice_ == nullptr) { s.store_field("invoice", "null"); } else { invoice_->store(s, "invoice"); }
    s.store_bytes_field("payload", payload_);
    s.store_field("provider", provider_);
    if (provider_data_ == nullptr) { s.store_field("provider_data", "null"); } else { provider_data_->store(s, "provider_data"); }
    s.store_field("start_param", start_param_);
    s.store_class_end();
  }
}

inputMediaGeoLive::inputMediaGeoLive()
  : geo_point_()
  , period_()
{}

inputMediaGeoLive::inputMediaGeoLive(object_ptr<InputGeoPoint> &&geo_point_, std::int32_t period_)
  : geo_point_(std::move(geo_point_))
  , period_(period_)
{}

const std::int32_t inputMediaGeoLive::ID;

void inputMediaGeoLive::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreBinary::store(period_, s);
}

void inputMediaGeoLive::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreBinary::store(period_, s);
}

void inputMediaGeoLive::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMediaGeoLive");
    if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); }
    s.store_field("period", period_);
    s.store_class_end();
  }
}

inputMessageID::inputMessageID()
  : id_()
{}

inputMessageID::inputMessageID(std::int32_t id_)
  : id_(id_)
{}

const std::int32_t inputMessageID::ID;

void inputMessageID::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
}

void inputMessageID::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
}

void inputMessageID::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessageID");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

inputMessageReplyTo::inputMessageReplyTo()
  : id_()
{}

inputMessageReplyTo::inputMessageReplyTo(std::int32_t id_)
  : id_(id_)
{}

const std::int32_t inputMessageReplyTo::ID;

void inputMessageReplyTo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
}

void inputMessageReplyTo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
}

void inputMessageReplyTo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessageReplyTo");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

inputMessagePinned::inputMessagePinned() {
}

const std::int32_t inputMessagePinned::ID;

void inputMessagePinned::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagePinned::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagePinned::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagePinned");
    s.store_class_end();
  }
}

inputNotifyPeer::inputNotifyPeer()
  : peer_()
{}

inputNotifyPeer::inputNotifyPeer(object_ptr<InputPeer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t inputNotifyPeer::ID;

void inputNotifyPeer::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void inputNotifyPeer::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void inputNotifyPeer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputNotifyPeer");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

inputNotifyUsers::inputNotifyUsers() {
}

const std::int32_t inputNotifyUsers::ID;

void inputNotifyUsers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputNotifyUsers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputNotifyUsers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputNotifyUsers");
    s.store_class_end();
  }
}

inputNotifyChats::inputNotifyChats() {
}

const std::int32_t inputNotifyChats::ID;

void inputNotifyChats::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputNotifyChats::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputNotifyChats::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputNotifyChats");
    s.store_class_end();
  }
}

inputPaymentCredentialsSaved::inputPaymentCredentialsSaved()
  : id_()
  , tmp_password_()
{}

inputPaymentCredentialsSaved::inputPaymentCredentialsSaved(std::string const &id_, BufferSlice &&tmp_password_)
  : id_(id_)
  , tmp_password_(std::move(tmp_password_))
{}

const std::int32_t inputPaymentCredentialsSaved::ID;

void inputPaymentCredentialsSaved::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(id_, s);
  TlStoreString::store(tmp_password_, s);
}

void inputPaymentCredentialsSaved::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(id_, s);
  TlStoreString::store(tmp_password_, s);
}

void inputPaymentCredentialsSaved::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPaymentCredentialsSaved");
    s.store_field("id", id_);
    s.store_bytes_field("tmp_password", tmp_password_);
    s.store_class_end();
  }
}

inputPaymentCredentials::inputPaymentCredentials()
  : flags_()
  , save_()
  , data_()
{}

inputPaymentCredentials::inputPaymentCredentials(std::int32_t flags_, bool save_, object_ptr<dataJSON> &&data_)
  : flags_(flags_)
  , save_(save_)
  , data_(std::move(data_))
{}

const std::int32_t inputPaymentCredentials::ID;

void inputPaymentCredentials::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(save_, s); }
  TlStoreBoxed<TlStoreObject, 2104790276>::store(data_, s);
}

void inputPaymentCredentials::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(save_, s); }
  TlStoreBoxed<TlStoreObject, 2104790276>::store(data_, s);
}

void inputPaymentCredentials::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPaymentCredentials");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (data_ == nullptr) { s.store_field("data", "null"); } else { data_->store(s, "data"); }
    s.store_class_end();
  }
}

inputPaymentCredentialsApplePay::inputPaymentCredentialsApplePay()
  : payment_data_()
{}

inputPaymentCredentialsApplePay::inputPaymentCredentialsApplePay(object_ptr<dataJSON> &&payment_data_)
  : payment_data_(std::move(payment_data_))
{}

const std::int32_t inputPaymentCredentialsApplePay::ID;

void inputPaymentCredentialsApplePay::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(payment_data_, s);
}

void inputPaymentCredentialsApplePay::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(payment_data_, s);
}

void inputPaymentCredentialsApplePay::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPaymentCredentialsApplePay");
    if (payment_data_ == nullptr) { s.store_field("payment_data", "null"); } else { payment_data_->store(s, "payment_data"); }
    s.store_class_end();
  }
}

inputPaymentCredentialsAndroidPay::inputPaymentCredentialsAndroidPay()
  : payment_token_()
  , google_transaction_id_()
{}

inputPaymentCredentialsAndroidPay::inputPaymentCredentialsAndroidPay(object_ptr<dataJSON> &&payment_token_, std::string const &google_transaction_id_)
  : payment_token_(std::move(payment_token_))
  , google_transaction_id_(google_transaction_id_)
{}

const std::int32_t inputPaymentCredentialsAndroidPay::ID;

void inputPaymentCredentialsAndroidPay::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(payment_token_, s);
  TlStoreString::store(google_transaction_id_, s);
}

void inputPaymentCredentialsAndroidPay::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(payment_token_, s);
  TlStoreString::store(google_transaction_id_, s);
}

void inputPaymentCredentialsAndroidPay::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPaymentCredentialsAndroidPay");
    if (payment_token_ == nullptr) { s.store_field("payment_token", "null"); } else { payment_token_->store(s, "payment_token"); }
    s.store_field("google_transaction_id", google_transaction_id_);
    s.store_class_end();
  }
}

inputPeerEmpty::inputPeerEmpty() {
}

const std::int32_t inputPeerEmpty::ID;

void inputPeerEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPeerEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPeerEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPeerEmpty");
    s.store_class_end();
  }
}

inputPeerSelf::inputPeerSelf() {
}

const std::int32_t inputPeerSelf::ID;

void inputPeerSelf::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPeerSelf::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPeerSelf::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPeerSelf");
    s.store_class_end();
  }
}

inputPeerChat::inputPeerChat()
  : chat_id_()
{}

inputPeerChat::inputPeerChat(std::int32_t chat_id_)
  : chat_id_(chat_id_)
{}

const std::int32_t inputPeerChat::ID;

void inputPeerChat::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(chat_id_, s);
}

void inputPeerChat::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(chat_id_, s);
}

void inputPeerChat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPeerChat");
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

inputPeerUser::inputPeerUser()
  : user_id_()
  , access_hash_()
{}

inputPeerUser::inputPeerUser(std::int32_t user_id_, std::int64_t access_hash_)
  : user_id_(user_id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputPeerUser::ID;

void inputPeerUser::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(user_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputPeerUser::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(user_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputPeerUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPeerUser");
    s.store_field("user_id", user_id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputPeerChannel::inputPeerChannel()
  : channel_id_()
  , access_hash_()
{}

inputPeerChannel::inputPeerChannel(std::int32_t channel_id_, std::int64_t access_hash_)
  : channel_id_(channel_id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputPeerChannel::ID;

void inputPeerChannel::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(channel_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputPeerChannel::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(channel_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputPeerChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPeerChannel");
    s.store_field("channel_id", channel_id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputPeerNotifySettings::inputPeerNotifySettings()
  : flags_()
  , show_previews_()
  , silent_()
  , mute_until_()
  , sound_()
{}

inputPeerNotifySettings::inputPeerNotifySettings(std::int32_t flags_, bool show_previews_, bool silent_, std::int32_t mute_until_, std::string const &sound_)
  : flags_(flags_)
  , show_previews_(show_previews_)
  , silent_(silent_)
  , mute_until_(mute_until_)
  , sound_(sound_)
{}

const std::int32_t inputPeerNotifySettings::ID;

void inputPeerNotifySettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreBool::store(show_previews_, s); }
  if (var0 & 2) { TlStoreBool::store(silent_, s); }
  if (var0 & 4) { TlStoreBinary::store(mute_until_, s); }
  if (var0 & 8) { TlStoreString::store(sound_, s); }
}

void inputPeerNotifySettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreBool::store(show_previews_, s); }
  if (var0 & 2) { TlStoreBool::store(silent_, s); }
  if (var0 & 4) { TlStoreBinary::store(mute_until_, s); }
  if (var0 & 8) { TlStoreString::store(sound_, s); }
}

void inputPeerNotifySettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPeerNotifySettings");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("show_previews", show_previews_); }
    if (var0 & 2) { s.store_field("silent", silent_); }
    if (var0 & 4) { s.store_field("mute_until", mute_until_); }
    if (var0 & 8) { s.store_field("sound", sound_); }
    s.store_class_end();
  }
}

inputPhoneCall::inputPhoneCall()
  : id_()
  , access_hash_()
{}

inputPhoneCall::inputPhoneCall(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputPhoneCall::ID;

void inputPhoneCall::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputPhoneCall::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputPhoneCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPhoneCall");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputPhotoEmpty::inputPhotoEmpty() {
}

const std::int32_t inputPhotoEmpty::ID;

void inputPhotoEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPhotoEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPhotoEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPhotoEmpty");
    s.store_class_end();
  }
}

inputPhoto::inputPhoto()
  : id_()
  , access_hash_()
{}

inputPhoto::inputPhoto(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputPhoto::ID;

void inputPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPhoto");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputPrivacyKeyStatusTimestamp::inputPrivacyKeyStatusTimestamp() {
}

const std::int32_t inputPrivacyKeyStatusTimestamp::ID;

void inputPrivacyKeyStatusTimestamp::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPrivacyKeyStatusTimestamp::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPrivacyKeyStatusTimestamp::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyKeyStatusTimestamp");
    s.store_class_end();
  }
}

inputPrivacyKeyChatInvite::inputPrivacyKeyChatInvite() {
}

const std::int32_t inputPrivacyKeyChatInvite::ID;

void inputPrivacyKeyChatInvite::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPrivacyKeyChatInvite::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPrivacyKeyChatInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyKeyChatInvite");
    s.store_class_end();
  }
}

inputPrivacyKeyPhoneCall::inputPrivacyKeyPhoneCall() {
}

const std::int32_t inputPrivacyKeyPhoneCall::ID;

void inputPrivacyKeyPhoneCall::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPrivacyKeyPhoneCall::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPrivacyKeyPhoneCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyKeyPhoneCall");
    s.store_class_end();
  }
}

inputPrivacyValueAllowContacts::inputPrivacyValueAllowContacts() {
}

const std::int32_t inputPrivacyValueAllowContacts::ID;

void inputPrivacyValueAllowContacts::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPrivacyValueAllowContacts::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPrivacyValueAllowContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyValueAllowContacts");
    s.store_class_end();
  }
}

inputPrivacyValueAllowAll::inputPrivacyValueAllowAll() {
}

const std::int32_t inputPrivacyValueAllowAll::ID;

void inputPrivacyValueAllowAll::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPrivacyValueAllowAll::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPrivacyValueAllowAll::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyValueAllowAll");
    s.store_class_end();
  }
}

inputPrivacyValueAllowUsers::inputPrivacyValueAllowUsers()
  : users_()
{}

inputPrivacyValueAllowUsers::inputPrivacyValueAllowUsers(std::vector<object_ptr<InputUser>> &&users_)
  : users_(std::move(users_))
{}

const std::int32_t inputPrivacyValueAllowUsers::ID;

void inputPrivacyValueAllowUsers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(users_, s);
}

void inputPrivacyValueAllowUsers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(users_, s);
}

void inputPrivacyValueAllowUsers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyValueAllowUsers");
    { const std::vector<object_ptr<InputUser>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

inputPrivacyValueDisallowContacts::inputPrivacyValueDisallowContacts() {
}

const std::int32_t inputPrivacyValueDisallowContacts::ID;

void inputPrivacyValueDisallowContacts::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPrivacyValueDisallowContacts::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPrivacyValueDisallowContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyValueDisallowContacts");
    s.store_class_end();
  }
}

inputPrivacyValueDisallowAll::inputPrivacyValueDisallowAll() {
}

const std::int32_t inputPrivacyValueDisallowAll::ID;

void inputPrivacyValueDisallowAll::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputPrivacyValueDisallowAll::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputPrivacyValueDisallowAll::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyValueDisallowAll");
    s.store_class_end();
  }
}

inputPrivacyValueDisallowUsers::inputPrivacyValueDisallowUsers()
  : users_()
{}

inputPrivacyValueDisallowUsers::inputPrivacyValueDisallowUsers(std::vector<object_ptr<InputUser>> &&users_)
  : users_(std::move(users_))
{}

const std::int32_t inputPrivacyValueDisallowUsers::ID;

void inputPrivacyValueDisallowUsers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(users_, s);
}

void inputPrivacyValueDisallowUsers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(users_, s);
}

void inputPrivacyValueDisallowUsers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputPrivacyValueDisallowUsers");
    { const std::vector<object_ptr<InputUser>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

inputSecureFileUploaded::inputSecureFileUploaded()
  : id_()
  , parts_()
  , md5_checksum_()
  , file_hash_()
  , secret_()
{}

inputSecureFileUploaded::inputSecureFileUploaded(std::int64_t id_, std::int32_t parts_, std::string const &md5_checksum_, BufferSlice &&file_hash_, BufferSlice &&secret_)
  : id_(id_)
  , parts_(parts_)
  , md5_checksum_(md5_checksum_)
  , file_hash_(std::move(file_hash_))
  , secret_(std::move(secret_))
{}

const std::int32_t inputSecureFileUploaded::ID;

void inputSecureFileUploaded::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreString::store(md5_checksum_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(secret_, s);
}

void inputSecureFileUploaded::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(parts_, s);
  TlStoreString::store(md5_checksum_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(secret_, s);
}

void inputSecureFileUploaded::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputSecureFileUploaded");
    s.store_field("id", id_);
    s.store_field("parts", parts_);
    s.store_field("md5_checksum", md5_checksum_);
    s.store_bytes_field("file_hash", file_hash_);
    s.store_bytes_field("secret", secret_);
    s.store_class_end();
  }
}

inputSecureFile::inputSecureFile()
  : id_()
  , access_hash_()
{}

inputSecureFile::inputSecureFile(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputSecureFile::ID;

void inputSecureFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputSecureFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputSecureFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputSecureFile");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputSecureValue::inputSecureValue()
  : flags_()
  , type_()
  , data_()
  , front_side_()
  , reverse_side_()
  , selfie_()
  , translation_()
  , files_()
  , plain_data_()
{}

inputSecureValue::inputSecureValue(std::int32_t flags_, object_ptr<SecureValueType> &&type_, object_ptr<secureData> &&data_, object_ptr<InputSecureFile> &&front_side_, object_ptr<InputSecureFile> &&reverse_side_, object_ptr<InputSecureFile> &&selfie_, std::vector<object_ptr<InputSecureFile>> &&translation_, std::vector<object_ptr<InputSecureFile>> &&files_, object_ptr<SecurePlainData> &&plain_data_)
  : flags_(flags_)
  , type_(std::move(type_))
  , data_(std::move(data_))
  , front_side_(std::move(front_side_))
  , reverse_side_(std::move(reverse_side_))
  , selfie_(std::move(selfie_))
  , translation_(std::move(translation_))
  , files_(std::move(files_))
  , plain_data_(std::move(plain_data_))
{}

const std::int32_t inputSecureValue::ID;

void inputSecureValue::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -1964327229>::store(data_, s); }
  if (var0 & 2) { TlStoreBoxedUnknown<TlStoreObject>::store(front_side_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reverse_side_, s); }
  if (var0 & 8) { TlStoreBoxedUnknown<TlStoreObject>::store(selfie_, s); }
  if (var0 & 64) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(translation_, s); }
  if (var0 & 16) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(files_, s); }
  if (var0 & 32) { TlStoreBoxedUnknown<TlStoreObject>::store(plain_data_, s); }
}

void inputSecureValue::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -1964327229>::store(data_, s); }
  if (var0 & 2) { TlStoreBoxedUnknown<TlStoreObject>::store(front_side_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reverse_side_, s); }
  if (var0 & 8) { TlStoreBoxedUnknown<TlStoreObject>::store(selfie_, s); }
  if (var0 & 64) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(translation_, s); }
  if (var0 & 16) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(files_, s); }
  if (var0 & 32) { TlStoreBoxedUnknown<TlStoreObject>::store(plain_data_, s); }
}

void inputSecureValue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputSecureValue");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    if (var0 & 1) { if (data_ == nullptr) { s.store_field("data", "null"); } else { data_->store(s, "data"); } }
    if (var0 & 2) { if (front_side_ == nullptr) { s.store_field("front_side", "null"); } else { front_side_->store(s, "front_side"); } }
    if (var0 & 4) { if (reverse_side_ == nullptr) { s.store_field("reverse_side", "null"); } else { reverse_side_->store(s, "reverse_side"); } }
    if (var0 & 8) { if (selfie_ == nullptr) { s.store_field("selfie", "null"); } else { selfie_->store(s, "selfie"); } }
    if (var0 & 64) { { const std::vector<object_ptr<InputSecureFile>> &v = translation_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("translation", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 16) { { const std::vector<object_ptr<InputSecureFile>> &v = files_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("files", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 32) { if (plain_data_ == nullptr) { s.store_field("plain_data", "null"); } else { plain_data_->store(s, "plain_data"); } }
    s.store_class_end();
  }
}

inputSingleMedia::inputSingleMedia()
  : flags_()
  , media_()
  , random_id_()
  , message_()
  , entities_()
{}

inputSingleMedia::inputSingleMedia(std::int32_t flags_, object_ptr<InputMedia> &&media_, std::int64_t random_id_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , media_(std::move(media_))
  , random_id_(random_id_)
  , message_(message_)
  , entities_(std::move(entities_))
{}

const std::int32_t inputSingleMedia::ID;

void inputSingleMedia::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(media_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(message_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void inputSingleMedia::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(media_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(message_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void inputSingleMedia::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputSingleMedia");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); }
    s.store_field("random_id", random_id_);
    s.store_field("message", message_);
    if (var0 & 1) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

object_ptr<InputStickerSet> InputStickerSet::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case inputStickerSetEmpty::ID:
      return inputStickerSetEmpty::fetch(p);
    case inputStickerSetID::ID:
      return inputStickerSetID::fetch(p);
    case inputStickerSetShortName::ID:
      return inputStickerSetShortName::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

inputStickerSetEmpty::inputStickerSetEmpty() {
}

const std::int32_t inputStickerSetEmpty::ID;

inputStickerSetEmpty::inputStickerSetEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void inputStickerSetEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputStickerSetEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputStickerSetEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputStickerSetEmpty");
    s.store_class_end();
  }
}

inputStickerSetID::inputStickerSetID()
  : id_()
  , access_hash_()
{}

inputStickerSetID::inputStickerSetID(std::int64_t id_, std::int64_t access_hash_)
  : id_(id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputStickerSetID::ID;

inputStickerSetID::inputStickerSetID(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , access_hash_(TlFetchLong::parse(p))
#undef FAIL
{}

void inputStickerSetID::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputStickerSetID::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputStickerSetID::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputStickerSetID");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputStickerSetShortName::inputStickerSetShortName()
  : short_name_()
{}

inputStickerSetShortName::inputStickerSetShortName(std::string const &short_name_)
  : short_name_(short_name_)
{}

const std::int32_t inputStickerSetShortName::ID;

inputStickerSetShortName::inputStickerSetShortName(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : short_name_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void inputStickerSetShortName::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(short_name_, s);
}

void inputStickerSetShortName::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(short_name_, s);
}

void inputStickerSetShortName::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputStickerSetShortName");
    s.store_field("short_name", short_name_);
    s.store_class_end();
  }
}

inputStickerSetItem::inputStickerSetItem()
  : flags_()
  , document_()
  , emoji_()
  , mask_coords_()
{}

inputStickerSetItem::inputStickerSetItem(std::int32_t flags_, object_ptr<InputDocument> &&document_, std::string const &emoji_, object_ptr<maskCoords> &&mask_coords_)
  : flags_(flags_)
  , document_(std::move(document_))
  , emoji_(emoji_)
  , mask_coords_(std::move(mask_coords_))
{}

const std::int32_t inputStickerSetItem::ID;

void inputStickerSetItem::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(document_, s);
  TlStoreString::store(emoji_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -1361650766>::store(mask_coords_, s); }
}

void inputStickerSetItem::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(document_, s);
  TlStoreString::store(emoji_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -1361650766>::store(mask_coords_, s); }
}

void inputStickerSetItem::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputStickerSetItem");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (document_ == nullptr) { s.store_field("document", "null"); } else { document_->store(s, "document"); }
    s.store_field("emoji", emoji_);
    if (var0 & 1) { if (mask_coords_ == nullptr) { s.store_field("mask_coords", "null"); } else { mask_coords_->store(s, "mask_coords"); } }
    s.store_class_end();
  }
}

inputStickeredMediaPhoto::inputStickeredMediaPhoto()
  : id_()
{}

inputStickeredMediaPhoto::inputStickeredMediaPhoto(object_ptr<InputPhoto> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t inputStickeredMediaPhoto::ID;

void inputStickeredMediaPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void inputStickeredMediaPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void inputStickeredMediaPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputStickeredMediaPhoto");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

inputStickeredMediaDocument::inputStickeredMediaDocument()
  : id_()
{}

inputStickeredMediaDocument::inputStickeredMediaDocument(object_ptr<InputDocument> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t inputStickeredMediaDocument::ID;

void inputStickeredMediaDocument::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void inputStickeredMediaDocument::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void inputStickeredMediaDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputStickeredMediaDocument");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

object_ptr<InputUser> InputUser::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case inputUserEmpty::ID:
      return inputUserEmpty::fetch(p);
    case inputUserSelf::ID:
      return inputUserSelf::fetch(p);
    case inputUser::ID:
      return inputUser::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

inputUserEmpty::inputUserEmpty() {
}

const std::int32_t inputUserEmpty::ID;

inputUserEmpty::inputUserEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void inputUserEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputUserEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputUserEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputUserEmpty");
    s.store_class_end();
  }
}

inputUserSelf::inputUserSelf() {
}

const std::int32_t inputUserSelf::ID;

inputUserSelf::inputUserSelf(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void inputUserSelf::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputUserSelf::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputUserSelf::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputUserSelf");
    s.store_class_end();
  }
}

inputUser::inputUser()
  : user_id_()
  , access_hash_()
{}

inputUser::inputUser(std::int32_t user_id_, std::int64_t access_hash_)
  : user_id_(user_id_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputUser::ID;

inputUser::inputUser(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , access_hash_(TlFetchLong::parse(p))
#undef FAIL
{}

void inputUser::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(user_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputUser::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(user_id_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputUser");
    s.store_field("user_id", user_id_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputWebDocument::inputWebDocument()
  : url_()
  , size_()
  , mime_type_()
  , attributes_()
{}

inputWebDocument::inputWebDocument(std::string const &url_, std::int32_t size_, std::string const &mime_type_, std::vector<object_ptr<DocumentAttribute>> &&attributes_)
  : url_(url_)
  , size_(size_)
  , mime_type_(mime_type_)
  , attributes_(std::move(attributes_))
{}

const std::int32_t inputWebDocument::ID;

void inputWebDocument::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(url_, s);
  TlStoreBinary::store(size_, s);
  TlStoreString::store(mime_type_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(attributes_, s);
}

void inputWebDocument::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(url_, s);
  TlStoreBinary::store(size_, s);
  TlStoreString::store(mime_type_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(attributes_, s);
}

void inputWebDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputWebDocument");
    s.store_field("url", url_);
    s.store_field("size", size_);
    s.store_field("mime_type", mime_type_);
    { const std::vector<object_ptr<DocumentAttribute>> &v = attributes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("attributes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

inputWebFileLocation::inputWebFileLocation()
  : url_()
  , access_hash_()
{}

inputWebFileLocation::inputWebFileLocation(std::string const &url_, std::int64_t access_hash_)
  : url_(url_)
  , access_hash_(access_hash_)
{}

const std::int32_t inputWebFileLocation::ID;

void inputWebFileLocation::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(url_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputWebFileLocation::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(url_, s);
  TlStoreBinary::store(access_hash_, s);
}

void inputWebFileLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputWebFileLocation");
    s.store_field("url", url_);
    s.store_field("access_hash", access_hash_);
    s.store_class_end();
  }
}

inputWebFileGeoPointLocation::inputWebFileGeoPointLocation()
  : geo_point_()
  , access_hash_()
  , w_()
  , h_()
  , zoom_()
  , scale_()
{}

inputWebFileGeoPointLocation::inputWebFileGeoPointLocation(object_ptr<InputGeoPoint> &&geo_point_, std::int64_t access_hash_, std::int32_t w_, std::int32_t h_, std::int32_t zoom_, std::int32_t scale_)
  : geo_point_(std::move(geo_point_))
  , access_hash_(access_hash_)
  , w_(w_)
  , h_(h_)
  , zoom_(zoom_)
  , scale_(scale_)
{}

const std::int32_t inputWebFileGeoPointLocation::ID;

void inputWebFileGeoPointLocation::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreBinary::store(access_hash_, s);
  TlStoreBinary::store(w_, s);
  TlStoreBinary::store(h_, s);
  TlStoreBinary::store(zoom_, s);
  TlStoreBinary::store(scale_, s);
}

void inputWebFileGeoPointLocation::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s);
  TlStoreBinary::store(access_hash_, s);
  TlStoreBinary::store(w_, s);
  TlStoreBinary::store(h_, s);
  TlStoreBinary::store(zoom_, s);
  TlStoreBinary::store(scale_, s);
}

void inputWebFileGeoPointLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputWebFileGeoPointLocation");
    if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); }
    s.store_field("access_hash", access_hash_);
    s.store_field("w", w_);
    s.store_field("h", h_);
    s.store_field("zoom", zoom_);
    s.store_field("scale", scale_);
    s.store_class_end();
  }
}

invoice::invoice()
  : flags_()
  , test_()
  , name_requested_()
  , phone_requested_()
  , email_requested_()
  , shipping_address_requested_()
  , flexible_()
  , phone_to_provider_()
  , email_to_provider_()
  , currency_()
  , prices_()
{}

invoice::invoice(std::int32_t flags_, bool test_, bool name_requested_, bool phone_requested_, bool email_requested_, bool shipping_address_requested_, bool flexible_, bool phone_to_provider_, bool email_to_provider_, std::string const &currency_, std::vector<object_ptr<labeledPrice>> &&prices_)
  : flags_(flags_)
  , test_(test_)
  , name_requested_(name_requested_)
  , phone_requested_(phone_requested_)
  , email_requested_(email_requested_)
  , shipping_address_requested_(shipping_address_requested_)
  , flexible_(flexible_)
  , phone_to_provider_(phone_to_provider_)
  , email_to_provider_(email_to_provider_)
  , currency_(currency_)
  , prices_(std::move(prices_))
{}

const std::int32_t invoice::ID;

object_ptr<invoice> invoice::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<invoice> res = make_tl_object<invoice>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->test_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->name_requested_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->phone_requested_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->email_requested_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->shipping_address_requested_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->flexible_ = TlFetchTrue::parse(p); }
  if (var0 & 64) { res->phone_to_provider_ = TlFetchTrue::parse(p); }
  if (var0 & 128) { res->email_to_provider_ = TlFetchTrue::parse(p); }
  res->currency_ = TlFetchString<std::string>::parse(p);
  res->prices_ = TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<labeledPrice>, -886477832>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void invoice::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(test_, s); }
  if (var0 & 2) { TlStoreTrue::store(name_requested_, s); }
  if (var0 & 4) { TlStoreTrue::store(phone_requested_, s); }
  if (var0 & 8) { TlStoreTrue::store(email_requested_, s); }
  if (var0 & 16) { TlStoreTrue::store(shipping_address_requested_, s); }
  if (var0 & 32) { TlStoreTrue::store(flexible_, s); }
  if (var0 & 64) { TlStoreTrue::store(phone_to_provider_, s); }
  if (var0 & 128) { TlStoreTrue::store(email_to_provider_, s); }
  TlStoreString::store(currency_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -886477832>>, 481674261>::store(prices_, s);
}

void invoice::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(test_, s); }
  if (var0 & 2) { TlStoreTrue::store(name_requested_, s); }
  if (var0 & 4) { TlStoreTrue::store(phone_requested_, s); }
  if (var0 & 8) { TlStoreTrue::store(email_requested_, s); }
  if (var0 & 16) { TlStoreTrue::store(shipping_address_requested_, s); }
  if (var0 & 32) { TlStoreTrue::store(flexible_, s); }
  if (var0 & 64) { TlStoreTrue::store(phone_to_provider_, s); }
  if (var0 & 128) { TlStoreTrue::store(email_to_provider_, s); }
  TlStoreString::store(currency_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -886477832>>, 481674261>::store(prices_, s);
}

void invoice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "invoice");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    s.store_field("currency", currency_);
    { const std::vector<object_ptr<labeledPrice>> &v = prices_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("prices", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<IpPort> IpPort::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case ipPort::ID:
      return ipPort::fetch(p);
    case ipPortSecret::ID:
      return ipPortSecret::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

ipPort::ipPort()
  : ipv4_()
  , port_()
{}

ipPort::ipPort(std::int32_t ipv4_, std::int32_t port_)
  : ipv4_(ipv4_)
  , port_(port_)
{}

const std::int32_t ipPort::ID;

ipPort::ipPort(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : ipv4_(TlFetchInt::parse(p))
  , port_(TlFetchInt::parse(p))
#undef FAIL
{}

void ipPort::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "ipPort");
    s.store_field("ipv4", ipv4_);
    s.store_field("port", port_);
    s.store_class_end();
  }
}

ipPortSecret::ipPortSecret()
  : ipv4_()
  , port_()
  , secret_()
{}

ipPortSecret::ipPortSecret(std::int32_t ipv4_, std::int32_t port_, BufferSlice &&secret_)
  : ipv4_(ipv4_)
  , port_(port_)
  , secret_(std::move(secret_))
{}

const std::int32_t ipPortSecret::ID;

ipPortSecret::ipPortSecret(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : ipv4_(TlFetchInt::parse(p))
  , port_(TlFetchInt::parse(p))
  , secret_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void ipPortSecret::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "ipPortSecret");
    s.store_field("ipv4", ipv4_);
    s.store_field("port", port_);
    s.store_bytes_field("secret", secret_);
    s.store_class_end();
  }
}

object_ptr<KeyboardButton> KeyboardButton::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case keyboardButton::ID:
      return keyboardButton::fetch(p);
    case keyboardButtonUrl::ID:
      return keyboardButtonUrl::fetch(p);
    case keyboardButtonCallback::ID:
      return keyboardButtonCallback::fetch(p);
    case keyboardButtonRequestPhone::ID:
      return keyboardButtonRequestPhone::fetch(p);
    case keyboardButtonRequestGeoLocation::ID:
      return keyboardButtonRequestGeoLocation::fetch(p);
    case keyboardButtonSwitchInline::ID:
      return keyboardButtonSwitchInline::fetch(p);
    case keyboardButtonGame::ID:
      return keyboardButtonGame::fetch(p);
    case keyboardButtonBuy::ID:
      return keyboardButtonBuy::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

keyboardButton::keyboardButton()
  : text_()
{}

keyboardButton::keyboardButton(std::string const &text_)
  : text_(text_)
{}

const std::int32_t keyboardButton::ID;

keyboardButton::keyboardButton(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void keyboardButton::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButton::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButton::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButton");
    s.store_field("text", text_);
    s.store_class_end();
  }
}

keyboardButtonUrl::keyboardButtonUrl()
  : text_()
  , url_()
{}

keyboardButtonUrl::keyboardButtonUrl(std::string const &text_, std::string const &url_)
  : text_(text_)
  , url_(url_)
{}

const std::int32_t keyboardButtonUrl::ID;

keyboardButtonUrl::keyboardButtonUrl(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
  , url_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void keyboardButtonUrl::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
  TlStoreString::store(url_, s);
}

void keyboardButtonUrl::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
  TlStoreString::store(url_, s);
}

void keyboardButtonUrl::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButtonUrl");
    s.store_field("text", text_);
    s.store_field("url", url_);
    s.store_class_end();
  }
}

keyboardButtonCallback::keyboardButtonCallback()
  : text_()
  , data_()
{}

keyboardButtonCallback::keyboardButtonCallback(std::string const &text_, BufferSlice &&data_)
  : text_(text_)
  , data_(std::move(data_))
{}

const std::int32_t keyboardButtonCallback::ID;

keyboardButtonCallback::keyboardButtonCallback(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
  , data_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void keyboardButtonCallback::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
  TlStoreString::store(data_, s);
}

void keyboardButtonCallback::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
  TlStoreString::store(data_, s);
}

void keyboardButtonCallback::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButtonCallback");
    s.store_field("text", text_);
    s.store_bytes_field("data", data_);
    s.store_class_end();
  }
}

keyboardButtonRequestPhone::keyboardButtonRequestPhone()
  : text_()
{}

keyboardButtonRequestPhone::keyboardButtonRequestPhone(std::string const &text_)
  : text_(text_)
{}

const std::int32_t keyboardButtonRequestPhone::ID;

keyboardButtonRequestPhone::keyboardButtonRequestPhone(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void keyboardButtonRequestPhone::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButtonRequestPhone::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButtonRequestPhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButtonRequestPhone");
    s.store_field("text", text_);
    s.store_class_end();
  }
}

keyboardButtonRequestGeoLocation::keyboardButtonRequestGeoLocation()
  : text_()
{}

keyboardButtonRequestGeoLocation::keyboardButtonRequestGeoLocation(std::string const &text_)
  : text_(text_)
{}

const std::int32_t keyboardButtonRequestGeoLocation::ID;

keyboardButtonRequestGeoLocation::keyboardButtonRequestGeoLocation(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void keyboardButtonRequestGeoLocation::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButtonRequestGeoLocation::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButtonRequestGeoLocation::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButtonRequestGeoLocation");
    s.store_field("text", text_);
    s.store_class_end();
  }
}

keyboardButtonSwitchInline::keyboardButtonSwitchInline()
  : flags_()
  , same_peer_()
  , text_()
  , query_()
{}

keyboardButtonSwitchInline::keyboardButtonSwitchInline(std::int32_t flags_, bool same_peer_, std::string const &text_, std::string const &query_)
  : flags_(flags_)
  , same_peer_(same_peer_)
  , text_(text_)
  , query_(query_)
{}

const std::int32_t keyboardButtonSwitchInline::ID;

object_ptr<keyboardButtonSwitchInline> keyboardButtonSwitchInline::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<keyboardButtonSwitchInline> res = make_tl_object<keyboardButtonSwitchInline>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->same_peer_ = TlFetchTrue::parse(p); }
  res->text_ = TlFetchString<std::string>::parse(p);
  res->query_ = TlFetchString<std::string>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void keyboardButtonSwitchInline::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(same_peer_, s); }
  TlStoreString::store(text_, s);
  TlStoreString::store(query_, s);
}

void keyboardButtonSwitchInline::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(same_peer_, s); }
  TlStoreString::store(text_, s);
  TlStoreString::store(query_, s);
}

void keyboardButtonSwitchInline::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButtonSwitchInline");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("text", text_);
    s.store_field("query", query_);
    s.store_class_end();
  }
}

keyboardButtonGame::keyboardButtonGame()
  : text_()
{}

keyboardButtonGame::keyboardButtonGame(std::string const &text_)
  : text_(text_)
{}

const std::int32_t keyboardButtonGame::ID;

keyboardButtonGame::keyboardButtonGame(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void keyboardButtonGame::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButtonGame::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButtonGame::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButtonGame");
    s.store_field("text", text_);
    s.store_class_end();
  }
}

keyboardButtonBuy::keyboardButtonBuy()
  : text_()
{}

keyboardButtonBuy::keyboardButtonBuy(std::string const &text_)
  : text_(text_)
{}

const std::int32_t keyboardButtonBuy::ID;

keyboardButtonBuy::keyboardButtonBuy(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void keyboardButtonBuy::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButtonBuy::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void keyboardButtonBuy::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButtonBuy");
    s.store_field("text", text_);
    s.store_class_end();
  }
}

keyboardButtonRow::keyboardButtonRow()
  : buttons_()
{}

keyboardButtonRow::keyboardButtonRow(std::vector<object_ptr<KeyboardButton>> &&buttons_)
  : buttons_(std::move(buttons_))
{}

const std::int32_t keyboardButtonRow::ID;

keyboardButtonRow::keyboardButtonRow(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : buttons_(TlFetchBoxed<TlFetchVector<TlFetchObject<KeyboardButton>>, 481674261>::parse(p))
#undef FAIL
{}

void keyboardButtonRow::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(buttons_, s);
}

void keyboardButtonRow::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(buttons_, s);
}

void keyboardButtonRow::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "keyboardButtonRow");
    { const std::vector<object_ptr<KeyboardButton>> &v = buttons_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("buttons", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

labeledPrice::labeledPrice()
  : label_()
  , amount_()
{}

labeledPrice::labeledPrice(std::string const &label_, std::int64_t amount_)
  : label_(label_)
  , amount_(amount_)
{}

const std::int32_t labeledPrice::ID;

labeledPrice::labeledPrice(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : label_(TlFetchString<std::string>::parse(p))
  , amount_(TlFetchLong::parse(p))
#undef FAIL
{}

void labeledPrice::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(label_, s);
  TlStoreBinary::store(amount_, s);
}

void labeledPrice::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(label_, s);
  TlStoreBinary::store(amount_, s);
}

void labeledPrice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "labeledPrice");
    s.store_field("label", label_);
    s.store_field("amount", amount_);
    s.store_class_end();
  }
}

langPackDifference::langPackDifference()
  : lang_code_()
  , from_version_()
  , version_()
  , strings_()
{}

langPackDifference::langPackDifference(std::string const &lang_code_, std::int32_t from_version_, std::int32_t version_, std::vector<object_ptr<LangPackString>> &&strings_)
  : lang_code_(lang_code_)
  , from_version_(from_version_)
  , version_(version_)
  , strings_(std::move(strings_))
{}

const std::int32_t langPackDifference::ID;

langPackDifference::langPackDifference(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : lang_code_(TlFetchString<std::string>::parse(p))
  , from_version_(TlFetchInt::parse(p))
  , version_(TlFetchInt::parse(p))
  , strings_(TlFetchBoxed<TlFetchVector<TlFetchObject<LangPackString>>, 481674261>::parse(p))
#undef FAIL
{}

void langPackDifference::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langPackDifference");
    s.store_field("lang_code", lang_code_);
    s.store_field("from_version", from_version_);
    s.store_field("version", version_);
    { const std::vector<object_ptr<LangPackString>> &v = strings_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("strings", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

langPackLanguage::langPackLanguage()
  : name_()
  , native_name_()
  , lang_code_()
{}

langPackLanguage::langPackLanguage(std::string const &name_, std::string const &native_name_, std::string const &lang_code_)
  : name_(name_)
  , native_name_(native_name_)
  , lang_code_(lang_code_)
{}

const std::int32_t langPackLanguage::ID;

langPackLanguage::langPackLanguage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : name_(TlFetchString<std::string>::parse(p))
  , native_name_(TlFetchString<std::string>::parse(p))
  , lang_code_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void langPackLanguage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langPackLanguage");
    s.store_field("name", name_);
    s.store_field("native_name", native_name_);
    s.store_field("lang_code", lang_code_);
    s.store_class_end();
  }
}

object_ptr<LangPackString> LangPackString::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case langPackString::ID:
      return langPackString::fetch(p);
    case langPackStringPluralized::ID:
      return langPackStringPluralized::fetch(p);
    case langPackStringDeleted::ID:
      return langPackStringDeleted::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

langPackString::langPackString()
  : key_()
  , value_()
{}

langPackString::langPackString(std::string const &key_, std::string const &value_)
  : key_(key_)
  , value_(value_)
{}

const std::int32_t langPackString::ID;

langPackString::langPackString(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : key_(TlFetchString<std::string>::parse(p))
  , value_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void langPackString::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langPackString");
    s.store_field("key", key_);
    s.store_field("value", value_);
    s.store_class_end();
  }
}

langPackStringPluralized::langPackStringPluralized()
  : flags_()
  , key_()
  , zero_value_()
  , one_value_()
  , two_value_()
  , few_value_()
  , many_value_()
  , other_value_()
{}

langPackStringPluralized::langPackStringPluralized(std::int32_t flags_, std::string const &key_, std::string const &zero_value_, std::string const &one_value_, std::string const &two_value_, std::string const &few_value_, std::string const &many_value_, std::string const &other_value_)
  : flags_(flags_)
  , key_(key_)
  , zero_value_(zero_value_)
  , one_value_(one_value_)
  , two_value_(two_value_)
  , few_value_(few_value_)
  , many_value_(many_value_)
  , other_value_(other_value_)
{}

const std::int32_t langPackStringPluralized::ID;

object_ptr<langPackStringPluralized> langPackStringPluralized::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<langPackStringPluralized> res = make_tl_object<langPackStringPluralized>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->key_ = TlFetchString<std::string>::parse(p);
  if (var0 & 1) { res->zero_value_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 2) { res->one_value_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->two_value_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 8) { res->few_value_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16) { res->many_value_ = TlFetchString<std::string>::parse(p); }
  res->other_value_ = TlFetchString<std::string>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void langPackStringPluralized::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langPackStringPluralized");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("key", key_);
    if (var0 & 1) { s.store_field("zero_value", zero_value_); }
    if (var0 & 2) { s.store_field("one_value", one_value_); }
    if (var0 & 4) { s.store_field("two_value", two_value_); }
    if (var0 & 8) { s.store_field("few_value", few_value_); }
    if (var0 & 16) { s.store_field("many_value", many_value_); }
    s.store_field("other_value", other_value_);
    s.store_class_end();
  }
}

langPackStringDeleted::langPackStringDeleted()
  : key_()
{}

langPackStringDeleted::langPackStringDeleted(std::string const &key_)
  : key_(key_)
{}

const std::int32_t langPackStringDeleted::ID;

langPackStringDeleted::langPackStringDeleted(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : key_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void langPackStringDeleted::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langPackStringDeleted");
    s.store_field("key", key_);
    s.store_class_end();
  }
}

maskCoords::maskCoords()
  : n_()
  , x_()
  , y_()
  , zoom_()
{}

maskCoords::maskCoords(std::int32_t n_, double x_, double y_, double zoom_)
  : n_(n_)
  , x_(x_)
  , y_(y_)
  , zoom_(zoom_)
{}

const std::int32_t maskCoords::ID;

maskCoords::maskCoords(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : n_(TlFetchInt::parse(p))
  , x_(TlFetchDouble::parse(p))
  , y_(TlFetchDouble::parse(p))
  , zoom_(TlFetchDouble::parse(p))
#undef FAIL
{}

void maskCoords::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(n_, s);
  TlStoreBinary::store(x_, s);
  TlStoreBinary::store(y_, s);
  TlStoreBinary::store(zoom_, s);
}

void maskCoords::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(n_, s);
  TlStoreBinary::store(x_, s);
  TlStoreBinary::store(y_, s);
  TlStoreBinary::store(zoom_, s);
}

void maskCoords::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "maskCoords");
    s.store_field("n", n_);
    s.store_field("x", x_);
    s.store_field("y", y_);
    s.store_field("zoom", zoom_);
    s.store_class_end();
  }
}

object_ptr<Message> Message::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messageEmpty::ID:
      return messageEmpty::fetch(p);
    case message::ID:
      return message::fetch(p);
    case messageService::ID:
      return messageService::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messageEmpty::messageEmpty()
  : id_()
{}

messageEmpty::messageEmpty(std::int32_t id_)
  : id_(id_)
{}

const std::int32_t messageEmpty::ID;

messageEmpty::messageEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEmpty");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

message::message()
  : flags_()
  , out_()
  , mentioned_()
  , media_unread_()
  , silent_()
  , post_()
  , id_()
  , from_id_()
  , to_id_()
  , fwd_from_()
  , via_bot_id_()
  , reply_to_msg_id_()
  , date_()
  , message_()
  , media_()
  , reply_markup_()
  , entities_()
  , views_()
  , edit_date_()
  , post_author_()
  , grouped_id_()
{}

message::message(std::int32_t flags_, bool out_, bool mentioned_, bool media_unread_, bool silent_, bool post_, std::int32_t id_, std::int32_t from_id_, object_ptr<Peer> &&to_id_, object_ptr<messageFwdHeader> &&fwd_from_, std::int32_t via_bot_id_, std::int32_t reply_to_msg_id_, std::int32_t date_, std::string const &message_, object_ptr<MessageMedia> &&media_, object_ptr<ReplyMarkup> &&reply_markup_, std::vector<object_ptr<MessageEntity>> &&entities_, std::int32_t views_, std::int32_t edit_date_, std::string const &post_author_, std::int64_t grouped_id_)
  : flags_(flags_)
  , out_(out_)
  , mentioned_(mentioned_)
  , media_unread_(media_unread_)
  , silent_(silent_)
  , post_(post_)
  , id_(id_)
  , from_id_(from_id_)
  , to_id_(std::move(to_id_))
  , fwd_from_(std::move(fwd_from_))
  , via_bot_id_(via_bot_id_)
  , reply_to_msg_id_(reply_to_msg_id_)
  , date_(date_)
  , message_(message_)
  , media_(std::move(media_))
  , reply_markup_(std::move(reply_markup_))
  , entities_(std::move(entities_))
  , views_(views_)
  , edit_date_(edit_date_)
  , post_author_(post_author_)
  , grouped_id_(grouped_id_)
{}

const std::int32_t message::ID;

object_ptr<message> message::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<message> res = make_tl_object<message>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->out_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->mentioned_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->media_unread_ = TlFetchTrue::parse(p); }
  if (var0 & 8192) { res->silent_ = TlFetchTrue::parse(p); }
  if (var0 & 16384) { res->post_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  if (var0 & 256) { res->from_id_ = TlFetchInt::parse(p); }
  res->to_id_ = TlFetchObject<Peer>::parse(p);
  if (var0 & 4) { res->fwd_from_ = TlFetchBoxed<TlFetchObject<messageFwdHeader>, 1436466797>::parse(p); }
  if (var0 & 2048) { res->via_bot_id_ = TlFetchInt::parse(p); }
  if (var0 & 8) { res->reply_to_msg_id_ = TlFetchInt::parse(p); }
  res->date_ = TlFetchInt::parse(p);
  res->message_ = TlFetchString<std::string>::parse(p);
  if (var0 & 512) { res->media_ = TlFetchObject<MessageMedia>::parse(p); }
  if (var0 & 64) { res->reply_markup_ = TlFetchObject<ReplyMarkup>::parse(p); }
  if (var0 & 128) { res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p); }
  if (var0 & 1024) { res->views_ = TlFetchInt::parse(p); }
  if (var0 & 32768) { res->edit_date_ = TlFetchInt::parse(p); }
  if (var0 & 65536) { res->post_author_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 131072) { res->grouped_id_ = TlFetchLong::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void message::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "message");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 8192) {  }
    if (var0 & 16384) {  }
    s.store_field("id", id_);
    if (var0 & 256) { s.store_field("from_id", from_id_); }
    if (to_id_ == nullptr) { s.store_field("to_id", "null"); } else { to_id_->store(s, "to_id"); }
    if (var0 & 4) { if (fwd_from_ == nullptr) { s.store_field("fwd_from", "null"); } else { fwd_from_->store(s, "fwd_from"); } }
    if (var0 & 2048) { s.store_field("via_bot_id", via_bot_id_); }
    if (var0 & 8) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    s.store_field("date", date_);
    s.store_field("message", message_);
    if (var0 & 512) { if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); } }
    if (var0 & 64) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    if (var0 & 128) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 1024) { s.store_field("views", views_); }
    if (var0 & 32768) { s.store_field("edit_date", edit_date_); }
    if (var0 & 65536) { s.store_field("post_author", post_author_); }
    if (var0 & 131072) { s.store_field("grouped_id", grouped_id_); }
    s.store_class_end();
  }
}

messageService::messageService()
  : flags_()
  , out_()
  , mentioned_()
  , media_unread_()
  , silent_()
  , post_()
  , id_()
  , from_id_()
  , to_id_()
  , reply_to_msg_id_()
  , date_()
  , action_()
{}

messageService::messageService(std::int32_t flags_, bool out_, bool mentioned_, bool media_unread_, bool silent_, bool post_, std::int32_t id_, std::int32_t from_id_, object_ptr<Peer> &&to_id_, std::int32_t reply_to_msg_id_, std::int32_t date_, object_ptr<MessageAction> &&action_)
  : flags_(flags_)
  , out_(out_)
  , mentioned_(mentioned_)
  , media_unread_(media_unread_)
  , silent_(silent_)
  , post_(post_)
  , id_(id_)
  , from_id_(from_id_)
  , to_id_(std::move(to_id_))
  , reply_to_msg_id_(reply_to_msg_id_)
  , date_(date_)
  , action_(std::move(action_))
{}

const std::int32_t messageService::ID;

object_ptr<messageService> messageService::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messageService> res = make_tl_object<messageService>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->out_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->mentioned_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->media_unread_ = TlFetchTrue::parse(p); }
  if (var0 & 8192) { res->silent_ = TlFetchTrue::parse(p); }
  if (var0 & 16384) { res->post_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  if (var0 & 256) { res->from_id_ = TlFetchInt::parse(p); }
  res->to_id_ = TlFetchObject<Peer>::parse(p);
  if (var0 & 8) { res->reply_to_msg_id_ = TlFetchInt::parse(p); }
  res->date_ = TlFetchInt::parse(p);
  res->action_ = TlFetchObject<MessageAction>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messageService::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageService");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 8192) {  }
    if (var0 & 16384) {  }
    s.store_field("id", id_);
    if (var0 & 256) { s.store_field("from_id", from_id_); }
    if (to_id_ == nullptr) { s.store_field("to_id", "null"); } else { to_id_->store(s, "to_id"); }
    if (var0 & 8) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    s.store_field("date", date_);
    if (action_ == nullptr) { s.store_field("action", "null"); } else { action_->store(s, "action"); }
    s.store_class_end();
  }
}

object_ptr<MessageAction> MessageAction::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messageActionEmpty::ID:
      return messageActionEmpty::fetch(p);
    case messageActionChatCreate::ID:
      return messageActionChatCreate::fetch(p);
    case messageActionChatEditTitle::ID:
      return messageActionChatEditTitle::fetch(p);
    case messageActionChatEditPhoto::ID:
      return messageActionChatEditPhoto::fetch(p);
    case messageActionChatDeletePhoto::ID:
      return messageActionChatDeletePhoto::fetch(p);
    case messageActionChatAddUser::ID:
      return messageActionChatAddUser::fetch(p);
    case messageActionChatDeleteUser::ID:
      return messageActionChatDeleteUser::fetch(p);
    case messageActionChatJoinedByLink::ID:
      return messageActionChatJoinedByLink::fetch(p);
    case messageActionChannelCreate::ID:
      return messageActionChannelCreate::fetch(p);
    case messageActionChatMigrateTo::ID:
      return messageActionChatMigrateTo::fetch(p);
    case messageActionChannelMigrateFrom::ID:
      return messageActionChannelMigrateFrom::fetch(p);
    case messageActionPinMessage::ID:
      return messageActionPinMessage::fetch(p);
    case messageActionHistoryClear::ID:
      return messageActionHistoryClear::fetch(p);
    case messageActionGameScore::ID:
      return messageActionGameScore::fetch(p);
    case messageActionPaymentSentMe::ID:
      return messageActionPaymentSentMe::fetch(p);
    case messageActionPaymentSent::ID:
      return messageActionPaymentSent::fetch(p);
    case messageActionPhoneCall::ID:
      return messageActionPhoneCall::fetch(p);
    case messageActionScreenshotTaken::ID:
      return messageActionScreenshotTaken::fetch(p);
    case messageActionCustomAction::ID:
      return messageActionCustomAction::fetch(p);
    case messageActionBotAllowed::ID:
      return messageActionBotAllowed::fetch(p);
    case messageActionSecureValuesSentMe::ID:
      return messageActionSecureValuesSentMe::fetch(p);
    case messageActionSecureValuesSent::ID:
      return messageActionSecureValuesSent::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messageActionEmpty::messageActionEmpty() {
}

const std::int32_t messageActionEmpty::ID;

messageActionEmpty::messageActionEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messageActionEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionEmpty");
    s.store_class_end();
  }
}

messageActionChatCreate::messageActionChatCreate()
  : title_()
  , users_()
{}

messageActionChatCreate::messageActionChatCreate(std::string const &title_, std::vector<std::int32_t> &&users_)
  : title_(title_)
  , users_(std::move(users_))
{}

const std::int32_t messageActionChatCreate::ID;

messageActionChatCreate::messageActionChatCreate(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : title_(TlFetchString<std::string>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
#undef FAIL
{}

void messageActionChatCreate::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChatCreate");
    s.store_field("title", title_);
    { const std::vector<std::int32_t> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messageActionChatEditTitle::messageActionChatEditTitle()
  : title_()
{}

messageActionChatEditTitle::messageActionChatEditTitle(std::string const &title_)
  : title_(title_)
{}

const std::int32_t messageActionChatEditTitle::ID;

messageActionChatEditTitle::messageActionChatEditTitle(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : title_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void messageActionChatEditTitle::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChatEditTitle");
    s.store_field("title", title_);
    s.store_class_end();
  }
}

messageActionChatEditPhoto::messageActionChatEditPhoto()
  : photo_()
{}

messageActionChatEditPhoto::messageActionChatEditPhoto(object_ptr<Photo> &&photo_)
  : photo_(std::move(photo_))
{}

const std::int32_t messageActionChatEditPhoto::ID;

messageActionChatEditPhoto::messageActionChatEditPhoto(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : photo_(TlFetchObject<Photo>::parse(p))
#undef FAIL
{}

void messageActionChatEditPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChatEditPhoto");
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    s.store_class_end();
  }
}

messageActionChatDeletePhoto::messageActionChatDeletePhoto() {
}

const std::int32_t messageActionChatDeletePhoto::ID;

messageActionChatDeletePhoto::messageActionChatDeletePhoto(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messageActionChatDeletePhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChatDeletePhoto");
    s.store_class_end();
  }
}

messageActionChatAddUser::messageActionChatAddUser()
  : users_()
{}

messageActionChatAddUser::messageActionChatAddUser(std::vector<std::int32_t> &&users_)
  : users_(std::move(users_))
{}

const std::int32_t messageActionChatAddUser::ID;

messageActionChatAddUser::messageActionChatAddUser(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : users_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
#undef FAIL
{}

void messageActionChatAddUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChatAddUser");
    { const std::vector<std::int32_t> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messageActionChatDeleteUser::messageActionChatDeleteUser()
  : user_id_()
{}

messageActionChatDeleteUser::messageActionChatDeleteUser(std::int32_t user_id_)
  : user_id_(user_id_)
{}

const std::int32_t messageActionChatDeleteUser::ID;

messageActionChatDeleteUser::messageActionChatDeleteUser(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageActionChatDeleteUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChatDeleteUser");
    s.store_field("user_id", user_id_);
    s.store_class_end();
  }
}

messageActionChatJoinedByLink::messageActionChatJoinedByLink()
  : inviter_id_()
{}

messageActionChatJoinedByLink::messageActionChatJoinedByLink(std::int32_t inviter_id_)
  : inviter_id_(inviter_id_)
{}

const std::int32_t messageActionChatJoinedByLink::ID;

messageActionChatJoinedByLink::messageActionChatJoinedByLink(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : inviter_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageActionChatJoinedByLink::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChatJoinedByLink");
    s.store_field("inviter_id", inviter_id_);
    s.store_class_end();
  }
}

messageActionChannelCreate::messageActionChannelCreate()
  : title_()
{}

messageActionChannelCreate::messageActionChannelCreate(std::string const &title_)
  : title_(title_)
{}

const std::int32_t messageActionChannelCreate::ID;

messageActionChannelCreate::messageActionChannelCreate(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : title_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void messageActionChannelCreate::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChannelCreate");
    s.store_field("title", title_);
    s.store_class_end();
  }
}

messageActionChatMigrateTo::messageActionChatMigrateTo()
  : channel_id_()
{}

messageActionChatMigrateTo::messageActionChatMigrateTo(std::int32_t channel_id_)
  : channel_id_(channel_id_)
{}

const std::int32_t messageActionChatMigrateTo::ID;

messageActionChatMigrateTo::messageActionChatMigrateTo(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageActionChatMigrateTo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChatMigrateTo");
    s.store_field("channel_id", channel_id_);
    s.store_class_end();
  }
}

messageActionChannelMigrateFrom::messageActionChannelMigrateFrom()
  : title_()
  , chat_id_()
{}

messageActionChannelMigrateFrom::messageActionChannelMigrateFrom(std::string const &title_, std::int32_t chat_id_)
  : title_(title_)
  , chat_id_(chat_id_)
{}

const std::int32_t messageActionChannelMigrateFrom::ID;

messageActionChannelMigrateFrom::messageActionChannelMigrateFrom(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : title_(TlFetchString<std::string>::parse(p))
  , chat_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageActionChannelMigrateFrom::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionChannelMigrateFrom");
    s.store_field("title", title_);
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

messageActionPinMessage::messageActionPinMessage() {
}

const std::int32_t messageActionPinMessage::ID;

messageActionPinMessage::messageActionPinMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messageActionPinMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionPinMessage");
    s.store_class_end();
  }
}

messageActionHistoryClear::messageActionHistoryClear() {
}

const std::int32_t messageActionHistoryClear::ID;

messageActionHistoryClear::messageActionHistoryClear(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messageActionHistoryClear::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionHistoryClear");
    s.store_class_end();
  }
}

messageActionGameScore::messageActionGameScore()
  : game_id_()
  , score_()
{}

messageActionGameScore::messageActionGameScore(std::int64_t game_id_, std::int32_t score_)
  : game_id_(game_id_)
  , score_(score_)
{}

const std::int32_t messageActionGameScore::ID;

messageActionGameScore::messageActionGameScore(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : game_id_(TlFetchLong::parse(p))
  , score_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageActionGameScore::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionGameScore");
    s.store_field("game_id", game_id_);
    s.store_field("score", score_);
    s.store_class_end();
  }
}

messageActionPaymentSentMe::messageActionPaymentSentMe()
  : flags_()
  , currency_()
  , total_amount_()
  , payload_()
  , info_()
  , shipping_option_id_()
  , charge_()
{}

messageActionPaymentSentMe::messageActionPaymentSentMe(std::int32_t flags_, std::string const &currency_, std::int64_t total_amount_, BufferSlice &&payload_, object_ptr<paymentRequestedInfo> &&info_, std::string const &shipping_option_id_, object_ptr<paymentCharge> &&charge_)
  : flags_(flags_)
  , currency_(currency_)
  , total_amount_(total_amount_)
  , payload_(std::move(payload_))
  , info_(std::move(info_))
  , shipping_option_id_(shipping_option_id_)
  , charge_(std::move(charge_))
{}

const std::int32_t messageActionPaymentSentMe::ID;

object_ptr<messageActionPaymentSentMe> messageActionPaymentSentMe::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messageActionPaymentSentMe> res = make_tl_object<messageActionPaymentSentMe>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->currency_ = TlFetchString<std::string>::parse(p);
  res->total_amount_ = TlFetchLong::parse(p);
  res->payload_ = TlFetchBytes<BufferSlice>::parse(p);
  if (var0 & 1) { res->info_ = TlFetchBoxed<TlFetchObject<paymentRequestedInfo>, -1868808300>::parse(p); }
  if (var0 & 2) { res->shipping_option_id_ = TlFetchString<std::string>::parse(p); }
  res->charge_ = TlFetchBoxed<TlFetchObject<paymentCharge>, -368917890>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messageActionPaymentSentMe::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionPaymentSentMe");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("currency", currency_);
    s.store_field("total_amount", total_amount_);
    s.store_bytes_field("payload", payload_);
    if (var0 & 1) { if (info_ == nullptr) { s.store_field("info", "null"); } else { info_->store(s, "info"); } }
    if (var0 & 2) { s.store_field("shipping_option_id", shipping_option_id_); }
    if (charge_ == nullptr) { s.store_field("charge", "null"); } else { charge_->store(s, "charge"); }
    s.store_class_end();
  }
}

messageActionPaymentSent::messageActionPaymentSent()
  : currency_()
  , total_amount_()
{}

messageActionPaymentSent::messageActionPaymentSent(std::string const &currency_, std::int64_t total_amount_)
  : currency_(currency_)
  , total_amount_(total_amount_)
{}

const std::int32_t messageActionPaymentSent::ID;

messageActionPaymentSent::messageActionPaymentSent(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : currency_(TlFetchString<std::string>::parse(p))
  , total_amount_(TlFetchLong::parse(p))
#undef FAIL
{}

void messageActionPaymentSent::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionPaymentSent");
    s.store_field("currency", currency_);
    s.store_field("total_amount", total_amount_);
    s.store_class_end();
  }
}

messageActionPhoneCall::messageActionPhoneCall()
  : flags_()
  , call_id_()
  , reason_()
  , duration_()
{}

messageActionPhoneCall::messageActionPhoneCall(std::int32_t flags_, std::int64_t call_id_, object_ptr<PhoneCallDiscardReason> &&reason_, std::int32_t duration_)
  : flags_(flags_)
  , call_id_(call_id_)
  , reason_(std::move(reason_))
  , duration_(duration_)
{}

const std::int32_t messageActionPhoneCall::ID;

object_ptr<messageActionPhoneCall> messageActionPhoneCall::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messageActionPhoneCall> res = make_tl_object<messageActionPhoneCall>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->call_id_ = TlFetchLong::parse(p);
  if (var0 & 1) { res->reason_ = TlFetchObject<PhoneCallDiscardReason>::parse(p); }
  if (var0 & 2) { res->duration_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messageActionPhoneCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionPhoneCall");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("call_id", call_id_);
    if (var0 & 1) { if (reason_ == nullptr) { s.store_field("reason", "null"); } else { reason_->store(s, "reason"); } }
    if (var0 & 2) { s.store_field("duration", duration_); }
    s.store_class_end();
  }
}

messageActionScreenshotTaken::messageActionScreenshotTaken() {
}

const std::int32_t messageActionScreenshotTaken::ID;

messageActionScreenshotTaken::messageActionScreenshotTaken(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messageActionScreenshotTaken::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionScreenshotTaken");
    s.store_class_end();
  }
}

messageActionCustomAction::messageActionCustomAction()
  : message_()
{}

messageActionCustomAction::messageActionCustomAction(std::string const &message_)
  : message_(message_)
{}

const std::int32_t messageActionCustomAction::ID;

messageActionCustomAction::messageActionCustomAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void messageActionCustomAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionCustomAction");
    s.store_field("message", message_);
    s.store_class_end();
  }
}

messageActionBotAllowed::messageActionBotAllowed()
  : domain_()
{}

messageActionBotAllowed::messageActionBotAllowed(std::string const &domain_)
  : domain_(domain_)
{}

const std::int32_t messageActionBotAllowed::ID;

messageActionBotAllowed::messageActionBotAllowed(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : domain_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void messageActionBotAllowed::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionBotAllowed");
    s.store_field("domain", domain_);
    s.store_class_end();
  }
}

messageActionSecureValuesSentMe::messageActionSecureValuesSentMe()
  : values_()
  , credentials_()
{}

messageActionSecureValuesSentMe::messageActionSecureValuesSentMe(std::vector<object_ptr<secureValue>> &&values_, object_ptr<secureCredentialsEncrypted> &&credentials_)
  : values_(std::move(values_))
  , credentials_(std::move(credentials_))
{}

const std::int32_t messageActionSecureValuesSentMe::ID;

messageActionSecureValuesSentMe::messageActionSecureValuesSentMe(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : values_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<secureValue>, 411017418>>, 481674261>::parse(p))
  , credentials_(TlFetchBoxed<TlFetchObject<secureCredentialsEncrypted>, 871426631>::parse(p))
#undef FAIL
{}

void messageActionSecureValuesSentMe::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionSecureValuesSentMe");
    { const std::vector<object_ptr<secureValue>> &v = values_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("values", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (credentials_ == nullptr) { s.store_field("credentials", "null"); } else { credentials_->store(s, "credentials"); }
    s.store_class_end();
  }
}

messageActionSecureValuesSent::messageActionSecureValuesSent()
  : types_()
{}

messageActionSecureValuesSent::messageActionSecureValuesSent(std::vector<object_ptr<SecureValueType>> &&types_)
  : types_(std::move(types_))
{}

const std::int32_t messageActionSecureValuesSent::ID;

messageActionSecureValuesSent::messageActionSecureValuesSent(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : types_(TlFetchBoxed<TlFetchVector<TlFetchObject<SecureValueType>>, 481674261>::parse(p))
#undef FAIL
{}

void messageActionSecureValuesSent::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageActionSecureValuesSent");
    { const std::vector<object_ptr<SecureValueType>> &v = types_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("types", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<MessageEntity> MessageEntity::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messageEntityUnknown::ID:
      return messageEntityUnknown::fetch(p);
    case messageEntityMention::ID:
      return messageEntityMention::fetch(p);
    case messageEntityHashtag::ID:
      return messageEntityHashtag::fetch(p);
    case messageEntityBotCommand::ID:
      return messageEntityBotCommand::fetch(p);
    case messageEntityUrl::ID:
      return messageEntityUrl::fetch(p);
    case messageEntityEmail::ID:
      return messageEntityEmail::fetch(p);
    case messageEntityBold::ID:
      return messageEntityBold::fetch(p);
    case messageEntityItalic::ID:
      return messageEntityItalic::fetch(p);
    case messageEntityCode::ID:
      return messageEntityCode::fetch(p);
    case messageEntityPre::ID:
      return messageEntityPre::fetch(p);
    case messageEntityTextUrl::ID:
      return messageEntityTextUrl::fetch(p);
    case messageEntityMentionName::ID:
      return messageEntityMentionName::fetch(p);
    case inputMessageEntityMentionName::ID:
      return inputMessageEntityMentionName::fetch(p);
    case messageEntityPhone::ID:
      return messageEntityPhone::fetch(p);
    case messageEntityCashtag::ID:
      return messageEntityCashtag::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messageEntityUnknown::messageEntityUnknown()
  : offset_()
  , length_()
{}

messageEntityUnknown::messageEntityUnknown(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityUnknown::ID;

messageEntityUnknown::messageEntityUnknown(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityUnknown::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityUnknown::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityUnknown::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityUnknown");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityMention::messageEntityMention()
  : offset_()
  , length_()
{}

messageEntityMention::messageEntityMention(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityMention::ID;

messageEntityMention::messageEntityMention(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityMention::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityMention::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityMention::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityMention");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityHashtag::messageEntityHashtag()
  : offset_()
  , length_()
{}

messageEntityHashtag::messageEntityHashtag(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityHashtag::ID;

messageEntityHashtag::messageEntityHashtag(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityHashtag::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityHashtag::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityHashtag::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityHashtag");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityBotCommand::messageEntityBotCommand()
  : offset_()
  , length_()
{}

messageEntityBotCommand::messageEntityBotCommand(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityBotCommand::ID;

messageEntityBotCommand::messageEntityBotCommand(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityBotCommand::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityBotCommand::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityBotCommand::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityBotCommand");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityUrl::messageEntityUrl()
  : offset_()
  , length_()
{}

messageEntityUrl::messageEntityUrl(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityUrl::ID;

messageEntityUrl::messageEntityUrl(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityUrl::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityUrl::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityUrl::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityUrl");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityEmail::messageEntityEmail()
  : offset_()
  , length_()
{}

messageEntityEmail::messageEntityEmail(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityEmail::ID;

messageEntityEmail::messageEntityEmail(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityEmail::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityEmail::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityEmail::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityEmail");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityBold::messageEntityBold()
  : offset_()
  , length_()
{}

messageEntityBold::messageEntityBold(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityBold::ID;

messageEntityBold::messageEntityBold(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityBold::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityBold::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityBold::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityBold");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityItalic::messageEntityItalic()
  : offset_()
  , length_()
{}

messageEntityItalic::messageEntityItalic(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityItalic::ID;

messageEntityItalic::messageEntityItalic(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityItalic::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityItalic::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityItalic::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityItalic");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityCode::messageEntityCode()
  : offset_()
  , length_()
{}

messageEntityCode::messageEntityCode(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityCode::ID;

messageEntityCode::messageEntityCode(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityCode::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityCode::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityCode");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityPre::messageEntityPre()
  : offset_()
  , length_()
  , language_()
{}

messageEntityPre::messageEntityPre(std::int32_t offset_, std::int32_t length_, std::string const &language_)
  : offset_(offset_)
  , length_(length_)
  , language_(language_)
{}

const std::int32_t messageEntityPre::ID;

messageEntityPre::messageEntityPre(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
  , language_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void messageEntityPre::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
  TlStoreString::store(language_, s);
}

void messageEntityPre::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
  TlStoreString::store(language_, s);
}

void messageEntityPre::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityPre");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_field("language", language_);
    s.store_class_end();
  }
}

messageEntityTextUrl::messageEntityTextUrl()
  : offset_()
  , length_()
  , url_()
{}

messageEntityTextUrl::messageEntityTextUrl(std::int32_t offset_, std::int32_t length_, std::string const &url_)
  : offset_(offset_)
  , length_(length_)
  , url_(url_)
{}

const std::int32_t messageEntityTextUrl::ID;

messageEntityTextUrl::messageEntityTextUrl(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
  , url_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void messageEntityTextUrl::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
  TlStoreString::store(url_, s);
}

void messageEntityTextUrl::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
  TlStoreString::store(url_, s);
}

void messageEntityTextUrl::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityTextUrl");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_field("url", url_);
    s.store_class_end();
  }
}

messageEntityMentionName::messageEntityMentionName()
  : offset_()
  , length_()
  , user_id_()
{}

messageEntityMentionName::messageEntityMentionName(std::int32_t offset_, std::int32_t length_, std::int32_t user_id_)
  : offset_(offset_)
  , length_(length_)
  , user_id_(user_id_)
{}

const std::int32_t messageEntityMentionName::ID;

messageEntityMentionName::messageEntityMentionName(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
  , user_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityMentionName::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
  TlStoreBinary::store(user_id_, s);
}

void messageEntityMentionName::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
  TlStoreBinary::store(user_id_, s);
}

void messageEntityMentionName::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityMentionName");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_field("user_id", user_id_);
    s.store_class_end();
  }
}

inputMessageEntityMentionName::inputMessageEntityMentionName()
  : offset_()
  , length_()
  , user_id_()
{}

inputMessageEntityMentionName::inputMessageEntityMentionName(std::int32_t offset_, std::int32_t length_, object_ptr<InputUser> &&user_id_)
  : offset_(offset_)
  , length_(length_)
  , user_id_(std::move(user_id_))
{}

const std::int32_t inputMessageEntityMentionName::ID;

inputMessageEntityMentionName::inputMessageEntityMentionName(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
  , user_id_(TlFetchObject<InputUser>::parse(p))
#undef FAIL
{}

void inputMessageEntityMentionName::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void inputMessageEntityMentionName::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void inputMessageEntityMentionName::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessageEntityMentionName");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_class_end();
  }
}

messageEntityPhone::messageEntityPhone()
  : offset_()
  , length_()
{}

messageEntityPhone::messageEntityPhone(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityPhone::ID;

messageEntityPhone::messageEntityPhone(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityPhone::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityPhone::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityPhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityPhone");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageEntityCashtag::messageEntityCashtag()
  : offset_()
  , length_()
{}

messageEntityCashtag::messageEntityCashtag(std::int32_t offset_, std::int32_t length_)
  : offset_(offset_)
  , length_(length_)
{}

const std::int32_t messageEntityCashtag::ID;

messageEntityCashtag::messageEntityCashtag(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : offset_(TlFetchInt::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageEntityCashtag::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityCashtag::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(length_, s);
}

void messageEntityCashtag::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageEntityCashtag");
    s.store_field("offset", offset_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

messageFwdHeader::messageFwdHeader()
  : flags_()
  , from_id_()
  , date_()
  , channel_id_()
  , channel_post_()
  , post_author_()
  , saved_from_peer_()
  , saved_from_msg_id_()
{}

messageFwdHeader::messageFwdHeader(std::int32_t flags_, std::int32_t from_id_, std::int32_t date_, std::int32_t channel_id_, std::int32_t channel_post_, std::string const &post_author_, object_ptr<Peer> &&saved_from_peer_, std::int32_t saved_from_msg_id_)
  : flags_(flags_)
  , from_id_(from_id_)
  , date_(date_)
  , channel_id_(channel_id_)
  , channel_post_(channel_post_)
  , post_author_(post_author_)
  , saved_from_peer_(std::move(saved_from_peer_))
  , saved_from_msg_id_(saved_from_msg_id_)
{}

const std::int32_t messageFwdHeader::ID;

object_ptr<messageFwdHeader> messageFwdHeader::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messageFwdHeader> res = make_tl_object<messageFwdHeader>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->from_id_ = TlFetchInt::parse(p); }
  res->date_ = TlFetchInt::parse(p);
  if (var0 & 2) { res->channel_id_ = TlFetchInt::parse(p); }
  if (var0 & 4) { res->channel_post_ = TlFetchInt::parse(p); }
  if (var0 & 8) { res->post_author_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16) { res->saved_from_peer_ = TlFetchObject<Peer>::parse(p); }
  if (var0 & 16) { res->saved_from_msg_id_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messageFwdHeader::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageFwdHeader");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("from_id", from_id_); }
    s.store_field("date", date_);
    if (var0 & 2) { s.store_field("channel_id", channel_id_); }
    if (var0 & 4) { s.store_field("channel_post", channel_post_); }
    if (var0 & 8) { s.store_field("post_author", post_author_); }
    if (var0 & 16) { if (saved_from_peer_ == nullptr) { s.store_field("saved_from_peer", "null"); } else { saved_from_peer_->store(s, "saved_from_peer"); } }
    if (var0 & 16) { s.store_field("saved_from_msg_id", saved_from_msg_id_); }
    s.store_class_end();
  }
}

object_ptr<MessageMedia> MessageMedia::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messageMediaEmpty::ID:
      return messageMediaEmpty::fetch(p);
    case messageMediaPhoto::ID:
      return messageMediaPhoto::fetch(p);
    case messageMediaGeo::ID:
      return messageMediaGeo::fetch(p);
    case messageMediaContact::ID:
      return messageMediaContact::fetch(p);
    case messageMediaUnsupported::ID:
      return messageMediaUnsupported::fetch(p);
    case messageMediaDocument::ID:
      return messageMediaDocument::fetch(p);
    case messageMediaWebPage::ID:
      return messageMediaWebPage::fetch(p);
    case messageMediaVenue::ID:
      return messageMediaVenue::fetch(p);
    case messageMediaGame::ID:
      return messageMediaGame::fetch(p);
    case messageMediaInvoice::ID:
      return messageMediaInvoice::fetch(p);
    case messageMediaGeoLive::ID:
      return messageMediaGeoLive::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messageMediaEmpty::messageMediaEmpty() {
}

const std::int32_t messageMediaEmpty::ID;

messageMediaEmpty::messageMediaEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messageMediaEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaEmpty");
    s.store_class_end();
  }
}

messageMediaPhoto::messageMediaPhoto()
  : flags_()
  , photo_()
  , ttl_seconds_()
{}

messageMediaPhoto::messageMediaPhoto(std::int32_t flags_, object_ptr<Photo> &&photo_, std::int32_t ttl_seconds_)
  : flags_(flags_)
  , photo_(std::move(photo_))
  , ttl_seconds_(ttl_seconds_)
{}

const std::int32_t messageMediaPhoto::ID;

object_ptr<messageMediaPhoto> messageMediaPhoto::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messageMediaPhoto> res = make_tl_object<messageMediaPhoto>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->photo_ = TlFetchObject<Photo>::parse(p); }
  if (var0 & 4) { res->ttl_seconds_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messageMediaPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaPhoto");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); } }
    if (var0 & 4) { s.store_field("ttl_seconds", ttl_seconds_); }
    s.store_class_end();
  }
}

messageMediaGeo::messageMediaGeo()
  : geo_()
{}

messageMediaGeo::messageMediaGeo(object_ptr<GeoPoint> &&geo_)
  : geo_(std::move(geo_))
{}

const std::int32_t messageMediaGeo::ID;

messageMediaGeo::messageMediaGeo(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : geo_(TlFetchObject<GeoPoint>::parse(p))
#undef FAIL
{}

void messageMediaGeo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaGeo");
    if (geo_ == nullptr) { s.store_field("geo", "null"); } else { geo_->store(s, "geo"); }
    s.store_class_end();
  }
}

messageMediaContact::messageMediaContact()
  : phone_number_()
  , first_name_()
  , last_name_()
  , vcard_()
  , user_id_()
{}

messageMediaContact::messageMediaContact(std::string const &phone_number_, std::string const &first_name_, std::string const &last_name_, std::string const &vcard_, std::int32_t user_id_)
  : phone_number_(phone_number_)
  , first_name_(first_name_)
  , last_name_(last_name_)
  , vcard_(vcard_)
  , user_id_(user_id_)
{}

const std::int32_t messageMediaContact::ID;

messageMediaContact::messageMediaContact(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : phone_number_(TlFetchString<std::string>::parse(p))
  , first_name_(TlFetchString<std::string>::parse(p))
  , last_name_(TlFetchString<std::string>::parse(p))
  , vcard_(TlFetchString<std::string>::parse(p))
  , user_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageMediaContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaContact");
    s.store_field("phone_number", phone_number_);
    s.store_field("first_name", first_name_);
    s.store_field("last_name", last_name_);
    s.store_field("vcard", vcard_);
    s.store_field("user_id", user_id_);
    s.store_class_end();
  }
}

messageMediaUnsupported::messageMediaUnsupported() {
}

const std::int32_t messageMediaUnsupported::ID;

messageMediaUnsupported::messageMediaUnsupported(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messageMediaUnsupported::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaUnsupported");
    s.store_class_end();
  }
}

messageMediaDocument::messageMediaDocument()
  : flags_()
  , document_()
  , ttl_seconds_()
{}

messageMediaDocument::messageMediaDocument(std::int32_t flags_, object_ptr<Document> &&document_, std::int32_t ttl_seconds_)
  : flags_(flags_)
  , document_(std::move(document_))
  , ttl_seconds_(ttl_seconds_)
{}

const std::int32_t messageMediaDocument::ID;

object_ptr<messageMediaDocument> messageMediaDocument::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messageMediaDocument> res = make_tl_object<messageMediaDocument>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->document_ = TlFetchObject<Document>::parse(p); }
  if (var0 & 4) { res->ttl_seconds_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messageMediaDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaDocument");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { if (document_ == nullptr) { s.store_field("document", "null"); } else { document_->store(s, "document"); } }
    if (var0 & 4) { s.store_field("ttl_seconds", ttl_seconds_); }
    s.store_class_end();
  }
}

messageMediaWebPage::messageMediaWebPage()
  : webpage_()
{}

messageMediaWebPage::messageMediaWebPage(object_ptr<WebPage> &&webpage_)
  : webpage_(std::move(webpage_))
{}

const std::int32_t messageMediaWebPage::ID;

messageMediaWebPage::messageMediaWebPage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : webpage_(TlFetchObject<WebPage>::parse(p))
#undef FAIL
{}

void messageMediaWebPage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaWebPage");
    if (webpage_ == nullptr) { s.store_field("webpage", "null"); } else { webpage_->store(s, "webpage"); }
    s.store_class_end();
  }
}

messageMediaVenue::messageMediaVenue()
  : geo_()
  , title_()
  , address_()
  , provider_()
  , venue_id_()
  , venue_type_()
{}

messageMediaVenue::messageMediaVenue(object_ptr<GeoPoint> &&geo_, std::string const &title_, std::string const &address_, std::string const &provider_, std::string const &venue_id_, std::string const &venue_type_)
  : geo_(std::move(geo_))
  , title_(title_)
  , address_(address_)
  , provider_(provider_)
  , venue_id_(venue_id_)
  , venue_type_(venue_type_)
{}

const std::int32_t messageMediaVenue::ID;

messageMediaVenue::messageMediaVenue(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : geo_(TlFetchObject<GeoPoint>::parse(p))
  , title_(TlFetchString<std::string>::parse(p))
  , address_(TlFetchString<std::string>::parse(p))
  , provider_(TlFetchString<std::string>::parse(p))
  , venue_id_(TlFetchString<std::string>::parse(p))
  , venue_type_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void messageMediaVenue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaVenue");
    if (geo_ == nullptr) { s.store_field("geo", "null"); } else { geo_->store(s, "geo"); }
    s.store_field("title", title_);
    s.store_field("address", address_);
    s.store_field("provider", provider_);
    s.store_field("venue_id", venue_id_);
    s.store_field("venue_type", venue_type_);
    s.store_class_end();
  }
}

messageMediaGame::messageMediaGame()
  : game_()
{}

messageMediaGame::messageMediaGame(object_ptr<game> &&game_)
  : game_(std::move(game_))
{}

const std::int32_t messageMediaGame::ID;

messageMediaGame::messageMediaGame(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : game_(TlFetchBoxed<TlFetchObject<game>, -1107729093>::parse(p))
#undef FAIL
{}

void messageMediaGame::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaGame");
    if (game_ == nullptr) { s.store_field("game", "null"); } else { game_->store(s, "game"); }
    s.store_class_end();
  }
}

messageMediaInvoice::messageMediaInvoice()
  : flags_()
  , shipping_address_requested_()
  , test_()
  , title_()
  , description_()
  , photo_()
  , receipt_msg_id_()
  , currency_()
  , total_amount_()
  , start_param_()
{}

messageMediaInvoice::messageMediaInvoice(std::int32_t flags_, bool shipping_address_requested_, bool test_, std::string const &title_, std::string const &description_, object_ptr<WebDocument> &&photo_, std::int32_t receipt_msg_id_, std::string const &currency_, std::int64_t total_amount_, std::string const &start_param_)
  : flags_(flags_)
  , shipping_address_requested_(shipping_address_requested_)
  , test_(test_)
  , title_(title_)
  , description_(description_)
  , photo_(std::move(photo_))
  , receipt_msg_id_(receipt_msg_id_)
  , currency_(currency_)
  , total_amount_(total_amount_)
  , start_param_(start_param_)
{}

const std::int32_t messageMediaInvoice::ID;

object_ptr<messageMediaInvoice> messageMediaInvoice::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messageMediaInvoice> res = make_tl_object<messageMediaInvoice>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->shipping_address_requested_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->test_ = TlFetchTrue::parse(p); }
  res->title_ = TlFetchString<std::string>::parse(p);
  res->description_ = TlFetchString<std::string>::parse(p);
  if (var0 & 1) { res->photo_ = TlFetchObject<WebDocument>::parse(p); }
  if (var0 & 4) { res->receipt_msg_id_ = TlFetchInt::parse(p); }
  res->currency_ = TlFetchString<std::string>::parse(p);
  res->total_amount_ = TlFetchLong::parse(p);
  res->start_param_ = TlFetchString<std::string>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messageMediaInvoice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaInvoice");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 8) {  }
    s.store_field("title", title_);
    s.store_field("description", description_);
    if (var0 & 1) { if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); } }
    if (var0 & 4) { s.store_field("receipt_msg_id", receipt_msg_id_); }
    s.store_field("currency", currency_);
    s.store_field("total_amount", total_amount_);
    s.store_field("start_param", start_param_);
    s.store_class_end();
  }
}

messageMediaGeoLive::messageMediaGeoLive()
  : geo_()
  , period_()
{}

messageMediaGeoLive::messageMediaGeoLive(object_ptr<GeoPoint> &&geo_, std::int32_t period_)
  : geo_(std::move(geo_))
  , period_(period_)
{}

const std::int32_t messageMediaGeoLive::ID;

messageMediaGeoLive::messageMediaGeoLive(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : geo_(TlFetchObject<GeoPoint>::parse(p))
  , period_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageMediaGeoLive::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageMediaGeoLive");
    if (geo_ == nullptr) { s.store_field("geo", "null"); } else { geo_->store(s, "geo"); }
    s.store_field("period", period_);
    s.store_class_end();
  }
}

messageRange::messageRange()
  : min_id_()
  , max_id_()
{}

messageRange::messageRange(std::int32_t min_id_, std::int32_t max_id_)
  : min_id_(min_id_)
  , max_id_(max_id_)
{}

const std::int32_t messageRange::ID;

messageRange::messageRange(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : min_id_(TlFetchInt::parse(p))
  , max_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void messageRange::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(min_id_, s);
  TlStoreBinary::store(max_id_, s);
}

void messageRange::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(min_id_, s);
  TlStoreBinary::store(max_id_, s);
}

void messageRange::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messageRange");
    s.store_field("min_id", min_id_);
    s.store_field("max_id", max_id_);
    s.store_class_end();
  }
}

inputMessagesFilterEmpty::inputMessagesFilterEmpty() {
}

const std::int32_t inputMessagesFilterEmpty::ID;

void inputMessagesFilterEmpty::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterEmpty::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterEmpty");
    s.store_class_end();
  }
}

inputMessagesFilterPhotos::inputMessagesFilterPhotos() {
}

const std::int32_t inputMessagesFilterPhotos::ID;

void inputMessagesFilterPhotos::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterPhotos::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterPhotos::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterPhotos");
    s.store_class_end();
  }
}

inputMessagesFilterVideo::inputMessagesFilterVideo() {
}

const std::int32_t inputMessagesFilterVideo::ID;

void inputMessagesFilterVideo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterVideo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterVideo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterVideo");
    s.store_class_end();
  }
}

inputMessagesFilterPhotoVideo::inputMessagesFilterPhotoVideo() {
}

const std::int32_t inputMessagesFilterPhotoVideo::ID;

void inputMessagesFilterPhotoVideo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterPhotoVideo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterPhotoVideo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterPhotoVideo");
    s.store_class_end();
  }
}

inputMessagesFilterDocument::inputMessagesFilterDocument() {
}

const std::int32_t inputMessagesFilterDocument::ID;

void inputMessagesFilterDocument::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterDocument::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterDocument");
    s.store_class_end();
  }
}

inputMessagesFilterUrl::inputMessagesFilterUrl() {
}

const std::int32_t inputMessagesFilterUrl::ID;

void inputMessagesFilterUrl::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterUrl::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterUrl::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterUrl");
    s.store_class_end();
  }
}

inputMessagesFilterGif::inputMessagesFilterGif() {
}

const std::int32_t inputMessagesFilterGif::ID;

void inputMessagesFilterGif::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterGif::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterGif::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterGif");
    s.store_class_end();
  }
}

inputMessagesFilterVoice::inputMessagesFilterVoice() {
}

const std::int32_t inputMessagesFilterVoice::ID;

void inputMessagesFilterVoice::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterVoice::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterVoice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterVoice");
    s.store_class_end();
  }
}

inputMessagesFilterMusic::inputMessagesFilterMusic() {
}

const std::int32_t inputMessagesFilterMusic::ID;

void inputMessagesFilterMusic::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterMusic::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterMusic::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterMusic");
    s.store_class_end();
  }
}

inputMessagesFilterChatPhotos::inputMessagesFilterChatPhotos() {
}

const std::int32_t inputMessagesFilterChatPhotos::ID;

void inputMessagesFilterChatPhotos::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterChatPhotos::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterChatPhotos::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterChatPhotos");
    s.store_class_end();
  }
}

inputMessagesFilterPhoneCalls::inputMessagesFilterPhoneCalls()
  : flags_()
  , missed_()
{}

inputMessagesFilterPhoneCalls::inputMessagesFilterPhoneCalls(std::int32_t flags_, bool missed_)
  : flags_(flags_)
  , missed_(missed_)
{}

const std::int32_t inputMessagesFilterPhoneCalls::ID;

void inputMessagesFilterPhoneCalls::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(missed_, s); }
}

void inputMessagesFilterPhoneCalls::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(missed_, s); }
}

void inputMessagesFilterPhoneCalls::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterPhoneCalls");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_class_end();
  }
}

inputMessagesFilterRoundVoice::inputMessagesFilterRoundVoice() {
}

const std::int32_t inputMessagesFilterRoundVoice::ID;

void inputMessagesFilterRoundVoice::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterRoundVoice::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterRoundVoice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterRoundVoice");
    s.store_class_end();
  }
}

inputMessagesFilterRoundVideo::inputMessagesFilterRoundVideo() {
}

const std::int32_t inputMessagesFilterRoundVideo::ID;

void inputMessagesFilterRoundVideo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterRoundVideo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterRoundVideo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterRoundVideo");
    s.store_class_end();
  }
}

inputMessagesFilterMyMentions::inputMessagesFilterMyMentions() {
}

const std::int32_t inputMessagesFilterMyMentions::ID;

void inputMessagesFilterMyMentions::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterMyMentions::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterMyMentions::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterMyMentions");
    s.store_class_end();
  }
}

inputMessagesFilterGeo::inputMessagesFilterGeo() {
}

const std::int32_t inputMessagesFilterGeo::ID;

void inputMessagesFilterGeo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterGeo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterGeo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterGeo");
    s.store_class_end();
  }
}

inputMessagesFilterContacts::inputMessagesFilterContacts() {
}

const std::int32_t inputMessagesFilterContacts::ID;

void inputMessagesFilterContacts::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterContacts::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputMessagesFilterContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputMessagesFilterContacts");
    s.store_class_end();
  }
}

nearestDc::nearestDc()
  : country_()
  , this_dc_()
  , nearest_dc_()
{}

nearestDc::nearestDc(std::string const &country_, std::int32_t this_dc_, std::int32_t nearest_dc_)
  : country_(country_)
  , this_dc_(this_dc_)
  , nearest_dc_(nearest_dc_)
{}

const std::int32_t nearestDc::ID;

nearestDc::nearestDc(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : country_(TlFetchString<std::string>::parse(p))
  , this_dc_(TlFetchInt::parse(p))
  , nearest_dc_(TlFetchInt::parse(p))
#undef FAIL
{}

void nearestDc::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "nearestDc");
    s.store_field("country", country_);
    s.store_field("this_dc", this_dc_);
    s.store_field("nearest_dc", nearest_dc_);
    s.store_class_end();
  }
}

object_ptr<NotifyPeer> NotifyPeer::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case notifyPeer::ID:
      return notifyPeer::fetch(p);
    case notifyUsers::ID:
      return notifyUsers::fetch(p);
    case notifyChats::ID:
      return notifyChats::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

notifyPeer::notifyPeer()
  : peer_()
{}

notifyPeer::notifyPeer(object_ptr<Peer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t notifyPeer::ID;

notifyPeer::notifyPeer(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : peer_(TlFetchObject<Peer>::parse(p))
#undef FAIL
{}

void notifyPeer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "notifyPeer");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

notifyUsers::notifyUsers() {
}

const std::int32_t notifyUsers::ID;

notifyUsers::notifyUsers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void notifyUsers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "notifyUsers");
    s.store_class_end();
  }
}

notifyChats::notifyChats() {
}

const std::int32_t notifyChats::ID;

notifyChats::notifyChats(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void notifyChats::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "notifyChats");
    s.store_class_end();
  }
}

object_ptr<Page> Page::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case pagePart::ID:
      return pagePart::fetch(p);
    case pageFull::ID:
      return pageFull::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

pagePart::pagePart()
  : blocks_()
  , photos_()
  , documents_()
{}

pagePart::pagePart(std::vector<object_ptr<PageBlock>> &&blocks_, std::vector<object_ptr<Photo>> &&photos_, std::vector<object_ptr<Document>> &&documents_)
  : blocks_(std::move(blocks_))
  , photos_(std::move(photos_))
  , documents_(std::move(documents_))
{}

const std::int32_t pagePart::ID;

pagePart::pagePart(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : blocks_(TlFetchBoxed<TlFetchVector<TlFetchObject<PageBlock>>, 481674261>::parse(p))
  , photos_(TlFetchBoxed<TlFetchVector<TlFetchObject<Photo>>, 481674261>::parse(p))
  , documents_(TlFetchBoxed<TlFetchVector<TlFetchObject<Document>>, 481674261>::parse(p))
#undef FAIL
{}

void pagePart::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pagePart");
    { const std::vector<object_ptr<PageBlock>> &v = blocks_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("blocks", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Photo>> &v = photos_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("photos", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Document>> &v = documents_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("documents", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

pageFull::pageFull()
  : blocks_()
  , photos_()
  , documents_()
{}

pageFull::pageFull(std::vector<object_ptr<PageBlock>> &&blocks_, std::vector<object_ptr<Photo>> &&photos_, std::vector<object_ptr<Document>> &&documents_)
  : blocks_(std::move(blocks_))
  , photos_(std::move(photos_))
  , documents_(std::move(documents_))
{}

const std::int32_t pageFull::ID;

pageFull::pageFull(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : blocks_(TlFetchBoxed<TlFetchVector<TlFetchObject<PageBlock>>, 481674261>::parse(p))
  , photos_(TlFetchBoxed<TlFetchVector<TlFetchObject<Photo>>, 481674261>::parse(p))
  , documents_(TlFetchBoxed<TlFetchVector<TlFetchObject<Document>>, 481674261>::parse(p))
#undef FAIL
{}

void pageFull::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageFull");
    { const std::vector<object_ptr<PageBlock>> &v = blocks_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("blocks", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Photo>> &v = photos_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("photos", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Document>> &v = documents_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("documents", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<PageBlock> PageBlock::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case pageBlockUnsupported::ID:
      return pageBlockUnsupported::fetch(p);
    case pageBlockTitle::ID:
      return pageBlockTitle::fetch(p);
    case pageBlockSubtitle::ID:
      return pageBlockSubtitle::fetch(p);
    case pageBlockAuthorDate::ID:
      return pageBlockAuthorDate::fetch(p);
    case pageBlockHeader::ID:
      return pageBlockHeader::fetch(p);
    case pageBlockSubheader::ID:
      return pageBlockSubheader::fetch(p);
    case pageBlockParagraph::ID:
      return pageBlockParagraph::fetch(p);
    case pageBlockPreformatted::ID:
      return pageBlockPreformatted::fetch(p);
    case pageBlockFooter::ID:
      return pageBlockFooter::fetch(p);
    case pageBlockDivider::ID:
      return pageBlockDivider::fetch(p);
    case pageBlockAnchor::ID:
      return pageBlockAnchor::fetch(p);
    case pageBlockList::ID:
      return pageBlockList::fetch(p);
    case pageBlockBlockquote::ID:
      return pageBlockBlockquote::fetch(p);
    case pageBlockPullquote::ID:
      return pageBlockPullquote::fetch(p);
    case pageBlockPhoto::ID:
      return pageBlockPhoto::fetch(p);
    case pageBlockVideo::ID:
      return pageBlockVideo::fetch(p);
    case pageBlockCover::ID:
      return pageBlockCover::fetch(p);
    case pageBlockEmbed::ID:
      return pageBlockEmbed::fetch(p);
    case pageBlockEmbedPost::ID:
      return pageBlockEmbedPost::fetch(p);
    case pageBlockCollage::ID:
      return pageBlockCollage::fetch(p);
    case pageBlockSlideshow::ID:
      return pageBlockSlideshow::fetch(p);
    case pageBlockChannel::ID:
      return pageBlockChannel::fetch(p);
    case pageBlockAudio::ID:
      return pageBlockAudio::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

pageBlockUnsupported::pageBlockUnsupported() {
}

const std::int32_t pageBlockUnsupported::ID;

pageBlockUnsupported::pageBlockUnsupported(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void pageBlockUnsupported::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockUnsupported");
    s.store_class_end();
  }
}

pageBlockTitle::pageBlockTitle()
  : text_()
{}

pageBlockTitle::pageBlockTitle(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t pageBlockTitle::ID;

pageBlockTitle::pageBlockTitle(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockTitle::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockTitle");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

pageBlockSubtitle::pageBlockSubtitle()
  : text_()
{}

pageBlockSubtitle::pageBlockSubtitle(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t pageBlockSubtitle::ID;

pageBlockSubtitle::pageBlockSubtitle(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockSubtitle::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockSubtitle");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

pageBlockAuthorDate::pageBlockAuthorDate()
  : author_()
  , published_date_()
{}

pageBlockAuthorDate::pageBlockAuthorDate(object_ptr<RichText> &&author_, std::int32_t published_date_)
  : author_(std::move(author_))
  , published_date_(published_date_)
{}

const std::int32_t pageBlockAuthorDate::ID;

pageBlockAuthorDate::pageBlockAuthorDate(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : author_(TlFetchObject<RichText>::parse(p))
  , published_date_(TlFetchInt::parse(p))
#undef FAIL
{}

void pageBlockAuthorDate::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockAuthorDate");
    if (author_ == nullptr) { s.store_field("author", "null"); } else { author_->store(s, "author"); }
    s.store_field("published_date", published_date_);
    s.store_class_end();
  }
}

pageBlockHeader::pageBlockHeader()
  : text_()
{}

pageBlockHeader::pageBlockHeader(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t pageBlockHeader::ID;

pageBlockHeader::pageBlockHeader(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockHeader::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockHeader");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

pageBlockSubheader::pageBlockSubheader()
  : text_()
{}

pageBlockSubheader::pageBlockSubheader(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t pageBlockSubheader::ID;

pageBlockSubheader::pageBlockSubheader(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockSubheader::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockSubheader");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

pageBlockParagraph::pageBlockParagraph()
  : text_()
{}

pageBlockParagraph::pageBlockParagraph(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t pageBlockParagraph::ID;

pageBlockParagraph::pageBlockParagraph(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockParagraph::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockParagraph");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

pageBlockPreformatted::pageBlockPreformatted()
  : text_()
  , language_()
{}

pageBlockPreformatted::pageBlockPreformatted(object_ptr<RichText> &&text_, std::string const &language_)
  : text_(std::move(text_))
  , language_(language_)
{}

const std::int32_t pageBlockPreformatted::ID;

pageBlockPreformatted::pageBlockPreformatted(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
  , language_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void pageBlockPreformatted::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockPreformatted");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_field("language", language_);
    s.store_class_end();
  }
}

pageBlockFooter::pageBlockFooter()
  : text_()
{}

pageBlockFooter::pageBlockFooter(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t pageBlockFooter::ID;

pageBlockFooter::pageBlockFooter(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockFooter::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockFooter");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

pageBlockDivider::pageBlockDivider() {
}

const std::int32_t pageBlockDivider::ID;

pageBlockDivider::pageBlockDivider(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void pageBlockDivider::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockDivider");
    s.store_class_end();
  }
}

pageBlockAnchor::pageBlockAnchor()
  : name_()
{}

pageBlockAnchor::pageBlockAnchor(std::string const &name_)
  : name_(name_)
{}

const std::int32_t pageBlockAnchor::ID;

pageBlockAnchor::pageBlockAnchor(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : name_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void pageBlockAnchor::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockAnchor");
    s.store_field("name", name_);
    s.store_class_end();
  }
}

pageBlockList::pageBlockList()
  : ordered_()
  , items_()
{}

pageBlockList::pageBlockList(bool ordered_, std::vector<object_ptr<RichText>> &&items_)
  : ordered_(ordered_)
  , items_(std::move(items_))
{}

const std::int32_t pageBlockList::ID;

pageBlockList::pageBlockList(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : ordered_(TlFetchBool::parse(p))
  , items_(TlFetchBoxed<TlFetchVector<TlFetchObject<RichText>>, 481674261>::parse(p))
#undef FAIL
{}

void pageBlockList::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockList");
    s.store_field("ordered", ordered_);
    { const std::vector<object_ptr<RichText>> &v = items_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("items", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

pageBlockBlockquote::pageBlockBlockquote()
  : text_()
  , caption_()
{}

pageBlockBlockquote::pageBlockBlockquote(object_ptr<RichText> &&text_, object_ptr<RichText> &&caption_)
  : text_(std::move(text_))
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockBlockquote::ID;

pageBlockBlockquote::pageBlockBlockquote(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
  , caption_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockBlockquote::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockBlockquote");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

pageBlockPullquote::pageBlockPullquote()
  : text_()
  , caption_()
{}

pageBlockPullquote::pageBlockPullquote(object_ptr<RichText> &&text_, object_ptr<RichText> &&caption_)
  : text_(std::move(text_))
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockPullquote::ID;

pageBlockPullquote::pageBlockPullquote(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
  , caption_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockPullquote::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockPullquote");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

pageBlockPhoto::pageBlockPhoto()
  : photo_id_()
  , caption_()
{}

pageBlockPhoto::pageBlockPhoto(std::int64_t photo_id_, object_ptr<RichText> &&caption_)
  : photo_id_(photo_id_)
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockPhoto::ID;

pageBlockPhoto::pageBlockPhoto(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : photo_id_(TlFetchLong::parse(p))
  , caption_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockPhoto");
    s.store_field("photo_id", photo_id_);
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

pageBlockVideo::pageBlockVideo()
  : flags_()
  , autoplay_()
  , loop_()
  , video_id_()
  , caption_()
{}

pageBlockVideo::pageBlockVideo(std::int32_t flags_, bool autoplay_, bool loop_, std::int64_t video_id_, object_ptr<RichText> &&caption_)
  : flags_(flags_)
  , autoplay_(autoplay_)
  , loop_(loop_)
  , video_id_(video_id_)
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockVideo::ID;

object_ptr<pageBlockVideo> pageBlockVideo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<pageBlockVideo> res = make_tl_object<pageBlockVideo>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->autoplay_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->loop_ = TlFetchTrue::parse(p); }
  res->video_id_ = TlFetchLong::parse(p);
  res->caption_ = TlFetchObject<RichText>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void pageBlockVideo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockVideo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    s.store_field("video_id", video_id_);
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

pageBlockCover::pageBlockCover()
  : cover_()
{}

pageBlockCover::pageBlockCover(object_ptr<PageBlock> &&cover_)
  : cover_(std::move(cover_))
{}

const std::int32_t pageBlockCover::ID;

pageBlockCover::pageBlockCover(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : cover_(TlFetchObject<PageBlock>::parse(p))
#undef FAIL
{}

void pageBlockCover::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockCover");
    if (cover_ == nullptr) { s.store_field("cover", "null"); } else { cover_->store(s, "cover"); }
    s.store_class_end();
  }
}

pageBlockEmbed::pageBlockEmbed()
  : flags_()
  , full_width_()
  , allow_scrolling_()
  , url_()
  , html_()
  , poster_photo_id_()
  , w_()
  , h_()
  , caption_()
{}

pageBlockEmbed::pageBlockEmbed(std::int32_t flags_, bool full_width_, bool allow_scrolling_, std::string const &url_, std::string const &html_, std::int64_t poster_photo_id_, std::int32_t w_, std::int32_t h_, object_ptr<RichText> &&caption_)
  : flags_(flags_)
  , full_width_(full_width_)
  , allow_scrolling_(allow_scrolling_)
  , url_(url_)
  , html_(html_)
  , poster_photo_id_(poster_photo_id_)
  , w_(w_)
  , h_(h_)
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockEmbed::ID;

object_ptr<pageBlockEmbed> pageBlockEmbed::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<pageBlockEmbed> res = make_tl_object<pageBlockEmbed>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->full_width_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->allow_scrolling_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->url_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->html_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16) { res->poster_photo_id_ = TlFetchLong::parse(p); }
  res->w_ = TlFetchInt::parse(p);
  res->h_ = TlFetchInt::parse(p);
  res->caption_ = TlFetchObject<RichText>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void pageBlockEmbed::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockEmbed");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 8) {  }
    if (var0 & 2) { s.store_field("url", url_); }
    if (var0 & 4) { s.store_field("html", html_); }
    if (var0 & 16) { s.store_field("poster_photo_id", poster_photo_id_); }
    s.store_field("w", w_);
    s.store_field("h", h_);
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

pageBlockEmbedPost::pageBlockEmbedPost()
  : url_()
  , webpage_id_()
  , author_photo_id_()
  , author_()
  , date_()
  , blocks_()
  , caption_()
{}

pageBlockEmbedPost::pageBlockEmbedPost(std::string const &url_, std::int64_t webpage_id_, std::int64_t author_photo_id_, std::string const &author_, std::int32_t date_, std::vector<object_ptr<PageBlock>> &&blocks_, object_ptr<RichText> &&caption_)
  : url_(url_)
  , webpage_id_(webpage_id_)
  , author_photo_id_(author_photo_id_)
  , author_(author_)
  , date_(date_)
  , blocks_(std::move(blocks_))
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockEmbedPost::ID;

pageBlockEmbedPost::pageBlockEmbedPost(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , webpage_id_(TlFetchLong::parse(p))
  , author_photo_id_(TlFetchLong::parse(p))
  , author_(TlFetchString<std::string>::parse(p))
  , date_(TlFetchInt::parse(p))
  , blocks_(TlFetchBoxed<TlFetchVector<TlFetchObject<PageBlock>>, 481674261>::parse(p))
  , caption_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockEmbedPost::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockEmbedPost");
    s.store_field("url", url_);
    s.store_field("webpage_id", webpage_id_);
    s.store_field("author_photo_id", author_photo_id_);
    s.store_field("author", author_);
    s.store_field("date", date_);
    { const std::vector<object_ptr<PageBlock>> &v = blocks_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("blocks", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

pageBlockCollage::pageBlockCollage()
  : items_()
  , caption_()
{}

pageBlockCollage::pageBlockCollage(std::vector<object_ptr<PageBlock>> &&items_, object_ptr<RichText> &&caption_)
  : items_(std::move(items_))
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockCollage::ID;

pageBlockCollage::pageBlockCollage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : items_(TlFetchBoxed<TlFetchVector<TlFetchObject<PageBlock>>, 481674261>::parse(p))
  , caption_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockCollage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockCollage");
    { const std::vector<object_ptr<PageBlock>> &v = items_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("items", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

pageBlockSlideshow::pageBlockSlideshow()
  : items_()
  , caption_()
{}

pageBlockSlideshow::pageBlockSlideshow(std::vector<object_ptr<PageBlock>> &&items_, object_ptr<RichText> &&caption_)
  : items_(std::move(items_))
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockSlideshow::ID;

pageBlockSlideshow::pageBlockSlideshow(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : items_(TlFetchBoxed<TlFetchVector<TlFetchObject<PageBlock>>, 481674261>::parse(p))
  , caption_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockSlideshow::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockSlideshow");
    { const std::vector<object_ptr<PageBlock>> &v = items_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("items", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

pageBlockChannel::pageBlockChannel()
  : channel_()
{}

pageBlockChannel::pageBlockChannel(object_ptr<Chat> &&channel_)
  : channel_(std::move(channel_))
{}

const std::int32_t pageBlockChannel::ID;

pageBlockChannel::pageBlockChannel(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_(TlFetchObject<Chat>::parse(p))
#undef FAIL
{}

void pageBlockChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockChannel");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_class_end();
  }
}

pageBlockAudio::pageBlockAudio()
  : audio_id_()
  , caption_()
{}

pageBlockAudio::pageBlockAudio(std::int64_t audio_id_, object_ptr<RichText> &&caption_)
  : audio_id_(audio_id_)
  , caption_(std::move(caption_))
{}

const std::int32_t pageBlockAudio::ID;

pageBlockAudio::pageBlockAudio(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : audio_id_(TlFetchLong::parse(p))
  , caption_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void pageBlockAudio::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "pageBlockAudio");
    s.store_field("audio_id", audio_id_);
    if (caption_ == nullptr) { s.store_field("caption", "null"); } else { caption_->store(s, "caption"); }
    s.store_class_end();
  }
}

object_ptr<PasswordKdfAlgo> PasswordKdfAlgo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case passwordKdfAlgoUnknown::ID:
      return passwordKdfAlgoUnknown::fetch(p);
    case passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::ID:
      return passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

passwordKdfAlgoUnknown::passwordKdfAlgoUnknown() {
}

const std::int32_t passwordKdfAlgoUnknown::ID;

passwordKdfAlgoUnknown::passwordKdfAlgoUnknown(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void passwordKdfAlgoUnknown::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void passwordKdfAlgoUnknown::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void passwordKdfAlgoUnknown::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "passwordKdfAlgoUnknown");
    s.store_class_end();
  }
}

passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow()
  : salt1_()
  , salt2_()
  , g_()
  , p_()
{}

passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow(BufferSlice &&salt1_, BufferSlice &&salt2_, std::int32_t g_, BufferSlice &&p_)
  : salt1_(std::move(salt1_))
  , salt2_(std::move(salt2_))
  , g_(g_)
  , p_(std::move(p_))
{}

const std::int32_t passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::ID;

passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : salt1_(TlFetchBytes<BufferSlice>::parse(p))
  , salt2_(TlFetchBytes<BufferSlice>::parse(p))
  , g_(TlFetchInt::parse(p))
  , p_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(salt1_, s);
  TlStoreString::store(salt2_, s);
  TlStoreBinary::store(g_, s);
  TlStoreString::store(p_, s);
}

void passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(salt1_, s);
  TlStoreString::store(salt2_, s);
  TlStoreBinary::store(g_, s);
  TlStoreString::store(p_, s);
}

void passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow");
    s.store_bytes_field("salt1", salt1_);
    s.store_bytes_field("salt2", salt2_);
    s.store_field("g", g_);
    s.store_bytes_field("p", p_);
    s.store_class_end();
  }
}

paymentCharge::paymentCharge()
  : id_()
  , provider_charge_id_()
{}

paymentCharge::paymentCharge(std::string const &id_, std::string const &provider_charge_id_)
  : id_(id_)
  , provider_charge_id_(provider_charge_id_)
{}

const std::int32_t paymentCharge::ID;

paymentCharge::paymentCharge(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchString<std::string>::parse(p))
  , provider_charge_id_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void paymentCharge::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "paymentCharge");
    s.store_field("id", id_);
    s.store_field("provider_charge_id", provider_charge_id_);
    s.store_class_end();
  }
}

paymentRequestedInfo::paymentRequestedInfo()
  : flags_()
  , name_()
  , phone_()
  , email_()
  , shipping_address_()
{}

paymentRequestedInfo::paymentRequestedInfo(std::int32_t flags_, std::string const &name_, std::string const &phone_, std::string const &email_, object_ptr<postAddress> &&shipping_address_)
  : flags_(flags_)
  , name_(name_)
  , phone_(phone_)
  , email_(email_)
  , shipping_address_(std::move(shipping_address_))
{}

const std::int32_t paymentRequestedInfo::ID;

object_ptr<paymentRequestedInfo> paymentRequestedInfo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<paymentRequestedInfo> res = make_tl_object<paymentRequestedInfo>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->name_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 2) { res->phone_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->email_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 8) { res->shipping_address_ = TlFetchBoxed<TlFetchObject<postAddress>, 512535275>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void paymentRequestedInfo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreString::store(name_, s); }
  if (var0 & 2) { TlStoreString::store(phone_, s); }
  if (var0 & 4) { TlStoreString::store(email_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreObject, 512535275>::store(shipping_address_, s); }
}

void paymentRequestedInfo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreString::store(name_, s); }
  if (var0 & 2) { TlStoreString::store(phone_, s); }
  if (var0 & 4) { TlStoreString::store(email_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreObject, 512535275>::store(shipping_address_, s); }
}

void paymentRequestedInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "paymentRequestedInfo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("name", name_); }
    if (var0 & 2) { s.store_field("phone", phone_); }
    if (var0 & 4) { s.store_field("email", email_); }
    if (var0 & 8) { if (shipping_address_ == nullptr) { s.store_field("shipping_address", "null"); } else { shipping_address_->store(s, "shipping_address"); } }
    s.store_class_end();
  }
}

paymentSavedCredentialsCard::paymentSavedCredentialsCard()
  : id_()
  , title_()
{}

paymentSavedCredentialsCard::paymentSavedCredentialsCard(std::string const &id_, std::string const &title_)
  : id_(id_)
  , title_(title_)
{}

const std::int32_t paymentSavedCredentialsCard::ID;

paymentSavedCredentialsCard::paymentSavedCredentialsCard(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchString<std::string>::parse(p))
  , title_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void paymentSavedCredentialsCard::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "paymentSavedCredentialsCard");
    s.store_field("id", id_);
    s.store_field("title", title_);
    s.store_class_end();
  }
}

object_ptr<Peer> Peer::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case peerUser::ID:
      return peerUser::fetch(p);
    case peerChat::ID:
      return peerChat::fetch(p);
    case peerChannel::ID:
      return peerChannel::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

peerUser::peerUser()
  : user_id_()
{}

peerUser::peerUser(std::int32_t user_id_)
  : user_id_(user_id_)
{}

const std::int32_t peerUser::ID;

peerUser::peerUser(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void peerUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "peerUser");
    s.store_field("user_id", user_id_);
    s.store_class_end();
  }
}

peerChat::peerChat()
  : chat_id_()
{}

peerChat::peerChat(std::int32_t chat_id_)
  : chat_id_(chat_id_)
{}

const std::int32_t peerChat::ID;

peerChat::peerChat(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void peerChat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "peerChat");
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

peerChannel::peerChannel()
  : channel_id_()
{}

peerChannel::peerChannel(std::int32_t channel_id_)
  : channel_id_(channel_id_)
{}

const std::int32_t peerChannel::ID;

peerChannel::peerChannel(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void peerChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "peerChannel");
    s.store_field("channel_id", channel_id_);
    s.store_class_end();
  }
}

peerNotifySettings::peerNotifySettings()
  : flags_()
  , show_previews_()
  , silent_()
  , mute_until_()
  , sound_()
{}

peerNotifySettings::peerNotifySettings(std::int32_t flags_, bool show_previews_, bool silent_, std::int32_t mute_until_, std::string const &sound_)
  : flags_(flags_)
  , show_previews_(show_previews_)
  , silent_(silent_)
  , mute_until_(mute_until_)
  , sound_(sound_)
{}

const std::int32_t peerNotifySettings::ID;

object_ptr<peerNotifySettings> peerNotifySettings::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<peerNotifySettings> res = make_tl_object<peerNotifySettings>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->show_previews_ = TlFetchBool::parse(p); }
  if (var0 & 2) { res->silent_ = TlFetchBool::parse(p); }
  if (var0 & 4) { res->mute_until_ = TlFetchInt::parse(p); }
  if (var0 & 8) { res->sound_ = TlFetchString<std::string>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void peerNotifySettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "peerNotifySettings");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("show_previews", show_previews_); }
    if (var0 & 2) { s.store_field("silent", silent_); }
    if (var0 & 4) { s.store_field("mute_until", mute_until_); }
    if (var0 & 8) { s.store_field("sound", sound_); }
    s.store_class_end();
  }
}

peerSettings::peerSettings()
  : flags_()
  , report_spam_()
{}

peerSettings::peerSettings(std::int32_t flags_, bool report_spam_)
  : flags_(flags_)
  , report_spam_(report_spam_)
{}

const std::int32_t peerSettings::ID;

object_ptr<peerSettings> peerSettings::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<peerSettings> res = make_tl_object<peerSettings>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->report_spam_ = TlFetchTrue::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void peerSettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "peerSettings");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_class_end();
  }
}

object_ptr<PhoneCall> PhoneCall::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case phoneCallEmpty::ID:
      return phoneCallEmpty::fetch(p);
    case phoneCallWaiting::ID:
      return phoneCallWaiting::fetch(p);
    case phoneCallRequested::ID:
      return phoneCallRequested::fetch(p);
    case phoneCallAccepted::ID:
      return phoneCallAccepted::fetch(p);
    case phoneCall::ID:
      return phoneCall::fetch(p);
    case phoneCallDiscarded::ID:
      return phoneCallDiscarded::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

phoneCallEmpty::phoneCallEmpty()
  : id_()
{}

phoneCallEmpty::phoneCallEmpty(std::int64_t id_)
  : id_(id_)
{}

const std::int32_t phoneCallEmpty::ID;

phoneCallEmpty::phoneCallEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
#undef FAIL
{}

void phoneCallEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallEmpty");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

phoneCallWaiting::phoneCallWaiting()
  : flags_()
  , id_()
  , access_hash_()
  , date_()
  , admin_id_()
  , participant_id_()
  , protocol_()
  , receive_date_()
{}

phoneCallWaiting::phoneCallWaiting(std::int32_t flags_, std::int64_t id_, std::int64_t access_hash_, std::int32_t date_, std::int32_t admin_id_, std::int32_t participant_id_, object_ptr<phoneCallProtocol> &&protocol_, std::int32_t receive_date_)
  : flags_(flags_)
  , id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , admin_id_(admin_id_)
  , participant_id_(participant_id_)
  , protocol_(std::move(protocol_))
  , receive_date_(receive_date_)
{}

const std::int32_t phoneCallWaiting::ID;

object_ptr<phoneCallWaiting> phoneCallWaiting::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<phoneCallWaiting> res = make_tl_object<phoneCallWaiting>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->id_ = TlFetchLong::parse(p);
  res->access_hash_ = TlFetchLong::parse(p);
  res->date_ = TlFetchInt::parse(p);
  res->admin_id_ = TlFetchInt::parse(p);
  res->participant_id_ = TlFetchInt::parse(p);
  res->protocol_ = TlFetchBoxed<TlFetchObject<phoneCallProtocol>, -1564789301>::parse(p);
  if (var0 & 1) { res->receive_date_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void phoneCallWaiting::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallWaiting");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    s.store_field("admin_id", admin_id_);
    s.store_field("participant_id", participant_id_);
    if (protocol_ == nullptr) { s.store_field("protocol", "null"); } else { protocol_->store(s, "protocol"); }
    if (var0 & 1) { s.store_field("receive_date", receive_date_); }
    s.store_class_end();
  }
}

phoneCallRequested::phoneCallRequested()
  : id_()
  , access_hash_()
  , date_()
  , admin_id_()
  , participant_id_()
  , g_a_hash_()
  , protocol_()
{}

phoneCallRequested::phoneCallRequested(std::int64_t id_, std::int64_t access_hash_, std::int32_t date_, std::int32_t admin_id_, std::int32_t participant_id_, BufferSlice &&g_a_hash_, object_ptr<phoneCallProtocol> &&protocol_)
  : id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , admin_id_(admin_id_)
  , participant_id_(participant_id_)
  , g_a_hash_(std::move(g_a_hash_))
  , protocol_(std::move(protocol_))
{}

const std::int32_t phoneCallRequested::ID;

phoneCallRequested::phoneCallRequested(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
  , admin_id_(TlFetchInt::parse(p))
  , participant_id_(TlFetchInt::parse(p))
  , g_a_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , protocol_(TlFetchBoxed<TlFetchObject<phoneCallProtocol>, -1564789301>::parse(p))
#undef FAIL
{}

void phoneCallRequested::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallRequested");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    s.store_field("admin_id", admin_id_);
    s.store_field("participant_id", participant_id_);
    s.store_bytes_field("g_a_hash", g_a_hash_);
    if (protocol_ == nullptr) { s.store_field("protocol", "null"); } else { protocol_->store(s, "protocol"); }
    s.store_class_end();
  }
}

phoneCallAccepted::phoneCallAccepted()
  : id_()
  , access_hash_()
  , date_()
  , admin_id_()
  , participant_id_()
  , g_b_()
  , protocol_()
{}

phoneCallAccepted::phoneCallAccepted(std::int64_t id_, std::int64_t access_hash_, std::int32_t date_, std::int32_t admin_id_, std::int32_t participant_id_, BufferSlice &&g_b_, object_ptr<phoneCallProtocol> &&protocol_)
  : id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , admin_id_(admin_id_)
  , participant_id_(participant_id_)
  , g_b_(std::move(g_b_))
  , protocol_(std::move(protocol_))
{}

const std::int32_t phoneCallAccepted::ID;

phoneCallAccepted::phoneCallAccepted(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
  , admin_id_(TlFetchInt::parse(p))
  , participant_id_(TlFetchInt::parse(p))
  , g_b_(TlFetchBytes<BufferSlice>::parse(p))
  , protocol_(TlFetchBoxed<TlFetchObject<phoneCallProtocol>, -1564789301>::parse(p))
#undef FAIL
{}

void phoneCallAccepted::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallAccepted");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    s.store_field("admin_id", admin_id_);
    s.store_field("participant_id", participant_id_);
    s.store_bytes_field("g_b", g_b_);
    if (protocol_ == nullptr) { s.store_field("protocol", "null"); } else { protocol_->store(s, "protocol"); }
    s.store_class_end();
  }
}

phoneCall::phoneCall()
  : id_()
  , access_hash_()
  , date_()
  , admin_id_()
  , participant_id_()
  , g_a_or_b_()
  , key_fingerprint_()
  , protocol_()
  , connection_()
  , alternative_connections_()
  , start_date_()
{}

phoneCall::phoneCall(std::int64_t id_, std::int64_t access_hash_, std::int32_t date_, std::int32_t admin_id_, std::int32_t participant_id_, BufferSlice &&g_a_or_b_, std::int64_t key_fingerprint_, object_ptr<phoneCallProtocol> &&protocol_, object_ptr<phoneConnection> &&connection_, std::vector<object_ptr<phoneConnection>> &&alternative_connections_, std::int32_t start_date_)
  : id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , admin_id_(admin_id_)
  , participant_id_(participant_id_)
  , g_a_or_b_(std::move(g_a_or_b_))
  , key_fingerprint_(key_fingerprint_)
  , protocol_(std::move(protocol_))
  , connection_(std::move(connection_))
  , alternative_connections_(std::move(alternative_connections_))
  , start_date_(start_date_)
{}

const std::int32_t phoneCall::ID;

phoneCall::phoneCall(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
  , admin_id_(TlFetchInt::parse(p))
  , participant_id_(TlFetchInt::parse(p))
  , g_a_or_b_(TlFetchBytes<BufferSlice>::parse(p))
  , key_fingerprint_(TlFetchLong::parse(p))
  , protocol_(TlFetchBoxed<TlFetchObject<phoneCallProtocol>, -1564789301>::parse(p))
  , connection_(TlFetchBoxed<TlFetchObject<phoneConnection>, -1655957568>::parse(p))
  , alternative_connections_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<phoneConnection>, -1655957568>>, 481674261>::parse(p))
  , start_date_(TlFetchInt::parse(p))
#undef FAIL
{}

void phoneCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCall");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    s.store_field("admin_id", admin_id_);
    s.store_field("participant_id", participant_id_);
    s.store_bytes_field("g_a_or_b", g_a_or_b_);
    s.store_field("key_fingerprint", key_fingerprint_);
    if (protocol_ == nullptr) { s.store_field("protocol", "null"); } else { protocol_->store(s, "protocol"); }
    if (connection_ == nullptr) { s.store_field("connection", "null"); } else { connection_->store(s, "connection"); }
    { const std::vector<object_ptr<phoneConnection>> &v = alternative_connections_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("alternative_connections", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("start_date", start_date_);
    s.store_class_end();
  }
}

phoneCallDiscarded::phoneCallDiscarded()
  : flags_()
  , need_rating_()
  , need_debug_()
  , id_()
  , reason_()
  , duration_()
{}

phoneCallDiscarded::phoneCallDiscarded(std::int32_t flags_, bool need_rating_, bool need_debug_, std::int64_t id_, object_ptr<PhoneCallDiscardReason> &&reason_, std::int32_t duration_)
  : flags_(flags_)
  , need_rating_(need_rating_)
  , need_debug_(need_debug_)
  , id_(id_)
  , reason_(std::move(reason_))
  , duration_(duration_)
{}

const std::int32_t phoneCallDiscarded::ID;

object_ptr<phoneCallDiscarded> phoneCallDiscarded::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<phoneCallDiscarded> res = make_tl_object<phoneCallDiscarded>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 4) { res->need_rating_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->need_debug_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchLong::parse(p);
  if (var0 & 1) { res->reason_ = TlFetchObject<PhoneCallDiscardReason>::parse(p); }
  if (var0 & 2) { res->duration_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void phoneCallDiscarded::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallDiscarded");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    s.store_field("id", id_);
    if (var0 & 1) { if (reason_ == nullptr) { s.store_field("reason", "null"); } else { reason_->store(s, "reason"); } }
    if (var0 & 2) { s.store_field("duration", duration_); }
    s.store_class_end();
  }
}

object_ptr<PhoneCallDiscardReason> PhoneCallDiscardReason::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case phoneCallDiscardReasonMissed::ID:
      return phoneCallDiscardReasonMissed::fetch(p);
    case phoneCallDiscardReasonDisconnect::ID:
      return phoneCallDiscardReasonDisconnect::fetch(p);
    case phoneCallDiscardReasonHangup::ID:
      return phoneCallDiscardReasonHangup::fetch(p);
    case phoneCallDiscardReasonBusy::ID:
      return phoneCallDiscardReasonBusy::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

phoneCallDiscardReasonMissed::phoneCallDiscardReasonMissed() {
}

const std::int32_t phoneCallDiscardReasonMissed::ID;

phoneCallDiscardReasonMissed::phoneCallDiscardReasonMissed(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void phoneCallDiscardReasonMissed::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void phoneCallDiscardReasonMissed::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void phoneCallDiscardReasonMissed::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallDiscardReasonMissed");
    s.store_class_end();
  }
}

phoneCallDiscardReasonDisconnect::phoneCallDiscardReasonDisconnect() {
}

const std::int32_t phoneCallDiscardReasonDisconnect::ID;

phoneCallDiscardReasonDisconnect::phoneCallDiscardReasonDisconnect(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void phoneCallDiscardReasonDisconnect::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void phoneCallDiscardReasonDisconnect::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void phoneCallDiscardReasonDisconnect::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallDiscardReasonDisconnect");
    s.store_class_end();
  }
}

phoneCallDiscardReasonHangup::phoneCallDiscardReasonHangup() {
}

const std::int32_t phoneCallDiscardReasonHangup::ID;

phoneCallDiscardReasonHangup::phoneCallDiscardReasonHangup(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void phoneCallDiscardReasonHangup::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void phoneCallDiscardReasonHangup::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void phoneCallDiscardReasonHangup::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallDiscardReasonHangup");
    s.store_class_end();
  }
}

phoneCallDiscardReasonBusy::phoneCallDiscardReasonBusy() {
}

const std::int32_t phoneCallDiscardReasonBusy::ID;

phoneCallDiscardReasonBusy::phoneCallDiscardReasonBusy(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void phoneCallDiscardReasonBusy::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void phoneCallDiscardReasonBusy::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void phoneCallDiscardReasonBusy::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallDiscardReasonBusy");
    s.store_class_end();
  }
}

phoneCallProtocol::phoneCallProtocol()
  : flags_()
  , udp_p2p_()
  , udp_reflector_()
  , min_layer_()
  , max_layer_()
{}

phoneCallProtocol::phoneCallProtocol(std::int32_t flags_, bool udp_p2p_, bool udp_reflector_, std::int32_t min_layer_, std::int32_t max_layer_)
  : flags_(flags_)
  , udp_p2p_(udp_p2p_)
  , udp_reflector_(udp_reflector_)
  , min_layer_(min_layer_)
  , max_layer_(max_layer_)
{}

const std::int32_t phoneCallProtocol::ID;

object_ptr<phoneCallProtocol> phoneCallProtocol::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<phoneCallProtocol> res = make_tl_object<phoneCallProtocol>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->udp_p2p_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->udp_reflector_ = TlFetchTrue::parse(p); }
  res->min_layer_ = TlFetchInt::parse(p);
  res->max_layer_ = TlFetchInt::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void phoneCallProtocol::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(udp_p2p_, s); }
  if (var0 & 2) { TlStoreTrue::store(udp_reflector_, s); }
  TlStoreBinary::store(min_layer_, s);
  TlStoreBinary::store(max_layer_, s);
}

void phoneCallProtocol::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(udp_p2p_, s); }
  if (var0 & 2) { TlStoreTrue::store(udp_reflector_, s); }
  TlStoreBinary::store(min_layer_, s);
  TlStoreBinary::store(max_layer_, s);
}

void phoneCallProtocol::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneCallProtocol");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    s.store_field("min_layer", min_layer_);
    s.store_field("max_layer", max_layer_);
    s.store_class_end();
  }
}

phoneConnection::phoneConnection()
  : id_()
  , ip_()
  , ipv6_()
  , port_()
  , peer_tag_()
{}

phoneConnection::phoneConnection(std::int64_t id_, std::string const &ip_, std::string const &ipv6_, std::int32_t port_, BufferSlice &&peer_tag_)
  : id_(id_)
  , ip_(ip_)
  , ipv6_(ipv6_)
  , port_(port_)
  , peer_tag_(std::move(peer_tag_))
{}

const std::int32_t phoneConnection::ID;

phoneConnection::phoneConnection(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , ip_(TlFetchString<std::string>::parse(p))
  , ipv6_(TlFetchString<std::string>::parse(p))
  , port_(TlFetchInt::parse(p))
  , peer_tag_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void phoneConnection::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phoneConnection");
    s.store_field("id", id_);
    s.store_field("ip", ip_);
    s.store_field("ipv6", ipv6_);
    s.store_field("port", port_);
    s.store_bytes_field("peer_tag", peer_tag_);
    s.store_class_end();
  }
}

object_ptr<Photo> Photo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case photoEmpty::ID:
      return photoEmpty::fetch(p);
    case photo::ID:
      return photo::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

photoEmpty::photoEmpty()
  : id_()
{}

photoEmpty::photoEmpty(std::int64_t id_)
  : id_(id_)
{}

const std::int32_t photoEmpty::ID;

photoEmpty::photoEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
#undef FAIL
{}

void photoEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photoEmpty");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

photo::photo()
  : flags_()
  , has_stickers_()
  , id_()
  , access_hash_()
  , date_()
  , sizes_()
{}

photo::photo(std::int32_t flags_, bool has_stickers_, std::int64_t id_, std::int64_t access_hash_, std::int32_t date_, std::vector<object_ptr<PhotoSize>> &&sizes_)
  : flags_(flags_)
  , has_stickers_(has_stickers_)
  , id_(id_)
  , access_hash_(access_hash_)
  , date_(date_)
  , sizes_(std::move(sizes_))
{}

const std::int32_t photo::ID;

object_ptr<photo> photo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<photo> res = make_tl_object<photo>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->has_stickers_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchLong::parse(p);
  res->access_hash_ = TlFetchLong::parse(p);
  res->date_ = TlFetchInt::parse(p);
  res->sizes_ = TlFetchBoxed<TlFetchVector<TlFetchObject<PhotoSize>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void photo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("date", date_);
    { const std::vector<object_ptr<PhotoSize>> &v = sizes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("sizes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<PhotoSize> PhotoSize::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case photoSizeEmpty::ID:
      return photoSizeEmpty::fetch(p);
    case photoSize::ID:
      return photoSize::fetch(p);
    case photoCachedSize::ID:
      return photoCachedSize::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

photoSizeEmpty::photoSizeEmpty()
  : type_()
{}

photoSizeEmpty::photoSizeEmpty(std::string const &type_)
  : type_(type_)
{}

const std::int32_t photoSizeEmpty::ID;

photoSizeEmpty::photoSizeEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void photoSizeEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photoSizeEmpty");
    s.store_field("type", type_);
    s.store_class_end();
  }
}

photoSize::photoSize()
  : type_()
  , location_()
  , w_()
  , h_()
  , size_()
{}

photoSize::photoSize(std::string const &type_, object_ptr<FileLocation> &&location_, std::int32_t w_, std::int32_t h_, std::int32_t size_)
  : type_(type_)
  , location_(std::move(location_))
  , w_(w_)
  , h_(h_)
  , size_(size_)
{}

const std::int32_t photoSize::ID;

photoSize::photoSize(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchString<std::string>::parse(p))
  , location_(TlFetchObject<FileLocation>::parse(p))
  , w_(TlFetchInt::parse(p))
  , h_(TlFetchInt::parse(p))
  , size_(TlFetchInt::parse(p))
#undef FAIL
{}

void photoSize::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photoSize");
    s.store_field("type", type_);
    if (location_ == nullptr) { s.store_field("location", "null"); } else { location_->store(s, "location"); }
    s.store_field("w", w_);
    s.store_field("h", h_);
    s.store_field("size", size_);
    s.store_class_end();
  }
}

photoCachedSize::photoCachedSize()
  : type_()
  , location_()
  , w_()
  , h_()
  , bytes_()
{}

photoCachedSize::photoCachedSize(std::string const &type_, object_ptr<FileLocation> &&location_, std::int32_t w_, std::int32_t h_, BufferSlice &&bytes_)
  : type_(type_)
  , location_(std::move(location_))
  , w_(w_)
  , h_(h_)
  , bytes_(std::move(bytes_))
{}

const std::int32_t photoCachedSize::ID;

photoCachedSize::photoCachedSize(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchString<std::string>::parse(p))
  , location_(TlFetchObject<FileLocation>::parse(p))
  , w_(TlFetchInt::parse(p))
  , h_(TlFetchInt::parse(p))
  , bytes_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void photoCachedSize::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photoCachedSize");
    s.store_field("type", type_);
    if (location_ == nullptr) { s.store_field("location", "null"); } else { location_->store(s, "location"); }
    s.store_field("w", w_);
    s.store_field("h", h_);
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

popularContact::popularContact()
  : client_id_()
  , importers_()
{}

popularContact::popularContact(std::int64_t client_id_, std::int32_t importers_)
  : client_id_(client_id_)
  , importers_(importers_)
{}

const std::int32_t popularContact::ID;

popularContact::popularContact(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : client_id_(TlFetchLong::parse(p))
  , importers_(TlFetchInt::parse(p))
#undef FAIL
{}

void popularContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "popularContact");
    s.store_field("client_id", client_id_);
    s.store_field("importers", importers_);
    s.store_class_end();
  }
}

postAddress::postAddress()
  : street_line1_()
  , street_line2_()
  , city_()
  , state_()
  , country_iso2_()
  , post_code_()
{}

postAddress::postAddress(std::string const &street_line1_, std::string const &street_line2_, std::string const &city_, std::string const &state_, std::string const &country_iso2_, std::string const &post_code_)
  : street_line1_(street_line1_)
  , street_line2_(street_line2_)
  , city_(city_)
  , state_(state_)
  , country_iso2_(country_iso2_)
  , post_code_(post_code_)
{}

const std::int32_t postAddress::ID;

postAddress::postAddress(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : street_line1_(TlFetchString<std::string>::parse(p))
  , street_line2_(TlFetchString<std::string>::parse(p))
  , city_(TlFetchString<std::string>::parse(p))
  , state_(TlFetchString<std::string>::parse(p))
  , country_iso2_(TlFetchString<std::string>::parse(p))
  , post_code_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void postAddress::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(street_line1_, s);
  TlStoreString::store(street_line2_, s);
  TlStoreString::store(city_, s);
  TlStoreString::store(state_, s);
  TlStoreString::store(country_iso2_, s);
  TlStoreString::store(post_code_, s);
}

void postAddress::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(street_line1_, s);
  TlStoreString::store(street_line2_, s);
  TlStoreString::store(city_, s);
  TlStoreString::store(state_, s);
  TlStoreString::store(country_iso2_, s);
  TlStoreString::store(post_code_, s);
}

void postAddress::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "postAddress");
    s.store_field("street_line1", street_line1_);
    s.store_field("street_line2", street_line2_);
    s.store_field("city", city_);
    s.store_field("state", state_);
    s.store_field("country_iso2", country_iso2_);
    s.store_field("post_code", post_code_);
    s.store_class_end();
  }
}

object_ptr<PrivacyKey> PrivacyKey::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case privacyKeyStatusTimestamp::ID:
      return privacyKeyStatusTimestamp::fetch(p);
    case privacyKeyChatInvite::ID:
      return privacyKeyChatInvite::fetch(p);
    case privacyKeyPhoneCall::ID:
      return privacyKeyPhoneCall::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

privacyKeyStatusTimestamp::privacyKeyStatusTimestamp() {
}

const std::int32_t privacyKeyStatusTimestamp::ID;

privacyKeyStatusTimestamp::privacyKeyStatusTimestamp(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void privacyKeyStatusTimestamp::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyKeyStatusTimestamp");
    s.store_class_end();
  }
}

privacyKeyChatInvite::privacyKeyChatInvite() {
}

const std::int32_t privacyKeyChatInvite::ID;

privacyKeyChatInvite::privacyKeyChatInvite(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void privacyKeyChatInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyKeyChatInvite");
    s.store_class_end();
  }
}

privacyKeyPhoneCall::privacyKeyPhoneCall() {
}

const std::int32_t privacyKeyPhoneCall::ID;

privacyKeyPhoneCall::privacyKeyPhoneCall(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void privacyKeyPhoneCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyKeyPhoneCall");
    s.store_class_end();
  }
}

object_ptr<PrivacyRule> PrivacyRule::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case privacyValueAllowContacts::ID:
      return privacyValueAllowContacts::fetch(p);
    case privacyValueAllowAll::ID:
      return privacyValueAllowAll::fetch(p);
    case privacyValueAllowUsers::ID:
      return privacyValueAllowUsers::fetch(p);
    case privacyValueDisallowContacts::ID:
      return privacyValueDisallowContacts::fetch(p);
    case privacyValueDisallowAll::ID:
      return privacyValueDisallowAll::fetch(p);
    case privacyValueDisallowUsers::ID:
      return privacyValueDisallowUsers::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

privacyValueAllowContacts::privacyValueAllowContacts() {
}

const std::int32_t privacyValueAllowContacts::ID;

privacyValueAllowContacts::privacyValueAllowContacts(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void privacyValueAllowContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyValueAllowContacts");
    s.store_class_end();
  }
}

privacyValueAllowAll::privacyValueAllowAll() {
}

const std::int32_t privacyValueAllowAll::ID;

privacyValueAllowAll::privacyValueAllowAll(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void privacyValueAllowAll::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyValueAllowAll");
    s.store_class_end();
  }
}

privacyValueAllowUsers::privacyValueAllowUsers()
  : users_()
{}

privacyValueAllowUsers::privacyValueAllowUsers(std::vector<std::int32_t> &&users_)
  : users_(std::move(users_))
{}

const std::int32_t privacyValueAllowUsers::ID;

privacyValueAllowUsers::privacyValueAllowUsers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : users_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
#undef FAIL
{}

void privacyValueAllowUsers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyValueAllowUsers");
    { const std::vector<std::int32_t> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

privacyValueDisallowContacts::privacyValueDisallowContacts() {
}

const std::int32_t privacyValueDisallowContacts::ID;

privacyValueDisallowContacts::privacyValueDisallowContacts(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void privacyValueDisallowContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyValueDisallowContacts");
    s.store_class_end();
  }
}

privacyValueDisallowAll::privacyValueDisallowAll() {
}

const std::int32_t privacyValueDisallowAll::ID;

privacyValueDisallowAll::privacyValueDisallowAll(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void privacyValueDisallowAll::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyValueDisallowAll");
    s.store_class_end();
  }
}

privacyValueDisallowUsers::privacyValueDisallowUsers()
  : users_()
{}

privacyValueDisallowUsers::privacyValueDisallowUsers(std::vector<std::int32_t> &&users_)
  : users_(std::move(users_))
{}

const std::int32_t privacyValueDisallowUsers::ID;

privacyValueDisallowUsers::privacyValueDisallowUsers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : users_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
#undef FAIL
{}

void privacyValueDisallowUsers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "privacyValueDisallowUsers");
    { const std::vector<std::int32_t> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

receivedNotifyMessage::receivedNotifyMessage()
  : id_()
  , flags_()
{}

receivedNotifyMessage::receivedNotifyMessage(std::int32_t id_, std::int32_t flags_)
  : id_(id_)
  , flags_(flags_)
{}

const std::int32_t receivedNotifyMessage::ID;

receivedNotifyMessage::receivedNotifyMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , flags_(TlFetchInt::parse(p))
#undef FAIL
{}

void receivedNotifyMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "receivedNotifyMessage");
    s.store_field("id", id_);
    s.store_field("flags", flags_);
    s.store_class_end();
  }
}

object_ptr<RecentMeUrl> RecentMeUrl::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case recentMeUrlUnknown::ID:
      return recentMeUrlUnknown::fetch(p);
    case recentMeUrlUser::ID:
      return recentMeUrlUser::fetch(p);
    case recentMeUrlChat::ID:
      return recentMeUrlChat::fetch(p);
    case recentMeUrlChatInvite::ID:
      return recentMeUrlChatInvite::fetch(p);
    case recentMeUrlStickerSet::ID:
      return recentMeUrlStickerSet::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

recentMeUrlUnknown::recentMeUrlUnknown()
  : url_()
{}

recentMeUrlUnknown::recentMeUrlUnknown(std::string const &url_)
  : url_(url_)
{}

const std::int32_t recentMeUrlUnknown::ID;

recentMeUrlUnknown::recentMeUrlUnknown(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void recentMeUrlUnknown::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "recentMeUrlUnknown");
    s.store_field("url", url_);
    s.store_class_end();
  }
}

recentMeUrlUser::recentMeUrlUser()
  : url_()
  , user_id_()
{}

recentMeUrlUser::recentMeUrlUser(std::string const &url_, std::int32_t user_id_)
  : url_(url_)
  , user_id_(user_id_)
{}

const std::int32_t recentMeUrlUser::ID;

recentMeUrlUser::recentMeUrlUser(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , user_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void recentMeUrlUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "recentMeUrlUser");
    s.store_field("url", url_);
    s.store_field("user_id", user_id_);
    s.store_class_end();
  }
}

recentMeUrlChat::recentMeUrlChat()
  : url_()
  , chat_id_()
{}

recentMeUrlChat::recentMeUrlChat(std::string const &url_, std::int32_t chat_id_)
  : url_(url_)
  , chat_id_(chat_id_)
{}

const std::int32_t recentMeUrlChat::ID;

recentMeUrlChat::recentMeUrlChat(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , chat_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void recentMeUrlChat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "recentMeUrlChat");
    s.store_field("url", url_);
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

recentMeUrlChatInvite::recentMeUrlChatInvite()
  : url_()
  , chat_invite_()
{}

recentMeUrlChatInvite::recentMeUrlChatInvite(std::string const &url_, object_ptr<ChatInvite> &&chat_invite_)
  : url_(url_)
  , chat_invite_(std::move(chat_invite_))
{}

const std::int32_t recentMeUrlChatInvite::ID;

recentMeUrlChatInvite::recentMeUrlChatInvite(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , chat_invite_(TlFetchObject<ChatInvite>::parse(p))
#undef FAIL
{}

void recentMeUrlChatInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "recentMeUrlChatInvite");
    s.store_field("url", url_);
    if (chat_invite_ == nullptr) { s.store_field("chat_invite", "null"); } else { chat_invite_->store(s, "chat_invite"); }
    s.store_class_end();
  }
}

recentMeUrlStickerSet::recentMeUrlStickerSet()
  : url_()
  , set_()
{}

recentMeUrlStickerSet::recentMeUrlStickerSet(std::string const &url_, object_ptr<StickerSetCovered> &&set_)
  : url_(url_)
  , set_(std::move(set_))
{}

const std::int32_t recentMeUrlStickerSet::ID;

recentMeUrlStickerSet::recentMeUrlStickerSet(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , set_(TlFetchObject<StickerSetCovered>::parse(p))
#undef FAIL
{}

void recentMeUrlStickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "recentMeUrlStickerSet");
    s.store_field("url", url_);
    if (set_ == nullptr) { s.store_field("set", "null"); } else { set_->store(s, "set"); }
    s.store_class_end();
  }
}

object_ptr<ReplyMarkup> ReplyMarkup::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case replyKeyboardHide::ID:
      return replyKeyboardHide::fetch(p);
    case replyKeyboardForceReply::ID:
      return replyKeyboardForceReply::fetch(p);
    case replyKeyboardMarkup::ID:
      return replyKeyboardMarkup::fetch(p);
    case replyInlineMarkup::ID:
      return replyInlineMarkup::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

replyKeyboardHide::replyKeyboardHide()
  : flags_()
  , selective_()
{}

replyKeyboardHide::replyKeyboardHide(std::int32_t flags_, bool selective_)
  : flags_(flags_)
  , selective_(selective_)
{}

const std::int32_t replyKeyboardHide::ID;

object_ptr<replyKeyboardHide> replyKeyboardHide::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<replyKeyboardHide> res = make_tl_object<replyKeyboardHide>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 4) { res->selective_ = TlFetchTrue::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void replyKeyboardHide::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 4) { TlStoreTrue::store(selective_, s); }
}

void replyKeyboardHide::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 4) { TlStoreTrue::store(selective_, s); }
}

void replyKeyboardHide::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "replyKeyboardHide");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 4) {  }
    s.store_class_end();
  }
}

replyKeyboardForceReply::replyKeyboardForceReply()
  : flags_()
  , single_use_()
  , selective_()
{}

replyKeyboardForceReply::replyKeyboardForceReply(std::int32_t flags_, bool single_use_, bool selective_)
  : flags_(flags_)
  , single_use_(single_use_)
  , selective_(selective_)
{}

const std::int32_t replyKeyboardForceReply::ID;

object_ptr<replyKeyboardForceReply> replyKeyboardForceReply::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<replyKeyboardForceReply> res = make_tl_object<replyKeyboardForceReply>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->single_use_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->selective_ = TlFetchTrue::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void replyKeyboardForceReply::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(single_use_, s); }
  if (var0 & 4) { TlStoreTrue::store(selective_, s); }
}

void replyKeyboardForceReply::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(single_use_, s); }
  if (var0 & 4) { TlStoreTrue::store(selective_, s); }
}

void replyKeyboardForceReply::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "replyKeyboardForceReply");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    s.store_class_end();
  }
}

replyKeyboardMarkup::replyKeyboardMarkup()
  : flags_()
  , resize_()
  , single_use_()
  , selective_()
  , rows_()
{}

replyKeyboardMarkup::replyKeyboardMarkup(std::int32_t flags_, bool resize_, bool single_use_, bool selective_, std::vector<object_ptr<keyboardButtonRow>> &&rows_)
  : flags_(flags_)
  , resize_(resize_)
  , single_use_(single_use_)
  , selective_(selective_)
  , rows_(std::move(rows_))
{}

const std::int32_t replyKeyboardMarkup::ID;

object_ptr<replyKeyboardMarkup> replyKeyboardMarkup::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<replyKeyboardMarkup> res = make_tl_object<replyKeyboardMarkup>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->resize_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->single_use_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->selective_ = TlFetchTrue::parse(p); }
  res->rows_ = TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<keyboardButtonRow>, 2002815875>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void replyKeyboardMarkup::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(resize_, s); }
  if (var0 & 2) { TlStoreTrue::store(single_use_, s); }
  if (var0 & 4) { TlStoreTrue::store(selective_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 2002815875>>, 481674261>::store(rows_, s);
}

void replyKeyboardMarkup::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(resize_, s); }
  if (var0 & 2) { TlStoreTrue::store(single_use_, s); }
  if (var0 & 4) { TlStoreTrue::store(selective_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 2002815875>>, 481674261>::store(rows_, s);
}

void replyKeyboardMarkup::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "replyKeyboardMarkup");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    { const std::vector<object_ptr<keyboardButtonRow>> &v = rows_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("rows", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

replyInlineMarkup::replyInlineMarkup()
  : rows_()
{}

replyInlineMarkup::replyInlineMarkup(std::vector<object_ptr<keyboardButtonRow>> &&rows_)
  : rows_(std::move(rows_))
{}

const std::int32_t replyInlineMarkup::ID;

replyInlineMarkup::replyInlineMarkup(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : rows_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<keyboardButtonRow>, 2002815875>>, 481674261>::parse(p))
#undef FAIL
{}

void replyInlineMarkup::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 2002815875>>, 481674261>::store(rows_, s);
}

void replyInlineMarkup::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 2002815875>>, 481674261>::store(rows_, s);
}

void replyInlineMarkup::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "replyInlineMarkup");
    { const std::vector<object_ptr<keyboardButtonRow>> &v = rows_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("rows", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

inputReportReasonSpam::inputReportReasonSpam() {
}

const std::int32_t inputReportReasonSpam::ID;

void inputReportReasonSpam::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputReportReasonSpam::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputReportReasonSpam::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputReportReasonSpam");
    s.store_class_end();
  }
}

inputReportReasonViolence::inputReportReasonViolence() {
}

const std::int32_t inputReportReasonViolence::ID;

void inputReportReasonViolence::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputReportReasonViolence::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputReportReasonViolence::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputReportReasonViolence");
    s.store_class_end();
  }
}

inputReportReasonPornography::inputReportReasonPornography() {
}

const std::int32_t inputReportReasonPornography::ID;

void inputReportReasonPornography::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputReportReasonPornography::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputReportReasonPornography::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputReportReasonPornography");
    s.store_class_end();
  }
}

inputReportReasonOther::inputReportReasonOther()
  : text_()
{}

inputReportReasonOther::inputReportReasonOther(std::string const &text_)
  : text_(text_)
{}

const std::int32_t inputReportReasonOther::ID;

void inputReportReasonOther::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void inputReportReasonOther::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(text_, s);
}

void inputReportReasonOther::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputReportReasonOther");
    s.store_field("text", text_);
    s.store_class_end();
  }
}

inputReportReasonCopyright::inputReportReasonCopyright() {
}

const std::int32_t inputReportReasonCopyright::ID;

void inputReportReasonCopyright::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void inputReportReasonCopyright::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void inputReportReasonCopyright::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "inputReportReasonCopyright");
    s.store_class_end();
  }
}

object_ptr<RichText> RichText::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case textEmpty::ID:
      return textEmpty::fetch(p);
    case textPlain::ID:
      return textPlain::fetch(p);
    case textBold::ID:
      return textBold::fetch(p);
    case textItalic::ID:
      return textItalic::fetch(p);
    case textUnderline::ID:
      return textUnderline::fetch(p);
    case textStrike::ID:
      return textStrike::fetch(p);
    case textFixed::ID:
      return textFixed::fetch(p);
    case textUrl::ID:
      return textUrl::fetch(p);
    case textEmail::ID:
      return textEmail::fetch(p);
    case textConcat::ID:
      return textConcat::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

textEmpty::textEmpty() {
}

const std::int32_t textEmpty::ID;

textEmpty::textEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void textEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textEmpty");
    s.store_class_end();
  }
}

textPlain::textPlain()
  : text_()
{}

textPlain::textPlain(std::string const &text_)
  : text_(text_)
{}

const std::int32_t textPlain::ID;

textPlain::textPlain(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void textPlain::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textPlain");
    s.store_field("text", text_);
    s.store_class_end();
  }
}

textBold::textBold()
  : text_()
{}

textBold::textBold(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t textBold::ID;

textBold::textBold(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void textBold::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textBold");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

textItalic::textItalic()
  : text_()
{}

textItalic::textItalic(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t textItalic::ID;

textItalic::textItalic(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void textItalic::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textItalic");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

textUnderline::textUnderline()
  : text_()
{}

textUnderline::textUnderline(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t textUnderline::ID;

textUnderline::textUnderline(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void textUnderline::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textUnderline");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

textStrike::textStrike()
  : text_()
{}

textStrike::textStrike(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t textStrike::ID;

textStrike::textStrike(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void textStrike::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textStrike");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

textFixed::textFixed()
  : text_()
{}

textFixed::textFixed(object_ptr<RichText> &&text_)
  : text_(std::move(text_))
{}

const std::int32_t textFixed::ID;

textFixed::textFixed(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
#undef FAIL
{}

void textFixed::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textFixed");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_class_end();
  }
}

textUrl::textUrl()
  : text_()
  , url_()
  , webpage_id_()
{}

textUrl::textUrl(object_ptr<RichText> &&text_, std::string const &url_, std::int64_t webpage_id_)
  : text_(std::move(text_))
  , url_(url_)
  , webpage_id_(webpage_id_)
{}

const std::int32_t textUrl::ID;

textUrl::textUrl(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
  , url_(TlFetchString<std::string>::parse(p))
  , webpage_id_(TlFetchLong::parse(p))
#undef FAIL
{}

void textUrl::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textUrl");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_field("url", url_);
    s.store_field("webpage_id", webpage_id_);
    s.store_class_end();
  }
}

textEmail::textEmail()
  : text_()
  , email_()
{}

textEmail::textEmail(object_ptr<RichText> &&text_, std::string const &email_)
  : text_(std::move(text_))
  , email_(email_)
{}

const std::int32_t textEmail::ID;

textEmail::textEmail(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : text_(TlFetchObject<RichText>::parse(p))
  , email_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void textEmail::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textEmail");
    if (text_ == nullptr) { s.store_field("text", "null"); } else { text_->store(s, "text"); }
    s.store_field("email", email_);
    s.store_class_end();
  }
}

textConcat::textConcat()
  : texts_()
{}

textConcat::textConcat(std::vector<object_ptr<RichText>> &&texts_)
  : texts_(std::move(texts_))
{}

const std::int32_t textConcat::ID;

textConcat::textConcat(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : texts_(TlFetchBoxed<TlFetchVector<TlFetchObject<RichText>>, 481674261>::parse(p))
#undef FAIL
{}

void textConcat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "textConcat");
    { const std::vector<object_ptr<RichText>> &v = texts_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("texts", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

savedPhoneContact::savedPhoneContact()
  : phone_()
  , first_name_()
  , last_name_()
  , date_()
{}

savedPhoneContact::savedPhoneContact(std::string const &phone_, std::string const &first_name_, std::string const &last_name_, std::int32_t date_)
  : phone_(phone_)
  , first_name_(first_name_)
  , last_name_(last_name_)
  , date_(date_)
{}

const std::int32_t savedPhoneContact::ID;

savedPhoneContact::savedPhoneContact(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : phone_(TlFetchString<std::string>::parse(p))
  , first_name_(TlFetchString<std::string>::parse(p))
  , last_name_(TlFetchString<std::string>::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void savedPhoneContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "savedPhoneContact");
    s.store_field("phone", phone_);
    s.store_field("first_name", first_name_);
    s.store_field("last_name", last_name_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

secureCredentialsEncrypted::secureCredentialsEncrypted()
  : data_()
  , hash_()
  , secret_()
{}

secureCredentialsEncrypted::secureCredentialsEncrypted(BufferSlice &&data_, BufferSlice &&hash_, BufferSlice &&secret_)
  : data_(std::move(data_))
  , hash_(std::move(hash_))
  , secret_(std::move(secret_))
{}

const std::int32_t secureCredentialsEncrypted::ID;

secureCredentialsEncrypted::secureCredentialsEncrypted(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : data_(TlFetchBytes<BufferSlice>::parse(p))
  , hash_(TlFetchBytes<BufferSlice>::parse(p))
  , secret_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void secureCredentialsEncrypted::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(data_, s);
  TlStoreString::store(hash_, s);
  TlStoreString::store(secret_, s);
}

void secureCredentialsEncrypted::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(data_, s);
  TlStoreString::store(hash_, s);
  TlStoreString::store(secret_, s);
}

void secureCredentialsEncrypted::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureCredentialsEncrypted");
    s.store_bytes_field("data", data_);
    s.store_bytes_field("hash", hash_);
    s.store_bytes_field("secret", secret_);
    s.store_class_end();
  }
}

secureData::secureData()
  : data_()
  , data_hash_()
  , secret_()
{}

secureData::secureData(BufferSlice &&data_, BufferSlice &&data_hash_, BufferSlice &&secret_)
  : data_(std::move(data_))
  , data_hash_(std::move(data_hash_))
  , secret_(std::move(secret_))
{}

const std::int32_t secureData::ID;

secureData::secureData(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : data_(TlFetchBytes<BufferSlice>::parse(p))
  , data_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , secret_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void secureData::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(data_, s);
  TlStoreString::store(data_hash_, s);
  TlStoreString::store(secret_, s);
}

void secureData::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(data_, s);
  TlStoreString::store(data_hash_, s);
  TlStoreString::store(secret_, s);
}

void secureData::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureData");
    s.store_bytes_field("data", data_);
    s.store_bytes_field("data_hash", data_hash_);
    s.store_bytes_field("secret", secret_);
    s.store_class_end();
  }
}

object_ptr<SecureFile> SecureFile::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case secureFileEmpty::ID:
      return secureFileEmpty::fetch(p);
    case secureFile::ID:
      return secureFile::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

secureFileEmpty::secureFileEmpty() {
}

const std::int32_t secureFileEmpty::ID;

secureFileEmpty::secureFileEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureFileEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureFileEmpty");
    s.store_class_end();
  }
}

secureFile::secureFile()
  : id_()
  , access_hash_()
  , size_()
  , dc_id_()
  , date_()
  , file_hash_()
  , secret_()
{}

secureFile::secureFile(std::int64_t id_, std::int64_t access_hash_, std::int32_t size_, std::int32_t dc_id_, std::int32_t date_, BufferSlice &&file_hash_, BufferSlice &&secret_)
  : id_(id_)
  , access_hash_(access_hash_)
  , size_(size_)
  , dc_id_(dc_id_)
  , date_(date_)
  , file_hash_(std::move(file_hash_))
  , secret_(std::move(secret_))
{}

const std::int32_t secureFile::ID;

secureFile::secureFile(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , size_(TlFetchInt::parse(p))
  , dc_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
  , file_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , secret_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void secureFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureFile");
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("size", size_);
    s.store_field("dc_id", dc_id_);
    s.store_field("date", date_);
    s.store_bytes_field("file_hash", file_hash_);
    s.store_bytes_field("secret", secret_);
    s.store_class_end();
  }
}

object_ptr<SecurePasswordKdfAlgo> SecurePasswordKdfAlgo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case securePasswordKdfAlgoUnknown::ID:
      return securePasswordKdfAlgoUnknown::fetch(p);
    case securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::ID:
      return securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::fetch(p);
    case securePasswordKdfAlgoSHA512::ID:
      return securePasswordKdfAlgoSHA512::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

securePasswordKdfAlgoUnknown::securePasswordKdfAlgoUnknown() {
}

const std::int32_t securePasswordKdfAlgoUnknown::ID;

securePasswordKdfAlgoUnknown::securePasswordKdfAlgoUnknown(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void securePasswordKdfAlgoUnknown::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void securePasswordKdfAlgoUnknown::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void securePasswordKdfAlgoUnknown::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "securePasswordKdfAlgoUnknown");
    s.store_class_end();
  }
}

securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::securePasswordKdfAlgoPBKDF2HMACSHA512iter100000()
  : salt_()
{}

securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::securePasswordKdfAlgoPBKDF2HMACSHA512iter100000(BufferSlice &&salt_)
  : salt_(std::move(salt_))
{}

const std::int32_t securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::ID;

securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::securePasswordKdfAlgoPBKDF2HMACSHA512iter100000(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : salt_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(salt_, s);
}

void securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(salt_, s);
}

void securePasswordKdfAlgoPBKDF2HMACSHA512iter100000::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000");
    s.store_bytes_field("salt", salt_);
    s.store_class_end();
  }
}

securePasswordKdfAlgoSHA512::securePasswordKdfAlgoSHA512()
  : salt_()
{}

securePasswordKdfAlgoSHA512::securePasswordKdfAlgoSHA512(BufferSlice &&salt_)
  : salt_(std::move(salt_))
{}

const std::int32_t securePasswordKdfAlgoSHA512::ID;

securePasswordKdfAlgoSHA512::securePasswordKdfAlgoSHA512(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : salt_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void securePasswordKdfAlgoSHA512::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(salt_, s);
}

void securePasswordKdfAlgoSHA512::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(salt_, s);
}

void securePasswordKdfAlgoSHA512::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "securePasswordKdfAlgoSHA512");
    s.store_bytes_field("salt", salt_);
    s.store_class_end();
  }
}

object_ptr<SecurePlainData> SecurePlainData::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case securePlainPhone::ID:
      return securePlainPhone::fetch(p);
    case securePlainEmail::ID:
      return securePlainEmail::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

securePlainPhone::securePlainPhone()
  : phone_()
{}

securePlainPhone::securePlainPhone(std::string const &phone_)
  : phone_(phone_)
{}

const std::int32_t securePlainPhone::ID;

securePlainPhone::securePlainPhone(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : phone_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void securePlainPhone::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(phone_, s);
}

void securePlainPhone::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(phone_, s);
}

void securePlainPhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "securePlainPhone");
    s.store_field("phone", phone_);
    s.store_class_end();
  }
}

securePlainEmail::securePlainEmail()
  : email_()
{}

securePlainEmail::securePlainEmail(std::string const &email_)
  : email_(email_)
{}

const std::int32_t securePlainEmail::ID;

securePlainEmail::securePlainEmail(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : email_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void securePlainEmail::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(email_, s);
}

void securePlainEmail::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(email_, s);
}

void securePlainEmail::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "securePlainEmail");
    s.store_field("email", email_);
    s.store_class_end();
  }
}

object_ptr<SecureRequiredType> SecureRequiredType::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case secureRequiredType::ID:
      return secureRequiredType::fetch(p);
    case secureRequiredTypeOneOf::ID:
      return secureRequiredTypeOneOf::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

secureRequiredType::secureRequiredType()
  : flags_()
  , native_names_()
  , selfie_required_()
  , translation_required_()
  , type_()
{}

secureRequiredType::secureRequiredType(std::int32_t flags_, bool native_names_, bool selfie_required_, bool translation_required_, object_ptr<SecureValueType> &&type_)
  : flags_(flags_)
  , native_names_(native_names_)
  , selfie_required_(selfie_required_)
  , translation_required_(translation_required_)
  , type_(std::move(type_))
{}

const std::int32_t secureRequiredType::ID;

object_ptr<secureRequiredType> secureRequiredType::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<secureRequiredType> res = make_tl_object<secureRequiredType>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->native_names_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->selfie_required_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->translation_required_ = TlFetchTrue::parse(p); }
  res->type_ = TlFetchObject<SecureValueType>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void secureRequiredType::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureRequiredType");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_class_end();
  }
}

secureRequiredTypeOneOf::secureRequiredTypeOneOf()
  : types_()
{}

secureRequiredTypeOneOf::secureRequiredTypeOneOf(std::vector<object_ptr<SecureRequiredType>> &&types_)
  : types_(std::move(types_))
{}

const std::int32_t secureRequiredTypeOneOf::ID;

secureRequiredTypeOneOf::secureRequiredTypeOneOf(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : types_(TlFetchBoxed<TlFetchVector<TlFetchObject<SecureRequiredType>>, 481674261>::parse(p))
#undef FAIL
{}

void secureRequiredTypeOneOf::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureRequiredTypeOneOf");
    { const std::vector<object_ptr<SecureRequiredType>> &v = types_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("types", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

secureSecretSettings::secureSecretSettings()
  : secure_algo_()
  , secure_secret_()
  , secure_secret_id_()
{}

secureSecretSettings::secureSecretSettings(object_ptr<SecurePasswordKdfAlgo> &&secure_algo_, BufferSlice &&secure_secret_, std::int64_t secure_secret_id_)
  : secure_algo_(std::move(secure_algo_))
  , secure_secret_(std::move(secure_secret_))
  , secure_secret_id_(secure_secret_id_)
{}

const std::int32_t secureSecretSettings::ID;

secureSecretSettings::secureSecretSettings(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : secure_algo_(TlFetchObject<SecurePasswordKdfAlgo>::parse(p))
  , secure_secret_(TlFetchBytes<BufferSlice>::parse(p))
  , secure_secret_id_(TlFetchLong::parse(p))
#undef FAIL
{}

void secureSecretSettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(secure_algo_, s);
  TlStoreString::store(secure_secret_, s);
  TlStoreBinary::store(secure_secret_id_, s);
}

void secureSecretSettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(secure_algo_, s);
  TlStoreString::store(secure_secret_, s);
  TlStoreBinary::store(secure_secret_id_, s);
}

void secureSecretSettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureSecretSettings");
    if (secure_algo_ == nullptr) { s.store_field("secure_algo", "null"); } else { secure_algo_->store(s, "secure_algo"); }
    s.store_bytes_field("secure_secret", secure_secret_);
    s.store_field("secure_secret_id", secure_secret_id_);
    s.store_class_end();
  }
}

secureValue::secureValue()
  : flags_()
  , type_()
  , data_()
  , front_side_()
  , reverse_side_()
  , selfie_()
  , translation_()
  , files_()
  , plain_data_()
  , hash_()
{}

secureValue::secureValue(std::int32_t flags_, object_ptr<SecureValueType> &&type_, object_ptr<secureData> &&data_, object_ptr<SecureFile> &&front_side_, object_ptr<SecureFile> &&reverse_side_, object_ptr<SecureFile> &&selfie_, std::vector<object_ptr<SecureFile>> &&translation_, std::vector<object_ptr<SecureFile>> &&files_, object_ptr<SecurePlainData> &&plain_data_, BufferSlice &&hash_)
  : flags_(flags_)
  , type_(std::move(type_))
  , data_(std::move(data_))
  , front_side_(std::move(front_side_))
  , reverse_side_(std::move(reverse_side_))
  , selfie_(std::move(selfie_))
  , translation_(std::move(translation_))
  , files_(std::move(files_))
  , plain_data_(std::move(plain_data_))
  , hash_(std::move(hash_))
{}

const std::int32_t secureValue::ID;

object_ptr<secureValue> secureValue::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<secureValue> res = make_tl_object<secureValue>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->type_ = TlFetchObject<SecureValueType>::parse(p);
  if (var0 & 1) { res->data_ = TlFetchBoxed<TlFetchObject<secureData>, -1964327229>::parse(p); }
  if (var0 & 2) { res->front_side_ = TlFetchObject<SecureFile>::parse(p); }
  if (var0 & 4) { res->reverse_side_ = TlFetchObject<SecureFile>::parse(p); }
  if (var0 & 8) { res->selfie_ = TlFetchObject<SecureFile>::parse(p); }
  if (var0 & 64) { res->translation_ = TlFetchBoxed<TlFetchVector<TlFetchObject<SecureFile>>, 481674261>::parse(p); }
  if (var0 & 16) { res->files_ = TlFetchBoxed<TlFetchVector<TlFetchObject<SecureFile>>, 481674261>::parse(p); }
  if (var0 & 32) { res->plain_data_ = TlFetchObject<SecurePlainData>::parse(p); }
  res->hash_ = TlFetchBytes<BufferSlice>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void secureValue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValue");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    if (var0 & 1) { if (data_ == nullptr) { s.store_field("data", "null"); } else { data_->store(s, "data"); } }
    if (var0 & 2) { if (front_side_ == nullptr) { s.store_field("front_side", "null"); } else { front_side_->store(s, "front_side"); } }
    if (var0 & 4) { if (reverse_side_ == nullptr) { s.store_field("reverse_side", "null"); } else { reverse_side_->store(s, "reverse_side"); } }
    if (var0 & 8) { if (selfie_ == nullptr) { s.store_field("selfie", "null"); } else { selfie_->store(s, "selfie"); } }
    if (var0 & 64) { { const std::vector<object_ptr<SecureFile>> &v = translation_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("translation", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 16) { { const std::vector<object_ptr<SecureFile>> &v = files_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("files", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 32) { if (plain_data_ == nullptr) { s.store_field("plain_data", "null"); } else { plain_data_->store(s, "plain_data"); } }
    s.store_bytes_field("hash", hash_);
    s.store_class_end();
  }
}

object_ptr<SecureValueError> SecureValueError::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case secureValueErrorData::ID:
      return secureValueErrorData::fetch(p);
    case secureValueErrorFrontSide::ID:
      return secureValueErrorFrontSide::fetch(p);
    case secureValueErrorReverseSide::ID:
      return secureValueErrorReverseSide::fetch(p);
    case secureValueErrorSelfie::ID:
      return secureValueErrorSelfie::fetch(p);
    case secureValueErrorFile::ID:
      return secureValueErrorFile::fetch(p);
    case secureValueErrorFiles::ID:
      return secureValueErrorFiles::fetch(p);
    case secureValueError::ID:
      return secureValueError::fetch(p);
    case secureValueErrorTranslationFile::ID:
      return secureValueErrorTranslationFile::fetch(p);
    case secureValueErrorTranslationFiles::ID:
      return secureValueErrorTranslationFiles::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

secureValueErrorData::secureValueErrorData()
  : type_()
  , data_hash_()
  , field_()
  , text_()
{}

secureValueErrorData::secureValueErrorData(object_ptr<SecureValueType> &&type_, BufferSlice &&data_hash_, std::string const &field_, std::string const &text_)
  : type_(std::move(type_))
  , data_hash_(std::move(data_hash_))
  , field_(field_)
  , text_(text_)
{}

const std::int32_t secureValueErrorData::ID;

secureValueErrorData::secureValueErrorData(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , data_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , field_(TlFetchString<std::string>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueErrorData::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(data_hash_, s);
  TlStoreString::store(field_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorData::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(data_hash_, s);
  TlStoreString::store(field_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorData::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueErrorData");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_bytes_field("data_hash", data_hash_);
    s.store_field("field", field_);
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueErrorFrontSide::secureValueErrorFrontSide()
  : type_()
  , file_hash_()
  , text_()
{}

secureValueErrorFrontSide::secureValueErrorFrontSide(object_ptr<SecureValueType> &&type_, BufferSlice &&file_hash_, std::string const &text_)
  : type_(std::move(type_))
  , file_hash_(std::move(file_hash_))
  , text_(text_)
{}

const std::int32_t secureValueErrorFrontSide::ID;

secureValueErrorFrontSide::secureValueErrorFrontSide(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , file_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueErrorFrontSide::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorFrontSide::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorFrontSide::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueErrorFrontSide");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_bytes_field("file_hash", file_hash_);
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueErrorReverseSide::secureValueErrorReverseSide()
  : type_()
  , file_hash_()
  , text_()
{}

secureValueErrorReverseSide::secureValueErrorReverseSide(object_ptr<SecureValueType> &&type_, BufferSlice &&file_hash_, std::string const &text_)
  : type_(std::move(type_))
  , file_hash_(std::move(file_hash_))
  , text_(text_)
{}

const std::int32_t secureValueErrorReverseSide::ID;

secureValueErrorReverseSide::secureValueErrorReverseSide(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , file_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueErrorReverseSide::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorReverseSide::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorReverseSide::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueErrorReverseSide");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_bytes_field("file_hash", file_hash_);
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueErrorSelfie::secureValueErrorSelfie()
  : type_()
  , file_hash_()
  , text_()
{}

secureValueErrorSelfie::secureValueErrorSelfie(object_ptr<SecureValueType> &&type_, BufferSlice &&file_hash_, std::string const &text_)
  : type_(std::move(type_))
  , file_hash_(std::move(file_hash_))
  , text_(text_)
{}

const std::int32_t secureValueErrorSelfie::ID;

secureValueErrorSelfie::secureValueErrorSelfie(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , file_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueErrorSelfie::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorSelfie::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorSelfie::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueErrorSelfie");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_bytes_field("file_hash", file_hash_);
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueErrorFile::secureValueErrorFile()
  : type_()
  , file_hash_()
  , text_()
{}

secureValueErrorFile::secureValueErrorFile(object_ptr<SecureValueType> &&type_, BufferSlice &&file_hash_, std::string const &text_)
  : type_(std::move(type_))
  , file_hash_(std::move(file_hash_))
  , text_(text_)
{}

const std::int32_t secureValueErrorFile::ID;

secureValueErrorFile::secureValueErrorFile(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , file_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueErrorFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueErrorFile");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_bytes_field("file_hash", file_hash_);
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueErrorFiles::secureValueErrorFiles()
  : type_()
  , file_hash_()
  , text_()
{}

secureValueErrorFiles::secureValueErrorFiles(object_ptr<SecureValueType> &&type_, std::vector<BufferSlice> &&file_hash_, std::string const &text_)
  : type_(std::move(type_))
  , file_hash_(std::move(file_hash_))
  , text_(text_)
{}

const std::int32_t secureValueErrorFiles::ID;

secureValueErrorFiles::secureValueErrorFiles(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , file_hash_(TlFetchBoxed<TlFetchVector<TlFetchBytes<BufferSlice>>, 481674261>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueErrorFiles::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreBoxed<TlStoreVector<TlStoreString>, 481674261>::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorFiles::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreBoxed<TlStoreVector<TlStoreString>, 481674261>::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorFiles::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueErrorFiles");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    { const std::vector<BufferSlice> &v = file_hash_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("file_hash", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_bytes_field("", v[i]); } s.store_class_end(); }
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueError::secureValueError()
  : type_()
  , hash_()
  , text_()
{}

secureValueError::secureValueError(object_ptr<SecureValueType> &&type_, BufferSlice &&hash_, std::string const &text_)
  : type_(std::move(type_))
  , hash_(std::move(hash_))
  , text_(text_)
{}

const std::int32_t secureValueError::ID;

secureValueError::secureValueError(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , hash_(TlFetchBytes<BufferSlice>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueError::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueError::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueError::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueError");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_bytes_field("hash", hash_);
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueErrorTranslationFile::secureValueErrorTranslationFile()
  : type_()
  , file_hash_()
  , text_()
{}

secureValueErrorTranslationFile::secureValueErrorTranslationFile(object_ptr<SecureValueType> &&type_, BufferSlice &&file_hash_, std::string const &text_)
  : type_(std::move(type_))
  , file_hash_(std::move(file_hash_))
  , text_(text_)
{}

const std::int32_t secureValueErrorTranslationFile::ID;

secureValueErrorTranslationFile::secureValueErrorTranslationFile(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , file_hash_(TlFetchBytes<BufferSlice>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueErrorTranslationFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorTranslationFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorTranslationFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueErrorTranslationFile");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_bytes_field("file_hash", file_hash_);
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueErrorTranslationFiles::secureValueErrorTranslationFiles()
  : type_()
  , file_hash_()
  , text_()
{}

secureValueErrorTranslationFiles::secureValueErrorTranslationFiles(object_ptr<SecureValueType> &&type_, std::vector<BufferSlice> &&file_hash_, std::string const &text_)
  : type_(std::move(type_))
  , file_hash_(std::move(file_hash_))
  , text_(text_)
{}

const std::int32_t secureValueErrorTranslationFiles::ID;

secureValueErrorTranslationFiles::secureValueErrorTranslationFiles(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<SecureValueType>::parse(p))
  , file_hash_(TlFetchBoxed<TlFetchVector<TlFetchBytes<BufferSlice>>, 481674261>::parse(p))
  , text_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void secureValueErrorTranslationFiles::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreBoxed<TlStoreVector<TlStoreString>, 481674261>::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorTranslationFiles::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreBoxed<TlStoreVector<TlStoreString>, 481674261>::store(file_hash_, s);
  TlStoreString::store(text_, s);
}

void secureValueErrorTranslationFiles::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueErrorTranslationFiles");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    { const std::vector<BufferSlice> &v = file_hash_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("file_hash", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_bytes_field("", v[i]); } s.store_class_end(); }
    s.store_field("text", text_);
    s.store_class_end();
  }
}

secureValueHash::secureValueHash()
  : type_()
  , hash_()
{}

secureValueHash::secureValueHash(object_ptr<SecureValueType> &&type_, BufferSlice &&hash_)
  : type_(std::move(type_))
  , hash_(std::move(hash_))
{}

const std::int32_t secureValueHash::ID;

void secureValueHash::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(hash_, s);
}

void secureValueHash::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBoxedUnknown<TlStoreObject>::store(type_, s);
  TlStoreString::store(hash_, s);
}

void secureValueHash::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueHash");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_bytes_field("hash", hash_);
    s.store_class_end();
  }
}

object_ptr<SecureValueType> SecureValueType::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case secureValueTypePersonalDetails::ID:
      return secureValueTypePersonalDetails::fetch(p);
    case secureValueTypePassport::ID:
      return secureValueTypePassport::fetch(p);
    case secureValueTypeDriverLicense::ID:
      return secureValueTypeDriverLicense::fetch(p);
    case secureValueTypeIdentityCard::ID:
      return secureValueTypeIdentityCard::fetch(p);
    case secureValueTypeInternalPassport::ID:
      return secureValueTypeInternalPassport::fetch(p);
    case secureValueTypeAddress::ID:
      return secureValueTypeAddress::fetch(p);
    case secureValueTypeUtilityBill::ID:
      return secureValueTypeUtilityBill::fetch(p);
    case secureValueTypeBankStatement::ID:
      return secureValueTypeBankStatement::fetch(p);
    case secureValueTypeRentalAgreement::ID:
      return secureValueTypeRentalAgreement::fetch(p);
    case secureValueTypePassportRegistration::ID:
      return secureValueTypePassportRegistration::fetch(p);
    case secureValueTypeTemporaryRegistration::ID:
      return secureValueTypeTemporaryRegistration::fetch(p);
    case secureValueTypePhone::ID:
      return secureValueTypePhone::fetch(p);
    case secureValueTypeEmail::ID:
      return secureValueTypeEmail::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

secureValueTypePersonalDetails::secureValueTypePersonalDetails() {
}

const std::int32_t secureValueTypePersonalDetails::ID;

secureValueTypePersonalDetails::secureValueTypePersonalDetails(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypePersonalDetails::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypePersonalDetails::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypePersonalDetails::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypePersonalDetails");
    s.store_class_end();
  }
}

secureValueTypePassport::secureValueTypePassport() {
}

const std::int32_t secureValueTypePassport::ID;

secureValueTypePassport::secureValueTypePassport(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypePassport::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypePassport::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypePassport::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypePassport");
    s.store_class_end();
  }
}

secureValueTypeDriverLicense::secureValueTypeDriverLicense() {
}

const std::int32_t secureValueTypeDriverLicense::ID;

secureValueTypeDriverLicense::secureValueTypeDriverLicense(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeDriverLicense::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeDriverLicense::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeDriverLicense::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeDriverLicense");
    s.store_class_end();
  }
}

secureValueTypeIdentityCard::secureValueTypeIdentityCard() {
}

const std::int32_t secureValueTypeIdentityCard::ID;

secureValueTypeIdentityCard::secureValueTypeIdentityCard(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeIdentityCard::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeIdentityCard::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeIdentityCard::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeIdentityCard");
    s.store_class_end();
  }
}

secureValueTypeInternalPassport::secureValueTypeInternalPassport() {
}

const std::int32_t secureValueTypeInternalPassport::ID;

secureValueTypeInternalPassport::secureValueTypeInternalPassport(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeInternalPassport::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeInternalPassport::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeInternalPassport::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeInternalPassport");
    s.store_class_end();
  }
}

secureValueTypeAddress::secureValueTypeAddress() {
}

const std::int32_t secureValueTypeAddress::ID;

secureValueTypeAddress::secureValueTypeAddress(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeAddress::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeAddress::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeAddress::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeAddress");
    s.store_class_end();
  }
}

secureValueTypeUtilityBill::secureValueTypeUtilityBill() {
}

const std::int32_t secureValueTypeUtilityBill::ID;

secureValueTypeUtilityBill::secureValueTypeUtilityBill(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeUtilityBill::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeUtilityBill::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeUtilityBill::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeUtilityBill");
    s.store_class_end();
  }
}

secureValueTypeBankStatement::secureValueTypeBankStatement() {
}

const std::int32_t secureValueTypeBankStatement::ID;

secureValueTypeBankStatement::secureValueTypeBankStatement(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeBankStatement::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeBankStatement::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeBankStatement::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeBankStatement");
    s.store_class_end();
  }
}

secureValueTypeRentalAgreement::secureValueTypeRentalAgreement() {
}

const std::int32_t secureValueTypeRentalAgreement::ID;

secureValueTypeRentalAgreement::secureValueTypeRentalAgreement(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeRentalAgreement::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeRentalAgreement::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeRentalAgreement::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeRentalAgreement");
    s.store_class_end();
  }
}

secureValueTypePassportRegistration::secureValueTypePassportRegistration() {
}

const std::int32_t secureValueTypePassportRegistration::ID;

secureValueTypePassportRegistration::secureValueTypePassportRegistration(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypePassportRegistration::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypePassportRegistration::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypePassportRegistration::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypePassportRegistration");
    s.store_class_end();
  }
}

secureValueTypeTemporaryRegistration::secureValueTypeTemporaryRegistration() {
}

const std::int32_t secureValueTypeTemporaryRegistration::ID;

secureValueTypeTemporaryRegistration::secureValueTypeTemporaryRegistration(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeTemporaryRegistration::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeTemporaryRegistration::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeTemporaryRegistration::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeTemporaryRegistration");
    s.store_class_end();
  }
}

secureValueTypePhone::secureValueTypePhone() {
}

const std::int32_t secureValueTypePhone::ID;

secureValueTypePhone::secureValueTypePhone(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypePhone::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypePhone::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypePhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypePhone");
    s.store_class_end();
  }
}

secureValueTypeEmail::secureValueTypeEmail() {
}

const std::int32_t secureValueTypeEmail::ID;

secureValueTypeEmail::secureValueTypeEmail(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void secureValueTypeEmail::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void secureValueTypeEmail::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void secureValueTypeEmail::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "secureValueTypeEmail");
    s.store_class_end();
  }
}

object_ptr<SendMessageAction> SendMessageAction::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case sendMessageTypingAction::ID:
      return sendMessageTypingAction::fetch(p);
    case sendMessageCancelAction::ID:
      return sendMessageCancelAction::fetch(p);
    case sendMessageRecordVideoAction::ID:
      return sendMessageRecordVideoAction::fetch(p);
    case sendMessageUploadVideoAction::ID:
      return sendMessageUploadVideoAction::fetch(p);
    case sendMessageRecordAudioAction::ID:
      return sendMessageRecordAudioAction::fetch(p);
    case sendMessageUploadAudioAction::ID:
      return sendMessageUploadAudioAction::fetch(p);
    case sendMessageUploadPhotoAction::ID:
      return sendMessageUploadPhotoAction::fetch(p);
    case sendMessageUploadDocumentAction::ID:
      return sendMessageUploadDocumentAction::fetch(p);
    case sendMessageGeoLocationAction::ID:
      return sendMessageGeoLocationAction::fetch(p);
    case sendMessageChooseContactAction::ID:
      return sendMessageChooseContactAction::fetch(p);
    case sendMessageGamePlayAction::ID:
      return sendMessageGamePlayAction::fetch(p);
    case sendMessageRecordRoundAction::ID:
      return sendMessageRecordRoundAction::fetch(p);
    case sendMessageUploadRoundAction::ID:
      return sendMessageUploadRoundAction::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

sendMessageTypingAction::sendMessageTypingAction() {
}

const std::int32_t sendMessageTypingAction::ID;

sendMessageTypingAction::sendMessageTypingAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void sendMessageTypingAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void sendMessageTypingAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void sendMessageTypingAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageTypingAction");
    s.store_class_end();
  }
}

sendMessageCancelAction::sendMessageCancelAction() {
}

const std::int32_t sendMessageCancelAction::ID;

sendMessageCancelAction::sendMessageCancelAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void sendMessageCancelAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void sendMessageCancelAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void sendMessageCancelAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageCancelAction");
    s.store_class_end();
  }
}

sendMessageRecordVideoAction::sendMessageRecordVideoAction() {
}

const std::int32_t sendMessageRecordVideoAction::ID;

sendMessageRecordVideoAction::sendMessageRecordVideoAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void sendMessageRecordVideoAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void sendMessageRecordVideoAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void sendMessageRecordVideoAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageRecordVideoAction");
    s.store_class_end();
  }
}

sendMessageUploadVideoAction::sendMessageUploadVideoAction()
  : progress_()
{}

sendMessageUploadVideoAction::sendMessageUploadVideoAction(std::int32_t progress_)
  : progress_(progress_)
{}

const std::int32_t sendMessageUploadVideoAction::ID;

sendMessageUploadVideoAction::sendMessageUploadVideoAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : progress_(TlFetchInt::parse(p))
#undef FAIL
{}

void sendMessageUploadVideoAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadVideoAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadVideoAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageUploadVideoAction");
    s.store_field("progress", progress_);
    s.store_class_end();
  }
}

sendMessageRecordAudioAction::sendMessageRecordAudioAction() {
}

const std::int32_t sendMessageRecordAudioAction::ID;

sendMessageRecordAudioAction::sendMessageRecordAudioAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void sendMessageRecordAudioAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void sendMessageRecordAudioAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void sendMessageRecordAudioAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageRecordAudioAction");
    s.store_class_end();
  }
}

sendMessageUploadAudioAction::sendMessageUploadAudioAction()
  : progress_()
{}

sendMessageUploadAudioAction::sendMessageUploadAudioAction(std::int32_t progress_)
  : progress_(progress_)
{}

const std::int32_t sendMessageUploadAudioAction::ID;

sendMessageUploadAudioAction::sendMessageUploadAudioAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : progress_(TlFetchInt::parse(p))
#undef FAIL
{}

void sendMessageUploadAudioAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadAudioAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadAudioAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageUploadAudioAction");
    s.store_field("progress", progress_);
    s.store_class_end();
  }
}

sendMessageUploadPhotoAction::sendMessageUploadPhotoAction()
  : progress_()
{}

sendMessageUploadPhotoAction::sendMessageUploadPhotoAction(std::int32_t progress_)
  : progress_(progress_)
{}

const std::int32_t sendMessageUploadPhotoAction::ID;

sendMessageUploadPhotoAction::sendMessageUploadPhotoAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : progress_(TlFetchInt::parse(p))
#undef FAIL
{}

void sendMessageUploadPhotoAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadPhotoAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadPhotoAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageUploadPhotoAction");
    s.store_field("progress", progress_);
    s.store_class_end();
  }
}

sendMessageUploadDocumentAction::sendMessageUploadDocumentAction()
  : progress_()
{}

sendMessageUploadDocumentAction::sendMessageUploadDocumentAction(std::int32_t progress_)
  : progress_(progress_)
{}

const std::int32_t sendMessageUploadDocumentAction::ID;

sendMessageUploadDocumentAction::sendMessageUploadDocumentAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : progress_(TlFetchInt::parse(p))
#undef FAIL
{}

void sendMessageUploadDocumentAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadDocumentAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadDocumentAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageUploadDocumentAction");
    s.store_field("progress", progress_);
    s.store_class_end();
  }
}

sendMessageGeoLocationAction::sendMessageGeoLocationAction() {
}

const std::int32_t sendMessageGeoLocationAction::ID;

sendMessageGeoLocationAction::sendMessageGeoLocationAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void sendMessageGeoLocationAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void sendMessageGeoLocationAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void sendMessageGeoLocationAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageGeoLocationAction");
    s.store_class_end();
  }
}

sendMessageChooseContactAction::sendMessageChooseContactAction() {
}

const std::int32_t sendMessageChooseContactAction::ID;

sendMessageChooseContactAction::sendMessageChooseContactAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void sendMessageChooseContactAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void sendMessageChooseContactAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void sendMessageChooseContactAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageChooseContactAction");
    s.store_class_end();
  }
}

sendMessageGamePlayAction::sendMessageGamePlayAction() {
}

const std::int32_t sendMessageGamePlayAction::ID;

sendMessageGamePlayAction::sendMessageGamePlayAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void sendMessageGamePlayAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void sendMessageGamePlayAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void sendMessageGamePlayAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageGamePlayAction");
    s.store_class_end();
  }
}

sendMessageRecordRoundAction::sendMessageRecordRoundAction() {
}

const std::int32_t sendMessageRecordRoundAction::ID;

sendMessageRecordRoundAction::sendMessageRecordRoundAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void sendMessageRecordRoundAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void sendMessageRecordRoundAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void sendMessageRecordRoundAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageRecordRoundAction");
    s.store_class_end();
  }
}

sendMessageUploadRoundAction::sendMessageUploadRoundAction()
  : progress_()
{}

sendMessageUploadRoundAction::sendMessageUploadRoundAction(std::int32_t progress_)
  : progress_(progress_)
{}

const std::int32_t sendMessageUploadRoundAction::ID;

sendMessageUploadRoundAction::sendMessageUploadRoundAction(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : progress_(TlFetchInt::parse(p))
#undef FAIL
{}

void sendMessageUploadRoundAction::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadRoundAction::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreBinary::store(progress_, s);
}

void sendMessageUploadRoundAction::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "sendMessageUploadRoundAction");
    s.store_field("progress", progress_);
    s.store_class_end();
  }
}

shippingOption::shippingOption()
  : id_()
  , title_()
  , prices_()
{}

shippingOption::shippingOption(std::string const &id_, std::string const &title_, std::vector<object_ptr<labeledPrice>> &&prices_)
  : id_(id_)
  , title_(title_)
  , prices_(std::move(prices_))
{}

const std::int32_t shippingOption::ID;

shippingOption::shippingOption(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchString<std::string>::parse(p))
  , title_(TlFetchString<std::string>::parse(p))
  , prices_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<labeledPrice>, -886477832>>, 481674261>::parse(p))
#undef FAIL
{}

void shippingOption::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  TlStoreString::store(id_, s);
  TlStoreString::store(title_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -886477832>>, 481674261>::store(prices_, s);
}

void shippingOption::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  TlStoreString::store(id_, s);
  TlStoreString::store(title_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -886477832>>, 481674261>::store(prices_, s);
}

void shippingOption::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "shippingOption");
    s.store_field("id", id_);
    s.store_field("title", title_);
    { const std::vector<object_ptr<labeledPrice>> &v = prices_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("prices", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

stickerPack::stickerPack()
  : emoticon_()
  , documents_()
{}

stickerPack::stickerPack(std::string const &emoticon_, std::vector<std::int64_t> &&documents_)
  : emoticon_(emoticon_)
  , documents_(std::move(documents_))
{}

const std::int32_t stickerPack::ID;

stickerPack::stickerPack(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : emoticon_(TlFetchString<std::string>::parse(p))
  , documents_(TlFetchBoxed<TlFetchVector<TlFetchLong>, 481674261>::parse(p))
#undef FAIL
{}

void stickerPack::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "stickerPack");
    s.store_field("emoticon", emoticon_);
    { const std::vector<std::int64_t> &v = documents_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("documents", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

stickerSet::stickerSet()
  : flags_()
  , archived_()
  , official_()
  , masks_()
  , installed_date_()
  , id_()
  , access_hash_()
  , title_()
  , short_name_()
  , count_()
  , hash_()
{}

stickerSet::stickerSet(std::int32_t flags_, bool archived_, bool official_, bool masks_, std::int32_t installed_date_, std::int64_t id_, std::int64_t access_hash_, std::string const &title_, std::string const &short_name_, std::int32_t count_, std::int32_t hash_)
  : flags_(flags_)
  , archived_(archived_)
  , official_(official_)
  , masks_(masks_)
  , installed_date_(installed_date_)
  , id_(id_)
  , access_hash_(access_hash_)
  , title_(title_)
  , short_name_(short_name_)
  , count_(count_)
  , hash_(hash_)
{}

const std::int32_t stickerSet::ID;

object_ptr<stickerSet> stickerSet::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<stickerSet> res = make_tl_object<stickerSet>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->archived_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->official_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->masks_ = TlFetchTrue::parse(p); }
  if (var0 & 1) { res->installed_date_ = TlFetchInt::parse(p); }
  res->id_ = TlFetchLong::parse(p);
  res->access_hash_ = TlFetchLong::parse(p);
  res->title_ = TlFetchString<std::string>::parse(p);
  res->short_name_ = TlFetchString<std::string>::parse(p);
  res->count_ = TlFetchInt::parse(p);
  res->hash_ = TlFetchInt::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void stickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "stickerSet");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 1) { s.store_field("installed_date", installed_date_); }
    s.store_field("id", id_);
    s.store_field("access_hash", access_hash_);
    s.store_field("title", title_);
    s.store_field("short_name", short_name_);
    s.store_field("count", count_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

object_ptr<StickerSetCovered> StickerSetCovered::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case stickerSetCovered::ID:
      return stickerSetCovered::fetch(p);
    case stickerSetMultiCovered::ID:
      return stickerSetMultiCovered::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

stickerSetCovered::stickerSetCovered()
  : set_()
  , cover_()
{}

stickerSetCovered::stickerSetCovered(object_ptr<stickerSet> &&set_, object_ptr<Document> &&cover_)
  : set_(std::move(set_))
  , cover_(std::move(cover_))
{}

const std::int32_t stickerSetCovered::ID;

stickerSetCovered::stickerSetCovered(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : set_(TlFetchBoxed<TlFetchObject<stickerSet>, 1434820921>::parse(p))
  , cover_(TlFetchObject<Document>::parse(p))
#undef FAIL
{}

void stickerSetCovered::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "stickerSetCovered");
    if (set_ == nullptr) { s.store_field("set", "null"); } else { set_->store(s, "set"); }
    if (cover_ == nullptr) { s.store_field("cover", "null"); } else { cover_->store(s, "cover"); }
    s.store_class_end();
  }
}

stickerSetMultiCovered::stickerSetMultiCovered()
  : set_()
  , covers_()
{}

stickerSetMultiCovered::stickerSetMultiCovered(object_ptr<stickerSet> &&set_, std::vector<object_ptr<Document>> &&covers_)
  : set_(std::move(set_))
  , covers_(std::move(covers_))
{}

const std::int32_t stickerSetMultiCovered::ID;

stickerSetMultiCovered::stickerSetMultiCovered(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : set_(TlFetchBoxed<TlFetchObject<stickerSet>, 1434820921>::parse(p))
  , covers_(TlFetchBoxed<TlFetchVector<TlFetchObject<Document>>, 481674261>::parse(p))
#undef FAIL
{}

void stickerSetMultiCovered::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "stickerSetMultiCovered");
    if (set_ == nullptr) { s.store_field("set", "null"); } else { set_->store(s, "set"); }
    { const std::vector<object_ptr<Document>> &v = covers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("covers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

topPeer::topPeer()
  : peer_()
  , rating_()
{}

topPeer::topPeer(object_ptr<Peer> &&peer_, double rating_)
  : peer_(std::move(peer_))
  , rating_(rating_)
{}

const std::int32_t topPeer::ID;

topPeer::topPeer(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : peer_(TlFetchObject<Peer>::parse(p))
  , rating_(TlFetchDouble::parse(p))
#undef FAIL
{}

void topPeer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "topPeer");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("rating", rating_);
    s.store_class_end();
  }
}

object_ptr<TopPeerCategory> TopPeerCategory::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case topPeerCategoryBotsPM::ID:
      return topPeerCategoryBotsPM::fetch(p);
    case topPeerCategoryBotsInline::ID:
      return topPeerCategoryBotsInline::fetch(p);
    case topPeerCategoryCorrespondents::ID:
      return topPeerCategoryCorrespondents::fetch(p);
    case topPeerCategoryGroups::ID:
      return topPeerCategoryGroups::fetch(p);
    case topPeerCategoryChannels::ID:
      return topPeerCategoryChannels::fetch(p);
    case topPeerCategoryPhoneCalls::ID:
      return topPeerCategoryPhoneCalls::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

topPeerCategoryBotsPM::topPeerCategoryBotsPM() {
}

const std::int32_t topPeerCategoryBotsPM::ID;

topPeerCategoryBotsPM::topPeerCategoryBotsPM(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void topPeerCategoryBotsPM::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void topPeerCategoryBotsPM::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void topPeerCategoryBotsPM::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "topPeerCategoryBotsPM");
    s.store_class_end();
  }
}

topPeerCategoryBotsInline::topPeerCategoryBotsInline() {
}

const std::int32_t topPeerCategoryBotsInline::ID;

topPeerCategoryBotsInline::topPeerCategoryBotsInline(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void topPeerCategoryBotsInline::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void topPeerCategoryBotsInline::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void topPeerCategoryBotsInline::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "topPeerCategoryBotsInline");
    s.store_class_end();
  }
}

topPeerCategoryCorrespondents::topPeerCategoryCorrespondents() {
}

const std::int32_t topPeerCategoryCorrespondents::ID;

topPeerCategoryCorrespondents::topPeerCategoryCorrespondents(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void topPeerCategoryCorrespondents::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void topPeerCategoryCorrespondents::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void topPeerCategoryCorrespondents::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "topPeerCategoryCorrespondents");
    s.store_class_end();
  }
}

topPeerCategoryGroups::topPeerCategoryGroups() {
}

const std::int32_t topPeerCategoryGroups::ID;

topPeerCategoryGroups::topPeerCategoryGroups(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void topPeerCategoryGroups::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void topPeerCategoryGroups::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void topPeerCategoryGroups::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "topPeerCategoryGroups");
    s.store_class_end();
  }
}

topPeerCategoryChannels::topPeerCategoryChannels() {
}

const std::int32_t topPeerCategoryChannels::ID;

topPeerCategoryChannels::topPeerCategoryChannels(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void topPeerCategoryChannels::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void topPeerCategoryChannels::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void topPeerCategoryChannels::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "topPeerCategoryChannels");
    s.store_class_end();
  }
}

topPeerCategoryPhoneCalls::topPeerCategoryPhoneCalls() {
}

const std::int32_t topPeerCategoryPhoneCalls::ID;

topPeerCategoryPhoneCalls::topPeerCategoryPhoneCalls(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void topPeerCategoryPhoneCalls::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
}

void topPeerCategoryPhoneCalls::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
}

void topPeerCategoryPhoneCalls::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "topPeerCategoryPhoneCalls");
    s.store_class_end();
  }
}

topPeerCategoryPeers::topPeerCategoryPeers()
  : category_()
  , count_()
  , peers_()
{}

topPeerCategoryPeers::topPeerCategoryPeers(object_ptr<TopPeerCategory> &&category_, std::int32_t count_, std::vector<object_ptr<topPeer>> &&peers_)
  : category_(std::move(category_))
  , count_(count_)
  , peers_(std::move(peers_))
{}

const std::int32_t topPeerCategoryPeers::ID;

topPeerCategoryPeers::topPeerCategoryPeers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : category_(TlFetchObject<TopPeerCategory>::parse(p))
  , count_(TlFetchInt::parse(p))
  , peers_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<topPeer>, -305282981>>, 481674261>::parse(p))
#undef FAIL
{}

void topPeerCategoryPeers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "topPeerCategoryPeers");
    if (category_ == nullptr) { s.store_field("category", "null"); } else { category_->store(s, "category"); }
    s.store_field("count", count_);
    { const std::vector<object_ptr<topPeer>> &v = peers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("peers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<Update> Update::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case updateNewMessage::ID:
      return updateNewMessage::fetch(p);
    case updateMessageID::ID:
      return updateMessageID::fetch(p);
    case updateDeleteMessages::ID:
      return updateDeleteMessages::fetch(p);
    case updateUserTyping::ID:
      return updateUserTyping::fetch(p);
    case updateChatUserTyping::ID:
      return updateChatUserTyping::fetch(p);
    case updateChatParticipants::ID:
      return updateChatParticipants::fetch(p);
    case updateUserStatus::ID:
      return updateUserStatus::fetch(p);
    case updateUserName::ID:
      return updateUserName::fetch(p);
    case updateUserPhoto::ID:
      return updateUserPhoto::fetch(p);
    case updateContactRegistered::ID:
      return updateContactRegistered::fetch(p);
    case updateContactLink::ID:
      return updateContactLink::fetch(p);
    case updateNewEncryptedMessage::ID:
      return updateNewEncryptedMessage::fetch(p);
    case updateEncryptedChatTyping::ID:
      return updateEncryptedChatTyping::fetch(p);
    case updateEncryption::ID:
      return updateEncryption::fetch(p);
    case updateEncryptedMessagesRead::ID:
      return updateEncryptedMessagesRead::fetch(p);
    case updateChatParticipantAdd::ID:
      return updateChatParticipantAdd::fetch(p);
    case updateChatParticipantDelete::ID:
      return updateChatParticipantDelete::fetch(p);
    case updateDcOptions::ID:
      return updateDcOptions::fetch(p);
    case updateUserBlocked::ID:
      return updateUserBlocked::fetch(p);
    case updateNotifySettings::ID:
      return updateNotifySettings::fetch(p);
    case updateServiceNotification::ID:
      return updateServiceNotification::fetch(p);
    case updatePrivacy::ID:
      return updatePrivacy::fetch(p);
    case updateUserPhone::ID:
      return updateUserPhone::fetch(p);
    case updateReadHistoryInbox::ID:
      return updateReadHistoryInbox::fetch(p);
    case updateReadHistoryOutbox::ID:
      return updateReadHistoryOutbox::fetch(p);
    case updateWebPage::ID:
      return updateWebPage::fetch(p);
    case updateReadMessagesContents::ID:
      return updateReadMessagesContents::fetch(p);
    case updateChannelTooLong::ID:
      return updateChannelTooLong::fetch(p);
    case updateChannel::ID:
      return updateChannel::fetch(p);
    case updateNewChannelMessage::ID:
      return updateNewChannelMessage::fetch(p);
    case updateReadChannelInbox::ID:
      return updateReadChannelInbox::fetch(p);
    case updateDeleteChannelMessages::ID:
      return updateDeleteChannelMessages::fetch(p);
    case updateChannelMessageViews::ID:
      return updateChannelMessageViews::fetch(p);
    case updateChatAdmins::ID:
      return updateChatAdmins::fetch(p);
    case updateChatParticipantAdmin::ID:
      return updateChatParticipantAdmin::fetch(p);
    case updateNewStickerSet::ID:
      return updateNewStickerSet::fetch(p);
    case updateStickerSetsOrder::ID:
      return updateStickerSetsOrder::fetch(p);
    case updateStickerSets::ID:
      return updateStickerSets::fetch(p);
    case updateSavedGifs::ID:
      return updateSavedGifs::fetch(p);
    case updateBotInlineQuery::ID:
      return updateBotInlineQuery::fetch(p);
    case updateBotInlineSend::ID:
      return updateBotInlineSend::fetch(p);
    case updateEditChannelMessage::ID:
      return updateEditChannelMessage::fetch(p);
    case updateChannelPinnedMessage::ID:
      return updateChannelPinnedMessage::fetch(p);
    case updateBotCallbackQuery::ID:
      return updateBotCallbackQuery::fetch(p);
    case updateEditMessage::ID:
      return updateEditMessage::fetch(p);
    case updateInlineBotCallbackQuery::ID:
      return updateInlineBotCallbackQuery::fetch(p);
    case updateReadChannelOutbox::ID:
      return updateReadChannelOutbox::fetch(p);
    case updateDraftMessage::ID:
      return updateDraftMessage::fetch(p);
    case updateReadFeaturedStickers::ID:
      return updateReadFeaturedStickers::fetch(p);
    case updateRecentStickers::ID:
      return updateRecentStickers::fetch(p);
    case updateConfig::ID:
      return updateConfig::fetch(p);
    case updatePtsChanged::ID:
      return updatePtsChanged::fetch(p);
    case updateChannelWebPage::ID:
      return updateChannelWebPage::fetch(p);
    case updateDialogPinned::ID:
      return updateDialogPinned::fetch(p);
    case updatePinnedDialogs::ID:
      return updatePinnedDialogs::fetch(p);
    case updateBotWebhookJSON::ID:
      return updateBotWebhookJSON::fetch(p);
    case updateBotWebhookJSONQuery::ID:
      return updateBotWebhookJSONQuery::fetch(p);
    case updateBotShippingQuery::ID:
      return updateBotShippingQuery::fetch(p);
    case updateBotPrecheckoutQuery::ID:
      return updateBotPrecheckoutQuery::fetch(p);
    case updatePhoneCall::ID:
      return updatePhoneCall::fetch(p);
    case updateLangPackTooLong::ID:
      return updateLangPackTooLong::fetch(p);
    case updateLangPack::ID:
      return updateLangPack::fetch(p);
    case updateFavedStickers::ID:
      return updateFavedStickers::fetch(p);
    case updateChannelReadMessagesContents::ID:
      return updateChannelReadMessagesContents::fetch(p);
    case updateContactsReset::ID:
      return updateContactsReset::fetch(p);
    case updateChannelAvailableMessages::ID:
      return updateChannelAvailableMessages::fetch(p);
    case updateDialogUnreadMark::ID:
      return updateDialogUnreadMark::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

updateNewMessage::updateNewMessage()
  : message_()
  , pts_()
  , pts_count_()
{}

updateNewMessage::updateNewMessage(object_ptr<Message> &&message_, std::int32_t pts_, std::int32_t pts_count_)
  : message_(std::move(message_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateNewMessage::ID;

updateNewMessage::updateNewMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchObject<Message>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateNewMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateNewMessage");
    if (message_ == nullptr) { s.store_field("message", "null"); } else { message_->store(s, "message"); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateMessageID::updateMessageID()
  : id_()
  , random_id_()
{}

updateMessageID::updateMessageID(std::int32_t id_, std::int64_t random_id_)
  : id_(id_)
  , random_id_(random_id_)
{}

const std::int32_t updateMessageID::ID;

updateMessageID::updateMessageID(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , random_id_(TlFetchLong::parse(p))
#undef FAIL
{}

void updateMessageID::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateMessageID");
    s.store_field("id", id_);
    s.store_field("random_id", random_id_);
    s.store_class_end();
  }
}

updateDeleteMessages::updateDeleteMessages()
  : messages_()
  , pts_()
  , pts_count_()
{}

updateDeleteMessages::updateDeleteMessages(std::vector<std::int32_t> &&messages_, std::int32_t pts_, std::int32_t pts_count_)
  : messages_(std::move(messages_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateDeleteMessages::ID;

updateDeleteMessages::updateDeleteMessages(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : messages_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateDeleteMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateDeleteMessages");
    { const std::vector<std::int32_t> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateUserTyping::updateUserTyping()
  : user_id_()
  , action_()
{}

updateUserTyping::updateUserTyping(std::int32_t user_id_, object_ptr<SendMessageAction> &&action_)
  : user_id_(user_id_)
  , action_(std::move(action_))
{}

const std::int32_t updateUserTyping::ID;

updateUserTyping::updateUserTyping(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , action_(TlFetchObject<SendMessageAction>::parse(p))
#undef FAIL
{}

void updateUserTyping::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateUserTyping");
    s.store_field("user_id", user_id_);
    if (action_ == nullptr) { s.store_field("action", "null"); } else { action_->store(s, "action"); }
    s.store_class_end();
  }
}

updateChatUserTyping::updateChatUserTyping()
  : chat_id_()
  , user_id_()
  , action_()
{}

updateChatUserTyping::updateChatUserTyping(std::int32_t chat_id_, std::int32_t user_id_, object_ptr<SendMessageAction> &&action_)
  : chat_id_(chat_id_)
  , user_id_(user_id_)
  , action_(std::move(action_))
{}

const std::int32_t updateChatUserTyping::ID;

updateChatUserTyping::updateChatUserTyping(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
  , user_id_(TlFetchInt::parse(p))
  , action_(TlFetchObject<SendMessageAction>::parse(p))
#undef FAIL
{}

void updateChatUserTyping::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChatUserTyping");
    s.store_field("chat_id", chat_id_);
    s.store_field("user_id", user_id_);
    if (action_ == nullptr) { s.store_field("action", "null"); } else { action_->store(s, "action"); }
    s.store_class_end();
  }
}

updateChatParticipants::updateChatParticipants()
  : participants_()
{}

updateChatParticipants::updateChatParticipants(object_ptr<ChatParticipants> &&participants_)
  : participants_(std::move(participants_))
{}

const std::int32_t updateChatParticipants::ID;

updateChatParticipants::updateChatParticipants(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : participants_(TlFetchObject<ChatParticipants>::parse(p))
#undef FAIL
{}

void updateChatParticipants::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChatParticipants");
    if (participants_ == nullptr) { s.store_field("participants", "null"); } else { participants_->store(s, "participants"); }
    s.store_class_end();
  }
}

updateUserStatus::updateUserStatus()
  : user_id_()
  , status_()
{}

updateUserStatus::updateUserStatus(std::int32_t user_id_, object_ptr<UserStatus> &&status_)
  : user_id_(user_id_)
  , status_(std::move(status_))
{}

const std::int32_t updateUserStatus::ID;

updateUserStatus::updateUserStatus(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , status_(TlFetchObject<UserStatus>::parse(p))
#undef FAIL
{}

void updateUserStatus::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateUserStatus");
    s.store_field("user_id", user_id_);
    if (status_ == nullptr) { s.store_field("status", "null"); } else { status_->store(s, "status"); }
    s.store_class_end();
  }
}

updateUserName::updateUserName()
  : user_id_()
  , first_name_()
  , last_name_()
  , username_()
{}

updateUserName::updateUserName(std::int32_t user_id_, std::string const &first_name_, std::string const &last_name_, std::string const &username_)
  : user_id_(user_id_)
  , first_name_(first_name_)
  , last_name_(last_name_)
  , username_(username_)
{}

const std::int32_t updateUserName::ID;

updateUserName::updateUserName(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , first_name_(TlFetchString<std::string>::parse(p))
  , last_name_(TlFetchString<std::string>::parse(p))
  , username_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void updateUserName::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateUserName");
    s.store_field("user_id", user_id_);
    s.store_field("first_name", first_name_);
    s.store_field("last_name", last_name_);
    s.store_field("username", username_);
    s.store_class_end();
  }
}

updateUserPhoto::updateUserPhoto()
  : user_id_()
  , date_()
  , photo_()
  , previous_()
{}

updateUserPhoto::updateUserPhoto(std::int32_t user_id_, std::int32_t date_, object_ptr<UserProfilePhoto> &&photo_, bool previous_)
  : user_id_(user_id_)
  , date_(date_)
  , photo_(std::move(photo_))
  , previous_(previous_)
{}

const std::int32_t updateUserPhoto::ID;

updateUserPhoto::updateUserPhoto(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
  , photo_(TlFetchObject<UserProfilePhoto>::parse(p))
  , previous_(TlFetchBool::parse(p))
#undef FAIL
{}

void updateUserPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateUserPhoto");
    s.store_field("user_id", user_id_);
    s.store_field("date", date_);
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    s.store_field("previous", previous_);
    s.store_class_end();
  }
}

updateContactRegistered::updateContactRegistered()
  : user_id_()
  , date_()
{}

updateContactRegistered::updateContactRegistered(std::int32_t user_id_, std::int32_t date_)
  : user_id_(user_id_)
  , date_(date_)
{}

const std::int32_t updateContactRegistered::ID;

updateContactRegistered::updateContactRegistered(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateContactRegistered::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateContactRegistered");
    s.store_field("user_id", user_id_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

updateContactLink::updateContactLink()
  : user_id_()
  , my_link_()
  , foreign_link_()
{}

updateContactLink::updateContactLink(std::int32_t user_id_, object_ptr<ContactLink> &&my_link_, object_ptr<ContactLink> &&foreign_link_)
  : user_id_(user_id_)
  , my_link_(std::move(my_link_))
  , foreign_link_(std::move(foreign_link_))
{}

const std::int32_t updateContactLink::ID;

updateContactLink::updateContactLink(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , my_link_(TlFetchObject<ContactLink>::parse(p))
  , foreign_link_(TlFetchObject<ContactLink>::parse(p))
#undef FAIL
{}

void updateContactLink::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateContactLink");
    s.store_field("user_id", user_id_);
    if (my_link_ == nullptr) { s.store_field("my_link", "null"); } else { my_link_->store(s, "my_link"); }
    if (foreign_link_ == nullptr) { s.store_field("foreign_link", "null"); } else { foreign_link_->store(s, "foreign_link"); }
    s.store_class_end();
  }
}

updateNewEncryptedMessage::updateNewEncryptedMessage()
  : message_()
  , qts_()
{}

updateNewEncryptedMessage::updateNewEncryptedMessage(object_ptr<EncryptedMessage> &&message_, std::int32_t qts_)
  : message_(std::move(message_))
  , qts_(qts_)
{}

const std::int32_t updateNewEncryptedMessage::ID;

updateNewEncryptedMessage::updateNewEncryptedMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchObject<EncryptedMessage>::parse(p))
  , qts_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateNewEncryptedMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateNewEncryptedMessage");
    if (message_ == nullptr) { s.store_field("message", "null"); } else { message_->store(s, "message"); }
    s.store_field("qts", qts_);
    s.store_class_end();
  }
}

updateEncryptedChatTyping::updateEncryptedChatTyping()
  : chat_id_()
{}

updateEncryptedChatTyping::updateEncryptedChatTyping(std::int32_t chat_id_)
  : chat_id_(chat_id_)
{}

const std::int32_t updateEncryptedChatTyping::ID;

updateEncryptedChatTyping::updateEncryptedChatTyping(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateEncryptedChatTyping::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateEncryptedChatTyping");
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

updateEncryption::updateEncryption()
  : chat_()
  , date_()
{}

updateEncryption::updateEncryption(object_ptr<EncryptedChat> &&chat_, std::int32_t date_)
  : chat_(std::move(chat_))
  , date_(date_)
{}

const std::int32_t updateEncryption::ID;

updateEncryption::updateEncryption(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_(TlFetchObject<EncryptedChat>::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateEncryption::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateEncryption");
    if (chat_ == nullptr) { s.store_field("chat", "null"); } else { chat_->store(s, "chat"); }
    s.store_field("date", date_);
    s.store_class_end();
  }
}

updateEncryptedMessagesRead::updateEncryptedMessagesRead()
  : chat_id_()
  , max_date_()
  , date_()
{}

updateEncryptedMessagesRead::updateEncryptedMessagesRead(std::int32_t chat_id_, std::int32_t max_date_, std::int32_t date_)
  : chat_id_(chat_id_)
  , max_date_(max_date_)
  , date_(date_)
{}

const std::int32_t updateEncryptedMessagesRead::ID;

updateEncryptedMessagesRead::updateEncryptedMessagesRead(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
  , max_date_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateEncryptedMessagesRead::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateEncryptedMessagesRead");
    s.store_field("chat_id", chat_id_);
    s.store_field("max_date", max_date_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

updateChatParticipantAdd::updateChatParticipantAdd()
  : chat_id_()
  , user_id_()
  , inviter_id_()
  , date_()
  , version_()
{}

updateChatParticipantAdd::updateChatParticipantAdd(std::int32_t chat_id_, std::int32_t user_id_, std::int32_t inviter_id_, std::int32_t date_, std::int32_t version_)
  : chat_id_(chat_id_)
  , user_id_(user_id_)
  , inviter_id_(inviter_id_)
  , date_(date_)
  , version_(version_)
{}

const std::int32_t updateChatParticipantAdd::ID;

updateChatParticipantAdd::updateChatParticipantAdd(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
  , user_id_(TlFetchInt::parse(p))
  , inviter_id_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
  , version_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChatParticipantAdd::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChatParticipantAdd");
    s.store_field("chat_id", chat_id_);
    s.store_field("user_id", user_id_);
    s.store_field("inviter_id", inviter_id_);
    s.store_field("date", date_);
    s.store_field("version", version_);
    s.store_class_end();
  }
}

updateChatParticipantDelete::updateChatParticipantDelete()
  : chat_id_()
  , user_id_()
  , version_()
{}

updateChatParticipantDelete::updateChatParticipantDelete(std::int32_t chat_id_, std::int32_t user_id_, std::int32_t version_)
  : chat_id_(chat_id_)
  , user_id_(user_id_)
  , version_(version_)
{}

const std::int32_t updateChatParticipantDelete::ID;

updateChatParticipantDelete::updateChatParticipantDelete(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
  , user_id_(TlFetchInt::parse(p))
  , version_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChatParticipantDelete::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChatParticipantDelete");
    s.store_field("chat_id", chat_id_);
    s.store_field("user_id", user_id_);
    s.store_field("version", version_);
    s.store_class_end();
  }
}

updateDcOptions::updateDcOptions()
  : dc_options_()
{}

updateDcOptions::updateDcOptions(std::vector<object_ptr<dcOption>> &&dc_options_)
  : dc_options_(std::move(dc_options_))
{}

const std::int32_t updateDcOptions::ID;

updateDcOptions::updateDcOptions(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : dc_options_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<dcOption>, 414687501>>, 481674261>::parse(p))
#undef FAIL
{}

void updateDcOptions::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateDcOptions");
    { const std::vector<object_ptr<dcOption>> &v = dc_options_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("dc_options", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

updateUserBlocked::updateUserBlocked()
  : user_id_()
  , blocked_()
{}

updateUserBlocked::updateUserBlocked(std::int32_t user_id_, bool blocked_)
  : user_id_(user_id_)
  , blocked_(blocked_)
{}

const std::int32_t updateUserBlocked::ID;

updateUserBlocked::updateUserBlocked(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , blocked_(TlFetchBool::parse(p))
#undef FAIL
{}

void updateUserBlocked::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateUserBlocked");
    s.store_field("user_id", user_id_);
    s.store_field("blocked", blocked_);
    s.store_class_end();
  }
}

updateNotifySettings::updateNotifySettings()
  : peer_()
  , notify_settings_()
{}

updateNotifySettings::updateNotifySettings(object_ptr<NotifyPeer> &&peer_, object_ptr<peerNotifySettings> &&notify_settings_)
  : peer_(std::move(peer_))
  , notify_settings_(std::move(notify_settings_))
{}

const std::int32_t updateNotifySettings::ID;

updateNotifySettings::updateNotifySettings(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : peer_(TlFetchObject<NotifyPeer>::parse(p))
  , notify_settings_(TlFetchBoxed<TlFetchObject<peerNotifySettings>, -1353671392>::parse(p))
#undef FAIL
{}

void updateNotifySettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateNotifySettings");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (notify_settings_ == nullptr) { s.store_field("notify_settings", "null"); } else { notify_settings_->store(s, "notify_settings"); }
    s.store_class_end();
  }
}

updateServiceNotification::updateServiceNotification()
  : flags_()
  , popup_()
  , inbox_date_()
  , type_()
  , message_()
  , media_()
  , entities_()
{}

updateServiceNotification::updateServiceNotification(std::int32_t flags_, bool popup_, std::int32_t inbox_date_, std::string const &type_, std::string const &message_, object_ptr<MessageMedia> &&media_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , popup_(popup_)
  , inbox_date_(inbox_date_)
  , type_(type_)
  , message_(message_)
  , media_(std::move(media_))
  , entities_(std::move(entities_))
{}

const std::int32_t updateServiceNotification::ID;

object_ptr<updateServiceNotification> updateServiceNotification::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateServiceNotification> res = make_tl_object<updateServiceNotification>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->popup_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->inbox_date_ = TlFetchInt::parse(p); }
  res->type_ = TlFetchString<std::string>::parse(p);
  res->message_ = TlFetchString<std::string>::parse(p);
  res->media_ = TlFetchObject<MessageMedia>::parse(p);
  res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateServiceNotification::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateServiceNotification");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) { s.store_field("inbox_date", inbox_date_); }
    s.store_field("type", type_);
    s.store_field("message", message_);
    if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); }
    { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

updatePrivacy::updatePrivacy()
  : key_()
  , rules_()
{}

updatePrivacy::updatePrivacy(object_ptr<PrivacyKey> &&key_, std::vector<object_ptr<PrivacyRule>> &&rules_)
  : key_(std::move(key_))
  , rules_(std::move(rules_))
{}

const std::int32_t updatePrivacy::ID;

updatePrivacy::updatePrivacy(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : key_(TlFetchObject<PrivacyKey>::parse(p))
  , rules_(TlFetchBoxed<TlFetchVector<TlFetchObject<PrivacyRule>>, 481674261>::parse(p))
#undef FAIL
{}

void updatePrivacy::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updatePrivacy");
    if (key_ == nullptr) { s.store_field("key", "null"); } else { key_->store(s, "key"); }
    { const std::vector<object_ptr<PrivacyRule>> &v = rules_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("rules", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

updateUserPhone::updateUserPhone()
  : user_id_()
  , phone_()
{}

updateUserPhone::updateUserPhone(std::int32_t user_id_, std::string const &phone_)
  : user_id_(user_id_)
  , phone_(phone_)
{}

const std::int32_t updateUserPhone::ID;

updateUserPhone::updateUserPhone(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : user_id_(TlFetchInt::parse(p))
  , phone_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void updateUserPhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateUserPhone");
    s.store_field("user_id", user_id_);
    s.store_field("phone", phone_);
    s.store_class_end();
  }
}

updateReadHistoryInbox::updateReadHistoryInbox()
  : peer_()
  , max_id_()
  , pts_()
  , pts_count_()
{}

updateReadHistoryInbox::updateReadHistoryInbox(object_ptr<Peer> &&peer_, std::int32_t max_id_, std::int32_t pts_, std::int32_t pts_count_)
  : peer_(std::move(peer_))
  , max_id_(max_id_)
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateReadHistoryInbox::ID;

updateReadHistoryInbox::updateReadHistoryInbox(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : peer_(TlFetchObject<Peer>::parse(p))
  , max_id_(TlFetchInt::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateReadHistoryInbox::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateReadHistoryInbox");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("max_id", max_id_);
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateReadHistoryOutbox::updateReadHistoryOutbox()
  : peer_()
  , max_id_()
  , pts_()
  , pts_count_()
{}

updateReadHistoryOutbox::updateReadHistoryOutbox(object_ptr<Peer> &&peer_, std::int32_t max_id_, std::int32_t pts_, std::int32_t pts_count_)
  : peer_(std::move(peer_))
  , max_id_(max_id_)
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateReadHistoryOutbox::ID;

updateReadHistoryOutbox::updateReadHistoryOutbox(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : peer_(TlFetchObject<Peer>::parse(p))
  , max_id_(TlFetchInt::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateReadHistoryOutbox::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateReadHistoryOutbox");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("max_id", max_id_);
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateWebPage::updateWebPage()
  : webpage_()
  , pts_()
  , pts_count_()
{}

updateWebPage::updateWebPage(object_ptr<WebPage> &&webpage_, std::int32_t pts_, std::int32_t pts_count_)
  : webpage_(std::move(webpage_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateWebPage::ID;

updateWebPage::updateWebPage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : webpage_(TlFetchObject<WebPage>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateWebPage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateWebPage");
    if (webpage_ == nullptr) { s.store_field("webpage", "null"); } else { webpage_->store(s, "webpage"); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateReadMessagesContents::updateReadMessagesContents()
  : messages_()
  , pts_()
  , pts_count_()
{}

updateReadMessagesContents::updateReadMessagesContents(std::vector<std::int32_t> &&messages_, std::int32_t pts_, std::int32_t pts_count_)
  : messages_(std::move(messages_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateReadMessagesContents::ID;

updateReadMessagesContents::updateReadMessagesContents(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : messages_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateReadMessagesContents::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateReadMessagesContents");
    { const std::vector<std::int32_t> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateChannelTooLong::updateChannelTooLong()
  : flags_()
  , channel_id_()
  , pts_()
{}

updateChannelTooLong::updateChannelTooLong(std::int32_t flags_, std::int32_t channel_id_, std::int32_t pts_)
  : flags_(flags_)
  , channel_id_(channel_id_)
  , pts_(pts_)
{}

const std::int32_t updateChannelTooLong::ID;

object_ptr<updateChannelTooLong> updateChannelTooLong::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateChannelTooLong> res = make_tl_object<updateChannelTooLong>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->channel_id_ = TlFetchInt::parse(p);
  if (var0 & 1) { res->pts_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateChannelTooLong::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChannelTooLong");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("channel_id", channel_id_);
    if (var0 & 1) { s.store_field("pts", pts_); }
    s.store_class_end();
  }
}

updateChannel::updateChannel()
  : channel_id_()
{}

updateChannel::updateChannel(std::int32_t channel_id_)
  : channel_id_(channel_id_)
{}

const std::int32_t updateChannel::ID;

updateChannel::updateChannel(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChannel");
    s.store_field("channel_id", channel_id_);
    s.store_class_end();
  }
}

updateNewChannelMessage::updateNewChannelMessage()
  : message_()
  , pts_()
  , pts_count_()
{}

updateNewChannelMessage::updateNewChannelMessage(object_ptr<Message> &&message_, std::int32_t pts_, std::int32_t pts_count_)
  : message_(std::move(message_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateNewChannelMessage::ID;

updateNewChannelMessage::updateNewChannelMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchObject<Message>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateNewChannelMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateNewChannelMessage");
    if (message_ == nullptr) { s.store_field("message", "null"); } else { message_->store(s, "message"); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateReadChannelInbox::updateReadChannelInbox()
  : channel_id_()
  , max_id_()
{}

updateReadChannelInbox::updateReadChannelInbox(std::int32_t channel_id_, std::int32_t max_id_)
  : channel_id_(channel_id_)
  , max_id_(max_id_)
{}

const std::int32_t updateReadChannelInbox::ID;

updateReadChannelInbox::updateReadChannelInbox(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , max_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateReadChannelInbox::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateReadChannelInbox");
    s.store_field("channel_id", channel_id_);
    s.store_field("max_id", max_id_);
    s.store_class_end();
  }
}

updateDeleteChannelMessages::updateDeleteChannelMessages()
  : channel_id_()
  , messages_()
  , pts_()
  , pts_count_()
{}

updateDeleteChannelMessages::updateDeleteChannelMessages(std::int32_t channel_id_, std::vector<std::int32_t> &&messages_, std::int32_t pts_, std::int32_t pts_count_)
  : channel_id_(channel_id_)
  , messages_(std::move(messages_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateDeleteChannelMessages::ID;

updateDeleteChannelMessages::updateDeleteChannelMessages(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , messages_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateDeleteChannelMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateDeleteChannelMessages");
    s.store_field("channel_id", channel_id_);
    { const std::vector<std::int32_t> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateChannelMessageViews::updateChannelMessageViews()
  : channel_id_()
  , id_()
  , views_()
{}

updateChannelMessageViews::updateChannelMessageViews(std::int32_t channel_id_, std::int32_t id_, std::int32_t views_)
  : channel_id_(channel_id_)
  , id_(id_)
  , views_(views_)
{}

const std::int32_t updateChannelMessageViews::ID;

updateChannelMessageViews::updateChannelMessageViews(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , id_(TlFetchInt::parse(p))
  , views_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChannelMessageViews::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChannelMessageViews");
    s.store_field("channel_id", channel_id_);
    s.store_field("id", id_);
    s.store_field("views", views_);
    s.store_class_end();
  }
}

updateChatAdmins::updateChatAdmins()
  : chat_id_()
  , enabled_()
  , version_()
{}

updateChatAdmins::updateChatAdmins(std::int32_t chat_id_, bool enabled_, std::int32_t version_)
  : chat_id_(chat_id_)
  , enabled_(enabled_)
  , version_(version_)
{}

const std::int32_t updateChatAdmins::ID;

updateChatAdmins::updateChatAdmins(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
  , enabled_(TlFetchBool::parse(p))
  , version_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChatAdmins::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChatAdmins");
    s.store_field("chat_id", chat_id_);
    s.store_field("enabled", enabled_);
    s.store_field("version", version_);
    s.store_class_end();
  }
}

updateChatParticipantAdmin::updateChatParticipantAdmin()
  : chat_id_()
  , user_id_()
  , is_admin_()
  , version_()
{}

updateChatParticipantAdmin::updateChatParticipantAdmin(std::int32_t chat_id_, std::int32_t user_id_, bool is_admin_, std::int32_t version_)
  : chat_id_(chat_id_)
  , user_id_(user_id_)
  , is_admin_(is_admin_)
  , version_(version_)
{}

const std::int32_t updateChatParticipantAdmin::ID;

updateChatParticipantAdmin::updateChatParticipantAdmin(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chat_id_(TlFetchInt::parse(p))
  , user_id_(TlFetchInt::parse(p))
  , is_admin_(TlFetchBool::parse(p))
  , version_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChatParticipantAdmin::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChatParticipantAdmin");
    s.store_field("chat_id", chat_id_);
    s.store_field("user_id", user_id_);
    s.store_field("is_admin", is_admin_);
    s.store_field("version", version_);
    s.store_class_end();
  }
}

updateNewStickerSet::updateNewStickerSet()
  : stickerset_()
{}

updateNewStickerSet::updateNewStickerSet(object_ptr<messages_stickerSet> &&stickerset_)
  : stickerset_(std::move(stickerset_))
{}

const std::int32_t updateNewStickerSet::ID;

updateNewStickerSet::updateNewStickerSet(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : stickerset_(TlFetchBoxed<TlFetchObject<messages_stickerSet>, -1240849242>::parse(p))
#undef FAIL
{}

void updateNewStickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateNewStickerSet");
    if (stickerset_ == nullptr) { s.store_field("stickerset", "null"); } else { stickerset_->store(s, "stickerset"); }
    s.store_class_end();
  }
}

updateStickerSetsOrder::updateStickerSetsOrder()
  : flags_()
  , masks_()
  , order_()
{}

updateStickerSetsOrder::updateStickerSetsOrder(std::int32_t flags_, bool masks_, std::vector<std::int64_t> &&order_)
  : flags_(flags_)
  , masks_(masks_)
  , order_(std::move(order_))
{}

const std::int32_t updateStickerSetsOrder::ID;

object_ptr<updateStickerSetsOrder> updateStickerSetsOrder::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateStickerSetsOrder> res = make_tl_object<updateStickerSetsOrder>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->masks_ = TlFetchTrue::parse(p); }
  res->order_ = TlFetchBoxed<TlFetchVector<TlFetchLong>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateStickerSetsOrder::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateStickerSetsOrder");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    { const std::vector<std::int64_t> &v = order_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("order", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

updateStickerSets::updateStickerSets() {
}

const std::int32_t updateStickerSets::ID;

updateStickerSets::updateStickerSets(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updateStickerSets::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateStickerSets");
    s.store_class_end();
  }
}

updateSavedGifs::updateSavedGifs() {
}

const std::int32_t updateSavedGifs::ID;

updateSavedGifs::updateSavedGifs(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updateSavedGifs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateSavedGifs");
    s.store_class_end();
  }
}

updateBotInlineQuery::updateBotInlineQuery()
  : flags_()
  , query_id_()
  , user_id_()
  , query_()
  , geo_()
  , offset_()
{}

updateBotInlineQuery::updateBotInlineQuery(std::int32_t flags_, std::int64_t query_id_, std::int32_t user_id_, std::string const &query_, object_ptr<GeoPoint> &&geo_, std::string const &offset_)
  : flags_(flags_)
  , query_id_(query_id_)
  , user_id_(user_id_)
  , query_(query_)
  , geo_(std::move(geo_))
  , offset_(offset_)
{}

const std::int32_t updateBotInlineQuery::ID;

object_ptr<updateBotInlineQuery> updateBotInlineQuery::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateBotInlineQuery> res = make_tl_object<updateBotInlineQuery>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->query_id_ = TlFetchLong::parse(p);
  res->user_id_ = TlFetchInt::parse(p);
  res->query_ = TlFetchString<std::string>::parse(p);
  if (var0 & 1) { res->geo_ = TlFetchObject<GeoPoint>::parse(p); }
  res->offset_ = TlFetchString<std::string>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateBotInlineQuery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateBotInlineQuery");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("query_id", query_id_);
    s.store_field("user_id", user_id_);
    s.store_field("query", query_);
    if (var0 & 1) { if (geo_ == nullptr) { s.store_field("geo", "null"); } else { geo_->store(s, "geo"); } }
    s.store_field("offset", offset_);
    s.store_class_end();
  }
}

updateBotInlineSend::updateBotInlineSend()
  : flags_()
  , user_id_()
  , query_()
  , geo_()
  , id_()
  , msg_id_()
{}

updateBotInlineSend::updateBotInlineSend(std::int32_t flags_, std::int32_t user_id_, std::string const &query_, object_ptr<GeoPoint> &&geo_, std::string const &id_, object_ptr<inputBotInlineMessageID> &&msg_id_)
  : flags_(flags_)
  , user_id_(user_id_)
  , query_(query_)
  , geo_(std::move(geo_))
  , id_(id_)
  , msg_id_(std::move(msg_id_))
{}

const std::int32_t updateBotInlineSend::ID;

object_ptr<updateBotInlineSend> updateBotInlineSend::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateBotInlineSend> res = make_tl_object<updateBotInlineSend>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->user_id_ = TlFetchInt::parse(p);
  res->query_ = TlFetchString<std::string>::parse(p);
  if (var0 & 1) { res->geo_ = TlFetchObject<GeoPoint>::parse(p); }
  res->id_ = TlFetchString<std::string>::parse(p);
  if (var0 & 2) { res->msg_id_ = TlFetchBoxed<TlFetchObject<inputBotInlineMessageID>, -1995686519>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateBotInlineSend::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateBotInlineSend");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("user_id", user_id_);
    s.store_field("query", query_);
    if (var0 & 1) { if (geo_ == nullptr) { s.store_field("geo", "null"); } else { geo_->store(s, "geo"); } }
    s.store_field("id", id_);
    if (var0 & 2) { if (msg_id_ == nullptr) { s.store_field("msg_id", "null"); } else { msg_id_->store(s, "msg_id"); } }
    s.store_class_end();
  }
}

updateEditChannelMessage::updateEditChannelMessage()
  : message_()
  , pts_()
  , pts_count_()
{}

updateEditChannelMessage::updateEditChannelMessage(object_ptr<Message> &&message_, std::int32_t pts_, std::int32_t pts_count_)
  : message_(std::move(message_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateEditChannelMessage::ID;

updateEditChannelMessage::updateEditChannelMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchObject<Message>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateEditChannelMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateEditChannelMessage");
    if (message_ == nullptr) { s.store_field("message", "null"); } else { message_->store(s, "message"); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateChannelPinnedMessage::updateChannelPinnedMessage()
  : channel_id_()
  , id_()
{}

updateChannelPinnedMessage::updateChannelPinnedMessage(std::int32_t channel_id_, std::int32_t id_)
  : channel_id_(channel_id_)
  , id_(id_)
{}

const std::int32_t updateChannelPinnedMessage::ID;

updateChannelPinnedMessage::updateChannelPinnedMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , id_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChannelPinnedMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChannelPinnedMessage");
    s.store_field("channel_id", channel_id_);
    s.store_field("id", id_);
    s.store_class_end();
  }
}

updateBotCallbackQuery::updateBotCallbackQuery()
  : flags_()
  , query_id_()
  , user_id_()
  , peer_()
  , msg_id_()
  , chat_instance_()
  , data_()
  , game_short_name_()
{}

updateBotCallbackQuery::updateBotCallbackQuery(std::int32_t flags_, std::int64_t query_id_, std::int32_t user_id_, object_ptr<Peer> &&peer_, std::int32_t msg_id_, std::int64_t chat_instance_, BufferSlice &&data_, std::string const &game_short_name_)
  : flags_(flags_)
  , query_id_(query_id_)
  , user_id_(user_id_)
  , peer_(std::move(peer_))
  , msg_id_(msg_id_)
  , chat_instance_(chat_instance_)
  , data_(std::move(data_))
  , game_short_name_(game_short_name_)
{}

const std::int32_t updateBotCallbackQuery::ID;

object_ptr<updateBotCallbackQuery> updateBotCallbackQuery::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateBotCallbackQuery> res = make_tl_object<updateBotCallbackQuery>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->query_id_ = TlFetchLong::parse(p);
  res->user_id_ = TlFetchInt::parse(p);
  res->peer_ = TlFetchObject<Peer>::parse(p);
  res->msg_id_ = TlFetchInt::parse(p);
  res->chat_instance_ = TlFetchLong::parse(p);
  if (var0 & 1) { res->data_ = TlFetchBytes<BufferSlice>::parse(p); }
  if (var0 & 2) { res->game_short_name_ = TlFetchString<std::string>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateBotCallbackQuery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateBotCallbackQuery");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("query_id", query_id_);
    s.store_field("user_id", user_id_);
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("msg_id", msg_id_);
    s.store_field("chat_instance", chat_instance_);
    if (var0 & 1) { s.store_bytes_field("data", data_); }
    if (var0 & 2) { s.store_field("game_short_name", game_short_name_); }
    s.store_class_end();
  }
}

updateEditMessage::updateEditMessage()
  : message_()
  , pts_()
  , pts_count_()
{}

updateEditMessage::updateEditMessage(object_ptr<Message> &&message_, std::int32_t pts_, std::int32_t pts_count_)
  : message_(std::move(message_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateEditMessage::ID;

updateEditMessage::updateEditMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchObject<Message>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateEditMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateEditMessage");
    if (message_ == nullptr) { s.store_field("message", "null"); } else { message_->store(s, "message"); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateInlineBotCallbackQuery::updateInlineBotCallbackQuery()
  : flags_()
  , query_id_()
  , user_id_()
  , msg_id_()
  , chat_instance_()
  , data_()
  , game_short_name_()
{}

updateInlineBotCallbackQuery::updateInlineBotCallbackQuery(std::int32_t flags_, std::int64_t query_id_, std::int32_t user_id_, object_ptr<inputBotInlineMessageID> &&msg_id_, std::int64_t chat_instance_, BufferSlice &&data_, std::string const &game_short_name_)
  : flags_(flags_)
  , query_id_(query_id_)
  , user_id_(user_id_)
  , msg_id_(std::move(msg_id_))
  , chat_instance_(chat_instance_)
  , data_(std::move(data_))
  , game_short_name_(game_short_name_)
{}

const std::int32_t updateInlineBotCallbackQuery::ID;

object_ptr<updateInlineBotCallbackQuery> updateInlineBotCallbackQuery::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateInlineBotCallbackQuery> res = make_tl_object<updateInlineBotCallbackQuery>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->query_id_ = TlFetchLong::parse(p);
  res->user_id_ = TlFetchInt::parse(p);
  res->msg_id_ = TlFetchBoxed<TlFetchObject<inputBotInlineMessageID>, -1995686519>::parse(p);
  res->chat_instance_ = TlFetchLong::parse(p);
  if (var0 & 1) { res->data_ = TlFetchBytes<BufferSlice>::parse(p); }
  if (var0 & 2) { res->game_short_name_ = TlFetchString<std::string>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateInlineBotCallbackQuery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateInlineBotCallbackQuery");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("query_id", query_id_);
    s.store_field("user_id", user_id_);
    if (msg_id_ == nullptr) { s.store_field("msg_id", "null"); } else { msg_id_->store(s, "msg_id"); }
    s.store_field("chat_instance", chat_instance_);
    if (var0 & 1) { s.store_bytes_field("data", data_); }
    if (var0 & 2) { s.store_field("game_short_name", game_short_name_); }
    s.store_class_end();
  }
}

updateReadChannelOutbox::updateReadChannelOutbox()
  : channel_id_()
  , max_id_()
{}

updateReadChannelOutbox::updateReadChannelOutbox(std::int32_t channel_id_, std::int32_t max_id_)
  : channel_id_(channel_id_)
  , max_id_(max_id_)
{}

const std::int32_t updateReadChannelOutbox::ID;

updateReadChannelOutbox::updateReadChannelOutbox(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , max_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateReadChannelOutbox::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateReadChannelOutbox");
    s.store_field("channel_id", channel_id_);
    s.store_field("max_id", max_id_);
    s.store_class_end();
  }
}

updateDraftMessage::updateDraftMessage()
  : peer_()
  , draft_()
{}

updateDraftMessage::updateDraftMessage(object_ptr<Peer> &&peer_, object_ptr<DraftMessage> &&draft_)
  : peer_(std::move(peer_))
  , draft_(std::move(draft_))
{}

const std::int32_t updateDraftMessage::ID;

updateDraftMessage::updateDraftMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : peer_(TlFetchObject<Peer>::parse(p))
  , draft_(TlFetchObject<DraftMessage>::parse(p))
#undef FAIL
{}

void updateDraftMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateDraftMessage");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (draft_ == nullptr) { s.store_field("draft", "null"); } else { draft_->store(s, "draft"); }
    s.store_class_end();
  }
}

updateReadFeaturedStickers::updateReadFeaturedStickers() {
}

const std::int32_t updateReadFeaturedStickers::ID;

updateReadFeaturedStickers::updateReadFeaturedStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updateReadFeaturedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateReadFeaturedStickers");
    s.store_class_end();
  }
}

updateRecentStickers::updateRecentStickers() {
}

const std::int32_t updateRecentStickers::ID;

updateRecentStickers::updateRecentStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updateRecentStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateRecentStickers");
    s.store_class_end();
  }
}

updateConfig::updateConfig() {
}

const std::int32_t updateConfig::ID;

updateConfig::updateConfig(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updateConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateConfig");
    s.store_class_end();
  }
}

updatePtsChanged::updatePtsChanged() {
}

const std::int32_t updatePtsChanged::ID;

updatePtsChanged::updatePtsChanged(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updatePtsChanged::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updatePtsChanged");
    s.store_class_end();
  }
}

updateChannelWebPage::updateChannelWebPage()
  : channel_id_()
  , webpage_()
  , pts_()
  , pts_count_()
{}

updateChannelWebPage::updateChannelWebPage(std::int32_t channel_id_, object_ptr<WebPage> &&webpage_, std::int32_t pts_, std::int32_t pts_count_)
  : channel_id_(channel_id_)
  , webpage_(std::move(webpage_))
  , pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t updateChannelWebPage::ID;

updateChannelWebPage::updateChannelWebPage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , webpage_(TlFetchObject<WebPage>::parse(p))
  , pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChannelWebPage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChannelWebPage");
    s.store_field("channel_id", channel_id_);
    if (webpage_ == nullptr) { s.store_field("webpage", "null"); } else { webpage_->store(s, "webpage"); }
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

updateDialogPinned::updateDialogPinned()
  : flags_()
  , pinned_()
  , peer_()
{}

updateDialogPinned::updateDialogPinned(std::int32_t flags_, bool pinned_, object_ptr<dialogPeer> &&peer_)
  : flags_(flags_)
  , pinned_(pinned_)
  , peer_(std::move(peer_))
{}

const std::int32_t updateDialogPinned::ID;

object_ptr<updateDialogPinned> updateDialogPinned::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateDialogPinned> res = make_tl_object<updateDialogPinned>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->pinned_ = TlFetchTrue::parse(p); }
  res->peer_ = TlFetchBoxed<TlFetchObject<dialogPeer>, -445792507>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateDialogPinned::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateDialogPinned");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

updatePinnedDialogs::updatePinnedDialogs()
  : flags_()
  , order_()
{}

updatePinnedDialogs::updatePinnedDialogs(std::int32_t flags_, std::vector<object_ptr<dialogPeer>> &&order_)
  : flags_(flags_)
  , order_(std::move(order_))
{}

const std::int32_t updatePinnedDialogs::ID;

object_ptr<updatePinnedDialogs> updatePinnedDialogs::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updatePinnedDialogs> res = make_tl_object<updatePinnedDialogs>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->order_ = TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<dialogPeer>, -445792507>>, 481674261>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updatePinnedDialogs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updatePinnedDialogs");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { { const std::vector<object_ptr<dialogPeer>> &v = order_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("order", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

updateBotWebhookJSON::updateBotWebhookJSON()
  : data_()
{}

updateBotWebhookJSON::updateBotWebhookJSON(object_ptr<dataJSON> &&data_)
  : data_(std::move(data_))
{}

const std::int32_t updateBotWebhookJSON::ID;

updateBotWebhookJSON::updateBotWebhookJSON(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : data_(TlFetchBoxed<TlFetchObject<dataJSON>, 2104790276>::parse(p))
#undef FAIL
{}

void updateBotWebhookJSON::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateBotWebhookJSON");
    if (data_ == nullptr) { s.store_field("data", "null"); } else { data_->store(s, "data"); }
    s.store_class_end();
  }
}

updateBotWebhookJSONQuery::updateBotWebhookJSONQuery()
  : query_id_()
  , data_()
  , timeout_()
{}

updateBotWebhookJSONQuery::updateBotWebhookJSONQuery(std::int64_t query_id_, object_ptr<dataJSON> &&data_, std::int32_t timeout_)
  : query_id_(query_id_)
  , data_(std::move(data_))
  , timeout_(timeout_)
{}

const std::int32_t updateBotWebhookJSONQuery::ID;

updateBotWebhookJSONQuery::updateBotWebhookJSONQuery(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : query_id_(TlFetchLong::parse(p))
  , data_(TlFetchBoxed<TlFetchObject<dataJSON>, 2104790276>::parse(p))
  , timeout_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateBotWebhookJSONQuery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateBotWebhookJSONQuery");
    s.store_field("query_id", query_id_);
    if (data_ == nullptr) { s.store_field("data", "null"); } else { data_->store(s, "data"); }
    s.store_field("timeout", timeout_);
    s.store_class_end();
  }
}

updateBotShippingQuery::updateBotShippingQuery()
  : query_id_()
  , user_id_()
  , payload_()
  , shipping_address_()
{}

updateBotShippingQuery::updateBotShippingQuery(std::int64_t query_id_, std::int32_t user_id_, BufferSlice &&payload_, object_ptr<postAddress> &&shipping_address_)
  : query_id_(query_id_)
  , user_id_(user_id_)
  , payload_(std::move(payload_))
  , shipping_address_(std::move(shipping_address_))
{}

const std::int32_t updateBotShippingQuery::ID;

updateBotShippingQuery::updateBotShippingQuery(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : query_id_(TlFetchLong::parse(p))
  , user_id_(TlFetchInt::parse(p))
  , payload_(TlFetchBytes<BufferSlice>::parse(p))
  , shipping_address_(TlFetchBoxed<TlFetchObject<postAddress>, 512535275>::parse(p))
#undef FAIL
{}

void updateBotShippingQuery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateBotShippingQuery");
    s.store_field("query_id", query_id_);
    s.store_field("user_id", user_id_);
    s.store_bytes_field("payload", payload_);
    if (shipping_address_ == nullptr) { s.store_field("shipping_address", "null"); } else { shipping_address_->store(s, "shipping_address"); }
    s.store_class_end();
  }
}

updateBotPrecheckoutQuery::updateBotPrecheckoutQuery()
  : flags_()
  , query_id_()
  , user_id_()
  , payload_()
  , info_()
  , shipping_option_id_()
  , currency_()
  , total_amount_()
{}

updateBotPrecheckoutQuery::updateBotPrecheckoutQuery(std::int32_t flags_, std::int64_t query_id_, std::int32_t user_id_, BufferSlice &&payload_, object_ptr<paymentRequestedInfo> &&info_, std::string const &shipping_option_id_, std::string const &currency_, std::int64_t total_amount_)
  : flags_(flags_)
  , query_id_(query_id_)
  , user_id_(user_id_)
  , payload_(std::move(payload_))
  , info_(std::move(info_))
  , shipping_option_id_(shipping_option_id_)
  , currency_(currency_)
  , total_amount_(total_amount_)
{}

const std::int32_t updateBotPrecheckoutQuery::ID;

object_ptr<updateBotPrecheckoutQuery> updateBotPrecheckoutQuery::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateBotPrecheckoutQuery> res = make_tl_object<updateBotPrecheckoutQuery>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->query_id_ = TlFetchLong::parse(p);
  res->user_id_ = TlFetchInt::parse(p);
  res->payload_ = TlFetchBytes<BufferSlice>::parse(p);
  if (var0 & 1) { res->info_ = TlFetchBoxed<TlFetchObject<paymentRequestedInfo>, -1868808300>::parse(p); }
  if (var0 & 2) { res->shipping_option_id_ = TlFetchString<std::string>::parse(p); }
  res->currency_ = TlFetchString<std::string>::parse(p);
  res->total_amount_ = TlFetchLong::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateBotPrecheckoutQuery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateBotPrecheckoutQuery");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("query_id", query_id_);
    s.store_field("user_id", user_id_);
    s.store_bytes_field("payload", payload_);
    if (var0 & 1) { if (info_ == nullptr) { s.store_field("info", "null"); } else { info_->store(s, "info"); } }
    if (var0 & 2) { s.store_field("shipping_option_id", shipping_option_id_); }
    s.store_field("currency", currency_);
    s.store_field("total_amount", total_amount_);
    s.store_class_end();
  }
}

updatePhoneCall::updatePhoneCall()
  : phone_call_()
{}

updatePhoneCall::updatePhoneCall(object_ptr<PhoneCall> &&phone_call_)
  : phone_call_(std::move(phone_call_))
{}

const std::int32_t updatePhoneCall::ID;

updatePhoneCall::updatePhoneCall(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : phone_call_(TlFetchObject<PhoneCall>::parse(p))
#undef FAIL
{}

void updatePhoneCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updatePhoneCall");
    if (phone_call_ == nullptr) { s.store_field("phone_call", "null"); } else { phone_call_->store(s, "phone_call"); }
    s.store_class_end();
  }
}

updateLangPackTooLong::updateLangPackTooLong() {
}

const std::int32_t updateLangPackTooLong::ID;

updateLangPackTooLong::updateLangPackTooLong(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updateLangPackTooLong::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateLangPackTooLong");
    s.store_class_end();
  }
}

updateLangPack::updateLangPack()
  : difference_()
{}

updateLangPack::updateLangPack(object_ptr<langPackDifference> &&difference_)
  : difference_(std::move(difference_))
{}

const std::int32_t updateLangPack::ID;

updateLangPack::updateLangPack(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : difference_(TlFetchBoxed<TlFetchObject<langPackDifference>, -209337866>::parse(p))
#undef FAIL
{}

void updateLangPack::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateLangPack");
    if (difference_ == nullptr) { s.store_field("difference", "null"); } else { difference_->store(s, "difference"); }
    s.store_class_end();
  }
}

updateFavedStickers::updateFavedStickers() {
}

const std::int32_t updateFavedStickers::ID;

updateFavedStickers::updateFavedStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updateFavedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateFavedStickers");
    s.store_class_end();
  }
}

updateChannelReadMessagesContents::updateChannelReadMessagesContents()
  : channel_id_()
  , messages_()
{}

updateChannelReadMessagesContents::updateChannelReadMessagesContents(std::int32_t channel_id_, std::vector<std::int32_t> &&messages_)
  : channel_id_(channel_id_)
  , messages_(std::move(messages_))
{}

const std::int32_t updateChannelReadMessagesContents::ID;

updateChannelReadMessagesContents::updateChannelReadMessagesContents(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , messages_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
#undef FAIL
{}

void updateChannelReadMessagesContents::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChannelReadMessagesContents");
    s.store_field("channel_id", channel_id_);
    { const std::vector<std::int32_t> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

updateContactsReset::updateContactsReset() {
}

const std::int32_t updateContactsReset::ID;

updateContactsReset::updateContactsReset(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updateContactsReset::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateContactsReset");
    s.store_class_end();
  }
}

updateChannelAvailableMessages::updateChannelAvailableMessages()
  : channel_id_()
  , available_min_id_()
{}

updateChannelAvailableMessages::updateChannelAvailableMessages(std::int32_t channel_id_, std::int32_t available_min_id_)
  : channel_id_(channel_id_)
  , available_min_id_(available_min_id_)
{}

const std::int32_t updateChannelAvailableMessages::ID;

updateChannelAvailableMessages::updateChannelAvailableMessages(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : channel_id_(TlFetchInt::parse(p))
  , available_min_id_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateChannelAvailableMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateChannelAvailableMessages");
    s.store_field("channel_id", channel_id_);
    s.store_field("available_min_id", available_min_id_);
    s.store_class_end();
  }
}

updateDialogUnreadMark::updateDialogUnreadMark()
  : flags_()
  , unread_()
  , peer_()
{}

updateDialogUnreadMark::updateDialogUnreadMark(std::int32_t flags_, bool unread_, object_ptr<dialogPeer> &&peer_)
  : flags_(flags_)
  , unread_(unread_)
  , peer_(std::move(peer_))
{}

const std::int32_t updateDialogUnreadMark::ID;

object_ptr<updateDialogUnreadMark> updateDialogUnreadMark::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateDialogUnreadMark> res = make_tl_object<updateDialogUnreadMark>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->unread_ = TlFetchTrue::parse(p); }
  res->peer_ = TlFetchBoxed<TlFetchObject<dialogPeer>, -445792507>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateDialogUnreadMark::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateDialogUnreadMark");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

object_ptr<Updates> Updates::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case updatesTooLong::ID:
      return updatesTooLong::fetch(p);
    case updateShortMessage::ID:
      return updateShortMessage::fetch(p);
    case updateShortChatMessage::ID:
      return updateShortChatMessage::fetch(p);
    case updateShort::ID:
      return updateShort::fetch(p);
    case updatesCombined::ID:
      return updatesCombined::fetch(p);
    case updates::ID:
      return updates::fetch(p);
    case updateShortSentMessage::ID:
      return updateShortSentMessage::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

updatesTooLong::updatesTooLong() {
}

const std::int32_t updatesTooLong::ID;

updatesTooLong::updatesTooLong(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void updatesTooLong::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updatesTooLong");
    s.store_class_end();
  }
}

updateShortMessage::updateShortMessage()
  : flags_()
  , out_()
  , mentioned_()
  , media_unread_()
  , silent_()
  , id_()
  , user_id_()
  , message_()
  , pts_()
  , pts_count_()
  , date_()
  , fwd_from_()
  , via_bot_id_()
  , reply_to_msg_id_()
  , entities_()
{}

updateShortMessage::updateShortMessage(std::int32_t flags_, bool out_, bool mentioned_, bool media_unread_, bool silent_, std::int32_t id_, std::int32_t user_id_, std::string const &message_, std::int32_t pts_, std::int32_t pts_count_, std::int32_t date_, object_ptr<messageFwdHeader> &&fwd_from_, std::int32_t via_bot_id_, std::int32_t reply_to_msg_id_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , out_(out_)
  , mentioned_(mentioned_)
  , media_unread_(media_unread_)
  , silent_(silent_)
  , id_(id_)
  , user_id_(user_id_)
  , message_(message_)
  , pts_(pts_)
  , pts_count_(pts_count_)
  , date_(date_)
  , fwd_from_(std::move(fwd_from_))
  , via_bot_id_(via_bot_id_)
  , reply_to_msg_id_(reply_to_msg_id_)
  , entities_(std::move(entities_))
{}

const std::int32_t updateShortMessage::ID;

object_ptr<updateShortMessage> updateShortMessage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateShortMessage> res = make_tl_object<updateShortMessage>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->out_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->mentioned_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->media_unread_ = TlFetchTrue::parse(p); }
  if (var0 & 8192) { res->silent_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  res->user_id_ = TlFetchInt::parse(p);
  res->message_ = TlFetchString<std::string>::parse(p);
  res->pts_ = TlFetchInt::parse(p);
  res->pts_count_ = TlFetchInt::parse(p);
  res->date_ = TlFetchInt::parse(p);
  if (var0 & 4) { res->fwd_from_ = TlFetchBoxed<TlFetchObject<messageFwdHeader>, 1436466797>::parse(p); }
  if (var0 & 2048) { res->via_bot_id_ = TlFetchInt::parse(p); }
  if (var0 & 8) { res->reply_to_msg_id_ = TlFetchInt::parse(p); }
  if (var0 & 128) { res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateShortMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateShortMessage");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 8192) {  }
    s.store_field("id", id_);
    s.store_field("user_id", user_id_);
    s.store_field("message", message_);
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_field("date", date_);
    if (var0 & 4) { if (fwd_from_ == nullptr) { s.store_field("fwd_from", "null"); } else { fwd_from_->store(s, "fwd_from"); } }
    if (var0 & 2048) { s.store_field("via_bot_id", via_bot_id_); }
    if (var0 & 8) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    if (var0 & 128) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

updateShortChatMessage::updateShortChatMessage()
  : flags_()
  , out_()
  , mentioned_()
  , media_unread_()
  , silent_()
  , id_()
  , from_id_()
  , chat_id_()
  , message_()
  , pts_()
  , pts_count_()
  , date_()
  , fwd_from_()
  , via_bot_id_()
  , reply_to_msg_id_()
  , entities_()
{}

updateShortChatMessage::updateShortChatMessage(std::int32_t flags_, bool out_, bool mentioned_, bool media_unread_, bool silent_, std::int32_t id_, std::int32_t from_id_, std::int32_t chat_id_, std::string const &message_, std::int32_t pts_, std::int32_t pts_count_, std::int32_t date_, object_ptr<messageFwdHeader> &&fwd_from_, std::int32_t via_bot_id_, std::int32_t reply_to_msg_id_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , out_(out_)
  , mentioned_(mentioned_)
  , media_unread_(media_unread_)
  , silent_(silent_)
  , id_(id_)
  , from_id_(from_id_)
  , chat_id_(chat_id_)
  , message_(message_)
  , pts_(pts_)
  , pts_count_(pts_count_)
  , date_(date_)
  , fwd_from_(std::move(fwd_from_))
  , via_bot_id_(via_bot_id_)
  , reply_to_msg_id_(reply_to_msg_id_)
  , entities_(std::move(entities_))
{}

const std::int32_t updateShortChatMessage::ID;

object_ptr<updateShortChatMessage> updateShortChatMessage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateShortChatMessage> res = make_tl_object<updateShortChatMessage>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->out_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->mentioned_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->media_unread_ = TlFetchTrue::parse(p); }
  if (var0 & 8192) { res->silent_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  res->from_id_ = TlFetchInt::parse(p);
  res->chat_id_ = TlFetchInt::parse(p);
  res->message_ = TlFetchString<std::string>::parse(p);
  res->pts_ = TlFetchInt::parse(p);
  res->pts_count_ = TlFetchInt::parse(p);
  res->date_ = TlFetchInt::parse(p);
  if (var0 & 4) { res->fwd_from_ = TlFetchBoxed<TlFetchObject<messageFwdHeader>, 1436466797>::parse(p); }
  if (var0 & 2048) { res->via_bot_id_ = TlFetchInt::parse(p); }
  if (var0 & 8) { res->reply_to_msg_id_ = TlFetchInt::parse(p); }
  if (var0 & 128) { res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateShortChatMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateShortChatMessage");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 8192) {  }
    s.store_field("id", id_);
    s.store_field("from_id", from_id_);
    s.store_field("chat_id", chat_id_);
    s.store_field("message", message_);
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_field("date", date_);
    if (var0 & 4) { if (fwd_from_ == nullptr) { s.store_field("fwd_from", "null"); } else { fwd_from_->store(s, "fwd_from"); } }
    if (var0 & 2048) { s.store_field("via_bot_id", via_bot_id_); }
    if (var0 & 8) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    if (var0 & 128) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

updateShort::updateShort()
  : update_()
  , date_()
{}

updateShort::updateShort(object_ptr<Update> &&update_, std::int32_t date_)
  : update_(std::move(update_))
  , date_(date_)
{}

const std::int32_t updateShort::ID;

updateShort::updateShort(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : update_(TlFetchObject<Update>::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void updateShort::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateShort");
    if (update_ == nullptr) { s.store_field("update", "null"); } else { update_->store(s, "update"); }
    s.store_field("date", date_);
    s.store_class_end();
  }
}

updatesCombined::updatesCombined()
  : updates_()
  , users_()
  , chats_()
  , date_()
  , seq_start_()
  , seq_()
{}

updatesCombined::updatesCombined(std::vector<object_ptr<Update>> &&updates_, std::vector<object_ptr<User>> &&users_, std::vector<object_ptr<Chat>> &&chats_, std::int32_t date_, std::int32_t seq_start_, std::int32_t seq_)
  : updates_(std::move(updates_))
  , users_(std::move(users_))
  , chats_(std::move(chats_))
  , date_(date_)
  , seq_start_(seq_start_)
  , seq_(seq_)
{}

const std::int32_t updatesCombined::ID;

updatesCombined::updatesCombined(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : updates_(TlFetchBoxed<TlFetchVector<TlFetchObject<Update>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , date_(TlFetchInt::parse(p))
  , seq_start_(TlFetchInt::parse(p))
  , seq_(TlFetchInt::parse(p))
#undef FAIL
{}

void updatesCombined::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updatesCombined");
    { const std::vector<object_ptr<Update>> &v = updates_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("updates", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("date", date_);
    s.store_field("seq_start", seq_start_);
    s.store_field("seq", seq_);
    s.store_class_end();
  }
}

updates::updates()
  : updates_()
  , users_()
  , chats_()
  , date_()
  , seq_()
{}

updates::updates(std::vector<object_ptr<Update>> &&updates_, std::vector<object_ptr<User>> &&users_, std::vector<object_ptr<Chat>> &&chats_, std::int32_t date_, std::int32_t seq_)
  : updates_(std::move(updates_))
  , users_(std::move(users_))
  , chats_(std::move(chats_))
  , date_(date_)
  , seq_(seq_)
{}

const std::int32_t updates::ID;

updates::updates(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : updates_(TlFetchBoxed<TlFetchVector<TlFetchObject<Update>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , date_(TlFetchInt::parse(p))
  , seq_(TlFetchInt::parse(p))
#undef FAIL
{}

void updates::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates");
    { const std::vector<object_ptr<Update>> &v = updates_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("updates", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("date", date_);
    s.store_field("seq", seq_);
    s.store_class_end();
  }
}

updateShortSentMessage::updateShortSentMessage()
  : flags_()
  , out_()
  , id_()
  , pts_()
  , pts_count_()
  , date_()
  , media_()
  , entities_()
{}

updateShortSentMessage::updateShortSentMessage(std::int32_t flags_, bool out_, std::int32_t id_, std::int32_t pts_, std::int32_t pts_count_, std::int32_t date_, object_ptr<MessageMedia> &&media_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , out_(out_)
  , id_(id_)
  , pts_(pts_)
  , pts_count_(pts_count_)
  , date_(date_)
  , media_(std::move(media_))
  , entities_(std::move(entities_))
{}

const std::int32_t updateShortSentMessage::ID;

object_ptr<updateShortSentMessage> updateShortSentMessage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updateShortSentMessage> res = make_tl_object<updateShortSentMessage>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->out_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  res->pts_ = TlFetchInt::parse(p);
  res->pts_count_ = TlFetchInt::parse(p);
  res->date_ = TlFetchInt::parse(p);
  if (var0 & 512) { res->media_ = TlFetchObject<MessageMedia>::parse(p); }
  if (var0 & 128) { res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updateShortSentMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updateShortSentMessage");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    s.store_field("id", id_);
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_field("date", date_);
    if (var0 & 512) { if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); } }
    if (var0 & 128) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

object_ptr<User> User::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case userEmpty::ID:
      return userEmpty::fetch(p);
    case user::ID:
      return user::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

userEmpty::userEmpty()
  : id_()
{}

userEmpty::userEmpty(std::int32_t id_)
  : id_(id_)
{}

const std::int32_t userEmpty::ID;

userEmpty::userEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
#undef FAIL
{}

void userEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userEmpty");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

user::user()
  : flags_()
  , self_()
  , contact_()
  , mutual_contact_()
  , deleted_()
  , bot_()
  , bot_chat_history_()
  , bot_nochats_()
  , verified_()
  , restricted_()
  , min_()
  , bot_inline_geo_()
  , id_()
  , access_hash_()
  , first_name_()
  , last_name_()
  , username_()
  , phone_()
  , photo_()
  , status_()
  , bot_info_version_()
  , restriction_reason_()
  , bot_inline_placeholder_()
  , lang_code_()
{}

user::user(std::int32_t flags_, bool self_, bool contact_, bool mutual_contact_, bool deleted_, bool bot_, bool bot_chat_history_, bool bot_nochats_, bool verified_, bool restricted_, bool min_, bool bot_inline_geo_, std::int32_t id_, std::int64_t access_hash_, std::string const &first_name_, std::string const &last_name_, std::string const &username_, std::string const &phone_, object_ptr<UserProfilePhoto> &&photo_, object_ptr<UserStatus> &&status_, std::int32_t bot_info_version_, std::string const &restriction_reason_, std::string const &bot_inline_placeholder_, std::string const &lang_code_)
  : flags_(flags_)
  , self_(self_)
  , contact_(contact_)
  , mutual_contact_(mutual_contact_)
  , deleted_(deleted_)
  , bot_(bot_)
  , bot_chat_history_(bot_chat_history_)
  , bot_nochats_(bot_nochats_)
  , verified_(verified_)
  , restricted_(restricted_)
  , min_(min_)
  , bot_inline_geo_(bot_inline_geo_)
  , id_(id_)
  , access_hash_(access_hash_)
  , first_name_(first_name_)
  , last_name_(last_name_)
  , username_(username_)
  , phone_(phone_)
  , photo_(std::move(photo_))
  , status_(std::move(status_))
  , bot_info_version_(bot_info_version_)
  , restriction_reason_(restriction_reason_)
  , bot_inline_placeholder_(bot_inline_placeholder_)
  , lang_code_(lang_code_)
{}

const std::int32_t user::ID;

object_ptr<user> user::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<user> res = make_tl_object<user>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1024) { res->self_ = TlFetchTrue::parse(p); }
  if (var0 & 2048) { res->contact_ = TlFetchTrue::parse(p); }
  if (var0 & 4096) { res->mutual_contact_ = TlFetchTrue::parse(p); }
  if (var0 & 8192) { res->deleted_ = TlFetchTrue::parse(p); }
  if (var0 & 16384) { res->bot_ = TlFetchTrue::parse(p); }
  if (var0 & 32768) { res->bot_chat_history_ = TlFetchTrue::parse(p); }
  if (var0 & 65536) { res->bot_nochats_ = TlFetchTrue::parse(p); }
  if (var0 & 131072) { res->verified_ = TlFetchTrue::parse(p); }
  if (var0 & 262144) { res->restricted_ = TlFetchTrue::parse(p); }
  if (var0 & 1048576) { res->min_ = TlFetchTrue::parse(p); }
  if (var0 & 2097152) { res->bot_inline_geo_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  if (var0 & 1) { res->access_hash_ = TlFetchLong::parse(p); }
  if (var0 & 2) { res->first_name_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->last_name_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 8) { res->username_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16) { res->phone_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 32) { res->photo_ = TlFetchObject<UserProfilePhoto>::parse(p); }
  if (var0 & 64) { res->status_ = TlFetchObject<UserStatus>::parse(p); }
  if (var0 & 16384) { res->bot_info_version_ = TlFetchInt::parse(p); }
  if (var0 & 262144) { res->restriction_reason_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 524288) { res->bot_inline_placeholder_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4194304) { res->lang_code_ = TlFetchString<std::string>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void user::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "user");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1024) {  }
    if (var0 & 2048) {  }
    if (var0 & 4096) {  }
    if (var0 & 8192) {  }
    if (var0 & 16384) {  }
    if (var0 & 32768) {  }
    if (var0 & 65536) {  }
    if (var0 & 131072) {  }
    if (var0 & 262144) {  }
    if (var0 & 1048576) {  }
    if (var0 & 2097152) {  }
    s.store_field("id", id_);
    if (var0 & 1) { s.store_field("access_hash", access_hash_); }
    if (var0 & 2) { s.store_field("first_name", first_name_); }
    if (var0 & 4) { s.store_field("last_name", last_name_); }
    if (var0 & 8) { s.store_field("username", username_); }
    if (var0 & 16) { s.store_field("phone", phone_); }
    if (var0 & 32) { if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); } }
    if (var0 & 64) { if (status_ == nullptr) { s.store_field("status", "null"); } else { status_->store(s, "status"); } }
    if (var0 & 16384) { s.store_field("bot_info_version", bot_info_version_); }
    if (var0 & 262144) { s.store_field("restriction_reason", restriction_reason_); }
    if (var0 & 524288) { s.store_field("bot_inline_placeholder", bot_inline_placeholder_); }
    if (var0 & 4194304) { s.store_field("lang_code", lang_code_); }
    s.store_class_end();
  }
}

userFull::userFull()
  : flags_()
  , blocked_()
  , phone_calls_available_()
  , phone_calls_private_()
  , user_()
  , about_()
  , link_()
  , profile_photo_()
  , notify_settings_()
  , bot_info_()
  , common_chats_count_()
{}

userFull::userFull(std::int32_t flags_, bool blocked_, bool phone_calls_available_, bool phone_calls_private_, object_ptr<User> &&user_, std::string const &about_, object_ptr<contacts_link> &&link_, object_ptr<Photo> &&profile_photo_, object_ptr<peerNotifySettings> &&notify_settings_, object_ptr<botInfo> &&bot_info_, std::int32_t common_chats_count_)
  : flags_(flags_)
  , blocked_(blocked_)
  , phone_calls_available_(phone_calls_available_)
  , phone_calls_private_(phone_calls_private_)
  , user_(std::move(user_))
  , about_(about_)
  , link_(std::move(link_))
  , profile_photo_(std::move(profile_photo_))
  , notify_settings_(std::move(notify_settings_))
  , bot_info_(std::move(bot_info_))
  , common_chats_count_(common_chats_count_)
{}

const std::int32_t userFull::ID;

object_ptr<userFull> userFull::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<userFull> res = make_tl_object<userFull>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->blocked_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->phone_calls_available_ = TlFetchTrue::parse(p); }
  if (var0 & 32) { res->phone_calls_private_ = TlFetchTrue::parse(p); }
  res->user_ = TlFetchObject<User>::parse(p);
  if (var0 & 2) { res->about_ = TlFetchString<std::string>::parse(p); }
  res->link_ = TlFetchBoxed<TlFetchObject<contacts_link>, 986597452>::parse(p);
  if (var0 & 4) { res->profile_photo_ = TlFetchObject<Photo>::parse(p); }
  res->notify_settings_ = TlFetchBoxed<TlFetchObject<peerNotifySettings>, -1353671392>::parse(p);
  if (var0 & 8) { res->bot_info_ = TlFetchBoxed<TlFetchObject<botInfo>, -1729618630>::parse(p); }
  res->common_chats_count_ = TlFetchInt::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void userFull::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userFull");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (user_ == nullptr) { s.store_field("user", "null"); } else { user_->store(s, "user"); }
    if (var0 & 2) { s.store_field("about", about_); }
    if (link_ == nullptr) { s.store_field("link", "null"); } else { link_->store(s, "link"); }
    if (var0 & 4) { if (profile_photo_ == nullptr) { s.store_field("profile_photo", "null"); } else { profile_photo_->store(s, "profile_photo"); } }
    if (notify_settings_ == nullptr) { s.store_field("notify_settings", "null"); } else { notify_settings_->store(s, "notify_settings"); }
    if (var0 & 8) { if (bot_info_ == nullptr) { s.store_field("bot_info", "null"); } else { bot_info_->store(s, "bot_info"); } }
    s.store_field("common_chats_count", common_chats_count_);
    s.store_class_end();
  }
}

object_ptr<UserProfilePhoto> UserProfilePhoto::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case userProfilePhotoEmpty::ID:
      return userProfilePhotoEmpty::fetch(p);
    case userProfilePhoto::ID:
      return userProfilePhoto::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

userProfilePhotoEmpty::userProfilePhotoEmpty() {
}

const std::int32_t userProfilePhotoEmpty::ID;

userProfilePhotoEmpty::userProfilePhotoEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void userProfilePhotoEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userProfilePhotoEmpty");
    s.store_class_end();
  }
}

userProfilePhoto::userProfilePhoto()
  : photo_id_()
  , photo_small_()
  , photo_big_()
{}

userProfilePhoto::userProfilePhoto(std::int64_t photo_id_, object_ptr<FileLocation> &&photo_small_, object_ptr<FileLocation> &&photo_big_)
  : photo_id_(photo_id_)
  , photo_small_(std::move(photo_small_))
  , photo_big_(std::move(photo_big_))
{}

const std::int32_t userProfilePhoto::ID;

userProfilePhoto::userProfilePhoto(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : photo_id_(TlFetchLong::parse(p))
  , photo_small_(TlFetchObject<FileLocation>::parse(p))
  , photo_big_(TlFetchObject<FileLocation>::parse(p))
#undef FAIL
{}

void userProfilePhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userProfilePhoto");
    s.store_field("photo_id", photo_id_);
    if (photo_small_ == nullptr) { s.store_field("photo_small", "null"); } else { photo_small_->store(s, "photo_small"); }
    if (photo_big_ == nullptr) { s.store_field("photo_big", "null"); } else { photo_big_->store(s, "photo_big"); }
    s.store_class_end();
  }
}

object_ptr<UserStatus> UserStatus::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case userStatusEmpty::ID:
      return userStatusEmpty::fetch(p);
    case userStatusOnline::ID:
      return userStatusOnline::fetch(p);
    case userStatusOffline::ID:
      return userStatusOffline::fetch(p);
    case userStatusRecently::ID:
      return userStatusRecently::fetch(p);
    case userStatusLastWeek::ID:
      return userStatusLastWeek::fetch(p);
    case userStatusLastMonth::ID:
      return userStatusLastMonth::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

userStatusEmpty::userStatusEmpty() {
}

const std::int32_t userStatusEmpty::ID;

userStatusEmpty::userStatusEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void userStatusEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userStatusEmpty");
    s.store_class_end();
  }
}

userStatusOnline::userStatusOnline()
  : expires_()
{}

userStatusOnline::userStatusOnline(std::int32_t expires_)
  : expires_(expires_)
{}

const std::int32_t userStatusOnline::ID;

userStatusOnline::userStatusOnline(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : expires_(TlFetchInt::parse(p))
#undef FAIL
{}

void userStatusOnline::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userStatusOnline");
    s.store_field("expires", expires_);
    s.store_class_end();
  }
}

userStatusOffline::userStatusOffline()
  : was_online_()
{}

userStatusOffline::userStatusOffline(std::int32_t was_online_)
  : was_online_(was_online_)
{}

const std::int32_t userStatusOffline::ID;

userStatusOffline::userStatusOffline(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : was_online_(TlFetchInt::parse(p))
#undef FAIL
{}

void userStatusOffline::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userStatusOffline");
    s.store_field("was_online", was_online_);
    s.store_class_end();
  }
}

userStatusRecently::userStatusRecently() {
}

const std::int32_t userStatusRecently::ID;

userStatusRecently::userStatusRecently(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void userStatusRecently::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userStatusRecently");
    s.store_class_end();
  }
}

userStatusLastWeek::userStatusLastWeek() {
}

const std::int32_t userStatusLastWeek::ID;

userStatusLastWeek::userStatusLastWeek(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void userStatusLastWeek::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userStatusLastWeek");
    s.store_class_end();
  }
}

userStatusLastMonth::userStatusLastMonth() {
}

const std::int32_t userStatusLastMonth::ID;

userStatusLastMonth::userStatusLastMonth(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void userStatusLastMonth::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "userStatusLastMonth");
    s.store_class_end();
  }
}

object_ptr<WallPaper> WallPaper::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case wallPaper::ID:
      return wallPaper::fetch(p);
    case wallPaperSolid::ID:
      return wallPaperSolid::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

wallPaper::wallPaper()
  : id_()
  , title_()
  , sizes_()
  , color_()
{}

wallPaper::wallPaper(std::int32_t id_, std::string const &title_, std::vector<object_ptr<PhotoSize>> &&sizes_, std::int32_t color_)
  : id_(id_)
  , title_(title_)
  , sizes_(std::move(sizes_))
  , color_(color_)
{}

const std::int32_t wallPaper::ID;

wallPaper::wallPaper(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , title_(TlFetchString<std::string>::parse(p))
  , sizes_(TlFetchBoxed<TlFetchVector<TlFetchObject<PhotoSize>>, 481674261>::parse(p))
  , color_(TlFetchInt::parse(p))
#undef FAIL
{}

void wallPaper::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "wallPaper");
    s.store_field("id", id_);
    s.store_field("title", title_);
    { const std::vector<object_ptr<PhotoSize>> &v = sizes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("sizes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("color", color_);
    s.store_class_end();
  }
}

wallPaperSolid::wallPaperSolid()
  : id_()
  , title_()
  , bg_color_()
  , color_()
{}

wallPaperSolid::wallPaperSolid(std::int32_t id_, std::string const &title_, std::int32_t bg_color_, std::int32_t color_)
  : id_(id_)
  , title_(title_)
  , bg_color_(bg_color_)
  , color_(color_)
{}

const std::int32_t wallPaperSolid::ID;

wallPaperSolid::wallPaperSolid(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , title_(TlFetchString<std::string>::parse(p))
  , bg_color_(TlFetchInt::parse(p))
  , color_(TlFetchInt::parse(p))
#undef FAIL
{}

void wallPaperSolid::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "wallPaperSolid");
    s.store_field("id", id_);
    s.store_field("title", title_);
    s.store_field("bg_color", bg_color_);
    s.store_field("color", color_);
    s.store_class_end();
  }
}

webAuthorization::webAuthorization()
  : hash_()
  , bot_id_()
  , domain_()
  , browser_()
  , platform_()
  , date_created_()
  , date_active_()
  , ip_()
  , region_()
{}

webAuthorization::webAuthorization(std::int64_t hash_, std::int32_t bot_id_, std::string const &domain_, std::string const &browser_, std::string const &platform_, std::int32_t date_created_, std::int32_t date_active_, std::string const &ip_, std::string const &region_)
  : hash_(hash_)
  , bot_id_(bot_id_)
  , domain_(domain_)
  , browser_(browser_)
  , platform_(platform_)
  , date_created_(date_created_)
  , date_active_(date_active_)
  , ip_(ip_)
  , region_(region_)
{}

const std::int32_t webAuthorization::ID;

webAuthorization::webAuthorization(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchLong::parse(p))
  , bot_id_(TlFetchInt::parse(p))
  , domain_(TlFetchString<std::string>::parse(p))
  , browser_(TlFetchString<std::string>::parse(p))
  , platform_(TlFetchString<std::string>::parse(p))
  , date_created_(TlFetchInt::parse(p))
  , date_active_(TlFetchInt::parse(p))
  , ip_(TlFetchString<std::string>::parse(p))
  , region_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void webAuthorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "webAuthorization");
    s.store_field("hash", hash_);
    s.store_field("bot_id", bot_id_);
    s.store_field("domain", domain_);
    s.store_field("browser", browser_);
    s.store_field("platform", platform_);
    s.store_field("date_created", date_created_);
    s.store_field("date_active", date_active_);
    s.store_field("ip", ip_);
    s.store_field("region", region_);
    s.store_class_end();
  }
}

object_ptr<WebDocument> WebDocument::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case webDocument::ID:
      return webDocument::fetch(p);
    case webDocumentNoProxy::ID:
      return webDocumentNoProxy::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

webDocument::webDocument()
  : url_()
  , access_hash_()
  , size_()
  , mime_type_()
  , attributes_()
{}

webDocument::webDocument(std::string const &url_, std::int64_t access_hash_, std::int32_t size_, std::string const &mime_type_, std::vector<object_ptr<DocumentAttribute>> &&attributes_)
  : url_(url_)
  , access_hash_(access_hash_)
  , size_(size_)
  , mime_type_(mime_type_)
  , attributes_(std::move(attributes_))
{}

const std::int32_t webDocument::ID;

webDocument::webDocument(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , access_hash_(TlFetchLong::parse(p))
  , size_(TlFetchInt::parse(p))
  , mime_type_(TlFetchString<std::string>::parse(p))
  , attributes_(TlFetchBoxed<TlFetchVector<TlFetchObject<DocumentAttribute>>, 481674261>::parse(p))
#undef FAIL
{}

void webDocument::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "webDocument");
    s.store_field("url", url_);
    s.store_field("access_hash", access_hash_);
    s.store_field("size", size_);
    s.store_field("mime_type", mime_type_);
    { const std::vector<object_ptr<DocumentAttribute>> &v = attributes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("attributes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

webDocumentNoProxy::webDocumentNoProxy()
  : url_()
  , size_()
  , mime_type_()
  , attributes_()
{}

webDocumentNoProxy::webDocumentNoProxy(std::string const &url_, std::int32_t size_, std::string const &mime_type_, std::vector<object_ptr<DocumentAttribute>> &&attributes_)
  : url_(url_)
  , size_(size_)
  , mime_type_(mime_type_)
  , attributes_(std::move(attributes_))
{}

const std::int32_t webDocumentNoProxy::ID;

webDocumentNoProxy::webDocumentNoProxy(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
  , size_(TlFetchInt::parse(p))
  , mime_type_(TlFetchString<std::string>::parse(p))
  , attributes_(TlFetchBoxed<TlFetchVector<TlFetchObject<DocumentAttribute>>, 481674261>::parse(p))
#undef FAIL
{}

void webDocumentNoProxy::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "webDocumentNoProxy");
    s.store_field("url", url_);
    s.store_field("size", size_);
    s.store_field("mime_type", mime_type_);
    { const std::vector<object_ptr<DocumentAttribute>> &v = attributes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("attributes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<WebPage> WebPage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case webPageEmpty::ID:
      return webPageEmpty::fetch(p);
    case webPagePending::ID:
      return webPagePending::fetch(p);
    case webPage::ID:
      return webPage::fetch(p);
    case webPageNotModified::ID:
      return webPageNotModified::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

webPageEmpty::webPageEmpty()
  : id_()
{}

webPageEmpty::webPageEmpty(std::int64_t id_)
  : id_(id_)
{}

const std::int32_t webPageEmpty::ID;

webPageEmpty::webPageEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
#undef FAIL
{}

void webPageEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "webPageEmpty");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

webPagePending::webPagePending()
  : id_()
  , date_()
{}

webPagePending::webPagePending(std::int64_t id_, std::int32_t date_)
  : id_(id_)
  , date_(date_)
{}

const std::int32_t webPagePending::ID;

webPagePending::webPagePending(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
  , date_(TlFetchInt::parse(p))
#undef FAIL
{}

void webPagePending::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "webPagePending");
    s.store_field("id", id_);
    s.store_field("date", date_);
    s.store_class_end();
  }
}

webPage::webPage()
  : flags_()
  , id_()
  , url_()
  , display_url_()
  , hash_()
  , type_()
  , site_name_()
  , title_()
  , description_()
  , photo_()
  , embed_url_()
  , embed_type_()
  , embed_width_()
  , embed_height_()
  , duration_()
  , author_()
  , document_()
  , cached_page_()
{}

webPage::webPage(std::int32_t flags_, std::int64_t id_, std::string const &url_, std::string const &display_url_, std::int32_t hash_, std::string const &type_, std::string const &site_name_, std::string const &title_, std::string const &description_, object_ptr<Photo> &&photo_, std::string const &embed_url_, std::string const &embed_type_, std::int32_t embed_width_, std::int32_t embed_height_, std::int32_t duration_, std::string const &author_, object_ptr<Document> &&document_, object_ptr<Page> &&cached_page_)
  : flags_(flags_)
  , id_(id_)
  , url_(url_)
  , display_url_(display_url_)
  , hash_(hash_)
  , type_(type_)
  , site_name_(site_name_)
  , title_(title_)
  , description_(description_)
  , photo_(std::move(photo_))
  , embed_url_(embed_url_)
  , embed_type_(embed_type_)
  , embed_width_(embed_width_)
  , embed_height_(embed_height_)
  , duration_(duration_)
  , author_(author_)
  , document_(std::move(document_))
  , cached_page_(std::move(cached_page_))
{}

const std::int32_t webPage::ID;

object_ptr<webPage> webPage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<webPage> res = make_tl_object<webPage>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->id_ = TlFetchLong::parse(p);
  res->url_ = TlFetchString<std::string>::parse(p);
  res->display_url_ = TlFetchString<std::string>::parse(p);
  res->hash_ = TlFetchInt::parse(p);
  if (var0 & 1) { res->type_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 2) { res->site_name_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->title_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 8) { res->description_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16) { res->photo_ = TlFetchObject<Photo>::parse(p); }
  if (var0 & 32) { res->embed_url_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 32) { res->embed_type_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 64) { res->embed_width_ = TlFetchInt::parse(p); }
  if (var0 & 64) { res->embed_height_ = TlFetchInt::parse(p); }
  if (var0 & 128) { res->duration_ = TlFetchInt::parse(p); }
  if (var0 & 256) { res->author_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 512) { res->document_ = TlFetchObject<Document>::parse(p); }
  if (var0 & 1024) { res->cached_page_ = TlFetchObject<Page>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void webPage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "webPage");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("id", id_);
    s.store_field("url", url_);
    s.store_field("display_url", display_url_);
    s.store_field("hash", hash_);
    if (var0 & 1) { s.store_field("type", type_); }
    if (var0 & 2) { s.store_field("site_name", site_name_); }
    if (var0 & 4) { s.store_field("title", title_); }
    if (var0 & 8) { s.store_field("description", description_); }
    if (var0 & 16) { if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); } }
    if (var0 & 32) { s.store_field("embed_url", embed_url_); }
    if (var0 & 32) { s.store_field("embed_type", embed_type_); }
    if (var0 & 64) { s.store_field("embed_width", embed_width_); }
    if (var0 & 64) { s.store_field("embed_height", embed_height_); }
    if (var0 & 128) { s.store_field("duration", duration_); }
    if (var0 & 256) { s.store_field("author", author_); }
    if (var0 & 512) { if (document_ == nullptr) { s.store_field("document", "null"); } else { document_->store(s, "document"); } }
    if (var0 & 1024) { if (cached_page_ == nullptr) { s.store_field("cached_page", "null"); } else { cached_page_->store(s, "cached_page"); } }
    s.store_class_end();
  }
}

webPageNotModified::webPageNotModified() {
}

const std::int32_t webPageNotModified::ID;

webPageNotModified::webPageNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void webPageNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "webPageNotModified");
    s.store_class_end();
  }
}

account_authorizationForm::account_authorizationForm()
  : flags_()
  , required_types_()
  , values_()
  , errors_()
  , users_()
  , privacy_policy_url_()
{}

account_authorizationForm::account_authorizationForm(std::int32_t flags_, std::vector<object_ptr<SecureRequiredType>> &&required_types_, std::vector<object_ptr<secureValue>> &&values_, std::vector<object_ptr<SecureValueError>> &&errors_, std::vector<object_ptr<User>> &&users_, std::string const &privacy_policy_url_)
  : flags_(flags_)
  , required_types_(std::move(required_types_))
  , values_(std::move(values_))
  , errors_(std::move(errors_))
  , users_(std::move(users_))
  , privacy_policy_url_(privacy_policy_url_)
{}

const std::int32_t account_authorizationForm::ID;

object_ptr<account_authorizationForm> account_authorizationForm::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<account_authorizationForm> res = make_tl_object<account_authorizationForm>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->required_types_ = TlFetchBoxed<TlFetchVector<TlFetchObject<SecureRequiredType>>, 481674261>::parse(p);
  res->values_ = TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<secureValue>, 411017418>>, 481674261>::parse(p);
  res->errors_ = TlFetchBoxed<TlFetchVector<TlFetchObject<SecureValueError>>, 481674261>::parse(p);
  res->users_ = TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p);
  if (var0 & 1) { res->privacy_policy_url_ = TlFetchString<std::string>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void account_authorizationForm::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_authorizationForm");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    { const std::vector<object_ptr<SecureRequiredType>> &v = required_types_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("required_types", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<secureValue>> &v = values_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("values", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<SecureValueError>> &v = errors_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("errors", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (var0 & 1) { s.store_field("privacy_policy_url", privacy_policy_url_); }
    s.store_class_end();
  }
}

account_authorizations::account_authorizations()
  : authorizations_()
{}

account_authorizations::account_authorizations(std::vector<object_ptr<authorization>> &&authorizations_)
  : authorizations_(std::move(authorizations_))
{}

const std::int32_t account_authorizations::ID;

account_authorizations::account_authorizations(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : authorizations_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<authorization>, 2079516406>>, 481674261>::parse(p))
#undef FAIL
{}

void account_authorizations::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_authorizations");
    { const std::vector<object_ptr<authorization>> &v = authorizations_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("authorizations", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

account_password::account_password()
  : flags_()
  , has_recovery_()
  , has_secure_values_()
  , has_password_()
  , current_algo_()
  , srp_B_()
  , srp_id_()
  , hint_()
  , email_unconfirmed_pattern_()
  , new_algo_()
  , new_secure_algo_()
  , secure_random_()
{}

account_password::account_password(std::int32_t flags_, bool has_recovery_, bool has_secure_values_, bool has_password_, object_ptr<PasswordKdfAlgo> &&current_algo_, BufferSlice &&srp_B_, std::int64_t srp_id_, std::string const &hint_, std::string const &email_unconfirmed_pattern_, object_ptr<PasswordKdfAlgo> &&new_algo_, object_ptr<SecurePasswordKdfAlgo> &&new_secure_algo_, BufferSlice &&secure_random_)
  : flags_(flags_)
  , has_recovery_(has_recovery_)
  , has_secure_values_(has_secure_values_)
  , has_password_(has_password_)
  , current_algo_(std::move(current_algo_))
  , srp_B_(std::move(srp_B_))
  , srp_id_(srp_id_)
  , hint_(hint_)
  , email_unconfirmed_pattern_(email_unconfirmed_pattern_)
  , new_algo_(std::move(new_algo_))
  , new_secure_algo_(std::move(new_secure_algo_))
  , secure_random_(std::move(secure_random_))
{}

const std::int32_t account_password::ID;

object_ptr<account_password> account_password::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<account_password> res = make_tl_object<account_password>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->has_recovery_ = TlFetchTrue::parse(p); }
  if (var0 & 2) { res->has_secure_values_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->has_password_ = TlFetchTrue::parse(p); }
  if (var0 & 4) { res->current_algo_ = TlFetchObject<PasswordKdfAlgo>::parse(p); }
  if (var0 & 4) { res->srp_B_ = TlFetchBytes<BufferSlice>::parse(p); }
  if (var0 & 4) { res->srp_id_ = TlFetchLong::parse(p); }
  if (var0 & 8) { res->hint_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16) { res->email_unconfirmed_pattern_ = TlFetchString<std::string>::parse(p); }
  res->new_algo_ = TlFetchObject<PasswordKdfAlgo>::parse(p);
  res->new_secure_algo_ = TlFetchObject<SecurePasswordKdfAlgo>::parse(p);
  res->secure_random_ = TlFetchBytes<BufferSlice>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void account_password::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_password");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 4) { if (current_algo_ == nullptr) { s.store_field("current_algo", "null"); } else { current_algo_->store(s, "current_algo"); } }
    if (var0 & 4) { s.store_bytes_field("srp_B", srp_B_); }
    if (var0 & 4) { s.store_field("srp_id", srp_id_); }
    if (var0 & 8) { s.store_field("hint", hint_); }
    if (var0 & 16) { s.store_field("email_unconfirmed_pattern", email_unconfirmed_pattern_); }
    if (new_algo_ == nullptr) { s.store_field("new_algo", "null"); } else { new_algo_->store(s, "new_algo"); }
    if (new_secure_algo_ == nullptr) { s.store_field("new_secure_algo", "null"); } else { new_secure_algo_->store(s, "new_secure_algo"); }
    s.store_bytes_field("secure_random", secure_random_);
    s.store_class_end();
  }
}

account_passwordInputSettings::account_passwordInputSettings()
  : flags_()
  , new_algo_()
  , new_password_hash_()
  , hint_()
  , email_()
  , new_secure_settings_()
{}

account_passwordInputSettings::account_passwordInputSettings(std::int32_t flags_, object_ptr<PasswordKdfAlgo> &&new_algo_, BufferSlice &&new_password_hash_, std::string const &hint_, std::string const &email_, object_ptr<secureSecretSettings> &&new_secure_settings_)
  : flags_(flags_)
  , new_algo_(std::move(new_algo_))
  , new_password_hash_(std::move(new_password_hash_))
  , hint_(hint_)
  , email_(email_)
  , new_secure_settings_(std::move(new_secure_settings_))
{}

const std::int32_t account_passwordInputSettings::ID;

void account_passwordInputSettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreBoxedUnknown<TlStoreObject>::store(new_algo_, s); }
  if (var0 & 1) { TlStoreString::store(new_password_hash_, s); }
  if (var0 & 1) { TlStoreString::store(hint_, s); }
  if (var0 & 2) { TlStoreString::store(email_, s); }
  if (var0 & 4) { TlStoreBoxed<TlStoreObject, 354925740>::store(new_secure_settings_, s); }
}

void account_passwordInputSettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  std::int32_t var0;
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreBoxedUnknown<TlStoreObject>::store(new_algo_, s); }
  if (var0 & 1) { TlStoreString::store(new_password_hash_, s); }
  if (var0 & 1) { TlStoreString::store(hint_, s); }
  if (var0 & 2) { TlStoreString::store(email_, s); }
  if (var0 & 4) { TlStoreBoxed<TlStoreObject, 354925740>::store(new_secure_settings_, s); }
}

void account_passwordInputSettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_passwordInputSettings");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { if (new_algo_ == nullptr) { s.store_field("new_algo", "null"); } else { new_algo_->store(s, "new_algo"); } }
    if (var0 & 1) { s.store_bytes_field("new_password_hash", new_password_hash_); }
    if (var0 & 1) { s.store_field("hint", hint_); }
    if (var0 & 2) { s.store_field("email", email_); }
    if (var0 & 4) { if (new_secure_settings_ == nullptr) { s.store_field("new_secure_settings", "null"); } else { new_secure_settings_->store(s, "new_secure_settings"); } }
    s.store_class_end();
  }
}

account_passwordSettings::account_passwordSettings()
  : flags_()
  , email_()
  , secure_settings_()
{}

account_passwordSettings::account_passwordSettings(std::int32_t flags_, std::string const &email_, object_ptr<secureSecretSettings> &&secure_settings_)
  : flags_(flags_)
  , email_(email_)
  , secure_settings_(std::move(secure_settings_))
{}

const std::int32_t account_passwordSettings::ID;

object_ptr<account_passwordSettings> account_passwordSettings::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<account_passwordSettings> res = make_tl_object<account_passwordSettings>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->email_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 2) { res->secure_settings_ = TlFetchBoxed<TlFetchObject<secureSecretSettings>, 354925740>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void account_passwordSettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_passwordSettings");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("email", email_); }
    if (var0 & 2) { if (secure_settings_ == nullptr) { s.store_field("secure_settings", "null"); } else { secure_settings_->store(s, "secure_settings"); } }
    s.store_class_end();
  }
}

account_privacyRules::account_privacyRules()
  : rules_()
  , users_()
{}

account_privacyRules::account_privacyRules(std::vector<object_ptr<PrivacyRule>> &&rules_, std::vector<object_ptr<User>> &&users_)
  : rules_(std::move(rules_))
  , users_(std::move(users_))
{}

const std::int32_t account_privacyRules::ID;

account_privacyRules::account_privacyRules(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : rules_(TlFetchBoxed<TlFetchVector<TlFetchObject<PrivacyRule>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void account_privacyRules::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_privacyRules");
    { const std::vector<object_ptr<PrivacyRule>> &v = rules_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("rules", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

account_sentEmailCode::account_sentEmailCode()
  : email_pattern_()
  , length_()
{}

account_sentEmailCode::account_sentEmailCode(std::string const &email_pattern_, std::int32_t length_)
  : email_pattern_(email_pattern_)
  , length_(length_)
{}

const std::int32_t account_sentEmailCode::ID;

account_sentEmailCode::account_sentEmailCode(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : email_pattern_(TlFetchString<std::string>::parse(p))
  , length_(TlFetchInt::parse(p))
#undef FAIL
{}

void account_sentEmailCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_sentEmailCode");
    s.store_field("email_pattern", email_pattern_);
    s.store_field("length", length_);
    s.store_class_end();
  }
}

account_takeout::account_takeout()
  : id_()
{}

account_takeout::account_takeout(std::int64_t id_)
  : id_(id_)
{}

const std::int32_t account_takeout::ID;

account_takeout::account_takeout(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchLong::parse(p))
#undef FAIL
{}

void account_takeout::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_takeout");
    s.store_field("id", id_);
    s.store_class_end();
  }
}

account_tmpPassword::account_tmpPassword()
  : tmp_password_()
  , valid_until_()
{}

account_tmpPassword::account_tmpPassword(BufferSlice &&tmp_password_, std::int32_t valid_until_)
  : tmp_password_(std::move(tmp_password_))
  , valid_until_(valid_until_)
{}

const std::int32_t account_tmpPassword::ID;

account_tmpPassword::account_tmpPassword(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : tmp_password_(TlFetchBytes<BufferSlice>::parse(p))
  , valid_until_(TlFetchInt::parse(p))
#undef FAIL
{}

void account_tmpPassword::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_tmpPassword");
    s.store_bytes_field("tmp_password", tmp_password_);
    s.store_field("valid_until", valid_until_);
    s.store_class_end();
  }
}

account_webAuthorizations::account_webAuthorizations()
  : authorizations_()
  , users_()
{}

account_webAuthorizations::account_webAuthorizations(std::vector<object_ptr<webAuthorization>> &&authorizations_, std::vector<object_ptr<User>> &&users_)
  : authorizations_(std::move(authorizations_))
  , users_(std::move(users_))
{}

const std::int32_t account_webAuthorizations::ID;

account_webAuthorizations::account_webAuthorizations(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : authorizations_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<webAuthorization>, -892779534>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void account_webAuthorizations::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_webAuthorizations");
    { const std::vector<object_ptr<webAuthorization>> &v = authorizations_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("authorizations", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

auth_authorization::auth_authorization()
  : flags_()
  , tmp_sessions_()
  , user_()
{}

auth_authorization::auth_authorization(std::int32_t flags_, std::int32_t tmp_sessions_, object_ptr<User> &&user_)
  : flags_(flags_)
  , tmp_sessions_(tmp_sessions_)
  , user_(std::move(user_))
{}

const std::int32_t auth_authorization::ID;

object_ptr<auth_authorization> auth_authorization::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<auth_authorization> res = make_tl_object<auth_authorization>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->tmp_sessions_ = TlFetchInt::parse(p); }
  res->user_ = TlFetchObject<User>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void auth_authorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_authorization");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("tmp_sessions", tmp_sessions_); }
    if (user_ == nullptr) { s.store_field("user", "null"); } else { user_->store(s, "user"); }
    s.store_class_end();
  }
}

auth_checkedPhone::auth_checkedPhone()
  : phone_registered_()
{}

auth_checkedPhone::auth_checkedPhone(bool phone_registered_)
  : phone_registered_(phone_registered_)
{}

const std::int32_t auth_checkedPhone::ID;

void auth_checkedPhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_checkedPhone");
    s.store_field("phone_registered", phone_registered_);
    s.store_class_end();
  }
}

object_ptr<auth_CodeType> auth_CodeType::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case auth_codeTypeSms::ID:
      return auth_codeTypeSms::fetch(p);
    case auth_codeTypeCall::ID:
      return auth_codeTypeCall::fetch(p);
    case auth_codeTypeFlashCall::ID:
      return auth_codeTypeFlashCall::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

auth_codeTypeSms::auth_codeTypeSms() {
}

const std::int32_t auth_codeTypeSms::ID;

auth_codeTypeSms::auth_codeTypeSms(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void auth_codeTypeSms::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_codeTypeSms");
    s.store_class_end();
  }
}

auth_codeTypeCall::auth_codeTypeCall() {
}

const std::int32_t auth_codeTypeCall::ID;

auth_codeTypeCall::auth_codeTypeCall(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void auth_codeTypeCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_codeTypeCall");
    s.store_class_end();
  }
}

auth_codeTypeFlashCall::auth_codeTypeFlashCall() {
}

const std::int32_t auth_codeTypeFlashCall::ID;

auth_codeTypeFlashCall::auth_codeTypeFlashCall(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void auth_codeTypeFlashCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_codeTypeFlashCall");
    s.store_class_end();
  }
}

auth_exportedAuthorization::auth_exportedAuthorization()
  : id_()
  , bytes_()
{}

auth_exportedAuthorization::auth_exportedAuthorization(std::int32_t id_, BufferSlice &&bytes_)
  : id_(id_)
  , bytes_(std::move(bytes_))
{}

const std::int32_t auth_exportedAuthorization::ID;

auth_exportedAuthorization::auth_exportedAuthorization(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : id_(TlFetchInt::parse(p))
  , bytes_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void auth_exportedAuthorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_exportedAuthorization");
    s.store_field("id", id_);
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

auth_passwordRecovery::auth_passwordRecovery()
  : email_pattern_()
{}

auth_passwordRecovery::auth_passwordRecovery(std::string const &email_pattern_)
  : email_pattern_(email_pattern_)
{}

const std::int32_t auth_passwordRecovery::ID;

auth_passwordRecovery::auth_passwordRecovery(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : email_pattern_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void auth_passwordRecovery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_passwordRecovery");
    s.store_field("email_pattern", email_pattern_);
    s.store_class_end();
  }
}

auth_sentCode::auth_sentCode()
  : flags_()
  , phone_registered_()
  , type_()
  , phone_code_hash_()
  , next_type_()
  , timeout_()
  , terms_of_service_()
{}

auth_sentCode::auth_sentCode(std::int32_t flags_, bool phone_registered_, object_ptr<auth_SentCodeType> &&type_, std::string const &phone_code_hash_, object_ptr<auth_CodeType> &&next_type_, std::int32_t timeout_, object_ptr<help_termsOfService> &&terms_of_service_)
  : flags_(flags_)
  , phone_registered_(phone_registered_)
  , type_(std::move(type_))
  , phone_code_hash_(phone_code_hash_)
  , next_type_(std::move(next_type_))
  , timeout_(timeout_)
  , terms_of_service_(std::move(terms_of_service_))
{}

const std::int32_t auth_sentCode::ID;

object_ptr<auth_sentCode> auth_sentCode::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<auth_sentCode> res = make_tl_object<auth_sentCode>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->phone_registered_ = TlFetchTrue::parse(p); }
  res->type_ = TlFetchObject<auth_SentCodeType>::parse(p);
  res->phone_code_hash_ = TlFetchString<std::string>::parse(p);
  if (var0 & 2) { res->next_type_ = TlFetchObject<auth_CodeType>::parse(p); }
  if (var0 & 4) { res->timeout_ = TlFetchInt::parse(p); }
  if (var0 & 8) { res->terms_of_service_ = TlFetchBoxed<TlFetchObject<help_termsOfService>, 2013922064>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void auth_sentCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_sentCode");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_field("phone_code_hash", phone_code_hash_);
    if (var0 & 2) { if (next_type_ == nullptr) { s.store_field("next_type", "null"); } else { next_type_->store(s, "next_type"); } }
    if (var0 & 4) { s.store_field("timeout", timeout_); }
    if (var0 & 8) { if (terms_of_service_ == nullptr) { s.store_field("terms_of_service", "null"); } else { terms_of_service_->store(s, "terms_of_service"); } }
    s.store_class_end();
  }
}

object_ptr<auth_SentCodeType> auth_SentCodeType::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case auth_sentCodeTypeApp::ID:
      return auth_sentCodeTypeApp::fetch(p);
    case auth_sentCodeTypeSms::ID:
      return auth_sentCodeTypeSms::fetch(p);
    case auth_sentCodeTypeCall::ID:
      return auth_sentCodeTypeCall::fetch(p);
    case auth_sentCodeTypeFlashCall::ID:
      return auth_sentCodeTypeFlashCall::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

auth_sentCodeTypeApp::auth_sentCodeTypeApp()
  : length_()
{}

auth_sentCodeTypeApp::auth_sentCodeTypeApp(std::int32_t length_)
  : length_(length_)
{}

const std::int32_t auth_sentCodeTypeApp::ID;

auth_sentCodeTypeApp::auth_sentCodeTypeApp(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : length_(TlFetchInt::parse(p))
#undef FAIL
{}

void auth_sentCodeTypeApp::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_sentCodeTypeApp");
    s.store_field("length", length_);
    s.store_class_end();
  }
}

auth_sentCodeTypeSms::auth_sentCodeTypeSms()
  : length_()
{}

auth_sentCodeTypeSms::auth_sentCodeTypeSms(std::int32_t length_)
  : length_(length_)
{}

const std::int32_t auth_sentCodeTypeSms::ID;

auth_sentCodeTypeSms::auth_sentCodeTypeSms(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : length_(TlFetchInt::parse(p))
#undef FAIL
{}

void auth_sentCodeTypeSms::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_sentCodeTypeSms");
    s.store_field("length", length_);
    s.store_class_end();
  }
}

auth_sentCodeTypeCall::auth_sentCodeTypeCall()
  : length_()
{}

auth_sentCodeTypeCall::auth_sentCodeTypeCall(std::int32_t length_)
  : length_(length_)
{}

const std::int32_t auth_sentCodeTypeCall::ID;

auth_sentCodeTypeCall::auth_sentCodeTypeCall(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : length_(TlFetchInt::parse(p))
#undef FAIL
{}

void auth_sentCodeTypeCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_sentCodeTypeCall");
    s.store_field("length", length_);
    s.store_class_end();
  }
}

auth_sentCodeTypeFlashCall::auth_sentCodeTypeFlashCall()
  : pattern_()
{}

auth_sentCodeTypeFlashCall::auth_sentCodeTypeFlashCall(std::string const &pattern_)
  : pattern_(pattern_)
{}

const std::int32_t auth_sentCodeTypeFlashCall::ID;

auth_sentCodeTypeFlashCall::auth_sentCodeTypeFlashCall(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : pattern_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void auth_sentCodeTypeFlashCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_sentCodeTypeFlashCall");
    s.store_field("pattern", pattern_);
    s.store_class_end();
  }
}

channels_adminLogResults::channels_adminLogResults()
  : events_()
  , chats_()
  , users_()
{}

channels_adminLogResults::channels_adminLogResults(std::vector<object_ptr<channelAdminLogEvent>> &&events_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : events_(std::move(events_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t channels_adminLogResults::ID;

channels_adminLogResults::channels_adminLogResults(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : events_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<channelAdminLogEvent>, 995769920>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void channels_adminLogResults::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_adminLogResults");
    { const std::vector<object_ptr<channelAdminLogEvent>> &v = events_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("events", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

channels_channelParticipant::channels_channelParticipant()
  : participant_()
  , users_()
{}

channels_channelParticipant::channels_channelParticipant(object_ptr<ChannelParticipant> &&participant_, std::vector<object_ptr<User>> &&users_)
  : participant_(std::move(participant_))
  , users_(std::move(users_))
{}

const std::int32_t channels_channelParticipant::ID;

channels_channelParticipant::channels_channelParticipant(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : participant_(TlFetchObject<ChannelParticipant>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void channels_channelParticipant::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_channelParticipant");
    if (participant_ == nullptr) { s.store_field("participant", "null"); } else { participant_->store(s, "participant"); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<channels_ChannelParticipants> channels_ChannelParticipants::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case channels_channelParticipants::ID:
      return channels_channelParticipants::fetch(p);
    case channels_channelParticipantsNotModified::ID:
      return channels_channelParticipantsNotModified::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

channels_channelParticipants::channels_channelParticipants()
  : count_()
  , participants_()
  , users_()
{}

channels_channelParticipants::channels_channelParticipants(std::int32_t count_, std::vector<object_ptr<ChannelParticipant>> &&participants_, std::vector<object_ptr<User>> &&users_)
  : count_(count_)
  , participants_(std::move(participants_))
  , users_(std::move(users_))
{}

const std::int32_t channels_channelParticipants::ID;

channels_channelParticipants::channels_channelParticipants(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
  , participants_(TlFetchBoxed<TlFetchVector<TlFetchObject<ChannelParticipant>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void channels_channelParticipants::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_channelParticipants");
    s.store_field("count", count_);
    { const std::vector<object_ptr<ChannelParticipant>> &v = participants_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("participants", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

channels_channelParticipantsNotModified::channels_channelParticipantsNotModified() {
}

const std::int32_t channels_channelParticipantsNotModified::ID;

channels_channelParticipantsNotModified::channels_channelParticipantsNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void channels_channelParticipantsNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_channelParticipantsNotModified");
    s.store_class_end();
  }
}

object_ptr<contacts_Blocked> contacts_Blocked::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case contacts_blocked::ID:
      return contacts_blocked::fetch(p);
    case contacts_blockedSlice::ID:
      return contacts_blockedSlice::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

contacts_blocked::contacts_blocked()
  : blocked_()
  , users_()
{}

contacts_blocked::contacts_blocked(std::vector<object_ptr<contactBlocked>> &&blocked_, std::vector<object_ptr<User>> &&users_)
  : blocked_(std::move(blocked_))
  , users_(std::move(users_))
{}

const std::int32_t contacts_blocked::ID;

contacts_blocked::contacts_blocked(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : blocked_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<contactBlocked>, 1444661369>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void contacts_blocked::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_blocked");
    { const std::vector<object_ptr<contactBlocked>> &v = blocked_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("blocked", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

contacts_blockedSlice::contacts_blockedSlice()
  : count_()
  , blocked_()
  , users_()
{}

contacts_blockedSlice::contacts_blockedSlice(std::int32_t count_, std::vector<object_ptr<contactBlocked>> &&blocked_, std::vector<object_ptr<User>> &&users_)
  : count_(count_)
  , blocked_(std::move(blocked_))
  , users_(std::move(users_))
{}

const std::int32_t contacts_blockedSlice::ID;

contacts_blockedSlice::contacts_blockedSlice(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
  , blocked_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<contactBlocked>, 1444661369>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void contacts_blockedSlice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_blockedSlice");
    s.store_field("count", count_);
    { const std::vector<object_ptr<contactBlocked>> &v = blocked_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("blocked", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<contacts_Contacts> contacts_Contacts::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case contacts_contactsNotModified::ID:
      return contacts_contactsNotModified::fetch(p);
    case contacts_contacts::ID:
      return contacts_contacts::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

contacts_contactsNotModified::contacts_contactsNotModified() {
}

const std::int32_t contacts_contactsNotModified::ID;

contacts_contactsNotModified::contacts_contactsNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void contacts_contactsNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_contactsNotModified");
    s.store_class_end();
  }
}

contacts_contacts::contacts_contacts()
  : contacts_()
  , saved_count_()
  , users_()
{}

contacts_contacts::contacts_contacts(std::vector<object_ptr<contact>> &&contacts_, std::int32_t saved_count_, std::vector<object_ptr<User>> &&users_)
  : contacts_(std::move(contacts_))
  , saved_count_(saved_count_)
  , users_(std::move(users_))
{}

const std::int32_t contacts_contacts::ID;

contacts_contacts::contacts_contacts(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : contacts_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<contact>, -116274796>>, 481674261>::parse(p))
  , saved_count_(TlFetchInt::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void contacts_contacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_contacts");
    { const std::vector<object_ptr<contact>> &v = contacts_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("contacts", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("saved_count", saved_count_);
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

contacts_found::contacts_found()
  : my_results_()
  , results_()
  , chats_()
  , users_()
{}

contacts_found::contacts_found(std::vector<object_ptr<Peer>> &&my_results_, std::vector<object_ptr<Peer>> &&results_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : my_results_(std::move(my_results_))
  , results_(std::move(results_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t contacts_found::ID;

contacts_found::contacts_found(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : my_results_(TlFetchBoxed<TlFetchVector<TlFetchObject<Peer>>, 481674261>::parse(p))
  , results_(TlFetchBoxed<TlFetchVector<TlFetchObject<Peer>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void contacts_found::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_found");
    { const std::vector<object_ptr<Peer>> &v = my_results_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("my_results", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Peer>> &v = results_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("results", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

contacts_importedContacts::contacts_importedContacts()
  : imported_()
  , popular_invites_()
  , retry_contacts_()
  , users_()
{}

contacts_importedContacts::contacts_importedContacts(std::vector<object_ptr<importedContact>> &&imported_, std::vector<object_ptr<popularContact>> &&popular_invites_, std::vector<std::int64_t> &&retry_contacts_, std::vector<object_ptr<User>> &&users_)
  : imported_(std::move(imported_))
  , popular_invites_(std::move(popular_invites_))
  , retry_contacts_(std::move(retry_contacts_))
  , users_(std::move(users_))
{}

const std::int32_t contacts_importedContacts::ID;

contacts_importedContacts::contacts_importedContacts(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : imported_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<importedContact>, -805141448>>, 481674261>::parse(p))
  , popular_invites_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<popularContact>, 1558266229>>, 481674261>::parse(p))
  , retry_contacts_(TlFetchBoxed<TlFetchVector<TlFetchLong>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void contacts_importedContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_importedContacts");
    { const std::vector<object_ptr<importedContact>> &v = imported_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("imported", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<popularContact>> &v = popular_invites_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("popular_invites", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<std::int64_t> &v = retry_contacts_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("retry_contacts", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

contacts_link::contacts_link()
  : my_link_()
  , foreign_link_()
  , user_()
{}

contacts_link::contacts_link(object_ptr<ContactLink> &&my_link_, object_ptr<ContactLink> &&foreign_link_, object_ptr<User> &&user_)
  : my_link_(std::move(my_link_))
  , foreign_link_(std::move(foreign_link_))
  , user_(std::move(user_))
{}

const std::int32_t contacts_link::ID;

contacts_link::contacts_link(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : my_link_(TlFetchObject<ContactLink>::parse(p))
  , foreign_link_(TlFetchObject<ContactLink>::parse(p))
  , user_(TlFetchObject<User>::parse(p))
#undef FAIL
{}

void contacts_link::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_link");
    if (my_link_ == nullptr) { s.store_field("my_link", "null"); } else { my_link_->store(s, "my_link"); }
    if (foreign_link_ == nullptr) { s.store_field("foreign_link", "null"); } else { foreign_link_->store(s, "foreign_link"); }
    if (user_ == nullptr) { s.store_field("user", "null"); } else { user_->store(s, "user"); }
    s.store_class_end();
  }
}

contacts_resolvedPeer::contacts_resolvedPeer()
  : peer_()
  , chats_()
  , users_()
{}

contacts_resolvedPeer::contacts_resolvedPeer(object_ptr<Peer> &&peer_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : peer_(std::move(peer_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t contacts_resolvedPeer::ID;

contacts_resolvedPeer::contacts_resolvedPeer(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : peer_(TlFetchObject<Peer>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void contacts_resolvedPeer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_resolvedPeer");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<contacts_TopPeers> contacts_TopPeers::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case contacts_topPeersNotModified::ID:
      return contacts_topPeersNotModified::fetch(p);
    case contacts_topPeers::ID:
      return contacts_topPeers::fetch(p);
    case contacts_topPeersDisabled::ID:
      return contacts_topPeersDisabled::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

contacts_topPeersNotModified::contacts_topPeersNotModified() {
}

const std::int32_t contacts_topPeersNotModified::ID;

contacts_topPeersNotModified::contacts_topPeersNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void contacts_topPeersNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_topPeersNotModified");
    s.store_class_end();
  }
}

contacts_topPeers::contacts_topPeers()
  : categories_()
  , chats_()
  , users_()
{}

contacts_topPeers::contacts_topPeers(std::vector<object_ptr<topPeerCategoryPeers>> &&categories_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : categories_(std::move(categories_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t contacts_topPeers::ID;

contacts_topPeers::contacts_topPeers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : categories_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<topPeerCategoryPeers>, -75283823>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void contacts_topPeers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_topPeers");
    { const std::vector<object_ptr<topPeerCategoryPeers>> &v = categories_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("categories", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

contacts_topPeersDisabled::contacts_topPeersDisabled() {
}

const std::int32_t contacts_topPeersDisabled::ID;

contacts_topPeersDisabled::contacts_topPeersDisabled(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void contacts_topPeersDisabled::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_topPeersDisabled");
    s.store_class_end();
  }
}

object_ptr<help_AppUpdate> help_AppUpdate::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case help_appUpdate::ID:
      return help_appUpdate::fetch(p);
    case help_noAppUpdate::ID:
      return help_noAppUpdate::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

help_appUpdate::help_appUpdate()
  : flags_()
  , popup_()
  , id_()
  , version_()
  , text_()
  , entities_()
  , document_()
  , url_()
{}

help_appUpdate::help_appUpdate(std::int32_t flags_, bool popup_, std::int32_t id_, std::string const &version_, std::string const &text_, std::vector<object_ptr<MessageEntity>> &&entities_, object_ptr<Document> &&document_, std::string const &url_)
  : flags_(flags_)
  , popup_(popup_)
  , id_(id_)
  , version_(version_)
  , text_(text_)
  , entities_(std::move(entities_))
  , document_(std::move(document_))
  , url_(url_)
{}

const std::int32_t help_appUpdate::ID;

object_ptr<help_appUpdate> help_appUpdate::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<help_appUpdate> res = make_tl_object<help_appUpdate>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->popup_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchInt::parse(p);
  res->version_ = TlFetchString<std::string>::parse(p);
  res->text_ = TlFetchString<std::string>::parse(p);
  res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p);
  if (var0 & 2) { res->document_ = TlFetchObject<Document>::parse(p); }
  if (var0 & 4) { res->url_ = TlFetchString<std::string>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void help_appUpdate::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_appUpdate");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("id", id_);
    s.store_field("version", version_);
    s.store_field("text", text_);
    { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (var0 & 2) { if (document_ == nullptr) { s.store_field("document", "null"); } else { document_->store(s, "document"); } }
    if (var0 & 4) { s.store_field("url", url_); }
    s.store_class_end();
  }
}

help_noAppUpdate::help_noAppUpdate() {
}

const std::int32_t help_noAppUpdate::ID;

help_noAppUpdate::help_noAppUpdate(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void help_noAppUpdate::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_noAppUpdate");
    s.store_class_end();
  }
}

help_configSimple::help_configSimple()
  : date_()
  , expires_()
  , rules_()
{}

help_configSimple::help_configSimple(std::int32_t date_, std::int32_t expires_, std::vector<object_ptr<accessPointRule>> &&rules_)
  : date_(date_)
  , expires_(expires_)
  , rules_(std::move(rules_))
{}

const std::int32_t help_configSimple::ID;

help_configSimple::help_configSimple(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : date_(TlFetchInt::parse(p))
  , expires_(TlFetchInt::parse(p))
  , rules_(TlFetchVector<TlFetchBoxed<TlFetchObject<accessPointRule>, 1182381663>>::parse(p))
#undef FAIL
{}

void help_configSimple::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_configSimple");
    s.store_field("date", date_);
    s.store_field("expires", expires_);
    { const std::vector<object_ptr<accessPointRule>> &v = rules_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("rules", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<help_DeepLinkInfo> help_DeepLinkInfo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case help_deepLinkInfoEmpty::ID:
      return help_deepLinkInfoEmpty::fetch(p);
    case help_deepLinkInfo::ID:
      return help_deepLinkInfo::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

help_deepLinkInfoEmpty::help_deepLinkInfoEmpty() {
}

const std::int32_t help_deepLinkInfoEmpty::ID;

help_deepLinkInfoEmpty::help_deepLinkInfoEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void help_deepLinkInfoEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_deepLinkInfoEmpty");
    s.store_class_end();
  }
}

help_deepLinkInfo::help_deepLinkInfo()
  : flags_()
  , update_app_()
  , message_()
  , entities_()
{}

help_deepLinkInfo::help_deepLinkInfo(std::int32_t flags_, bool update_app_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , update_app_(update_app_)
  , message_(message_)
  , entities_(std::move(entities_))
{}

const std::int32_t help_deepLinkInfo::ID;

object_ptr<help_deepLinkInfo> help_deepLinkInfo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<help_deepLinkInfo> res = make_tl_object<help_deepLinkInfo>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->update_app_ = TlFetchTrue::parse(p); }
  res->message_ = TlFetchString<std::string>::parse(p);
  if (var0 & 2) { res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void help_deepLinkInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_deepLinkInfo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("message", message_);
    if (var0 & 2) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

help_inviteText::help_inviteText()
  : message_()
{}

help_inviteText::help_inviteText(std::string const &message_)
  : message_(message_)
{}

const std::int32_t help_inviteText::ID;

help_inviteText::help_inviteText(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : message_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void help_inviteText::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_inviteText");
    s.store_field("message", message_);
    s.store_class_end();
  }
}

object_ptr<help_PassportConfig> help_PassportConfig::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case help_passportConfigNotModified::ID:
      return help_passportConfigNotModified::fetch(p);
    case help_passportConfig::ID:
      return help_passportConfig::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

help_passportConfigNotModified::help_passportConfigNotModified() {
}

const std::int32_t help_passportConfigNotModified::ID;

help_passportConfigNotModified::help_passportConfigNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void help_passportConfigNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_passportConfigNotModified");
    s.store_class_end();
  }
}

help_passportConfig::help_passportConfig()
  : hash_()
  , countries_langs_()
{}

help_passportConfig::help_passportConfig(std::int32_t hash_, object_ptr<dataJSON> &&countries_langs_)
  : hash_(hash_)
  , countries_langs_(std::move(countries_langs_))
{}

const std::int32_t help_passportConfig::ID;

help_passportConfig::help_passportConfig(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchInt::parse(p))
  , countries_langs_(TlFetchBoxed<TlFetchObject<dataJSON>, 2104790276>::parse(p))
#undef FAIL
{}

void help_passportConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_passportConfig");
    s.store_field("hash", hash_);
    if (countries_langs_ == nullptr) { s.store_field("countries_langs", "null"); } else { countries_langs_->store(s, "countries_langs"); }
    s.store_class_end();
  }
}

object_ptr<help_ProxyData> help_ProxyData::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case help_proxyDataEmpty::ID:
      return help_proxyDataEmpty::fetch(p);
    case help_proxyDataPromo::ID:
      return help_proxyDataPromo::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

help_proxyDataEmpty::help_proxyDataEmpty()
  : expires_()
{}

help_proxyDataEmpty::help_proxyDataEmpty(std::int32_t expires_)
  : expires_(expires_)
{}

const std::int32_t help_proxyDataEmpty::ID;

help_proxyDataEmpty::help_proxyDataEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : expires_(TlFetchInt::parse(p))
#undef FAIL
{}

void help_proxyDataEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_proxyDataEmpty");
    s.store_field("expires", expires_);
    s.store_class_end();
  }
}

help_proxyDataPromo::help_proxyDataPromo()
  : expires_()
  , peer_()
  , chats_()
  , users_()
{}

help_proxyDataPromo::help_proxyDataPromo(std::int32_t expires_, object_ptr<Peer> &&peer_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : expires_(expires_)
  , peer_(std::move(peer_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t help_proxyDataPromo::ID;

help_proxyDataPromo::help_proxyDataPromo(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : expires_(TlFetchInt::parse(p))
  , peer_(TlFetchObject<Peer>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void help_proxyDataPromo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_proxyDataPromo");
    s.store_field("expires", expires_);
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

help_recentMeUrls::help_recentMeUrls()
  : urls_()
  , chats_()
  , users_()
{}

help_recentMeUrls::help_recentMeUrls(std::vector<object_ptr<RecentMeUrl>> &&urls_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : urls_(std::move(urls_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t help_recentMeUrls::ID;

help_recentMeUrls::help_recentMeUrls(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : urls_(TlFetchBoxed<TlFetchVector<TlFetchObject<RecentMeUrl>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void help_recentMeUrls::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_recentMeUrls");
    { const std::vector<object_ptr<RecentMeUrl>> &v = urls_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("urls", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

help_support::help_support()
  : phone_number_()
  , user_()
{}

help_support::help_support(std::string const &phone_number_, object_ptr<User> &&user_)
  : phone_number_(phone_number_)
  , user_(std::move(user_))
{}

const std::int32_t help_support::ID;

help_support::help_support(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : phone_number_(TlFetchString<std::string>::parse(p))
  , user_(TlFetchObject<User>::parse(p))
#undef FAIL
{}

void help_support::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_support");
    s.store_field("phone_number", phone_number_);
    if (user_ == nullptr) { s.store_field("user", "null"); } else { user_->store(s, "user"); }
    s.store_class_end();
  }
}

help_termsOfService::help_termsOfService()
  : flags_()
  , popup_()
  , id_()
  , text_()
  , entities_()
  , min_age_confirm_()
{}

help_termsOfService::help_termsOfService(std::int32_t flags_, bool popup_, object_ptr<dataJSON> &&id_, std::string const &text_, std::vector<object_ptr<MessageEntity>> &&entities_, std::int32_t min_age_confirm_)
  : flags_(flags_)
  , popup_(popup_)
  , id_(std::move(id_))
  , text_(text_)
  , entities_(std::move(entities_))
  , min_age_confirm_(min_age_confirm_)
{}

const std::int32_t help_termsOfService::ID;

object_ptr<help_termsOfService> help_termsOfService::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<help_termsOfService> res = make_tl_object<help_termsOfService>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->popup_ = TlFetchTrue::parse(p); }
  res->id_ = TlFetchBoxed<TlFetchObject<dataJSON>, 2104790276>::parse(p);
  res->text_ = TlFetchString<std::string>::parse(p);
  res->entities_ = TlFetchBoxed<TlFetchVector<TlFetchObject<MessageEntity>>, 481674261>::parse(p);
  if (var0 & 2) { res->min_age_confirm_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void help_termsOfService::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_termsOfService");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_field("text", text_);
    { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (var0 & 2) { s.store_field("min_age_confirm", min_age_confirm_); }
    s.store_class_end();
  }
}

object_ptr<help_TermsOfServiceUpdate> help_TermsOfServiceUpdate::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case help_termsOfServiceUpdateEmpty::ID:
      return help_termsOfServiceUpdateEmpty::fetch(p);
    case help_termsOfServiceUpdate::ID:
      return help_termsOfServiceUpdate::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

help_termsOfServiceUpdateEmpty::help_termsOfServiceUpdateEmpty()
  : expires_()
{}

help_termsOfServiceUpdateEmpty::help_termsOfServiceUpdateEmpty(std::int32_t expires_)
  : expires_(expires_)
{}

const std::int32_t help_termsOfServiceUpdateEmpty::ID;

help_termsOfServiceUpdateEmpty::help_termsOfServiceUpdateEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : expires_(TlFetchInt::parse(p))
#undef FAIL
{}

void help_termsOfServiceUpdateEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_termsOfServiceUpdateEmpty");
    s.store_field("expires", expires_);
    s.store_class_end();
  }
}

help_termsOfServiceUpdate::help_termsOfServiceUpdate()
  : expires_()
  , terms_of_service_()
{}

help_termsOfServiceUpdate::help_termsOfServiceUpdate(std::int32_t expires_, object_ptr<help_termsOfService> &&terms_of_service_)
  : expires_(expires_)
  , terms_of_service_(std::move(terms_of_service_))
{}

const std::int32_t help_termsOfServiceUpdate::ID;

help_termsOfServiceUpdate::help_termsOfServiceUpdate(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : expires_(TlFetchInt::parse(p))
  , terms_of_service_(TlFetchBoxed<TlFetchObject<help_termsOfService>, 2013922064>::parse(p))
#undef FAIL
{}

void help_termsOfServiceUpdate::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_termsOfServiceUpdate");
    s.store_field("expires", expires_);
    if (terms_of_service_ == nullptr) { s.store_field("terms_of_service", "null"); } else { terms_of_service_->store(s, "terms_of_service"); }
    s.store_class_end();
  }
}

messages_affectedHistory::messages_affectedHistory()
  : pts_()
  , pts_count_()
  , offset_()
{}

messages_affectedHistory::messages_affectedHistory(std::int32_t pts_, std::int32_t pts_count_, std::int32_t offset_)
  : pts_(pts_)
  , pts_count_(pts_count_)
  , offset_(offset_)
{}

const std::int32_t messages_affectedHistory::ID;

messages_affectedHistory::messages_affectedHistory(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
  , offset_(TlFetchInt::parse(p))
#undef FAIL
{}

void messages_affectedHistory::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_affectedHistory");
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_field("offset", offset_);
    s.store_class_end();
  }
}

messages_affectedMessages::messages_affectedMessages()
  : pts_()
  , pts_count_()
{}

messages_affectedMessages::messages_affectedMessages(std::int32_t pts_, std::int32_t pts_count_)
  : pts_(pts_)
  , pts_count_(pts_count_)
{}

const std::int32_t messages_affectedMessages::ID;

messages_affectedMessages::messages_affectedMessages(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : pts_(TlFetchInt::parse(p))
  , pts_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void messages_affectedMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_affectedMessages");
    s.store_field("pts", pts_);
    s.store_field("pts_count", pts_count_);
    s.store_class_end();
  }
}

object_ptr<messages_AllStickers> messages_AllStickers::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_allStickersNotModified::ID:
      return messages_allStickersNotModified::fetch(p);
    case messages_allStickers::ID:
      return messages_allStickers::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_allStickersNotModified::messages_allStickersNotModified() {
}

const std::int32_t messages_allStickersNotModified::ID;

messages_allStickersNotModified::messages_allStickersNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messages_allStickersNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_allStickersNotModified");
    s.store_class_end();
  }
}

messages_allStickers::messages_allStickers()
  : hash_()
  , sets_()
{}

messages_allStickers::messages_allStickers(std::int32_t hash_, std::vector<object_ptr<stickerSet>> &&sets_)
  : hash_(hash_)
  , sets_(std::move(sets_))
{}

const std::int32_t messages_allStickers::ID;

messages_allStickers::messages_allStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchInt::parse(p))
  , sets_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<stickerSet>, 1434820921>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_allStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_allStickers");
    s.store_field("hash", hash_);
    { const std::vector<object_ptr<stickerSet>> &v = sets_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("sets", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_archivedStickers::messages_archivedStickers()
  : count_()
  , sets_()
{}

messages_archivedStickers::messages_archivedStickers(std::int32_t count_, std::vector<object_ptr<StickerSetCovered>> &&sets_)
  : count_(count_)
  , sets_(std::move(sets_))
{}

const std::int32_t messages_archivedStickers::ID;

messages_archivedStickers::messages_archivedStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
  , sets_(TlFetchBoxed<TlFetchVector<TlFetchObject<StickerSetCovered>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_archivedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_archivedStickers");
    s.store_field("count", count_);
    { const std::vector<object_ptr<StickerSetCovered>> &v = sets_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("sets", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_botCallbackAnswer::messages_botCallbackAnswer()
  : flags_()
  , alert_()
  , has_url_()
  , native_ui_()
  , message_()
  , url_()
  , cache_time_()
{}

messages_botCallbackAnswer::messages_botCallbackAnswer(std::int32_t flags_, bool alert_, bool has_url_, bool native_ui_, std::string const &message_, std::string const &url_, std::int32_t cache_time_)
  : flags_(flags_)
  , alert_(alert_)
  , has_url_(has_url_)
  , native_ui_(native_ui_)
  , message_(message_)
  , url_(url_)
  , cache_time_(cache_time_)
{}

const std::int32_t messages_botCallbackAnswer::ID;

object_ptr<messages_botCallbackAnswer> messages_botCallbackAnswer::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messages_botCallbackAnswer> res = make_tl_object<messages_botCallbackAnswer>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->alert_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->has_url_ = TlFetchTrue::parse(p); }
  if (var0 & 16) { res->native_ui_ = TlFetchTrue::parse(p); }
  if (var0 & 1) { res->message_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->url_ = TlFetchString<std::string>::parse(p); }
  res->cache_time_ = TlFetchInt::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messages_botCallbackAnswer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_botCallbackAnswer");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    if (var0 & 1) { s.store_field("message", message_); }
    if (var0 & 4) { s.store_field("url", url_); }
    s.store_field("cache_time", cache_time_);
    s.store_class_end();
  }
}

messages_botResults::messages_botResults()
  : flags_()
  , gallery_()
  , query_id_()
  , next_offset_()
  , switch_pm_()
  , results_()
  , cache_time_()
  , users_()
{}

messages_botResults::messages_botResults(std::int32_t flags_, bool gallery_, std::int64_t query_id_, std::string const &next_offset_, object_ptr<inlineBotSwitchPM> &&switch_pm_, std::vector<object_ptr<BotInlineResult>> &&results_, std::int32_t cache_time_, std::vector<object_ptr<User>> &&users_)
  : flags_(flags_)
  , gallery_(gallery_)
  , query_id_(query_id_)
  , next_offset_(next_offset_)
  , switch_pm_(std::move(switch_pm_))
  , results_(std::move(results_))
  , cache_time_(cache_time_)
  , users_(std::move(users_))
{}

const std::int32_t messages_botResults::ID;

object_ptr<messages_botResults> messages_botResults::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messages_botResults> res = make_tl_object<messages_botResults>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->gallery_ = TlFetchTrue::parse(p); }
  res->query_id_ = TlFetchLong::parse(p);
  if (var0 & 2) { res->next_offset_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 4) { res->switch_pm_ = TlFetchBoxed<TlFetchObject<inlineBotSwitchPM>, 1008755359>::parse(p); }
  res->results_ = TlFetchBoxed<TlFetchVector<TlFetchObject<BotInlineResult>>, 481674261>::parse(p);
  res->cache_time_ = TlFetchInt::parse(p);
  res->users_ = TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messages_botResults::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_botResults");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("query_id", query_id_);
    if (var0 & 2) { s.store_field("next_offset", next_offset_); }
    if (var0 & 4) { if (switch_pm_ == nullptr) { s.store_field("switch_pm", "null"); } else { switch_pm_->store(s, "switch_pm"); } }
    { const std::vector<object_ptr<BotInlineResult>> &v = results_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("results", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("cache_time", cache_time_);
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_chatFull::messages_chatFull()
  : full_chat_()
  , chats_()
  , users_()
{}

messages_chatFull::messages_chatFull(object_ptr<ChatFull> &&full_chat_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : full_chat_(std::move(full_chat_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t messages_chatFull::ID;

messages_chatFull::messages_chatFull(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : full_chat_(TlFetchObject<ChatFull>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_chatFull::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_chatFull");
    if (full_chat_ == nullptr) { s.store_field("full_chat", "null"); } else { full_chat_->store(s, "full_chat"); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<messages_Chats> messages_Chats::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_chats::ID:
      return messages_chats::fetch(p);
    case messages_chatsSlice::ID:
      return messages_chatsSlice::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_chats::messages_chats()
  : chats_()
{}

messages_chats::messages_chats(std::vector<object_ptr<Chat>> &&chats_)
  : chats_(std::move(chats_))
{}

const std::int32_t messages_chats::ID;

messages_chats::messages_chats(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_chats::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_chats");
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_chatsSlice::messages_chatsSlice()
  : count_()
  , chats_()
{}

messages_chatsSlice::messages_chatsSlice(std::int32_t count_, std::vector<object_ptr<Chat>> &&chats_)
  : count_(count_)
  , chats_(std::move(chats_))
{}

const std::int32_t messages_chatsSlice::ID;

messages_chatsSlice::messages_chatsSlice(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_chatsSlice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_chatsSlice");
    s.store_field("count", count_);
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<messages_DhConfig> messages_DhConfig::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_dhConfigNotModified::ID:
      return messages_dhConfigNotModified::fetch(p);
    case messages_dhConfig::ID:
      return messages_dhConfig::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_dhConfigNotModified::messages_dhConfigNotModified()
  : random_()
{}

messages_dhConfigNotModified::messages_dhConfigNotModified(BufferSlice &&random_)
  : random_(std::move(random_))
{}

const std::int32_t messages_dhConfigNotModified::ID;

messages_dhConfigNotModified::messages_dhConfigNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : random_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void messages_dhConfigNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_dhConfigNotModified");
    s.store_bytes_field("random", random_);
    s.store_class_end();
  }
}

messages_dhConfig::messages_dhConfig()
  : g_()
  , p_()
  , version_()
  , random_()
{}

messages_dhConfig::messages_dhConfig(std::int32_t g_, BufferSlice &&p_, std::int32_t version_, BufferSlice &&random_)
  : g_(g_)
  , p_(std::move(p_))
  , version_(version_)
  , random_(std::move(random_))
{}

const std::int32_t messages_dhConfig::ID;

messages_dhConfig::messages_dhConfig(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : g_(TlFetchInt::parse(p))
  , p_(TlFetchBytes<BufferSlice>::parse(p))
  , version_(TlFetchInt::parse(p))
  , random_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void messages_dhConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_dhConfig");
    s.store_field("g", g_);
    s.store_bytes_field("p", p_);
    s.store_field("version", version_);
    s.store_bytes_field("random", random_);
    s.store_class_end();
  }
}

object_ptr<messages_Dialogs> messages_Dialogs::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_dialogs::ID:
      return messages_dialogs::fetch(p);
    case messages_dialogsSlice::ID:
      return messages_dialogsSlice::fetch(p);
    case messages_dialogsNotModified::ID:
      return messages_dialogsNotModified::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_dialogs::messages_dialogs()
  : dialogs_()
  , messages_()
  , chats_()
  , users_()
{}

messages_dialogs::messages_dialogs(std::vector<object_ptr<dialog>> &&dialogs_, std::vector<object_ptr<Message>> &&messages_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : dialogs_(std::move(dialogs_))
  , messages_(std::move(messages_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t messages_dialogs::ID;

messages_dialogs::messages_dialogs(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : dialogs_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<dialog>, -455150117>>, 481674261>::parse(p))
  , messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_dialogs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_dialogs");
    { const std::vector<object_ptr<dialog>> &v = dialogs_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("dialogs", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Message>> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_dialogsSlice::messages_dialogsSlice()
  : count_()
  , dialogs_()
  , messages_()
  , chats_()
  , users_()
{}

messages_dialogsSlice::messages_dialogsSlice(std::int32_t count_, std::vector<object_ptr<dialog>> &&dialogs_, std::vector<object_ptr<Message>> &&messages_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : count_(count_)
  , dialogs_(std::move(dialogs_))
  , messages_(std::move(messages_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t messages_dialogsSlice::ID;

messages_dialogsSlice::messages_dialogsSlice(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
  , dialogs_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<dialog>, -455150117>>, 481674261>::parse(p))
  , messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_dialogsSlice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_dialogsSlice");
    s.store_field("count", count_);
    { const std::vector<object_ptr<dialog>> &v = dialogs_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("dialogs", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Message>> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_dialogsNotModified::messages_dialogsNotModified()
  : count_()
{}

messages_dialogsNotModified::messages_dialogsNotModified(std::int32_t count_)
  : count_(count_)
{}

const std::int32_t messages_dialogsNotModified::ID;

messages_dialogsNotModified::messages_dialogsNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
#undef FAIL
{}

void messages_dialogsNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_dialogsNotModified");
    s.store_field("count", count_);
    s.store_class_end();
  }
}

object_ptr<messages_FavedStickers> messages_FavedStickers::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_favedStickersNotModified::ID:
      return messages_favedStickersNotModified::fetch(p);
    case messages_favedStickers::ID:
      return messages_favedStickers::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_favedStickersNotModified::messages_favedStickersNotModified() {
}

const std::int32_t messages_favedStickersNotModified::ID;

messages_favedStickersNotModified::messages_favedStickersNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messages_favedStickersNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_favedStickersNotModified");
    s.store_class_end();
  }
}

messages_favedStickers::messages_favedStickers()
  : hash_()
  , packs_()
  , stickers_()
{}

messages_favedStickers::messages_favedStickers(std::int32_t hash_, std::vector<object_ptr<stickerPack>> &&packs_, std::vector<object_ptr<Document>> &&stickers_)
  : hash_(hash_)
  , packs_(std::move(packs_))
  , stickers_(std::move(stickers_))
{}

const std::int32_t messages_favedStickers::ID;

messages_favedStickers::messages_favedStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchInt::parse(p))
  , packs_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<stickerPack>, 313694676>>, 481674261>::parse(p))
  , stickers_(TlFetchBoxed<TlFetchVector<TlFetchObject<Document>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_favedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_favedStickers");
    s.store_field("hash", hash_);
    { const std::vector<object_ptr<stickerPack>> &v = packs_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("packs", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Document>> &v = stickers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("stickers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<messages_FeaturedStickers> messages_FeaturedStickers::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_featuredStickersNotModified::ID:
      return messages_featuredStickersNotModified::fetch(p);
    case messages_featuredStickers::ID:
      return messages_featuredStickers::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_featuredStickersNotModified::messages_featuredStickersNotModified() {
}

const std::int32_t messages_featuredStickersNotModified::ID;

messages_featuredStickersNotModified::messages_featuredStickersNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messages_featuredStickersNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_featuredStickersNotModified");
    s.store_class_end();
  }
}

messages_featuredStickers::messages_featuredStickers()
  : hash_()
  , sets_()
  , unread_()
{}

messages_featuredStickers::messages_featuredStickers(std::int32_t hash_, std::vector<object_ptr<StickerSetCovered>> &&sets_, std::vector<std::int64_t> &&unread_)
  : hash_(hash_)
  , sets_(std::move(sets_))
  , unread_(std::move(unread_))
{}

const std::int32_t messages_featuredStickers::ID;

messages_featuredStickers::messages_featuredStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchInt::parse(p))
  , sets_(TlFetchBoxed<TlFetchVector<TlFetchObject<StickerSetCovered>>, 481674261>::parse(p))
  , unread_(TlFetchBoxed<TlFetchVector<TlFetchLong>, 481674261>::parse(p))
#undef FAIL
{}

void messages_featuredStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_featuredStickers");
    s.store_field("hash", hash_);
    { const std::vector<object_ptr<StickerSetCovered>> &v = sets_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("sets", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<std::int64_t> &v = unread_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("unread", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_foundGifs::messages_foundGifs()
  : next_offset_()
  , results_()
{}

messages_foundGifs::messages_foundGifs(std::int32_t next_offset_, std::vector<object_ptr<FoundGif>> &&results_)
  : next_offset_(next_offset_)
  , results_(std::move(results_))
{}

const std::int32_t messages_foundGifs::ID;

messages_foundGifs::messages_foundGifs(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : next_offset_(TlFetchInt::parse(p))
  , results_(TlFetchBoxed<TlFetchVector<TlFetchObject<FoundGif>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_foundGifs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_foundGifs");
    s.store_field("next_offset", next_offset_);
    { const std::vector<object_ptr<FoundGif>> &v = results_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("results", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<messages_FoundStickerSets> messages_FoundStickerSets::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_foundStickerSetsNotModified::ID:
      return messages_foundStickerSetsNotModified::fetch(p);
    case messages_foundStickerSets::ID:
      return messages_foundStickerSets::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_foundStickerSetsNotModified::messages_foundStickerSetsNotModified() {
}

const std::int32_t messages_foundStickerSetsNotModified::ID;

messages_foundStickerSetsNotModified::messages_foundStickerSetsNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messages_foundStickerSetsNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_foundStickerSetsNotModified");
    s.store_class_end();
  }
}

messages_foundStickerSets::messages_foundStickerSets()
  : hash_()
  , sets_()
{}

messages_foundStickerSets::messages_foundStickerSets(std::int32_t hash_, std::vector<object_ptr<StickerSetCovered>> &&sets_)
  : hash_(hash_)
  , sets_(std::move(sets_))
{}

const std::int32_t messages_foundStickerSets::ID;

messages_foundStickerSets::messages_foundStickerSets(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchInt::parse(p))
  , sets_(TlFetchBoxed<TlFetchVector<TlFetchObject<StickerSetCovered>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_foundStickerSets::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_foundStickerSets");
    s.store_field("hash", hash_);
    { const std::vector<object_ptr<StickerSetCovered>> &v = sets_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("sets", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_highScores::messages_highScores()
  : scores_()
  , users_()
{}

messages_highScores::messages_highScores(std::vector<object_ptr<highScore>> &&scores_, std::vector<object_ptr<User>> &&users_)
  : scores_(std::move(scores_))
  , users_(std::move(users_))
{}

const std::int32_t messages_highScores::ID;

messages_highScores::messages_highScores(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : scores_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<highScore>, 1493171408>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_highScores::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_highScores");
    { const std::vector<object_ptr<highScore>> &v = scores_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("scores", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_messageEditData::messages_messageEditData()
  : flags_()
  , caption_()
{}

messages_messageEditData::messages_messageEditData(std::int32_t flags_, bool caption_)
  : flags_(flags_)
  , caption_(caption_)
{}

const std::int32_t messages_messageEditData::ID;

object_ptr<messages_messageEditData> messages_messageEditData::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messages_messageEditData> res = make_tl_object<messages_messageEditData>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->caption_ = TlFetchTrue::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messages_messageEditData::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_messageEditData");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_class_end();
  }
}

object_ptr<messages_Messages> messages_Messages::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_messages::ID:
      return messages_messages::fetch(p);
    case messages_messagesSlice::ID:
      return messages_messagesSlice::fetch(p);
    case messages_channelMessages::ID:
      return messages_channelMessages::fetch(p);
    case messages_messagesNotModified::ID:
      return messages_messagesNotModified::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_messages::messages_messages()
  : messages_()
  , chats_()
  , users_()
{}

messages_messages::messages_messages(std::vector<object_ptr<Message>> &&messages_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : messages_(std::move(messages_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t messages_messages::ID;

messages_messages::messages_messages(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_messages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_messages");
    { const std::vector<object_ptr<Message>> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_messagesSlice::messages_messagesSlice()
  : count_()
  , messages_()
  , chats_()
  , users_()
{}

messages_messagesSlice::messages_messagesSlice(std::int32_t count_, std::vector<object_ptr<Message>> &&messages_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : count_(count_)
  , messages_(std::move(messages_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t messages_messagesSlice::ID;

messages_messagesSlice::messages_messagesSlice(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
  , messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_messagesSlice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_messagesSlice");
    s.store_field("count", count_);
    { const std::vector<object_ptr<Message>> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_channelMessages::messages_channelMessages()
  : flags_()
  , pts_()
  , count_()
  , messages_()
  , chats_()
  , users_()
{}

messages_channelMessages::messages_channelMessages(std::int32_t flags_, std::int32_t pts_, std::int32_t count_, std::vector<object_ptr<Message>> &&messages_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : flags_(flags_)
  , pts_(pts_)
  , count_(count_)
  , messages_(std::move(messages_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t messages_channelMessages::ID;

object_ptr<messages_channelMessages> messages_channelMessages::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<messages_channelMessages> res = make_tl_object<messages_channelMessages>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->pts_ = TlFetchInt::parse(p);
  res->count_ = TlFetchInt::parse(p);
  res->messages_ = TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p);
  res->chats_ = TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p);
  res->users_ = TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void messages_channelMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_channelMessages");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("pts", pts_);
    s.store_field("count", count_);
    { const std::vector<object_ptr<Message>> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_messagesNotModified::messages_messagesNotModified()
  : count_()
{}

messages_messagesNotModified::messages_messagesNotModified(std::int32_t count_)
  : count_(count_)
{}

const std::int32_t messages_messagesNotModified::ID;

messages_messagesNotModified::messages_messagesNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
#undef FAIL
{}

void messages_messagesNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_messagesNotModified");
    s.store_field("count", count_);
    s.store_class_end();
  }
}

messages_peerDialogs::messages_peerDialogs()
  : dialogs_()
  , messages_()
  , chats_()
  , users_()
  , state_()
{}

messages_peerDialogs::messages_peerDialogs(std::vector<object_ptr<dialog>> &&dialogs_, std::vector<object_ptr<Message>> &&messages_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_, object_ptr<updates_state> &&state_)
  : dialogs_(std::move(dialogs_))
  , messages_(std::move(messages_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
  , state_(std::move(state_))
{}

const std::int32_t messages_peerDialogs::ID;

messages_peerDialogs::messages_peerDialogs(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : dialogs_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<dialog>, -455150117>>, 481674261>::parse(p))
  , messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
  , state_(TlFetchBoxed<TlFetchObject<updates_state>, -1519637954>::parse(p))
#undef FAIL
{}

void messages_peerDialogs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_peerDialogs");
    { const std::vector<object_ptr<dialog>> &v = dialogs_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("dialogs", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Message>> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (state_ == nullptr) { s.store_field("state", "null"); } else { state_->store(s, "state"); }
    s.store_class_end();
  }
}

object_ptr<messages_RecentStickers> messages_RecentStickers::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_recentStickersNotModified::ID:
      return messages_recentStickersNotModified::fetch(p);
    case messages_recentStickers::ID:
      return messages_recentStickers::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_recentStickersNotModified::messages_recentStickersNotModified() {
}

const std::int32_t messages_recentStickersNotModified::ID;

messages_recentStickersNotModified::messages_recentStickersNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messages_recentStickersNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_recentStickersNotModified");
    s.store_class_end();
  }
}

messages_recentStickers::messages_recentStickers()
  : hash_()
  , packs_()
  , stickers_()
  , dates_()
{}

messages_recentStickers::messages_recentStickers(std::int32_t hash_, std::vector<object_ptr<stickerPack>> &&packs_, std::vector<object_ptr<Document>> &&stickers_, std::vector<std::int32_t> &&dates_)
  : hash_(hash_)
  , packs_(std::move(packs_))
  , stickers_(std::move(stickers_))
  , dates_(std::move(dates_))
{}

const std::int32_t messages_recentStickers::ID;

messages_recentStickers::messages_recentStickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchInt::parse(p))
  , packs_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<stickerPack>, 313694676>>, 481674261>::parse(p))
  , stickers_(TlFetchBoxed<TlFetchVector<TlFetchObject<Document>>, 481674261>::parse(p))
  , dates_(TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p))
#undef FAIL
{}

void messages_recentStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_recentStickers");
    s.store_field("hash", hash_);
    { const std::vector<object_ptr<stickerPack>> &v = packs_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("packs", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Document>> &v = stickers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("stickers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<std::int32_t> &v = dates_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("dates", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<messages_SavedGifs> messages_SavedGifs::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_savedGifsNotModified::ID:
      return messages_savedGifsNotModified::fetch(p);
    case messages_savedGifs::ID:
      return messages_savedGifs::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_savedGifsNotModified::messages_savedGifsNotModified() {
}

const std::int32_t messages_savedGifsNotModified::ID;

messages_savedGifsNotModified::messages_savedGifsNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messages_savedGifsNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_savedGifsNotModified");
    s.store_class_end();
  }
}

messages_savedGifs::messages_savedGifs()
  : hash_()
  , gifs_()
{}

messages_savedGifs::messages_savedGifs(std::int32_t hash_, std::vector<object_ptr<Document>> &&gifs_)
  : hash_(hash_)
  , gifs_(std::move(gifs_))
{}

const std::int32_t messages_savedGifs::ID;

messages_savedGifs::messages_savedGifs(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchInt::parse(p))
  , gifs_(TlFetchBoxed<TlFetchVector<TlFetchObject<Document>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_savedGifs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_savedGifs");
    s.store_field("hash", hash_);
    { const std::vector<object_ptr<Document>> &v = gifs_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("gifs", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<messages_SentEncryptedMessage> messages_SentEncryptedMessage::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_sentEncryptedMessage::ID:
      return messages_sentEncryptedMessage::fetch(p);
    case messages_sentEncryptedFile::ID:
      return messages_sentEncryptedFile::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_sentEncryptedMessage::messages_sentEncryptedMessage()
  : date_()
{}

messages_sentEncryptedMessage::messages_sentEncryptedMessage(std::int32_t date_)
  : date_(date_)
{}

const std::int32_t messages_sentEncryptedMessage::ID;

messages_sentEncryptedMessage::messages_sentEncryptedMessage(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : date_(TlFetchInt::parse(p))
#undef FAIL
{}

void messages_sentEncryptedMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sentEncryptedMessage");
    s.store_field("date", date_);
    s.store_class_end();
  }
}

messages_sentEncryptedFile::messages_sentEncryptedFile()
  : date_()
  , file_()
{}

messages_sentEncryptedFile::messages_sentEncryptedFile(std::int32_t date_, object_ptr<EncryptedFile> &&file_)
  : date_(date_)
  , file_(std::move(file_))
{}

const std::int32_t messages_sentEncryptedFile::ID;

messages_sentEncryptedFile::messages_sentEncryptedFile(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : date_(TlFetchInt::parse(p))
  , file_(TlFetchObject<EncryptedFile>::parse(p))
#undef FAIL
{}

void messages_sentEncryptedFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sentEncryptedFile");
    s.store_field("date", date_);
    if (file_ == nullptr) { s.store_field("file", "null"); } else { file_->store(s, "file"); }
    s.store_class_end();
  }
}

messages_stickerSet::messages_stickerSet()
  : set_()
  , packs_()
  , documents_()
{}

messages_stickerSet::messages_stickerSet(object_ptr<stickerSet> &&set_, std::vector<object_ptr<stickerPack>> &&packs_, std::vector<object_ptr<Document>> &&documents_)
  : set_(std::move(set_))
  , packs_(std::move(packs_))
  , documents_(std::move(documents_))
{}

const std::int32_t messages_stickerSet::ID;

messages_stickerSet::messages_stickerSet(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : set_(TlFetchBoxed<TlFetchObject<stickerSet>, 1434820921>::parse(p))
  , packs_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<stickerPack>, 313694676>>, 481674261>::parse(p))
  , documents_(TlFetchBoxed<TlFetchVector<TlFetchObject<Document>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_stickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_stickerSet");
    if (set_ == nullptr) { s.store_field("set", "null"); } else { set_->store(s, "set"); }
    { const std::vector<object_ptr<stickerPack>> &v = packs_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("packs", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Document>> &v = documents_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("documents", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<messages_StickerSetInstallResult> messages_StickerSetInstallResult::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_stickerSetInstallResultSuccess::ID:
      return messages_stickerSetInstallResultSuccess::fetch(p);
    case messages_stickerSetInstallResultArchive::ID:
      return messages_stickerSetInstallResultArchive::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_stickerSetInstallResultSuccess::messages_stickerSetInstallResultSuccess() {
}

const std::int32_t messages_stickerSetInstallResultSuccess::ID;

messages_stickerSetInstallResultSuccess::messages_stickerSetInstallResultSuccess(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messages_stickerSetInstallResultSuccess::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_stickerSetInstallResultSuccess");
    s.store_class_end();
  }
}

messages_stickerSetInstallResultArchive::messages_stickerSetInstallResultArchive()
  : sets_()
{}

messages_stickerSetInstallResultArchive::messages_stickerSetInstallResultArchive(std::vector<object_ptr<StickerSetCovered>> &&sets_)
  : sets_(std::move(sets_))
{}

const std::int32_t messages_stickerSetInstallResultArchive::ID;

messages_stickerSetInstallResultArchive::messages_stickerSetInstallResultArchive(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : sets_(TlFetchBoxed<TlFetchVector<TlFetchObject<StickerSetCovered>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_stickerSetInstallResultArchive::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_stickerSetInstallResultArchive");
    { const std::vector<object_ptr<StickerSetCovered>> &v = sets_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("sets", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<messages_Stickers> messages_Stickers::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case messages_stickersNotModified::ID:
      return messages_stickersNotModified::fetch(p);
    case messages_stickers::ID:
      return messages_stickers::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

messages_stickersNotModified::messages_stickersNotModified() {
}

const std::int32_t messages_stickersNotModified::ID;

messages_stickersNotModified::messages_stickersNotModified(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void messages_stickersNotModified::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_stickersNotModified");
    s.store_class_end();
  }
}

messages_stickers::messages_stickers()
  : hash_()
  , stickers_()
{}

messages_stickers::messages_stickers(std::int32_t hash_, std::vector<object_ptr<Document>> &&stickers_)
  : hash_(hash_)
  , stickers_(std::move(stickers_))
{}

const std::int32_t messages_stickers::ID;

messages_stickers::messages_stickers(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : hash_(TlFetchInt::parse(p))
  , stickers_(TlFetchBoxed<TlFetchVector<TlFetchObject<Document>>, 481674261>::parse(p))
#undef FAIL
{}

void messages_stickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_stickers");
    s.store_field("hash", hash_);
    { const std::vector<object_ptr<Document>> &v = stickers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("stickers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

payments_paymentForm::payments_paymentForm()
  : flags_()
  , can_save_credentials_()
  , password_missing_()
  , bot_id_()
  , invoice_()
  , provider_id_()
  , url_()
  , native_provider_()
  , native_params_()
  , saved_info_()
  , saved_credentials_()
  , users_()
{}

payments_paymentForm::payments_paymentForm(std::int32_t flags_, bool can_save_credentials_, bool password_missing_, std::int32_t bot_id_, object_ptr<invoice> &&invoice_, std::int32_t provider_id_, std::string const &url_, std::string const &native_provider_, object_ptr<dataJSON> &&native_params_, object_ptr<paymentRequestedInfo> &&saved_info_, object_ptr<paymentSavedCredentialsCard> &&saved_credentials_, std::vector<object_ptr<User>> &&users_)
  : flags_(flags_)
  , can_save_credentials_(can_save_credentials_)
  , password_missing_(password_missing_)
  , bot_id_(bot_id_)
  , invoice_(std::move(invoice_))
  , provider_id_(provider_id_)
  , url_(url_)
  , native_provider_(native_provider_)
  , native_params_(std::move(native_params_))
  , saved_info_(std::move(saved_info_))
  , saved_credentials_(std::move(saved_credentials_))
  , users_(std::move(users_))
{}

const std::int32_t payments_paymentForm::ID;

object_ptr<payments_paymentForm> payments_paymentForm::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<payments_paymentForm> res = make_tl_object<payments_paymentForm>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 4) { res->can_save_credentials_ = TlFetchTrue::parse(p); }
  if (var0 & 8) { res->password_missing_ = TlFetchTrue::parse(p); }
  res->bot_id_ = TlFetchInt::parse(p);
  res->invoice_ = TlFetchBoxed<TlFetchObject<invoice>, -1022713000>::parse(p);
  res->provider_id_ = TlFetchInt::parse(p);
  res->url_ = TlFetchString<std::string>::parse(p);
  if (var0 & 16) { res->native_provider_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 16) { res->native_params_ = TlFetchBoxed<TlFetchObject<dataJSON>, 2104790276>::parse(p); }
  if (var0 & 1) { res->saved_info_ = TlFetchBoxed<TlFetchObject<paymentRequestedInfo>, -1868808300>::parse(p); }
  if (var0 & 2) { res->saved_credentials_ = TlFetchBoxed<TlFetchObject<paymentSavedCredentialsCard>, -842892769>::parse(p); }
  res->users_ = TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void payments_paymentForm::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_paymentForm");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    s.store_field("bot_id", bot_id_);
    if (invoice_ == nullptr) { s.store_field("invoice", "null"); } else { invoice_->store(s, "invoice"); }
    s.store_field("provider_id", provider_id_);
    s.store_field("url", url_);
    if (var0 & 16) { s.store_field("native_provider", native_provider_); }
    if (var0 & 16) { if (native_params_ == nullptr) { s.store_field("native_params", "null"); } else { native_params_->store(s, "native_params"); } }
    if (var0 & 1) { if (saved_info_ == nullptr) { s.store_field("saved_info", "null"); } else { saved_info_->store(s, "saved_info"); } }
    if (var0 & 2) { if (saved_credentials_ == nullptr) { s.store_field("saved_credentials", "null"); } else { saved_credentials_->store(s, "saved_credentials"); } }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

payments_paymentReceipt::payments_paymentReceipt()
  : flags_()
  , date_()
  , bot_id_()
  , invoice_()
  , provider_id_()
  , info_()
  , shipping_()
  , currency_()
  , total_amount_()
  , credentials_title_()
  , users_()
{}

payments_paymentReceipt::payments_paymentReceipt(std::int32_t flags_, std::int32_t date_, std::int32_t bot_id_, object_ptr<invoice> &&invoice_, std::int32_t provider_id_, object_ptr<paymentRequestedInfo> &&info_, object_ptr<shippingOption> &&shipping_, std::string const &currency_, std::int64_t total_amount_, std::string const &credentials_title_, std::vector<object_ptr<User>> &&users_)
  : flags_(flags_)
  , date_(date_)
  , bot_id_(bot_id_)
  , invoice_(std::move(invoice_))
  , provider_id_(provider_id_)
  , info_(std::move(info_))
  , shipping_(std::move(shipping_))
  , currency_(currency_)
  , total_amount_(total_amount_)
  , credentials_title_(credentials_title_)
  , users_(std::move(users_))
{}

const std::int32_t payments_paymentReceipt::ID;

object_ptr<payments_paymentReceipt> payments_paymentReceipt::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<payments_paymentReceipt> res = make_tl_object<payments_paymentReceipt>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  res->date_ = TlFetchInt::parse(p);
  res->bot_id_ = TlFetchInt::parse(p);
  res->invoice_ = TlFetchBoxed<TlFetchObject<invoice>, -1022713000>::parse(p);
  res->provider_id_ = TlFetchInt::parse(p);
  if (var0 & 1) { res->info_ = TlFetchBoxed<TlFetchObject<paymentRequestedInfo>, -1868808300>::parse(p); }
  if (var0 & 2) { res->shipping_ = TlFetchBoxed<TlFetchObject<shippingOption>, -1239335713>::parse(p); }
  res->currency_ = TlFetchString<std::string>::parse(p);
  res->total_amount_ = TlFetchLong::parse(p);
  res->credentials_title_ = TlFetchString<std::string>::parse(p);
  res->users_ = TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void payments_paymentReceipt::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_paymentReceipt");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    s.store_field("date", date_);
    s.store_field("bot_id", bot_id_);
    if (invoice_ == nullptr) { s.store_field("invoice", "null"); } else { invoice_->store(s, "invoice"); }
    s.store_field("provider_id", provider_id_);
    if (var0 & 1) { if (info_ == nullptr) { s.store_field("info", "null"); } else { info_->store(s, "info"); } }
    if (var0 & 2) { if (shipping_ == nullptr) { s.store_field("shipping", "null"); } else { shipping_->store(s, "shipping"); } }
    s.store_field("currency", currency_);
    s.store_field("total_amount", total_amount_);
    s.store_field("credentials_title", credentials_title_);
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<payments_PaymentResult> payments_PaymentResult::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case payments_paymentResult::ID:
      return payments_paymentResult::fetch(p);
    case payments_paymentVerficationNeeded::ID:
      return payments_paymentVerficationNeeded::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

payments_paymentResult::payments_paymentResult()
  : updates_()
{}

payments_paymentResult::payments_paymentResult(object_ptr<Updates> &&updates_)
  : updates_(std::move(updates_))
{}

const std::int32_t payments_paymentResult::ID;

payments_paymentResult::payments_paymentResult(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : updates_(TlFetchObject<Updates>::parse(p))
#undef FAIL
{}

void payments_paymentResult::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_paymentResult");
    if (updates_ == nullptr) { s.store_field("updates", "null"); } else { updates_->store(s, "updates"); }
    s.store_class_end();
  }
}

payments_paymentVerficationNeeded::payments_paymentVerficationNeeded()
  : url_()
{}

payments_paymentVerficationNeeded::payments_paymentVerficationNeeded(std::string const &url_)
  : url_(url_)
{}

const std::int32_t payments_paymentVerficationNeeded::ID;

payments_paymentVerficationNeeded::payments_paymentVerficationNeeded(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : url_(TlFetchString<std::string>::parse(p))
#undef FAIL
{}

void payments_paymentVerficationNeeded::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_paymentVerficationNeeded");
    s.store_field("url", url_);
    s.store_class_end();
  }
}

payments_savedInfo::payments_savedInfo()
  : flags_()
  , has_saved_credentials_()
  , saved_info_()
{}

payments_savedInfo::payments_savedInfo(std::int32_t flags_, bool has_saved_credentials_, object_ptr<paymentRequestedInfo> &&saved_info_)
  : flags_(flags_)
  , has_saved_credentials_(has_saved_credentials_)
  , saved_info_(std::move(saved_info_))
{}

const std::int32_t payments_savedInfo::ID;

object_ptr<payments_savedInfo> payments_savedInfo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<payments_savedInfo> res = make_tl_object<payments_savedInfo>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 2) { res->has_saved_credentials_ = TlFetchTrue::parse(p); }
  if (var0 & 1) { res->saved_info_ = TlFetchBoxed<TlFetchObject<paymentRequestedInfo>, -1868808300>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void payments_savedInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_savedInfo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 1) { if (saved_info_ == nullptr) { s.store_field("saved_info", "null"); } else { saved_info_->store(s, "saved_info"); } }
    s.store_class_end();
  }
}

payments_validatedRequestedInfo::payments_validatedRequestedInfo()
  : flags_()
  , id_()
  , shipping_options_()
{}

payments_validatedRequestedInfo::payments_validatedRequestedInfo(std::int32_t flags_, std::string const &id_, std::vector<object_ptr<shippingOption>> &&shipping_options_)
  : flags_(flags_)
  , id_(id_)
  , shipping_options_(std::move(shipping_options_))
{}

const std::int32_t payments_validatedRequestedInfo::ID;

object_ptr<payments_validatedRequestedInfo> payments_validatedRequestedInfo::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<payments_validatedRequestedInfo> res = make_tl_object<payments_validatedRequestedInfo>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->id_ = TlFetchString<std::string>::parse(p); }
  if (var0 & 2) { res->shipping_options_ = TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<shippingOption>, -1239335713>>, 481674261>::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void payments_validatedRequestedInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_validatedRequestedInfo");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("id", id_); }
    if (var0 & 2) { { const std::vector<object_ptr<shippingOption>> &v = shipping_options_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("shipping_options", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

phone_phoneCall::phone_phoneCall()
  : phone_call_()
  , users_()
{}

phone_phoneCall::phone_phoneCall(object_ptr<PhoneCall> &&phone_call_, std::vector<object_ptr<User>> &&users_)
  : phone_call_(std::move(phone_call_))
  , users_(std::move(users_))
{}

const std::int32_t phone_phoneCall::ID;

phone_phoneCall::phone_phoneCall(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : phone_call_(TlFetchObject<PhoneCall>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void phone_phoneCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_phoneCall");
    if (phone_call_ == nullptr) { s.store_field("phone_call", "null"); } else { phone_call_->store(s, "phone_call"); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

photos_photo::photos_photo()
  : photo_()
  , users_()
{}

photos_photo::photos_photo(object_ptr<Photo> &&photo_, std::vector<object_ptr<User>> &&users_)
  : photo_(std::move(photo_))
  , users_(std::move(users_))
{}

const std::int32_t photos_photo::ID;

photos_photo::photos_photo(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : photo_(TlFetchObject<Photo>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void photos_photo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photos_photo");
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<photos_Photos> photos_Photos::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case photos_photos::ID:
      return photos_photos::fetch(p);
    case photos_photosSlice::ID:
      return photos_photosSlice::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

photos_photos::photos_photos()
  : photos_()
  , users_()
{}

photos_photos::photos_photos(std::vector<object_ptr<Photo>> &&photos_, std::vector<object_ptr<User>> &&users_)
  : photos_(std::move(photos_))
  , users_(std::move(users_))
{}

const std::int32_t photos_photos::ID;

photos_photos::photos_photos(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : photos_(TlFetchBoxed<TlFetchVector<TlFetchObject<Photo>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void photos_photos::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photos_photos");
    { const std::vector<object_ptr<Photo>> &v = photos_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("photos", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

photos_photosSlice::photos_photosSlice()
  : count_()
  , photos_()
  , users_()
{}

photos_photosSlice::photos_photosSlice(std::int32_t count_, std::vector<object_ptr<Photo>> &&photos_, std::vector<object_ptr<User>> &&users_)
  : count_(count_)
  , photos_(std::move(photos_))
  , users_(std::move(users_))
{}

const std::int32_t photos_photosSlice::ID;

photos_photosSlice::photos_photosSlice(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : count_(TlFetchInt::parse(p))
  , photos_(TlFetchBoxed<TlFetchVector<TlFetchObject<Photo>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
#undef FAIL
{}

void photos_photosSlice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photos_photosSlice");
    s.store_field("count", count_);
    { const std::vector<object_ptr<Photo>> &v = photos_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("photos", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<storage_FileType> storage_FileType::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case storage_fileUnknown::ID:
      return storage_fileUnknown::fetch(p);
    case storage_filePartial::ID:
      return storage_filePartial::fetch(p);
    case storage_fileJpeg::ID:
      return storage_fileJpeg::fetch(p);
    case storage_fileGif::ID:
      return storage_fileGif::fetch(p);
    case storage_filePng::ID:
      return storage_filePng::fetch(p);
    case storage_filePdf::ID:
      return storage_filePdf::fetch(p);
    case storage_fileMp3::ID:
      return storage_fileMp3::fetch(p);
    case storage_fileMov::ID:
      return storage_fileMov::fetch(p);
    case storage_fileMp4::ID:
      return storage_fileMp4::fetch(p);
    case storage_fileWebp::ID:
      return storage_fileWebp::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

storage_fileUnknown::storage_fileUnknown() {
}

const std::int32_t storage_fileUnknown::ID;

storage_fileUnknown::storage_fileUnknown(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_fileUnknown::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_fileUnknown");
    s.store_class_end();
  }
}

storage_filePartial::storage_filePartial() {
}

const std::int32_t storage_filePartial::ID;

storage_filePartial::storage_filePartial(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_filePartial::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_filePartial");
    s.store_class_end();
  }
}

storage_fileJpeg::storage_fileJpeg() {
}

const std::int32_t storage_fileJpeg::ID;

storage_fileJpeg::storage_fileJpeg(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_fileJpeg::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_fileJpeg");
    s.store_class_end();
  }
}

storage_fileGif::storage_fileGif() {
}

const std::int32_t storage_fileGif::ID;

storage_fileGif::storage_fileGif(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_fileGif::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_fileGif");
    s.store_class_end();
  }
}

storage_filePng::storage_filePng() {
}

const std::int32_t storage_filePng::ID;

storage_filePng::storage_filePng(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_filePng::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_filePng");
    s.store_class_end();
  }
}

storage_filePdf::storage_filePdf() {
}

const std::int32_t storage_filePdf::ID;

storage_filePdf::storage_filePdf(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_filePdf::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_filePdf");
    s.store_class_end();
  }
}

storage_fileMp3::storage_fileMp3() {
}

const std::int32_t storage_fileMp3::ID;

storage_fileMp3::storage_fileMp3(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_fileMp3::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_fileMp3");
    s.store_class_end();
  }
}

storage_fileMov::storage_fileMov() {
}

const std::int32_t storage_fileMov::ID;

storage_fileMov::storage_fileMov(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_fileMov::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_fileMov");
    s.store_class_end();
  }
}

storage_fileMp4::storage_fileMp4() {
}

const std::int32_t storage_fileMp4::ID;

storage_fileMp4::storage_fileMp4(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_fileMp4::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_fileMp4");
    s.store_class_end();
  }
}

storage_fileWebp::storage_fileWebp() {
}

const std::int32_t storage_fileWebp::ID;

storage_fileWebp::storage_fileWebp(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
#undef FAIL
{
  (void)p;
}

void storage_fileWebp::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "storage_fileWebp");
    s.store_class_end();
  }
}

object_ptr<updates_ChannelDifference> updates_ChannelDifference::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case updates_channelDifferenceEmpty::ID:
      return updates_channelDifferenceEmpty::fetch(p);
    case updates_channelDifferenceTooLong::ID:
      return updates_channelDifferenceTooLong::fetch(p);
    case updates_channelDifference::ID:
      return updates_channelDifference::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

updates_channelDifferenceEmpty::updates_channelDifferenceEmpty()
  : flags_()
  , final_()
  , pts_()
  , timeout_()
{}

updates_channelDifferenceEmpty::updates_channelDifferenceEmpty(std::int32_t flags_, bool final_, std::int32_t pts_, std::int32_t timeout_)
  : flags_(flags_)
  , final_(final_)
  , pts_(pts_)
  , timeout_(timeout_)
{}

const std::int32_t updates_channelDifferenceEmpty::ID;

object_ptr<updates_channelDifferenceEmpty> updates_channelDifferenceEmpty::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updates_channelDifferenceEmpty> res = make_tl_object<updates_channelDifferenceEmpty>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->final_ = TlFetchTrue::parse(p); }
  res->pts_ = TlFetchInt::parse(p);
  if (var0 & 2) { res->timeout_ = TlFetchInt::parse(p); }
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updates_channelDifferenceEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_channelDifferenceEmpty");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("pts", pts_);
    if (var0 & 2) { s.store_field("timeout", timeout_); }
    s.store_class_end();
  }
}

updates_channelDifferenceTooLong::updates_channelDifferenceTooLong()
  : flags_()
  , final_()
  , pts_()
  , timeout_()
  , top_message_()
  , read_inbox_max_id_()
  , read_outbox_max_id_()
  , unread_count_()
  , unread_mentions_count_()
  , messages_()
  , chats_()
  , users_()
{}

updates_channelDifferenceTooLong::updates_channelDifferenceTooLong(std::int32_t flags_, bool final_, std::int32_t pts_, std::int32_t timeout_, std::int32_t top_message_, std::int32_t read_inbox_max_id_, std::int32_t read_outbox_max_id_, std::int32_t unread_count_, std::int32_t unread_mentions_count_, std::vector<object_ptr<Message>> &&messages_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : flags_(flags_)
  , final_(final_)
  , pts_(pts_)
  , timeout_(timeout_)
  , top_message_(top_message_)
  , read_inbox_max_id_(read_inbox_max_id_)
  , read_outbox_max_id_(read_outbox_max_id_)
  , unread_count_(unread_count_)
  , unread_mentions_count_(unread_mentions_count_)
  , messages_(std::move(messages_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t updates_channelDifferenceTooLong::ID;

object_ptr<updates_channelDifferenceTooLong> updates_channelDifferenceTooLong::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updates_channelDifferenceTooLong> res = make_tl_object<updates_channelDifferenceTooLong>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->final_ = TlFetchTrue::parse(p); }
  res->pts_ = TlFetchInt::parse(p);
  if (var0 & 2) { res->timeout_ = TlFetchInt::parse(p); }
  res->top_message_ = TlFetchInt::parse(p);
  res->read_inbox_max_id_ = TlFetchInt::parse(p);
  res->read_outbox_max_id_ = TlFetchInt::parse(p);
  res->unread_count_ = TlFetchInt::parse(p);
  res->unread_mentions_count_ = TlFetchInt::parse(p);
  res->messages_ = TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p);
  res->chats_ = TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p);
  res->users_ = TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updates_channelDifferenceTooLong::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_channelDifferenceTooLong");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("pts", pts_);
    if (var0 & 2) { s.store_field("timeout", timeout_); }
    s.store_field("top_message", top_message_);
    s.store_field("read_inbox_max_id", read_inbox_max_id_);
    s.store_field("read_outbox_max_id", read_outbox_max_id_);
    s.store_field("unread_count", unread_count_);
    s.store_field("unread_mentions_count", unread_mentions_count_);
    { const std::vector<object_ptr<Message>> &v = messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

updates_channelDifference::updates_channelDifference()
  : flags_()
  , final_()
  , pts_()
  , timeout_()
  , new_messages_()
  , other_updates_()
  , chats_()
  , users_()
{}

updates_channelDifference::updates_channelDifference(std::int32_t flags_, bool final_, std::int32_t pts_, std::int32_t timeout_, std::vector<object_ptr<Message>> &&new_messages_, std::vector<object_ptr<Update>> &&other_updates_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_)
  : flags_(flags_)
  , final_(final_)
  , pts_(pts_)
  , timeout_(timeout_)
  , new_messages_(std::move(new_messages_))
  , other_updates_(std::move(other_updates_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
{}

const std::int32_t updates_channelDifference::ID;

object_ptr<updates_channelDifference> updates_channelDifference::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  object_ptr<updates_channelDifference> res = make_tl_object<updates_channelDifference>();
  std::int32_t var0;
  if ((var0 = res->flags_ = TlFetchInt::parse(p)) < 0) { FAIL("Variable of type # can't be negative"); }
  if (var0 & 1) { res->final_ = TlFetchTrue::parse(p); }
  res->pts_ = TlFetchInt::parse(p);
  if (var0 & 2) { res->timeout_ = TlFetchInt::parse(p); }
  res->new_messages_ = TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p);
  res->other_updates_ = TlFetchBoxed<TlFetchVector<TlFetchObject<Update>>, 481674261>::parse(p);
  res->chats_ = TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p);
  res->users_ = TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p);
  if (p.get_error()) { FAIL(""); }
  return res;
#undef FAIL
}

void updates_channelDifference::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_channelDifference");
  std::int32_t var0;
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("pts", pts_);
    if (var0 & 2) { s.store_field("timeout", timeout_); }
    { const std::vector<object_ptr<Message>> &v = new_messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("new_messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Update>> &v = other_updates_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("other_updates", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

object_ptr<updates_Difference> updates_Difference::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case updates_differenceEmpty::ID:
      return updates_differenceEmpty::fetch(p);
    case updates_difference::ID:
      return updates_difference::fetch(p);
    case updates_differenceSlice::ID:
      return updates_differenceSlice::fetch(p);
    case updates_differenceTooLong::ID:
      return updates_differenceTooLong::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

updates_differenceEmpty::updates_differenceEmpty()
  : date_()
  , seq_()
{}

updates_differenceEmpty::updates_differenceEmpty(std::int32_t date_, std::int32_t seq_)
  : date_(date_)
  , seq_(seq_)
{}

const std::int32_t updates_differenceEmpty::ID;

updates_differenceEmpty::updates_differenceEmpty(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : date_(TlFetchInt::parse(p))
  , seq_(TlFetchInt::parse(p))
#undef FAIL
{}

void updates_differenceEmpty::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_differenceEmpty");
    s.store_field("date", date_);
    s.store_field("seq", seq_);
    s.store_class_end();
  }
}

updates_difference::updates_difference()
  : new_messages_()
  , new_encrypted_messages_()
  , other_updates_()
  , chats_()
  , users_()
  , state_()
{}

updates_difference::updates_difference(std::vector<object_ptr<Message>> &&new_messages_, std::vector<object_ptr<EncryptedMessage>> &&new_encrypted_messages_, std::vector<object_ptr<Update>> &&other_updates_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_, object_ptr<updates_state> &&state_)
  : new_messages_(std::move(new_messages_))
  , new_encrypted_messages_(std::move(new_encrypted_messages_))
  , other_updates_(std::move(other_updates_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
  , state_(std::move(state_))
{}

const std::int32_t updates_difference::ID;

updates_difference::updates_difference(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : new_messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p))
  , new_encrypted_messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<EncryptedMessage>>, 481674261>::parse(p))
  , other_updates_(TlFetchBoxed<TlFetchVector<TlFetchObject<Update>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
  , state_(TlFetchBoxed<TlFetchObject<updates_state>, -1519637954>::parse(p))
#undef FAIL
{}

void updates_difference::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_difference");
    { const std::vector<object_ptr<Message>> &v = new_messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("new_messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<EncryptedMessage>> &v = new_encrypted_messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("new_encrypted_messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Update>> &v = other_updates_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("other_updates", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (state_ == nullptr) { s.store_field("state", "null"); } else { state_->store(s, "state"); }
    s.store_class_end();
  }
}

updates_differenceSlice::updates_differenceSlice()
  : new_messages_()
  , new_encrypted_messages_()
  , other_updates_()
  , chats_()
  , users_()
  , intermediate_state_()
{}

updates_differenceSlice::updates_differenceSlice(std::vector<object_ptr<Message>> &&new_messages_, std::vector<object_ptr<EncryptedMessage>> &&new_encrypted_messages_, std::vector<object_ptr<Update>> &&other_updates_, std::vector<object_ptr<Chat>> &&chats_, std::vector<object_ptr<User>> &&users_, object_ptr<updates_state> &&intermediate_state_)
  : new_messages_(std::move(new_messages_))
  , new_encrypted_messages_(std::move(new_encrypted_messages_))
  , other_updates_(std::move(other_updates_))
  , chats_(std::move(chats_))
  , users_(std::move(users_))
  , intermediate_state_(std::move(intermediate_state_))
{}

const std::int32_t updates_differenceSlice::ID;

updates_differenceSlice::updates_differenceSlice(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : new_messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<Message>>, 481674261>::parse(p))
  , new_encrypted_messages_(TlFetchBoxed<TlFetchVector<TlFetchObject<EncryptedMessage>>, 481674261>::parse(p))
  , other_updates_(TlFetchBoxed<TlFetchVector<TlFetchObject<Update>>, 481674261>::parse(p))
  , chats_(TlFetchBoxed<TlFetchVector<TlFetchObject<Chat>>, 481674261>::parse(p))
  , users_(TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p))
  , intermediate_state_(TlFetchBoxed<TlFetchObject<updates_state>, -1519637954>::parse(p))
#undef FAIL
{}

void updates_differenceSlice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_differenceSlice");
    { const std::vector<object_ptr<Message>> &v = new_messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("new_messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<EncryptedMessage>> &v = new_encrypted_messages_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("new_encrypted_messages", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Update>> &v = other_updates_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("other_updates", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<Chat>> &v = chats_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("chats", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    { const std::vector<object_ptr<User>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (intermediate_state_ == nullptr) { s.store_field("intermediate_state", "null"); } else { intermediate_state_->store(s, "intermediate_state"); }
    s.store_class_end();
  }
}

updates_differenceTooLong::updates_differenceTooLong()
  : pts_()
{}

updates_differenceTooLong::updates_differenceTooLong(std::int32_t pts_)
  : pts_(pts_)
{}

const std::int32_t updates_differenceTooLong::ID;

updates_differenceTooLong::updates_differenceTooLong(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : pts_(TlFetchInt::parse(p))
#undef FAIL
{}

void updates_differenceTooLong::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_differenceTooLong");
    s.store_field("pts", pts_);
    s.store_class_end();
  }
}

updates_state::updates_state()
  : pts_()
  , qts_()
  , date_()
  , seq_()
  , unread_count_()
{}

updates_state::updates_state(std::int32_t pts_, std::int32_t qts_, std::int32_t date_, std::int32_t seq_, std::int32_t unread_count_)
  : pts_(pts_)
  , qts_(qts_)
  , date_(date_)
  , seq_(seq_)
  , unread_count_(unread_count_)
{}

const std::int32_t updates_state::ID;

updates_state::updates_state(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : pts_(TlFetchInt::parse(p))
  , qts_(TlFetchInt::parse(p))
  , date_(TlFetchInt::parse(p))
  , seq_(TlFetchInt::parse(p))
  , unread_count_(TlFetchInt::parse(p))
#undef FAIL
{}

void updates_state::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_state");
    s.store_field("pts", pts_);
    s.store_field("qts", qts_);
    s.store_field("date", date_);
    s.store_field("seq", seq_);
    s.store_field("unread_count", unread_count_);
    s.store_class_end();
  }
}

object_ptr<upload_CdnFile> upload_CdnFile::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case upload_cdnFileReuploadNeeded::ID:
      return upload_cdnFileReuploadNeeded::fetch(p);
    case upload_cdnFile::ID:
      return upload_cdnFile::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

upload_cdnFileReuploadNeeded::upload_cdnFileReuploadNeeded()
  : request_token_()
{}

upload_cdnFileReuploadNeeded::upload_cdnFileReuploadNeeded(BufferSlice &&request_token_)
  : request_token_(std::move(request_token_))
{}

const std::int32_t upload_cdnFileReuploadNeeded::ID;

upload_cdnFileReuploadNeeded::upload_cdnFileReuploadNeeded(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : request_token_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void upload_cdnFileReuploadNeeded::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_cdnFileReuploadNeeded");
    s.store_bytes_field("request_token", request_token_);
    s.store_class_end();
  }
}

upload_cdnFile::upload_cdnFile()
  : bytes_()
{}

upload_cdnFile::upload_cdnFile(BufferSlice &&bytes_)
  : bytes_(std::move(bytes_))
{}

const std::int32_t upload_cdnFile::ID;

upload_cdnFile::upload_cdnFile(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : bytes_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void upload_cdnFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_cdnFile");
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

object_ptr<upload_File> upload_File::fetch(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return nullptr;
  int constructor = p.fetch_int();
  switch (constructor) {
    case upload_file::ID:
      return upload_file::fetch(p);
    case upload_fileCdnRedirect::ID:
      return upload_fileCdnRedirect::fetch(p);
    default:
      FAIL(PSTRING() << "Unknown constructor found " << format::as_hex(constructor));
  }
#undef FAIL
}

upload_file::upload_file()
  : type_()
  , mtime_()
  , bytes_()
{}

upload_file::upload_file(object_ptr<storage_FileType> &&type_, std::int32_t mtime_, BufferSlice &&bytes_)
  : type_(std::move(type_))
  , mtime_(mtime_)
  , bytes_(std::move(bytes_))
{}

const std::int32_t upload_file::ID;

upload_file::upload_file(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : type_(TlFetchObject<storage_FileType>::parse(p))
  , mtime_(TlFetchInt::parse(p))
  , bytes_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void upload_file::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_file");
    if (type_ == nullptr) { s.store_field("type", "null"); } else { type_->store(s, "type"); }
    s.store_field("mtime", mtime_);
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

upload_fileCdnRedirect::upload_fileCdnRedirect()
  : dc_id_()
  , file_token_()
  , encryption_key_()
  , encryption_iv_()
  , file_hashes_()
{}

upload_fileCdnRedirect::upload_fileCdnRedirect(std::int32_t dc_id_, BufferSlice &&file_token_, BufferSlice &&encryption_key_, BufferSlice &&encryption_iv_, std::vector<object_ptr<fileHash>> &&file_hashes_)
  : dc_id_(dc_id_)
  , file_token_(std::move(file_token_))
  , encryption_key_(std::move(encryption_key_))
  , encryption_iv_(std::move(encryption_iv_))
  , file_hashes_(std::move(file_hashes_))
{}

const std::int32_t upload_fileCdnRedirect::ID;

upload_fileCdnRedirect::upload_fileCdnRedirect(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : dc_id_(TlFetchInt::parse(p))
  , file_token_(TlFetchBytes<BufferSlice>::parse(p))
  , encryption_key_(TlFetchBytes<BufferSlice>::parse(p))
  , encryption_iv_(TlFetchBytes<BufferSlice>::parse(p))
  , file_hashes_(TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<fileHash>, 1648543603>>, 481674261>::parse(p))
#undef FAIL
{}

void upload_fileCdnRedirect::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_fileCdnRedirect");
    s.store_field("dc_id", dc_id_);
    s.store_bytes_field("file_token", file_token_);
    s.store_bytes_field("encryption_key", encryption_key_);
    s.store_bytes_field("encryption_iv", encryption_iv_);
    { const std::vector<object_ptr<fileHash>> &v = file_hashes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("file_hashes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

upload_webFile::upload_webFile()
  : size_()
  , mime_type_()
  , file_type_()
  , mtime_()
  , bytes_()
{}

upload_webFile::upload_webFile(std::int32_t size_, std::string const &mime_type_, object_ptr<storage_FileType> &&file_type_, std::int32_t mtime_, BufferSlice &&bytes_)
  : size_(size_)
  , mime_type_(mime_type_)
  , file_type_(std::move(file_type_))
  , mtime_(mtime_)
  , bytes_(std::move(bytes_))
{}

const std::int32_t upload_webFile::ID;

upload_webFile::upload_webFile(TlBufferParser &p)
#define FAIL(error) p.set_error(error)
  : size_(TlFetchInt::parse(p))
  , mime_type_(TlFetchString<std::string>::parse(p))
  , file_type_(TlFetchObject<storage_FileType>::parse(p))
  , mtime_(TlFetchInt::parse(p))
  , bytes_(TlFetchBytes<BufferSlice>::parse(p))
#undef FAIL
{}

void upload_webFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_webFile");
    s.store_field("size", size_);
    s.store_field("mime_type", mime_type_);
    if (file_type_ == nullptr) { s.store_field("file_type", "null"); } else { file_type_->store(s, "file_type"); }
    s.store_field("mtime", mtime_);
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

account_acceptAuthorization::account_acceptAuthorization()
  : bot_id_()
  , scope_()
  , public_key_()
  , value_hashes_()
  , credentials_()
{}

account_acceptAuthorization::account_acceptAuthorization(std::int32_t bot_id_, std::string const &scope_, std::string const &public_key_, std::vector<object_ptr<secureValueHash>> &&value_hashes_, object_ptr<secureCredentialsEncrypted> &&credentials_)
  : bot_id_(bot_id_)
  , scope_(scope_)
  , public_key_(public_key_)
  , value_hashes_(std::move(value_hashes_))
  , credentials_(std::move(credentials_))
{}

const std::int32_t account_acceptAuthorization::ID;

void account_acceptAuthorization::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-419267436);
  TlStoreBinary::store(bot_id_, s);
  TlStoreString::store(scope_, s);
  TlStoreString::store(public_key_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -316748368>>, 481674261>::store(value_hashes_, s);
  TlStoreBoxed<TlStoreObject, 871426631>::store(credentials_, s);
}

void account_acceptAuthorization::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-419267436);
  TlStoreBinary::store(bot_id_, s);
  TlStoreString::store(scope_, s);
  TlStoreString::store(public_key_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -316748368>>, 481674261>::store(value_hashes_, s);
  TlStoreBoxed<TlStoreObject, 871426631>::store(credentials_, s);
}

void account_acceptAuthorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_acceptAuthorization");
    s.store_field("bot_id", bot_id_);
    s.store_field("scope", scope_);
    s.store_field("public_key", public_key_);
    { const std::vector<object_ptr<secureValueHash>> &v = value_hashes_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("value_hashes", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    if (credentials_ == nullptr) { s.store_field("credentials", "null"); } else { credentials_->store(s, "credentials"); }
    s.store_class_end();
  }
}

account_acceptAuthorization::ReturnType account_acceptAuthorization::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_changePhone::account_changePhone()
  : phone_number_()
  , phone_code_hash_()
  , phone_code_()
{}

account_changePhone::account_changePhone(std::string const &phone_number_, std::string const &phone_code_hash_, std::string const &phone_code_)
  : phone_number_(phone_number_)
  , phone_code_hash_(phone_code_hash_)
  , phone_code_(phone_code_)
{}

const std::int32_t account_changePhone::ID;

void account_changePhone::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1891839707);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
}

void account_changePhone::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1891839707);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
}

void account_changePhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_changePhone");
    s.store_field("phone_number", phone_number_);
    s.store_field("phone_code_hash", phone_code_hash_);
    s.store_field("phone_code", phone_code_);
    s.store_class_end();
  }
}

account_changePhone::ReturnType account_changePhone::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<User>::parse(p);
#undef FAIL
}

account_checkUsername::account_checkUsername()
  : username_()
{}

account_checkUsername::account_checkUsername(std::string const &username_)
  : username_(username_)
{}

const std::int32_t account_checkUsername::ID;

void account_checkUsername::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(655677548);
  TlStoreString::store(username_, s);
}

void account_checkUsername::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(655677548);
  TlStoreString::store(username_, s);
}

void account_checkUsername::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_checkUsername");
    s.store_field("username", username_);
    s.store_class_end();
  }
}

account_checkUsername::ReturnType account_checkUsername::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_confirmPhone::account_confirmPhone()
  : phone_code_hash_()
  , phone_code_()
{}

account_confirmPhone::account_confirmPhone(std::string const &phone_code_hash_, std::string const &phone_code_)
  : phone_code_hash_(phone_code_hash_)
  , phone_code_(phone_code_)
{}

const std::int32_t account_confirmPhone::ID;

void account_confirmPhone::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1596029123);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
}

void account_confirmPhone::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1596029123);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
}

void account_confirmPhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_confirmPhone");
    s.store_field("phone_code_hash", phone_code_hash_);
    s.store_field("phone_code", phone_code_);
    s.store_class_end();
  }
}

account_confirmPhone::ReturnType account_confirmPhone::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_deleteAccount::account_deleteAccount()
  : reason_()
{}

account_deleteAccount::account_deleteAccount(std::string const &reason_)
  : reason_(reason_)
{}

const std::int32_t account_deleteAccount::ID;

void account_deleteAccount::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1099779595);
  TlStoreString::store(reason_, s);
}

void account_deleteAccount::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1099779595);
  TlStoreString::store(reason_, s);
}

void account_deleteAccount::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_deleteAccount");
    s.store_field("reason", reason_);
    s.store_class_end();
  }
}

account_deleteAccount::ReturnType account_deleteAccount::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_deleteSecureValue::account_deleteSecureValue()
  : types_()
{}

account_deleteSecureValue::account_deleteSecureValue(std::vector<object_ptr<SecureValueType>> &&types_)
  : types_(std::move(types_))
{}

const std::int32_t account_deleteSecureValue::ID;

void account_deleteSecureValue::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1199522741);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(types_, s);
}

void account_deleteSecureValue::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1199522741);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(types_, s);
}

void account_deleteSecureValue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_deleteSecureValue");
    { const std::vector<object_ptr<SecureValueType>> &v = types_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("types", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

account_deleteSecureValue::ReturnType account_deleteSecureValue::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_finishTakeoutSession::account_finishTakeoutSession()
  : flags_()
  , success_()
{}

account_finishTakeoutSession::account_finishTakeoutSession(std::int32_t flags_, bool success_)
  : flags_(flags_)
  , success_(success_)
{}

const std::int32_t account_finishTakeoutSession::ID;

void account_finishTakeoutSession::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(489050862);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(success_, s); }
}

void account_finishTakeoutSession::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(489050862);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(success_, s); }
}

void account_finishTakeoutSession::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_finishTakeoutSession");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_class_end();
  }
}

account_finishTakeoutSession::ReturnType account_finishTakeoutSession::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_getAccountTTL::account_getAccountTTL() {
}

const std::int32_t account_getAccountTTL::ID;

void account_getAccountTTL::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(150761757);
}

void account_getAccountTTL::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(150761757);
}

void account_getAccountTTL::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getAccountTTL");
    s.store_class_end();
  }
}

account_getAccountTTL::ReturnType account_getAccountTTL::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<accountDaysTTL>, -1194283041>::parse(p);
#undef FAIL
}

account_getAllSecureValues::account_getAllSecureValues() {
}

const std::int32_t account_getAllSecureValues::ID;

void account_getAllSecureValues::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1299661699);
}

void account_getAllSecureValues::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1299661699);
}

void account_getAllSecureValues::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getAllSecureValues");
    s.store_class_end();
  }
}

account_getAllSecureValues::ReturnType account_getAllSecureValues::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<secureValue>, 411017418>>, 481674261>::parse(p);
#undef FAIL
}

account_getAuthorizationForm::account_getAuthorizationForm()
  : bot_id_()
  , scope_()
  , public_key_()
{}

account_getAuthorizationForm::account_getAuthorizationForm(std::int32_t bot_id_, std::string const &scope_, std::string const &public_key_)
  : bot_id_(bot_id_)
  , scope_(scope_)
  , public_key_(public_key_)
{}

const std::int32_t account_getAuthorizationForm::ID;

void account_getAuthorizationForm::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1200903967);
  TlStoreBinary::store(bot_id_, s);
  TlStoreString::store(scope_, s);
  TlStoreString::store(public_key_, s);
}

void account_getAuthorizationForm::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1200903967);
  TlStoreBinary::store(bot_id_, s);
  TlStoreString::store(scope_, s);
  TlStoreString::store(public_key_, s);
}

void account_getAuthorizationForm::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getAuthorizationForm");
    s.store_field("bot_id", bot_id_);
    s.store_field("scope", scope_);
    s.store_field("public_key", public_key_);
    s.store_class_end();
  }
}

account_getAuthorizationForm::ReturnType account_getAuthorizationForm::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_authorizationForm>, -1389486888>::parse(p);
#undef FAIL
}

account_getAuthorizations::account_getAuthorizations() {
}

const std::int32_t account_getAuthorizations::ID;

void account_getAuthorizations::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-484392616);
}

void account_getAuthorizations::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-484392616);
}

void account_getAuthorizations::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getAuthorizations");
    s.store_class_end();
  }
}

account_getAuthorizations::ReturnType account_getAuthorizations::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_authorizations>, 307276766>::parse(p);
#undef FAIL
}

account_getNotifySettings::account_getNotifySettings()
  : peer_()
{}

account_getNotifySettings::account_getNotifySettings(object_ptr<InputNotifyPeer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t account_getNotifySettings::ID;

void account_getNotifySettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(313765169);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void account_getNotifySettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(313765169);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void account_getNotifySettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getNotifySettings");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

account_getNotifySettings::ReturnType account_getNotifySettings::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<peerNotifySettings>, -1353671392>::parse(p);
#undef FAIL
}

account_getPassword::account_getPassword() {
}

const std::int32_t account_getPassword::ID;

void account_getPassword::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1418342645);
}

void account_getPassword::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1418342645);
}

void account_getPassword::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getPassword");
    s.store_class_end();
  }
}

account_getPassword::ReturnType account_getPassword::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_password>, -1390001672>::parse(p);
#undef FAIL
}

account_getPasswordSettings::account_getPasswordSettings()
  : password_()
{}

account_getPasswordSettings::account_getPasswordSettings(object_ptr<InputCheckPasswordSRP> &&password_)
  : password_(std::move(password_))
{}

const std::int32_t account_getPasswordSettings::ID;

void account_getPasswordSettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1663767815);
  TlStoreBoxedUnknown<TlStoreObject>::store(password_, s);
}

void account_getPasswordSettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1663767815);
  TlStoreBoxedUnknown<TlStoreObject>::store(password_, s);
}

void account_getPasswordSettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getPasswordSettings");
    if (password_ == nullptr) { s.store_field("password", "null"); } else { password_->store(s, "password"); }
    s.store_class_end();
  }
}

account_getPasswordSettings::ReturnType account_getPasswordSettings::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_passwordSettings>, -1705233435>::parse(p);
#undef FAIL
}

account_getPrivacy::account_getPrivacy()
  : key_()
{}

account_getPrivacy::account_getPrivacy(object_ptr<InputPrivacyKey> &&key_)
  : key_(std::move(key_))
{}

const std::int32_t account_getPrivacy::ID;

void account_getPrivacy::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-623130288);
  TlStoreBoxedUnknown<TlStoreObject>::store(key_, s);
}

void account_getPrivacy::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-623130288);
  TlStoreBoxedUnknown<TlStoreObject>::store(key_, s);
}

void account_getPrivacy::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getPrivacy");
    if (key_ == nullptr) { s.store_field("key", "null"); } else { key_->store(s, "key"); }
    s.store_class_end();
  }
}

account_getPrivacy::ReturnType account_getPrivacy::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_privacyRules>, 1430961007>::parse(p);
#undef FAIL
}

account_getSecureValue::account_getSecureValue()
  : types_()
{}

account_getSecureValue::account_getSecureValue(std::vector<object_ptr<SecureValueType>> &&types_)
  : types_(std::move(types_))
{}

const std::int32_t account_getSecureValue::ID;

void account_getSecureValue::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1936088002);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(types_, s);
}

void account_getSecureValue::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1936088002);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(types_, s);
}

void account_getSecureValue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getSecureValue");
    { const std::vector<object_ptr<SecureValueType>> &v = types_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("types", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

account_getSecureValue::ReturnType account_getSecureValue::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<secureValue>, 411017418>>, 481674261>::parse(p);
#undef FAIL
}

account_getTmpPassword::account_getTmpPassword()
  : password_()
  , period_()
{}

account_getTmpPassword::account_getTmpPassword(object_ptr<InputCheckPasswordSRP> &&password_, std::int32_t period_)
  : password_(std::move(password_))
  , period_(period_)
{}

const std::int32_t account_getTmpPassword::ID;

void account_getTmpPassword::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1151208273);
  TlStoreBoxedUnknown<TlStoreObject>::store(password_, s);
  TlStoreBinary::store(period_, s);
}

void account_getTmpPassword::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1151208273);
  TlStoreBoxedUnknown<TlStoreObject>::store(password_, s);
  TlStoreBinary::store(period_, s);
}

void account_getTmpPassword::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getTmpPassword");
    if (password_ == nullptr) { s.store_field("password", "null"); } else { password_->store(s, "password"); }
    s.store_field("period", period_);
    s.store_class_end();
  }
}

account_getTmpPassword::ReturnType account_getTmpPassword::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_tmpPassword>, -614138572>::parse(p);
#undef FAIL
}

account_getWallPapers::account_getWallPapers() {
}

const std::int32_t account_getWallPapers::ID;

void account_getWallPapers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1068696894);
}

void account_getWallPapers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1068696894);
}

void account_getWallPapers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getWallPapers");
    s.store_class_end();
  }
}

account_getWallPapers::ReturnType account_getWallPapers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchObject<WallPaper>>, 481674261>::parse(p);
#undef FAIL
}

account_getWebAuthorizations::account_getWebAuthorizations() {
}

const std::int32_t account_getWebAuthorizations::ID;

void account_getWebAuthorizations::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(405695855);
}

void account_getWebAuthorizations::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(405695855);
}

void account_getWebAuthorizations::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_getWebAuthorizations");
    s.store_class_end();
  }
}

account_getWebAuthorizations::ReturnType account_getWebAuthorizations::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_webAuthorizations>, -313079300>::parse(p);
#undef FAIL
}

account_initTakeoutSession::account_initTakeoutSession()
  : flags_()
  , contacts_()
  , message_users_()
  , message_chats_()
  , message_megagroups_()
  , message_channels_()
  , files_()
  , file_max_size_()
{}

account_initTakeoutSession::account_initTakeoutSession(std::int32_t flags_, bool contacts_, bool message_users_, bool message_chats_, bool message_megagroups_, bool message_channels_, bool files_, std::int32_t file_max_size_)
  : flags_(flags_)
  , contacts_(contacts_)
  , message_users_(message_users_)
  , message_chats_(message_chats_)
  , message_megagroups_(message_megagroups_)
  , message_channels_(message_channels_)
  , files_(files_)
  , file_max_size_(file_max_size_)
{}

const std::int32_t account_initTakeoutSession::ID;

void account_initTakeoutSession::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-262453244);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(contacts_, s); }
  if (var0 & 2) { TlStoreTrue::store(message_users_, s); }
  if (var0 & 4) { TlStoreTrue::store(message_chats_, s); }
  if (var0 & 8) { TlStoreTrue::store(message_megagroups_, s); }
  if (var0 & 16) { TlStoreTrue::store(message_channels_, s); }
  if (var0 & 32) { TlStoreTrue::store(files_, s); }
  if (var0 & 32) { TlStoreBinary::store(file_max_size_, s); }
}

void account_initTakeoutSession::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-262453244);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(contacts_, s); }
  if (var0 & 2) { TlStoreTrue::store(message_users_, s); }
  if (var0 & 4) { TlStoreTrue::store(message_chats_, s); }
  if (var0 & 8) { TlStoreTrue::store(message_megagroups_, s); }
  if (var0 & 16) { TlStoreTrue::store(message_channels_, s); }
  if (var0 & 32) { TlStoreTrue::store(files_, s); }
  if (var0 & 32) { TlStoreBinary::store(file_max_size_, s); }
}

void account_initTakeoutSession::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_initTakeoutSession");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 16) {  }
    if (var0 & 32) {  }
    if (var0 & 32) { s.store_field("file_max_size", file_max_size_); }
    s.store_class_end();
  }
}

account_initTakeoutSession::ReturnType account_initTakeoutSession::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_takeout>, 1304052993>::parse(p);
#undef FAIL
}

account_registerDevice::account_registerDevice()
  : token_type_()
  , token_()
  , app_sandbox_()
  , secret_()
  , other_uids_()
{}

account_registerDevice::account_registerDevice(std::int32_t token_type_, std::string const &token_, bool app_sandbox_, BufferSlice &&secret_, std::vector<std::int32_t> &&other_uids_)
  : token_type_(token_type_)
  , token_(token_)
  , app_sandbox_(app_sandbox_)
  , secret_(std::move(secret_))
  , other_uids_(std::move(other_uids_))
{}

const std::int32_t account_registerDevice::ID;

void account_registerDevice::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1555998096);
  TlStoreBinary::store(token_type_, s);
  TlStoreString::store(token_, s);
  TlStoreBool::store(app_sandbox_, s);
  TlStoreString::store(secret_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(other_uids_, s);
}

void account_registerDevice::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1555998096);
  TlStoreBinary::store(token_type_, s);
  TlStoreString::store(token_, s);
  TlStoreBool::store(app_sandbox_, s);
  TlStoreString::store(secret_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(other_uids_, s);
}

void account_registerDevice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_registerDevice");
    s.store_field("token_type", token_type_);
    s.store_field("token", token_);
    s.store_field("app_sandbox", app_sandbox_);
    s.store_bytes_field("secret", secret_);
    { const std::vector<std::int32_t> &v = other_uids_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("other_uids", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

account_registerDevice::ReturnType account_registerDevice::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_reportPeer::account_reportPeer()
  : peer_()
  , reason_()
{}

account_reportPeer::account_reportPeer(object_ptr<InputPeer> &&peer_, object_ptr<ReportReason> &&reason_)
  : peer_(std::move(peer_))
  , reason_(std::move(reason_))
{}

const std::int32_t account_reportPeer::ID;

void account_reportPeer::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1374118561);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(reason_, s);
}

void account_reportPeer::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1374118561);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(reason_, s);
}

void account_reportPeer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_reportPeer");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (reason_ == nullptr) { s.store_field("reason", "null"); } else { reason_->store(s, "reason"); }
    s.store_class_end();
  }
}

account_reportPeer::ReturnType account_reportPeer::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_resetAuthorization::account_resetAuthorization()
  : hash_()
{}

account_resetAuthorization::account_resetAuthorization(std::int64_t hash_)
  : hash_(hash_)
{}

const std::int32_t account_resetAuthorization::ID;

void account_resetAuthorization::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-545786948);
  TlStoreBinary::store(hash_, s);
}

void account_resetAuthorization::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-545786948);
  TlStoreBinary::store(hash_, s);
}

void account_resetAuthorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_resetAuthorization");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

account_resetAuthorization::ReturnType account_resetAuthorization::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_resetNotifySettings::account_resetNotifySettings() {
}

const std::int32_t account_resetNotifySettings::ID;

void account_resetNotifySettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-612493497);
}

void account_resetNotifySettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-612493497);
}

void account_resetNotifySettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_resetNotifySettings");
    s.store_class_end();
  }
}

account_resetNotifySettings::ReturnType account_resetNotifySettings::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_resetWebAuthorization::account_resetWebAuthorization()
  : hash_()
{}

account_resetWebAuthorization::account_resetWebAuthorization(std::int64_t hash_)
  : hash_(hash_)
{}

const std::int32_t account_resetWebAuthorization::ID;

void account_resetWebAuthorization::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(755087855);
  TlStoreBinary::store(hash_, s);
}

void account_resetWebAuthorization::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(755087855);
  TlStoreBinary::store(hash_, s);
}

void account_resetWebAuthorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_resetWebAuthorization");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

account_resetWebAuthorization::ReturnType account_resetWebAuthorization::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_resetWebAuthorizations::account_resetWebAuthorizations() {
}

const std::int32_t account_resetWebAuthorizations::ID;

void account_resetWebAuthorizations::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1747789204);
}

void account_resetWebAuthorizations::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1747789204);
}

void account_resetWebAuthorizations::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_resetWebAuthorizations");
    s.store_class_end();
  }
}

account_resetWebAuthorizations::ReturnType account_resetWebAuthorizations::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_saveSecureValue::account_saveSecureValue()
  : value_()
  , secure_secret_id_()
{}

account_saveSecureValue::account_saveSecureValue(object_ptr<inputSecureValue> &&value_, std::int64_t secure_secret_id_)
  : value_(std::move(value_))
  , secure_secret_id_(secure_secret_id_)
{}

const std::int32_t account_saveSecureValue::ID;

void account_saveSecureValue::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1986010339);
  TlStoreBoxed<TlStoreObject, -618540889>::store(value_, s);
  TlStoreBinary::store(secure_secret_id_, s);
}

void account_saveSecureValue::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1986010339);
  TlStoreBoxed<TlStoreObject, -618540889>::store(value_, s);
  TlStoreBinary::store(secure_secret_id_, s);
}

void account_saveSecureValue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_saveSecureValue");
    if (value_ == nullptr) { s.store_field("value", "null"); } else { value_->store(s, "value"); }
    s.store_field("secure_secret_id", secure_secret_id_);
    s.store_class_end();
  }
}

account_saveSecureValue::ReturnType account_saveSecureValue::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<secureValue>, 411017418>::parse(p);
#undef FAIL
}

account_sendChangePhoneCode::account_sendChangePhoneCode()
  : flags_()
  , allow_flashcall_()
  , phone_number_()
  , current_number_()
{}

account_sendChangePhoneCode::account_sendChangePhoneCode(std::int32_t flags_, bool allow_flashcall_, std::string const &phone_number_, bool current_number_)
  : flags_(flags_)
  , allow_flashcall_(allow_flashcall_)
  , phone_number_(phone_number_)
  , current_number_(current_number_)
{}

const std::int32_t account_sendChangePhoneCode::ID;

void account_sendChangePhoneCode::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(149257707);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(allow_flashcall_, s); }
  TlStoreString::store(phone_number_, s);
  if (var0 & 1) { TlStoreBool::store(current_number_, s); }
}

void account_sendChangePhoneCode::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(149257707);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(allow_flashcall_, s); }
  TlStoreString::store(phone_number_, s);
  if (var0 & 1) { TlStoreBool::store(current_number_, s); }
}

void account_sendChangePhoneCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_sendChangePhoneCode");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("phone_number", phone_number_);
    if (var0 & 1) { s.store_field("current_number", current_number_); }
    s.store_class_end();
  }
}

account_sendChangePhoneCode::ReturnType account_sendChangePhoneCode::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_sentCode>, 955951967>::parse(p);
#undef FAIL
}

account_sendConfirmPhoneCode::account_sendConfirmPhoneCode()
  : flags_()
  , allow_flashcall_()
  , hash_()
  , current_number_()
{}

account_sendConfirmPhoneCode::account_sendConfirmPhoneCode(std::int32_t flags_, bool allow_flashcall_, std::string const &hash_, bool current_number_)
  : flags_(flags_)
  , allow_flashcall_(allow_flashcall_)
  , hash_(hash_)
  , current_number_(current_number_)
{}

const std::int32_t account_sendConfirmPhoneCode::ID;

void account_sendConfirmPhoneCode::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(353818557);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(allow_flashcall_, s); }
  TlStoreString::store(hash_, s);
  if (var0 & 1) { TlStoreBool::store(current_number_, s); }
}

void account_sendConfirmPhoneCode::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(353818557);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(allow_flashcall_, s); }
  TlStoreString::store(hash_, s);
  if (var0 & 1) { TlStoreBool::store(current_number_, s); }
}

void account_sendConfirmPhoneCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_sendConfirmPhoneCode");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("hash", hash_);
    if (var0 & 1) { s.store_field("current_number", current_number_); }
    s.store_class_end();
  }
}

account_sendConfirmPhoneCode::ReturnType account_sendConfirmPhoneCode::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_sentCode>, 955951967>::parse(p);
#undef FAIL
}

account_sendVerifyEmailCode::account_sendVerifyEmailCode()
  : email_()
{}

account_sendVerifyEmailCode::account_sendVerifyEmailCode(std::string const &email_)
  : email_(email_)
{}

const std::int32_t account_sendVerifyEmailCode::ID;

void account_sendVerifyEmailCode::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1880182943);
  TlStoreString::store(email_, s);
}

void account_sendVerifyEmailCode::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1880182943);
  TlStoreString::store(email_, s);
}

void account_sendVerifyEmailCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_sendVerifyEmailCode");
    s.store_field("email", email_);
    s.store_class_end();
  }
}

account_sendVerifyEmailCode::ReturnType account_sendVerifyEmailCode::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_sentEmailCode>, -2128640689>::parse(p);
#undef FAIL
}

account_sendVerifyPhoneCode::account_sendVerifyPhoneCode()
  : flags_()
  , allow_flashcall_()
  , phone_number_()
  , current_number_()
{}

account_sendVerifyPhoneCode::account_sendVerifyPhoneCode(std::int32_t flags_, bool allow_flashcall_, std::string const &phone_number_, bool current_number_)
  : flags_(flags_)
  , allow_flashcall_(allow_flashcall_)
  , phone_number_(phone_number_)
  , current_number_(current_number_)
{}

const std::int32_t account_sendVerifyPhoneCode::ID;

void account_sendVerifyPhoneCode::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2110553932);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(allow_flashcall_, s); }
  TlStoreString::store(phone_number_, s);
  if (var0 & 1) { TlStoreBool::store(current_number_, s); }
}

void account_sendVerifyPhoneCode::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2110553932);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(allow_flashcall_, s); }
  TlStoreString::store(phone_number_, s);
  if (var0 & 1) { TlStoreBool::store(current_number_, s); }
}

void account_sendVerifyPhoneCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_sendVerifyPhoneCode");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("phone_number", phone_number_);
    if (var0 & 1) { s.store_field("current_number", current_number_); }
    s.store_class_end();
  }
}

account_sendVerifyPhoneCode::ReturnType account_sendVerifyPhoneCode::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_sentCode>, 955951967>::parse(p);
#undef FAIL
}

account_setAccountTTL::account_setAccountTTL()
  : ttl_()
{}

account_setAccountTTL::account_setAccountTTL(object_ptr<accountDaysTTL> &&ttl_)
  : ttl_(std::move(ttl_))
{}

const std::int32_t account_setAccountTTL::ID;

void account_setAccountTTL::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(608323678);
  TlStoreBoxed<TlStoreObject, -1194283041>::store(ttl_, s);
}

void account_setAccountTTL::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(608323678);
  TlStoreBoxed<TlStoreObject, -1194283041>::store(ttl_, s);
}

void account_setAccountTTL::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_setAccountTTL");
    if (ttl_ == nullptr) { s.store_field("ttl", "null"); } else { ttl_->store(s, "ttl"); }
    s.store_class_end();
  }
}

account_setAccountTTL::ReturnType account_setAccountTTL::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_setPrivacy::account_setPrivacy()
  : key_()
  , rules_()
{}

account_setPrivacy::account_setPrivacy(object_ptr<InputPrivacyKey> &&key_, std::vector<object_ptr<InputPrivacyRule>> &&rules_)
  : key_(std::move(key_))
  , rules_(std::move(rules_))
{}

const std::int32_t account_setPrivacy::ID;

void account_setPrivacy::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-906486552);
  TlStoreBoxedUnknown<TlStoreObject>::store(key_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(rules_, s);
}

void account_setPrivacy::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-906486552);
  TlStoreBoxedUnknown<TlStoreObject>::store(key_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(rules_, s);
}

void account_setPrivacy::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_setPrivacy");
    if (key_ == nullptr) { s.store_field("key", "null"); } else { key_->store(s, "key"); }
    { const std::vector<object_ptr<InputPrivacyRule>> &v = rules_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("rules", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

account_setPrivacy::ReturnType account_setPrivacy::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<account_privacyRules>, 1430961007>::parse(p);
#undef FAIL
}

account_unregisterDevice::account_unregisterDevice()
  : token_type_()
  , token_()
  , other_uids_()
{}

account_unregisterDevice::account_unregisterDevice(std::int32_t token_type_, std::string const &token_, std::vector<std::int32_t> &&other_uids_)
  : token_type_(token_type_)
  , token_(token_)
  , other_uids_(std::move(other_uids_))
{}

const std::int32_t account_unregisterDevice::ID;

void account_unregisterDevice::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(813089983);
  TlStoreBinary::store(token_type_, s);
  TlStoreString::store(token_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(other_uids_, s);
}

void account_unregisterDevice::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(813089983);
  TlStoreBinary::store(token_type_, s);
  TlStoreString::store(token_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(other_uids_, s);
}

void account_unregisterDevice::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_unregisterDevice");
    s.store_field("token_type", token_type_);
    s.store_field("token", token_);
    { const std::vector<std::int32_t> &v = other_uids_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("other_uids", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

account_unregisterDevice::ReturnType account_unregisterDevice::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_updateDeviceLocked::account_updateDeviceLocked()
  : period_()
{}

account_updateDeviceLocked::account_updateDeviceLocked(std::int32_t period_)
  : period_(period_)
{}

const std::int32_t account_updateDeviceLocked::ID;

void account_updateDeviceLocked::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(954152242);
  TlStoreBinary::store(period_, s);
}

void account_updateDeviceLocked::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(954152242);
  TlStoreBinary::store(period_, s);
}

void account_updateDeviceLocked::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_updateDeviceLocked");
    s.store_field("period", period_);
    s.store_class_end();
  }
}

account_updateDeviceLocked::ReturnType account_updateDeviceLocked::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_updateNotifySettings::account_updateNotifySettings()
  : peer_()
  , settings_()
{}

account_updateNotifySettings::account_updateNotifySettings(object_ptr<InputNotifyPeer> &&peer_, object_ptr<inputPeerNotifySettings> &&settings_)
  : peer_(std::move(peer_))
  , settings_(std::move(settings_))
{}

const std::int32_t account_updateNotifySettings::ID;

void account_updateNotifySettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2067899501);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxed<TlStoreObject, -1673717362>::store(settings_, s);
}

void account_updateNotifySettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2067899501);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxed<TlStoreObject, -1673717362>::store(settings_, s);
}

void account_updateNotifySettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_updateNotifySettings");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (settings_ == nullptr) { s.store_field("settings", "null"); } else { settings_->store(s, "settings"); }
    s.store_class_end();
  }
}

account_updateNotifySettings::ReturnType account_updateNotifySettings::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_updatePasswordSettings::account_updatePasswordSettings()
  : password_()
  , new_settings_()
{}

account_updatePasswordSettings::account_updatePasswordSettings(object_ptr<InputCheckPasswordSRP> &&password_, object_ptr<account_passwordInputSettings> &&new_settings_)
  : password_(std::move(password_))
  , new_settings_(std::move(new_settings_))
{}

const std::int32_t account_updatePasswordSettings::ID;

void account_updatePasswordSettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1516564433);
  TlStoreBoxedUnknown<TlStoreObject>::store(password_, s);
  TlStoreBoxed<TlStoreObject, -1036572727>::store(new_settings_, s);
}

void account_updatePasswordSettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1516564433);
  TlStoreBoxedUnknown<TlStoreObject>::store(password_, s);
  TlStoreBoxed<TlStoreObject, -1036572727>::store(new_settings_, s);
}

void account_updatePasswordSettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_updatePasswordSettings");
    if (password_ == nullptr) { s.store_field("password", "null"); } else { password_->store(s, "password"); }
    if (new_settings_ == nullptr) { s.store_field("new_settings", "null"); } else { new_settings_->store(s, "new_settings"); }
    s.store_class_end();
  }
}

account_updatePasswordSettings::ReturnType account_updatePasswordSettings::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_updateProfile::account_updateProfile()
  : flags_()
  , first_name_()
  , last_name_()
  , about_()
{}

account_updateProfile::account_updateProfile(std::int32_t flags_, std::string const &first_name_, std::string const &last_name_, std::string const &about_)
  : flags_(flags_)
  , first_name_(first_name_)
  , last_name_(last_name_)
  , about_(about_)
{}

const std::int32_t account_updateProfile::ID;

void account_updateProfile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(2018596725);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreString::store(first_name_, s); }
  if (var0 & 2) { TlStoreString::store(last_name_, s); }
  if (var0 & 4) { TlStoreString::store(about_, s); }
}

void account_updateProfile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(2018596725);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreString::store(first_name_, s); }
  if (var0 & 2) { TlStoreString::store(last_name_, s); }
  if (var0 & 4) { TlStoreString::store(about_, s); }
}

void account_updateProfile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_updateProfile");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) { s.store_field("first_name", first_name_); }
    if (var0 & 2) { s.store_field("last_name", last_name_); }
    if (var0 & 4) { s.store_field("about", about_); }
    s.store_class_end();
  }
}

account_updateProfile::ReturnType account_updateProfile::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<User>::parse(p);
#undef FAIL
}

account_updateStatus::account_updateStatus()
  : offline_()
{}

account_updateStatus::account_updateStatus(bool offline_)
  : offline_(offline_)
{}

const std::int32_t account_updateStatus::ID;

void account_updateStatus::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1713919532);
  TlStoreBool::store(offline_, s);
}

void account_updateStatus::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1713919532);
  TlStoreBool::store(offline_, s);
}

void account_updateStatus::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_updateStatus");
    s.store_field("offline", offline_);
    s.store_class_end();
  }
}

account_updateStatus::ReturnType account_updateStatus::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_updateUsername::account_updateUsername()
  : username_()
{}

account_updateUsername::account_updateUsername(std::string const &username_)
  : username_(username_)
{}

const std::int32_t account_updateUsername::ID;

void account_updateUsername::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1040964988);
  TlStoreString::store(username_, s);
}

void account_updateUsername::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1040964988);
  TlStoreString::store(username_, s);
}

void account_updateUsername::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_updateUsername");
    s.store_field("username", username_);
    s.store_class_end();
  }
}

account_updateUsername::ReturnType account_updateUsername::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<User>::parse(p);
#undef FAIL
}

account_verifyEmail::account_verifyEmail()
  : email_()
  , code_()
{}

account_verifyEmail::account_verifyEmail(std::string const &email_, std::string const &code_)
  : email_(email_)
  , code_(code_)
{}

const std::int32_t account_verifyEmail::ID;

void account_verifyEmail::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-323339813);
  TlStoreString::store(email_, s);
  TlStoreString::store(code_, s);
}

void account_verifyEmail::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-323339813);
  TlStoreString::store(email_, s);
  TlStoreString::store(code_, s);
}

void account_verifyEmail::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_verifyEmail");
    s.store_field("email", email_);
    s.store_field("code", code_);
    s.store_class_end();
  }
}

account_verifyEmail::ReturnType account_verifyEmail::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

account_verifyPhone::account_verifyPhone()
  : phone_number_()
  , phone_code_hash_()
  , phone_code_()
{}

account_verifyPhone::account_verifyPhone(std::string const &phone_number_, std::string const &phone_code_hash_, std::string const &phone_code_)
  : phone_number_(phone_number_)
  , phone_code_hash_(phone_code_hash_)
  , phone_code_(phone_code_)
{}

const std::int32_t account_verifyPhone::ID;

void account_verifyPhone::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1305716726);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
}

void account_verifyPhone::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1305716726);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
}

void account_verifyPhone::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "account_verifyPhone");
    s.store_field("phone_number", phone_number_);
    s.store_field("phone_code_hash", phone_code_hash_);
    s.store_field("phone_code", phone_code_);
    s.store_class_end();
  }
}

account_verifyPhone::ReturnType account_verifyPhone::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

auth_bindTempAuthKey::auth_bindTempAuthKey()
  : perm_auth_key_id_()
  , nonce_()
  , expires_at_()
  , encrypted_message_()
{}

auth_bindTempAuthKey::auth_bindTempAuthKey(std::int64_t perm_auth_key_id_, std::int64_t nonce_, std::int32_t expires_at_, BufferSlice &&encrypted_message_)
  : perm_auth_key_id_(perm_auth_key_id_)
  , nonce_(nonce_)
  , expires_at_(expires_at_)
  , encrypted_message_(std::move(encrypted_message_))
{}

const std::int32_t auth_bindTempAuthKey::ID;

void auth_bindTempAuthKey::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-841733627);
  TlStoreBinary::store(perm_auth_key_id_, s);
  TlStoreBinary::store(nonce_, s);
  TlStoreBinary::store(expires_at_, s);
  TlStoreString::store(encrypted_message_, s);
}

void auth_bindTempAuthKey::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-841733627);
  TlStoreBinary::store(perm_auth_key_id_, s);
  TlStoreBinary::store(nonce_, s);
  TlStoreBinary::store(expires_at_, s);
  TlStoreString::store(encrypted_message_, s);
}

void auth_bindTempAuthKey::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_bindTempAuthKey");
    s.store_field("perm_auth_key_id", perm_auth_key_id_);
    s.store_field("nonce", nonce_);
    s.store_field("expires_at", expires_at_);
    s.store_bytes_field("encrypted_message", encrypted_message_);
    s.store_class_end();
  }
}

auth_bindTempAuthKey::ReturnType auth_bindTempAuthKey::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

auth_cancelCode::auth_cancelCode()
  : phone_number_()
  , phone_code_hash_()
{}

auth_cancelCode::auth_cancelCode(std::string const &phone_number_, std::string const &phone_code_hash_)
  : phone_number_(phone_number_)
  , phone_code_hash_(phone_code_hash_)
{}

const std::int32_t auth_cancelCode::ID;

void auth_cancelCode::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(520357240);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
}

void auth_cancelCode::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(520357240);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
}

void auth_cancelCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_cancelCode");
    s.store_field("phone_number", phone_number_);
    s.store_field("phone_code_hash", phone_code_hash_);
    s.store_class_end();
  }
}

auth_cancelCode::ReturnType auth_cancelCode::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

auth_checkPassword::auth_checkPassword()
  : password_()
{}

auth_checkPassword::auth_checkPassword(object_ptr<InputCheckPasswordSRP> &&password_)
  : password_(std::move(password_))
{}

const std::int32_t auth_checkPassword::ID;

void auth_checkPassword::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-779399914);
  TlStoreBoxedUnknown<TlStoreObject>::store(password_, s);
}

void auth_checkPassword::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-779399914);
  TlStoreBoxedUnknown<TlStoreObject>::store(password_, s);
}

void auth_checkPassword::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_checkPassword");
    if (password_ == nullptr) { s.store_field("password", "null"); } else { password_->store(s, "password"); }
    s.store_class_end();
  }
}

auth_checkPassword::ReturnType auth_checkPassword::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_authorization>, -855308010>::parse(p);
#undef FAIL
}

auth_dropTempAuthKeys::auth_dropTempAuthKeys()
  : except_auth_keys_()
{}

auth_dropTempAuthKeys::auth_dropTempAuthKeys(std::vector<std::int64_t> &&except_auth_keys_)
  : except_auth_keys_(std::move(except_auth_keys_))
{}

const std::int32_t auth_dropTempAuthKeys::ID;

void auth_dropTempAuthKeys::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1907842680);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(except_auth_keys_, s);
}

void auth_dropTempAuthKeys::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1907842680);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(except_auth_keys_, s);
}

void auth_dropTempAuthKeys::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_dropTempAuthKeys");
    { const std::vector<std::int64_t> &v = except_auth_keys_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("except_auth_keys", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

auth_dropTempAuthKeys::ReturnType auth_dropTempAuthKeys::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

auth_exportAuthorization::auth_exportAuthorization()
  : dc_id_()
{}

auth_exportAuthorization::auth_exportAuthorization(std::int32_t dc_id_)
  : dc_id_(dc_id_)
{}

const std::int32_t auth_exportAuthorization::ID;

void auth_exportAuthorization::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-440401971);
  TlStoreBinary::store(dc_id_, s);
}

void auth_exportAuthorization::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-440401971);
  TlStoreBinary::store(dc_id_, s);
}

void auth_exportAuthorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_exportAuthorization");
    s.store_field("dc_id", dc_id_);
    s.store_class_end();
  }
}

auth_exportAuthorization::ReturnType auth_exportAuthorization::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_exportedAuthorization>, -543777747>::parse(p);
#undef FAIL
}

auth_importAuthorization::auth_importAuthorization()
  : id_()
  , bytes_()
{}

auth_importAuthorization::auth_importAuthorization(std::int32_t id_, BufferSlice &&bytes_)
  : id_(id_)
  , bytes_(std::move(bytes_))
{}

const std::int32_t auth_importAuthorization::ID;

void auth_importAuthorization::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-470837741);
  TlStoreBinary::store(id_, s);
  TlStoreString::store(bytes_, s);
}

void auth_importAuthorization::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-470837741);
  TlStoreBinary::store(id_, s);
  TlStoreString::store(bytes_, s);
}

void auth_importAuthorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_importAuthorization");
    s.store_field("id", id_);
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

auth_importAuthorization::ReturnType auth_importAuthorization::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_authorization>, -855308010>::parse(p);
#undef FAIL
}

auth_importBotAuthorization::auth_importBotAuthorization()
  : flags_()
  , api_id_()
  , api_hash_()
  , bot_auth_token_()
{}

auth_importBotAuthorization::auth_importBotAuthorization(std::int32_t flags_, std::int32_t api_id_, std::string const &api_hash_, std::string const &bot_auth_token_)
  : flags_(flags_)
  , api_id_(api_id_)
  , api_hash_(api_hash_)
  , bot_auth_token_(bot_auth_token_)
{}

const std::int32_t auth_importBotAuthorization::ID;

void auth_importBotAuthorization::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1738800940);
  TlStoreBinary::store(flags_, s);
  TlStoreBinary::store(api_id_, s);
  TlStoreString::store(api_hash_, s);
  TlStoreString::store(bot_auth_token_, s);
}

void auth_importBotAuthorization::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1738800940);
  TlStoreBinary::store(flags_, s);
  TlStoreBinary::store(api_id_, s);
  TlStoreString::store(api_hash_, s);
  TlStoreString::store(bot_auth_token_, s);
}

void auth_importBotAuthorization::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_importBotAuthorization");
    s.store_field("flags", flags_);
    s.store_field("api_id", api_id_);
    s.store_field("api_hash", api_hash_);
    s.store_field("bot_auth_token", bot_auth_token_);
    s.store_class_end();
  }
}

auth_importBotAuthorization::ReturnType auth_importBotAuthorization::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_authorization>, -855308010>::parse(p);
#undef FAIL
}

auth_logOut::auth_logOut() {
}

const std::int32_t auth_logOut::ID;

void auth_logOut::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1461180992);
}

void auth_logOut::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1461180992);
}

void auth_logOut::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_logOut");
    s.store_class_end();
  }
}

auth_logOut::ReturnType auth_logOut::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

auth_recoverPassword::auth_recoverPassword()
  : code_()
{}

auth_recoverPassword::auth_recoverPassword(std::string const &code_)
  : code_(code_)
{}

const std::int32_t auth_recoverPassword::ID;

void auth_recoverPassword::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1319464594);
  TlStoreString::store(code_, s);
}

void auth_recoverPassword::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1319464594);
  TlStoreString::store(code_, s);
}

void auth_recoverPassword::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_recoverPassword");
    s.store_field("code", code_);
    s.store_class_end();
  }
}

auth_recoverPassword::ReturnType auth_recoverPassword::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_authorization>, -855308010>::parse(p);
#undef FAIL
}

auth_requestPasswordRecovery::auth_requestPasswordRecovery() {
}

const std::int32_t auth_requestPasswordRecovery::ID;

void auth_requestPasswordRecovery::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-661144474);
}

void auth_requestPasswordRecovery::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-661144474);
}

void auth_requestPasswordRecovery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_requestPasswordRecovery");
    s.store_class_end();
  }
}

auth_requestPasswordRecovery::ReturnType auth_requestPasswordRecovery::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_passwordRecovery>, 326715557>::parse(p);
#undef FAIL
}

auth_resendCode::auth_resendCode()
  : phone_number_()
  , phone_code_hash_()
{}

auth_resendCode::auth_resendCode(std::string const &phone_number_, std::string const &phone_code_hash_)
  : phone_number_(phone_number_)
  , phone_code_hash_(phone_code_hash_)
{}

const std::int32_t auth_resendCode::ID;

void auth_resendCode::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1056025023);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
}

void auth_resendCode::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1056025023);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
}

void auth_resendCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_resendCode");
    s.store_field("phone_number", phone_number_);
    s.store_field("phone_code_hash", phone_code_hash_);
    s.store_class_end();
  }
}

auth_resendCode::ReturnType auth_resendCode::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_sentCode>, 955951967>::parse(p);
#undef FAIL
}

auth_resetAuthorizations::auth_resetAuthorizations() {
}

const std::int32_t auth_resetAuthorizations::ID;

void auth_resetAuthorizations::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1616179942);
}

void auth_resetAuthorizations::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1616179942);
}

void auth_resetAuthorizations::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_resetAuthorizations");
    s.store_class_end();
  }
}

auth_resetAuthorizations::ReturnType auth_resetAuthorizations::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

auth_sendCode::auth_sendCode()
  : flags_()
  , allow_flashcall_()
  , phone_number_()
  , current_number_()
  , api_id_()
  , api_hash_()
{}

auth_sendCode::auth_sendCode(std::int32_t flags_, bool allow_flashcall_, std::string const &phone_number_, bool current_number_, std::int32_t api_id_, std::string const &api_hash_)
  : flags_(flags_)
  , allow_flashcall_(allow_flashcall_)
  , phone_number_(phone_number_)
  , current_number_(current_number_)
  , api_id_(api_id_)
  , api_hash_(api_hash_)
{}

const std::int32_t auth_sendCode::ID;

void auth_sendCode::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2035355412);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(allow_flashcall_, s); }
  TlStoreString::store(phone_number_, s);
  if (var0 & 1) { TlStoreBool::store(current_number_, s); }
  TlStoreBinary::store(api_id_, s);
  TlStoreString::store(api_hash_, s);
}

void auth_sendCode::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2035355412);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(allow_flashcall_, s); }
  TlStoreString::store(phone_number_, s);
  if (var0 & 1) { TlStoreBool::store(current_number_, s); }
  TlStoreBinary::store(api_id_, s);
  TlStoreString::store(api_hash_, s);
}

void auth_sendCode::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_sendCode");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("phone_number", phone_number_);
    if (var0 & 1) { s.store_field("current_number", current_number_); }
    s.store_field("api_id", api_id_);
    s.store_field("api_hash", api_hash_);
    s.store_class_end();
  }
}

auth_sendCode::ReturnType auth_sendCode::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_sentCode>, 955951967>::parse(p);
#undef FAIL
}

auth_signIn::auth_signIn()
  : phone_number_()
  , phone_code_hash_()
  , phone_code_()
{}

auth_signIn::auth_signIn(std::string const &phone_number_, std::string const &phone_code_hash_, std::string const &phone_code_)
  : phone_number_(phone_number_)
  , phone_code_hash_(phone_code_hash_)
  , phone_code_(phone_code_)
{}

const std::int32_t auth_signIn::ID;

void auth_signIn::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1126886015);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
}

void auth_signIn::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1126886015);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
}

void auth_signIn::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_signIn");
    s.store_field("phone_number", phone_number_);
    s.store_field("phone_code_hash", phone_code_hash_);
    s.store_field("phone_code", phone_code_);
    s.store_class_end();
  }
}

auth_signIn::ReturnType auth_signIn::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_authorization>, -855308010>::parse(p);
#undef FAIL
}

auth_signUp::auth_signUp()
  : phone_number_()
  , phone_code_hash_()
  , phone_code_()
  , first_name_()
  , last_name_()
{}

auth_signUp::auth_signUp(std::string const &phone_number_, std::string const &phone_code_hash_, std::string const &phone_code_, std::string const &first_name_, std::string const &last_name_)
  : phone_number_(phone_number_)
  , phone_code_hash_(phone_code_hash_)
  , phone_code_(phone_code_)
  , first_name_(first_name_)
  , last_name_(last_name_)
{}

const std::int32_t auth_signUp::ID;

void auth_signUp::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(453408308);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
  TlStoreString::store(first_name_, s);
  TlStoreString::store(last_name_, s);
}

void auth_signUp::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(453408308);
  TlStoreString::store(phone_number_, s);
  TlStoreString::store(phone_code_hash_, s);
  TlStoreString::store(phone_code_, s);
  TlStoreString::store(first_name_, s);
  TlStoreString::store(last_name_, s);
}

void auth_signUp::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "auth_signUp");
    s.store_field("phone_number", phone_number_);
    s.store_field("phone_code_hash", phone_code_hash_);
    s.store_field("phone_code", phone_code_);
    s.store_field("first_name", first_name_);
    s.store_field("last_name", last_name_);
    s.store_class_end();
  }
}

auth_signUp::ReturnType auth_signUp::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<auth_authorization>, -855308010>::parse(p);
#undef FAIL
}

bots_answerWebhookJSONQuery::bots_answerWebhookJSONQuery()
  : query_id_()
  , data_()
{}

bots_answerWebhookJSONQuery::bots_answerWebhookJSONQuery(std::int64_t query_id_, object_ptr<dataJSON> &&data_)
  : query_id_(query_id_)
  , data_(std::move(data_))
{}

const std::int32_t bots_answerWebhookJSONQuery::ID;

void bots_answerWebhookJSONQuery::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-434028723);
  TlStoreBinary::store(query_id_, s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(data_, s);
}

void bots_answerWebhookJSONQuery::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-434028723);
  TlStoreBinary::store(query_id_, s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(data_, s);
}

void bots_answerWebhookJSONQuery::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "bots_answerWebhookJSONQuery");
    s.store_field("query_id", query_id_);
    if (data_ == nullptr) { s.store_field("data", "null"); } else { data_->store(s, "data"); }
    s.store_class_end();
  }
}

bots_answerWebhookJSONQuery::ReturnType bots_answerWebhookJSONQuery::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

bots_sendCustomRequest::bots_sendCustomRequest()
  : custom_method_()
  , params_()
{}

bots_sendCustomRequest::bots_sendCustomRequest(std::string const &custom_method_, object_ptr<dataJSON> &&params_)
  : custom_method_(custom_method_)
  , params_(std::move(params_))
{}

const std::int32_t bots_sendCustomRequest::ID;

void bots_sendCustomRequest::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1440257555);
  TlStoreString::store(custom_method_, s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(params_, s);
}

void bots_sendCustomRequest::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1440257555);
  TlStoreString::store(custom_method_, s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(params_, s);
}

void bots_sendCustomRequest::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "bots_sendCustomRequest");
    s.store_field("custom_method", custom_method_);
    if (params_ == nullptr) { s.store_field("params", "null"); } else { params_->store(s, "params"); }
    s.store_class_end();
  }
}

bots_sendCustomRequest::ReturnType bots_sendCustomRequest::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<dataJSON>, 2104790276>::parse(p);
#undef FAIL
}

channels_checkUsername::channels_checkUsername()
  : channel_()
  , username_()
{}

channels_checkUsername::channels_checkUsername(object_ptr<InputChannel> &&channel_, std::string const &username_)
  : channel_(std::move(channel_))
  , username_(username_)
{}

const std::int32_t channels_checkUsername::ID;

void channels_checkUsername::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(283557164);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(username_, s);
}

void channels_checkUsername::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(283557164);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(username_, s);
}

void channels_checkUsername::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_checkUsername");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("username", username_);
    s.store_class_end();
  }
}

channels_checkUsername::ReturnType channels_checkUsername::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

channels_createChannel::channels_createChannel()
  : flags_()
  , broadcast_()
  , megagroup_()
  , title_()
  , about_()
{}

channels_createChannel::channels_createChannel(std::int32_t flags_, bool broadcast_, bool megagroup_, std::string const &title_, std::string const &about_)
  : flags_(flags_)
  , broadcast_(broadcast_)
  , megagroup_(megagroup_)
  , title_(title_)
  , about_(about_)
{}

const std::int32_t channels_createChannel::ID;

void channels_createChannel::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-192332417);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(broadcast_, s); }
  if (var0 & 2) { TlStoreTrue::store(megagroup_, s); }
  TlStoreString::store(title_, s);
  TlStoreString::store(about_, s);
}

void channels_createChannel::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-192332417);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(broadcast_, s); }
  if (var0 & 2) { TlStoreTrue::store(megagroup_, s); }
  TlStoreString::store(title_, s);
  TlStoreString::store(about_, s);
}

void channels_createChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_createChannel");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    s.store_field("title", title_);
    s.store_field("about", about_);
    s.store_class_end();
  }
}

channels_createChannel::ReturnType channels_createChannel::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_deleteChannel::channels_deleteChannel()
  : channel_()
{}

channels_deleteChannel::channels_deleteChannel(object_ptr<InputChannel> &&channel_)
  : channel_(std::move(channel_))
{}

const std::int32_t channels_deleteChannel::ID;

void channels_deleteChannel::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1072619549);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_deleteChannel::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1072619549);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_deleteChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_deleteChannel");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_class_end();
  }
}

channels_deleteChannel::ReturnType channels_deleteChannel::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_deleteHistory::channels_deleteHistory()
  : channel_()
  , max_id_()
{}

channels_deleteHistory::channels_deleteHistory(object_ptr<InputChannel> &&channel_, std::int32_t max_id_)
  : channel_(std::move(channel_))
  , max_id_(max_id_)
{}

const std::int32_t channels_deleteHistory::ID;

void channels_deleteHistory::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1355375294);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBinary::store(max_id_, s);
}

void channels_deleteHistory::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1355375294);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBinary::store(max_id_, s);
}

void channels_deleteHistory::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_deleteHistory");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("max_id", max_id_);
    s.store_class_end();
  }
}

channels_deleteHistory::ReturnType channels_deleteHistory::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

channels_deleteMessages::channels_deleteMessages()
  : channel_()
  , id_()
{}

channels_deleteMessages::channels_deleteMessages(object_ptr<InputChannel> &&channel_, std::vector<std::int32_t> &&id_)
  : channel_(std::move(channel_))
  , id_(std::move(id_))
{}

const std::int32_t channels_deleteMessages::ID;

void channels_deleteMessages::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2067661490);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void channels_deleteMessages::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2067661490);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void channels_deleteMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_deleteMessages");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

channels_deleteMessages::ReturnType channels_deleteMessages::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_affectedMessages>, -2066640507>::parse(p);
#undef FAIL
}

channels_deleteUserHistory::channels_deleteUserHistory()
  : channel_()
  , user_id_()
{}

channels_deleteUserHistory::channels_deleteUserHistory(object_ptr<InputChannel> &&channel_, object_ptr<InputUser> &&user_id_)
  : channel_(std::move(channel_))
  , user_id_(std::move(user_id_))
{}

const std::int32_t channels_deleteUserHistory::ID;

void channels_deleteUserHistory::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-787622117);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void channels_deleteUserHistory::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-787622117);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void channels_deleteUserHistory::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_deleteUserHistory");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_class_end();
  }
}

channels_deleteUserHistory::ReturnType channels_deleteUserHistory::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_affectedHistory>, -1269012015>::parse(p);
#undef FAIL
}

channels_editAbout::channels_editAbout()
  : channel_()
  , about_()
{}

channels_editAbout::channels_editAbout(object_ptr<InputChannel> &&channel_, std::string const &about_)
  : channel_(std::move(channel_))
  , about_(about_)
{}

const std::int32_t channels_editAbout::ID;

void channels_editAbout::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(333610782);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(about_, s);
}

void channels_editAbout::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(333610782);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(about_, s);
}

void channels_editAbout::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_editAbout");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("about", about_);
    s.store_class_end();
  }
}

channels_editAbout::ReturnType channels_editAbout::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

channels_editAdmin::channels_editAdmin()
  : channel_()
  , user_id_()
  , admin_rights_()
{}

channels_editAdmin::channels_editAdmin(object_ptr<InputChannel> &&channel_, object_ptr<InputUser> &&user_id_, object_ptr<channelAdminRights> &&admin_rights_)
  : channel_(std::move(channel_))
  , user_id_(std::move(user_id_))
  , admin_rights_(std::move(admin_rights_))
{}

const std::int32_t channels_editAdmin::ID;

void channels_editAdmin::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(548962836);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBoxed<TlStoreObject, 1568467877>::store(admin_rights_, s);
}

void channels_editAdmin::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(548962836);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBoxed<TlStoreObject, 1568467877>::store(admin_rights_, s);
}

void channels_editAdmin::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_editAdmin");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    if (admin_rights_ == nullptr) { s.store_field("admin_rights", "null"); } else { admin_rights_->store(s, "admin_rights"); }
    s.store_class_end();
  }
}

channels_editAdmin::ReturnType channels_editAdmin::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_editBanned::channels_editBanned()
  : channel_()
  , user_id_()
  , banned_rights_()
{}

channels_editBanned::channels_editBanned(object_ptr<InputChannel> &&channel_, object_ptr<InputUser> &&user_id_, object_ptr<channelBannedRights> &&banned_rights_)
  : channel_(std::move(channel_))
  , user_id_(std::move(user_id_))
  , banned_rights_(std::move(banned_rights_))
{}

const std::int32_t channels_editBanned::ID;

void channels_editBanned::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1076292147);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBoxed<TlStoreObject, 1489977929>::store(banned_rights_, s);
}

void channels_editBanned::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1076292147);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBoxed<TlStoreObject, 1489977929>::store(banned_rights_, s);
}

void channels_editBanned::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_editBanned");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    if (banned_rights_ == nullptr) { s.store_field("banned_rights", "null"); } else { banned_rights_->store(s, "banned_rights"); }
    s.store_class_end();
  }
}

channels_editBanned::ReturnType channels_editBanned::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_editPhoto::channels_editPhoto()
  : channel_()
  , photo_()
{}

channels_editPhoto::channels_editPhoto(object_ptr<InputChannel> &&channel_, object_ptr<InputChatPhoto> &&photo_)
  : channel_(std::move(channel_))
  , photo_(std::move(photo_))
{}

const std::int32_t channels_editPhoto::ID;

void channels_editPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-248621111);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(photo_, s);
}

void channels_editPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-248621111);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(photo_, s);
}

void channels_editPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_editPhoto");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    s.store_class_end();
  }
}

channels_editPhoto::ReturnType channels_editPhoto::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_editTitle::channels_editTitle()
  : channel_()
  , title_()
{}

channels_editTitle::channels_editTitle(object_ptr<InputChannel> &&channel_, std::string const &title_)
  : channel_(std::move(channel_))
  , title_(title_)
{}

const std::int32_t channels_editTitle::ID;

void channels_editTitle::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1450044624);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(title_, s);
}

void channels_editTitle::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1450044624);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(title_, s);
}

void channels_editTitle::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_editTitle");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("title", title_);
    s.store_class_end();
  }
}

channels_editTitle::ReturnType channels_editTitle::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_exportInvite::channels_exportInvite()
  : channel_()
{}

channels_exportInvite::channels_exportInvite(object_ptr<InputChannel> &&channel_)
  : channel_(std::move(channel_))
{}

const std::int32_t channels_exportInvite::ID;

void channels_exportInvite::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-950663035);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_exportInvite::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-950663035);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_exportInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_exportInvite");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_class_end();
  }
}

channels_exportInvite::ReturnType channels_exportInvite::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<ExportedChatInvite>::parse(p);
#undef FAIL
}

channels_exportMessageLink::channels_exportMessageLink()
  : channel_()
  , id_()
  , grouped_()
{}

channels_exportMessageLink::channels_exportMessageLink(object_ptr<InputChannel> &&channel_, std::int32_t id_, bool grouped_)
  : channel_(std::move(channel_))
  , id_(id_)
  , grouped_(grouped_)
{}

const std::int32_t channels_exportMessageLink::ID;

void channels_exportMessageLink::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-826838685);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBinary::store(id_, s);
  TlStoreBool::store(grouped_, s);
}

void channels_exportMessageLink::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-826838685);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBinary::store(id_, s);
  TlStoreBool::store(grouped_, s);
}

void channels_exportMessageLink::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_exportMessageLink");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("id", id_);
    s.store_field("grouped", grouped_);
    s.store_class_end();
  }
}

channels_exportMessageLink::ReturnType channels_exportMessageLink::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<exportedMessageLink>, 1571494644>::parse(p);
#undef FAIL
}

channels_getAdminLog::channels_getAdminLog()
  : flags_()
  , channel_()
  , q_()
  , events_filter_()
  , admins_()
  , max_id_()
  , min_id_()
  , limit_()
{}

channels_getAdminLog::channels_getAdminLog(std::int32_t flags_, object_ptr<InputChannel> &&channel_, std::string const &q_, object_ptr<channelAdminLogEventsFilter> &&events_filter_, std::vector<object_ptr<InputUser>> &&admins_, std::int64_t max_id_, std::int64_t min_id_, std::int32_t limit_)
  : flags_(flags_)
  , channel_(std::move(channel_))
  , q_(q_)
  , events_filter_(std::move(events_filter_))
  , admins_(std::move(admins_))
  , max_id_(max_id_)
  , min_id_(min_id_)
  , limit_(limit_)
{}

const std::int32_t channels_getAdminLog::ID;

void channels_getAdminLog::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(870184064);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(q_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -368018716>::store(events_filter_, s); }
  if (var0 & 2) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(admins_, s); }
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(min_id_, s);
  TlStoreBinary::store(limit_, s);
}

void channels_getAdminLog::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(870184064);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(q_, s);
  if (var0 & 1) { TlStoreBoxed<TlStoreObject, -368018716>::store(events_filter_, s); }
  if (var0 & 2) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(admins_, s); }
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(min_id_, s);
  TlStoreBinary::store(limit_, s);
}

void channels_getAdminLog::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_getAdminLog");
    s.store_field("flags", (var0 = flags_));
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("q", q_);
    if (var0 & 1) { if (events_filter_ == nullptr) { s.store_field("events_filter", "null"); } else { events_filter_->store(s, "events_filter"); } }
    if (var0 & 2) { { const std::vector<object_ptr<InputUser>> &v = admins_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("admins", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_field("max_id", max_id_);
    s.store_field("min_id", min_id_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

channels_getAdminLog::ReturnType channels_getAdminLog::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<channels_adminLogResults>, -309659827>::parse(p);
#undef FAIL
}

channels_getAdminedPublicChannels::channels_getAdminedPublicChannels() {
}

const std::int32_t channels_getAdminedPublicChannels::ID;

void channels_getAdminedPublicChannels::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1920105769);
}

void channels_getAdminedPublicChannels::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1920105769);
}

void channels_getAdminedPublicChannels::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_getAdminedPublicChannels");
    s.store_class_end();
  }
}

channels_getAdminedPublicChannels::ReturnType channels_getAdminedPublicChannels::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Chats>::parse(p);
#undef FAIL
}

channels_getChannels::channels_getChannels()
  : id_()
{}

channels_getChannels::channels_getChannels(std::vector<object_ptr<InputChannel>> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t channels_getChannels::ID;

void channels_getChannels::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(176122811);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void channels_getChannels::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(176122811);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void channels_getChannels::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_getChannels");
    { const std::vector<object_ptr<InputChannel>> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

channels_getChannels::ReturnType channels_getChannels::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Chats>::parse(p);
#undef FAIL
}

channels_getFullChannel::channels_getFullChannel()
  : channel_()
{}

channels_getFullChannel::channels_getFullChannel(object_ptr<InputChannel> &&channel_)
  : channel_(std::move(channel_))
{}

const std::int32_t channels_getFullChannel::ID;

void channels_getFullChannel::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(141781513);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_getFullChannel::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(141781513);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_getFullChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_getFullChannel");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_class_end();
  }
}

channels_getFullChannel::ReturnType channels_getFullChannel::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_chatFull>, -438840932>::parse(p);
#undef FAIL
}

channels_getLeftChannels::channels_getLeftChannels()
  : offset_()
{}

channels_getLeftChannels::channels_getLeftChannels(std::int32_t offset_)
  : offset_(offset_)
{}

const std::int32_t channels_getLeftChannels::ID;

void channels_getLeftChannels::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2092831552);
  TlStoreBinary::store(offset_, s);
}

void channels_getLeftChannels::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2092831552);
  TlStoreBinary::store(offset_, s);
}

void channels_getLeftChannels::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_getLeftChannels");
    s.store_field("offset", offset_);
    s.store_class_end();
  }
}

channels_getLeftChannels::ReturnType channels_getLeftChannels::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Chats>::parse(p);
#undef FAIL
}

channels_getMessages::channels_getMessages()
  : channel_()
  , id_()
{}

channels_getMessages::channels_getMessages(object_ptr<InputChannel> &&channel_, std::vector<object_ptr<InputMessage>> &&id_)
  : channel_(std::move(channel_))
  , id_(std::move(id_))
{}

const std::int32_t channels_getMessages::ID;

void channels_getMessages::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1383294429);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void channels_getMessages::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1383294429);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void channels_getMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_getMessages");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    { const std::vector<object_ptr<InputMessage>> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

channels_getMessages::ReturnType channels_getMessages::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Messages>::parse(p);
#undef FAIL
}

channels_getParticipant::channels_getParticipant()
  : channel_()
  , user_id_()
{}

channels_getParticipant::channels_getParticipant(object_ptr<InputChannel> &&channel_, object_ptr<InputUser> &&user_id_)
  : channel_(std::move(channel_))
  , user_id_(std::move(user_id_))
{}

const std::int32_t channels_getParticipant::ID;

void channels_getParticipant::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1416484774);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void channels_getParticipant::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1416484774);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void channels_getParticipant::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_getParticipant");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_class_end();
  }
}

channels_getParticipant::ReturnType channels_getParticipant::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<channels_channelParticipant>, -791039645>::parse(p);
#undef FAIL
}

channels_getParticipants::channels_getParticipants()
  : channel_()
  , filter_()
  , offset_()
  , limit_()
  , hash_()
{}

channels_getParticipants::channels_getParticipants(object_ptr<InputChannel> &&channel_, object_ptr<ChannelParticipantsFilter> &&filter_, std::int32_t offset_, std::int32_t limit_, std::int32_t hash_)
  : channel_(std::move(channel_))
  , filter_(std::move(filter_))
  , offset_(offset_)
  , limit_(limit_)
  , hash_(hash_)
{}

const std::int32_t channels_getParticipants::ID;

void channels_getParticipants::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(306054633);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(filter_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(hash_, s);
}

void channels_getParticipants::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(306054633);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(filter_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(hash_, s);
}

void channels_getParticipants::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_getParticipants");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (filter_ == nullptr) { s.store_field("filter", "null"); } else { filter_->store(s, "filter"); }
    s.store_field("offset", offset_);
    s.store_field("limit", limit_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

channels_getParticipants::ReturnType channels_getParticipants::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<channels_ChannelParticipants>::parse(p);
#undef FAIL
}

channels_inviteToChannel::channels_inviteToChannel()
  : channel_()
  , users_()
{}

channels_inviteToChannel::channels_inviteToChannel(object_ptr<InputChannel> &&channel_, std::vector<object_ptr<InputUser>> &&users_)
  : channel_(std::move(channel_))
  , users_(std::move(users_))
{}

const std::int32_t channels_inviteToChannel::ID;

void channels_inviteToChannel::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(429865580);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(users_, s);
}

void channels_inviteToChannel::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(429865580);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(users_, s);
}

void channels_inviteToChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_inviteToChannel");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    { const std::vector<object_ptr<InputUser>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

channels_inviteToChannel::ReturnType channels_inviteToChannel::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_joinChannel::channels_joinChannel()
  : channel_()
{}

channels_joinChannel::channels_joinChannel(object_ptr<InputChannel> &&channel_)
  : channel_(std::move(channel_))
{}

const std::int32_t channels_joinChannel::ID;

void channels_joinChannel::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(615851205);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_joinChannel::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(615851205);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_joinChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_joinChannel");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_class_end();
  }
}

channels_joinChannel::ReturnType channels_joinChannel::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_leaveChannel::channels_leaveChannel()
  : channel_()
{}

channels_leaveChannel::channels_leaveChannel(object_ptr<InputChannel> &&channel_)
  : channel_(std::move(channel_))
{}

const std::int32_t channels_leaveChannel::ID;

void channels_leaveChannel::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-130635115);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_leaveChannel::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-130635115);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
}

void channels_leaveChannel::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_leaveChannel");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_class_end();
  }
}

channels_leaveChannel::ReturnType channels_leaveChannel::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_readHistory::channels_readHistory()
  : channel_()
  , max_id_()
{}

channels_readHistory::channels_readHistory(object_ptr<InputChannel> &&channel_, std::int32_t max_id_)
  : channel_(std::move(channel_))
  , max_id_(max_id_)
{}

const std::int32_t channels_readHistory::ID;

void channels_readHistory::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-871347913);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBinary::store(max_id_, s);
}

void channels_readHistory::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-871347913);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBinary::store(max_id_, s);
}

void channels_readHistory::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_readHistory");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("max_id", max_id_);
    s.store_class_end();
  }
}

channels_readHistory::ReturnType channels_readHistory::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

channels_readMessageContents::channels_readMessageContents()
  : channel_()
  , id_()
{}

channels_readMessageContents::channels_readMessageContents(object_ptr<InputChannel> &&channel_, std::vector<std::int32_t> &&id_)
  : channel_(std::move(channel_))
  , id_(std::move(id_))
{}

const std::int32_t channels_readMessageContents::ID;

void channels_readMessageContents::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-357180360);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void channels_readMessageContents::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-357180360);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void channels_readMessageContents::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_readMessageContents");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

channels_readMessageContents::ReturnType channels_readMessageContents::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

channels_reportSpam::channels_reportSpam()
  : channel_()
  , user_id_()
  , id_()
{}

channels_reportSpam::channels_reportSpam(object_ptr<InputChannel> &&channel_, object_ptr<InputUser> &&user_id_, std::vector<std::int32_t> &&id_)
  : channel_(std::move(channel_))
  , user_id_(std::move(user_id_))
  , id_(std::move(id_))
{}

const std::int32_t channels_reportSpam::ID;

void channels_reportSpam::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-32999408);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void channels_reportSpam::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-32999408);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void channels_reportSpam::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_reportSpam");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

channels_reportSpam::ReturnType channels_reportSpam::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

channels_setStickers::channels_setStickers()
  : channel_()
  , stickerset_()
{}

channels_setStickers::channels_setStickers(object_ptr<InputChannel> &&channel_, object_ptr<InputStickerSet> &&stickerset_)
  : channel_(std::move(channel_))
  , stickerset_(std::move(stickerset_))
{}

const std::int32_t channels_setStickers::ID;

void channels_setStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-359881479);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
}

void channels_setStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-359881479);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
}

void channels_setStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_setStickers");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (stickerset_ == nullptr) { s.store_field("stickerset", "null"); } else { stickerset_->store(s, "stickerset"); }
    s.store_class_end();
  }
}

channels_setStickers::ReturnType channels_setStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

channels_toggleInvites::channels_toggleInvites()
  : channel_()
  , enabled_()
{}

channels_toggleInvites::channels_toggleInvites(object_ptr<InputChannel> &&channel_, bool enabled_)
  : channel_(std::move(channel_))
  , enabled_(enabled_)
{}

const std::int32_t channels_toggleInvites::ID;

void channels_toggleInvites::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1231065863);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBool::store(enabled_, s);
}

void channels_toggleInvites::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1231065863);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBool::store(enabled_, s);
}

void channels_toggleInvites::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_toggleInvites");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("enabled", enabled_);
    s.store_class_end();
  }
}

channels_toggleInvites::ReturnType channels_toggleInvites::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_togglePreHistoryHidden::channels_togglePreHistoryHidden()
  : channel_()
  , enabled_()
{}

channels_togglePreHistoryHidden::channels_togglePreHistoryHidden(object_ptr<InputChannel> &&channel_, bool enabled_)
  : channel_(std::move(channel_))
  , enabled_(enabled_)
{}

const std::int32_t channels_togglePreHistoryHidden::ID;

void channels_togglePreHistoryHidden::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-356796084);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBool::store(enabled_, s);
}

void channels_togglePreHistoryHidden::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-356796084);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBool::store(enabled_, s);
}

void channels_togglePreHistoryHidden::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_togglePreHistoryHidden");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("enabled", enabled_);
    s.store_class_end();
  }
}

channels_togglePreHistoryHidden::ReturnType channels_togglePreHistoryHidden::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_toggleSignatures::channels_toggleSignatures()
  : channel_()
  , enabled_()
{}

channels_toggleSignatures::channels_toggleSignatures(object_ptr<InputChannel> &&channel_, bool enabled_)
  : channel_(std::move(channel_))
  , enabled_(enabled_)
{}

const std::int32_t channels_toggleSignatures::ID;

void channels_toggleSignatures::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(527021574);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBool::store(enabled_, s);
}

void channels_toggleSignatures::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(527021574);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBool::store(enabled_, s);
}

void channels_toggleSignatures::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_toggleSignatures");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("enabled", enabled_);
    s.store_class_end();
  }
}

channels_toggleSignatures::ReturnType channels_toggleSignatures::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_updatePinnedMessage::channels_updatePinnedMessage()
  : flags_()
  , silent_()
  , channel_()
  , id_()
{}

channels_updatePinnedMessage::channels_updatePinnedMessage(std::int32_t flags_, bool silent_, object_ptr<InputChannel> &&channel_, std::int32_t id_)
  : flags_(flags_)
  , silent_(silent_)
  , channel_(std::move(channel_))
  , id_(id_)
{}

const std::int32_t channels_updatePinnedMessage::ID;

void channels_updatePinnedMessage::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1490162350);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(silent_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBinary::store(id_, s);
}

void channels_updatePinnedMessage::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1490162350);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(silent_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBinary::store(id_, s);
}

void channels_updatePinnedMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_updatePinnedMessage");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("id", id_);
    s.store_class_end();
  }
}

channels_updatePinnedMessage::ReturnType channels_updatePinnedMessage::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

channels_updateUsername::channels_updateUsername()
  : channel_()
  , username_()
{}

channels_updateUsername::channels_updateUsername(object_ptr<InputChannel> &&channel_, std::string const &username_)
  : channel_(std::move(channel_))
  , username_(username_)
{}

const std::int32_t channels_updateUsername::ID;

void channels_updateUsername::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(890549214);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(username_, s);
}

void channels_updateUsername::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(890549214);
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreString::store(username_, s);
}

void channels_updateUsername::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "channels_updateUsername");
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    s.store_field("username", username_);
    s.store_class_end();
  }
}

channels_updateUsername::ReturnType channels_updateUsername::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

contacts_block::contacts_block()
  : id_()
{}

contacts_block::contacts_block(object_ptr<InputUser> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t contacts_block::ID;

void contacts_block::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(858475004);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void contacts_block::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(858475004);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void contacts_block::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_block");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

contacts_block::ReturnType contacts_block::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

contacts_deleteContact::contacts_deleteContact()
  : id_()
{}

contacts_deleteContact::contacts_deleteContact(object_ptr<InputUser> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t contacts_deleteContact::ID;

void contacts_deleteContact::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1902823612);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void contacts_deleteContact::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1902823612);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void contacts_deleteContact::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_deleteContact");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

contacts_deleteContact::ReturnType contacts_deleteContact::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<contacts_link>, 986597452>::parse(p);
#undef FAIL
}

contacts_deleteContacts::contacts_deleteContacts()
  : id_()
{}

contacts_deleteContacts::contacts_deleteContacts(std::vector<object_ptr<InputUser>> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t contacts_deleteContacts::ID;

void contacts_deleteContacts::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1504393374);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void contacts_deleteContacts::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1504393374);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void contacts_deleteContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_deleteContacts");
    { const std::vector<object_ptr<InputUser>> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

contacts_deleteContacts::ReturnType contacts_deleteContacts::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

contacts_exportCard::contacts_exportCard() {
}

const std::int32_t contacts_exportCard::ID;

void contacts_exportCard::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2065352905);
}

void contacts_exportCard::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2065352905);
}

void contacts_exportCard::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_exportCard");
    s.store_class_end();
  }
}

contacts_exportCard::ReturnType contacts_exportCard::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p);
#undef FAIL
}

contacts_getBlocked::contacts_getBlocked()
  : offset_()
  , limit_()
{}

contacts_getBlocked::contacts_getBlocked(std::int32_t offset_, std::int32_t limit_)
  : offset_(offset_)
  , limit_(limit_)
{}

const std::int32_t contacts_getBlocked::ID;

void contacts_getBlocked::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-176409329);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
}

void contacts_getBlocked::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-176409329);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
}

void contacts_getBlocked::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_getBlocked");
    s.store_field("offset", offset_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

contacts_getBlocked::ReturnType contacts_getBlocked::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<contacts_Blocked>::parse(p);
#undef FAIL
}

contacts_getContacts::contacts_getContacts()
  : hash_()
{}

contacts_getContacts::contacts_getContacts(std::int32_t hash_)
  : hash_(hash_)
{}

const std::int32_t contacts_getContacts::ID;

void contacts_getContacts::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1071414113);
  TlStoreBinary::store(hash_, s);
}

void contacts_getContacts::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1071414113);
  TlStoreBinary::store(hash_, s);
}

void contacts_getContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_getContacts");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

contacts_getContacts::ReturnType contacts_getContacts::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<contacts_Contacts>::parse(p);
#undef FAIL
}

contacts_getSaved::contacts_getSaved() {
}

const std::int32_t contacts_getSaved::ID;

void contacts_getSaved::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2098076769);
}

void contacts_getSaved::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2098076769);
}

void contacts_getSaved::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_getSaved");
    s.store_class_end();
  }
}

contacts_getSaved::ReturnType contacts_getSaved::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<savedPhoneContact>, 289586518>>, 481674261>::parse(p);
#undef FAIL
}

contacts_getStatuses::contacts_getStatuses() {
}

const std::int32_t contacts_getStatuses::ID;

void contacts_getStatuses::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-995929106);
}

void contacts_getStatuses::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-995929106);
}

void contacts_getStatuses::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_getStatuses");
    s.store_class_end();
  }
}

contacts_getStatuses::ReturnType contacts_getStatuses::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<contactStatus>, -748155807>>, 481674261>::parse(p);
#undef FAIL
}

contacts_getTopPeers::contacts_getTopPeers()
  : flags_()
  , correspondents_()
  , bots_pm_()
  , bots_inline_()
  , phone_calls_()
  , groups_()
  , channels_()
  , offset_()
  , limit_()
  , hash_()
{}

contacts_getTopPeers::contacts_getTopPeers(std::int32_t flags_, bool correspondents_, bool bots_pm_, bool bots_inline_, bool phone_calls_, bool groups_, bool channels_, std::int32_t offset_, std::int32_t limit_, std::int32_t hash_)
  : flags_(flags_)
  , correspondents_(correspondents_)
  , bots_pm_(bots_pm_)
  , bots_inline_(bots_inline_)
  , phone_calls_(phone_calls_)
  , groups_(groups_)
  , channels_(channels_)
  , offset_(offset_)
  , limit_(limit_)
  , hash_(hash_)
{}

const std::int32_t contacts_getTopPeers::ID;

void contacts_getTopPeers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-728224331);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(correspondents_, s); }
  if (var0 & 2) { TlStoreTrue::store(bots_pm_, s); }
  if (var0 & 4) { TlStoreTrue::store(bots_inline_, s); }
  if (var0 & 8) { TlStoreTrue::store(phone_calls_, s); }
  if (var0 & 1024) { TlStoreTrue::store(groups_, s); }
  if (var0 & 32768) { TlStoreTrue::store(channels_, s); }
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(hash_, s);
}

void contacts_getTopPeers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-728224331);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(correspondents_, s); }
  if (var0 & 2) { TlStoreTrue::store(bots_pm_, s); }
  if (var0 & 4) { TlStoreTrue::store(bots_inline_, s); }
  if (var0 & 8) { TlStoreTrue::store(phone_calls_, s); }
  if (var0 & 1024) { TlStoreTrue::store(groups_, s); }
  if (var0 & 32768) { TlStoreTrue::store(channels_, s); }
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(hash_, s);
}

void contacts_getTopPeers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_getTopPeers");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (var0 & 4) {  }
    if (var0 & 8) {  }
    if (var0 & 1024) {  }
    if (var0 & 32768) {  }
    s.store_field("offset", offset_);
    s.store_field("limit", limit_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

contacts_getTopPeers::ReturnType contacts_getTopPeers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<contacts_TopPeers>::parse(p);
#undef FAIL
}

contacts_importCard::contacts_importCard()
  : export_card_()
{}

contacts_importCard::contacts_importCard(std::vector<std::int32_t> &&export_card_)
  : export_card_(std::move(export_card_))
{}

const std::int32_t contacts_importCard::ID;

void contacts_importCard::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1340184318);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(export_card_, s);
}

void contacts_importCard::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1340184318);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(export_card_, s);
}

void contacts_importCard::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_importCard");
    { const std::vector<std::int32_t> &v = export_card_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("export_card", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

contacts_importCard::ReturnType contacts_importCard::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<User>::parse(p);
#undef FAIL
}

contacts_importContacts::contacts_importContacts()
  : contacts_()
{}

contacts_importContacts::contacts_importContacts(std::vector<object_ptr<inputPhoneContact>> &&contacts_)
  : contacts_(std::move(contacts_))
{}

const std::int32_t contacts_importContacts::ID;

void contacts_importContacts::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(746589157);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -208488460>>, 481674261>::store(contacts_, s);
}

void contacts_importContacts::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(746589157);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -208488460>>, 481674261>::store(contacts_, s);
}

void contacts_importContacts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_importContacts");
    { const std::vector<object_ptr<inputPhoneContact>> &v = contacts_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("contacts", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

contacts_importContacts::ReturnType contacts_importContacts::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<contacts_importedContacts>, 2010127419>::parse(p);
#undef FAIL
}

contacts_resetSaved::contacts_resetSaved() {
}

const std::int32_t contacts_resetSaved::ID;

void contacts_resetSaved::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2020263951);
}

void contacts_resetSaved::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2020263951);
}

void contacts_resetSaved::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_resetSaved");
    s.store_class_end();
  }
}

contacts_resetSaved::ReturnType contacts_resetSaved::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

contacts_resetTopPeerRating::contacts_resetTopPeerRating()
  : category_()
  , peer_()
{}

contacts_resetTopPeerRating::contacts_resetTopPeerRating(object_ptr<TopPeerCategory> &&category_, object_ptr<InputPeer> &&peer_)
  : category_(std::move(category_))
  , peer_(std::move(peer_))
{}

const std::int32_t contacts_resetTopPeerRating::ID;

void contacts_resetTopPeerRating::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(451113900);
  TlStoreBoxedUnknown<TlStoreObject>::store(category_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void contacts_resetTopPeerRating::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(451113900);
  TlStoreBoxedUnknown<TlStoreObject>::store(category_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void contacts_resetTopPeerRating::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_resetTopPeerRating");
    if (category_ == nullptr) { s.store_field("category", "null"); } else { category_->store(s, "category"); }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

contacts_resetTopPeerRating::ReturnType contacts_resetTopPeerRating::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

contacts_resolveUsername::contacts_resolveUsername()
  : username_()
{}

contacts_resolveUsername::contacts_resolveUsername(std::string const &username_)
  : username_(username_)
{}

const std::int32_t contacts_resolveUsername::ID;

void contacts_resolveUsername::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-113456221);
  TlStoreString::store(username_, s);
}

void contacts_resolveUsername::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-113456221);
  TlStoreString::store(username_, s);
}

void contacts_resolveUsername::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_resolveUsername");
    s.store_field("username", username_);
    s.store_class_end();
  }
}

contacts_resolveUsername::ReturnType contacts_resolveUsername::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<contacts_resolvedPeer>, 2131196633>::parse(p);
#undef FAIL
}

contacts_search::contacts_search()
  : q_()
  , limit_()
{}

contacts_search::contacts_search(std::string const &q_, std::int32_t limit_)
  : q_(q_)
  , limit_(limit_)
{}

const std::int32_t contacts_search::ID;

void contacts_search::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(301470424);
  TlStoreString::store(q_, s);
  TlStoreBinary::store(limit_, s);
}

void contacts_search::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(301470424);
  TlStoreString::store(q_, s);
  TlStoreBinary::store(limit_, s);
}

void contacts_search::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_search");
    s.store_field("q", q_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

contacts_search::ReturnType contacts_search::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<contacts_found>, -1290580579>::parse(p);
#undef FAIL
}

contacts_toggleTopPeers::contacts_toggleTopPeers()
  : enabled_()
{}

contacts_toggleTopPeers::contacts_toggleTopPeers(bool enabled_)
  : enabled_(enabled_)
{}

const std::int32_t contacts_toggleTopPeers::ID;

void contacts_toggleTopPeers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2062238246);
  TlStoreBool::store(enabled_, s);
}

void contacts_toggleTopPeers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2062238246);
  TlStoreBool::store(enabled_, s);
}

void contacts_toggleTopPeers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_toggleTopPeers");
    s.store_field("enabled", enabled_);
    s.store_class_end();
  }
}

contacts_toggleTopPeers::ReturnType contacts_toggleTopPeers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

contacts_unblock::contacts_unblock()
  : id_()
{}

contacts_unblock::contacts_unblock(object_ptr<InputUser> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t contacts_unblock::ID;

void contacts_unblock::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-448724803);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void contacts_unblock::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-448724803);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void contacts_unblock::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "contacts_unblock");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

contacts_unblock::ReturnType contacts_unblock::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

help_acceptTermsOfService::help_acceptTermsOfService()
  : id_()
{}

help_acceptTermsOfService::help_acceptTermsOfService(object_ptr<dataJSON> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t help_acceptTermsOfService::ID;

void help_acceptTermsOfService::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-294455398);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(id_, s);
}

void help_acceptTermsOfService::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-294455398);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(id_, s);
}

void help_acceptTermsOfService::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_acceptTermsOfService");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

help_acceptTermsOfService::ReturnType help_acceptTermsOfService::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

help_getAppChangelog::help_getAppChangelog()
  : prev_app_version_()
{}

help_getAppChangelog::help_getAppChangelog(std::string const &prev_app_version_)
  : prev_app_version_(prev_app_version_)
{}

const std::int32_t help_getAppChangelog::ID;

void help_getAppChangelog::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1877938321);
  TlStoreString::store(prev_app_version_, s);
}

void help_getAppChangelog::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1877938321);
  TlStoreString::store(prev_app_version_, s);
}

void help_getAppChangelog::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getAppChangelog");
    s.store_field("prev_app_version", prev_app_version_);
    s.store_class_end();
  }
}

help_getAppChangelog::ReturnType help_getAppChangelog::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

help_getAppUpdate::help_getAppUpdate()
  : source_()
{}

help_getAppUpdate::help_getAppUpdate(std::string const &source_)
  : source_(source_)
{}

const std::int32_t help_getAppUpdate::ID;

void help_getAppUpdate::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1378703997);
  TlStoreString::store(source_, s);
}

void help_getAppUpdate::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1378703997);
  TlStoreString::store(source_, s);
}

void help_getAppUpdate::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getAppUpdate");
    s.store_field("source", source_);
    s.store_class_end();
  }
}

help_getAppUpdate::ReturnType help_getAppUpdate::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<help_AppUpdate>::parse(p);
#undef FAIL
}

help_getCdnConfig::help_getCdnConfig() {
}

const std::int32_t help_getCdnConfig::ID;

void help_getCdnConfig::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1375900482);
}

void help_getCdnConfig::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1375900482);
}

void help_getCdnConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getCdnConfig");
    s.store_class_end();
  }
}

help_getCdnConfig::ReturnType help_getCdnConfig::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<cdnConfig>, 1462101002>::parse(p);
#undef FAIL
}

help_getConfig::help_getConfig() {
}

const std::int32_t help_getConfig::ID;

void help_getConfig::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-990308245);
}

void help_getConfig::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-990308245);
}

void help_getConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getConfig");
    s.store_class_end();
  }
}

help_getConfig::ReturnType help_getConfig::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<config>, 840162234>::parse(p);
#undef FAIL
}

help_getDeepLinkInfo::help_getDeepLinkInfo()
  : path_()
{}

help_getDeepLinkInfo::help_getDeepLinkInfo(std::string const &path_)
  : path_(path_)
{}

const std::int32_t help_getDeepLinkInfo::ID;

void help_getDeepLinkInfo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1072547679);
  TlStoreString::store(path_, s);
}

void help_getDeepLinkInfo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1072547679);
  TlStoreString::store(path_, s);
}

void help_getDeepLinkInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getDeepLinkInfo");
    s.store_field("path", path_);
    s.store_class_end();
  }
}

help_getDeepLinkInfo::ReturnType help_getDeepLinkInfo::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<help_DeepLinkInfo>::parse(p);
#undef FAIL
}

help_getInviteText::help_getInviteText() {
}

const std::int32_t help_getInviteText::ID;

void help_getInviteText::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1295590211);
}

void help_getInviteText::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1295590211);
}

void help_getInviteText::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getInviteText");
    s.store_class_end();
  }
}

help_getInviteText::ReturnType help_getInviteText::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<help_inviteText>, 415997816>::parse(p);
#undef FAIL
}

help_getNearestDc::help_getNearestDc() {
}

const std::int32_t help_getNearestDc::ID;

void help_getNearestDc::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(531836966);
}

void help_getNearestDc::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(531836966);
}

void help_getNearestDc::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getNearestDc");
    s.store_class_end();
  }
}

help_getNearestDc::ReturnType help_getNearestDc::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<nearestDc>, -1910892683>::parse(p);
#undef FAIL
}

help_getPassportConfig::help_getPassportConfig()
  : hash_()
{}

help_getPassportConfig::help_getPassportConfig(std::int32_t hash_)
  : hash_(hash_)
{}

const std::int32_t help_getPassportConfig::ID;

void help_getPassportConfig::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-966677240);
  TlStoreBinary::store(hash_, s);
}

void help_getPassportConfig::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-966677240);
  TlStoreBinary::store(hash_, s);
}

void help_getPassportConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getPassportConfig");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

help_getPassportConfig::ReturnType help_getPassportConfig::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<help_PassportConfig>::parse(p);
#undef FAIL
}

help_getProxyData::help_getProxyData() {
}

const std::int32_t help_getProxyData::ID;

void help_getProxyData::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1031231713);
}

void help_getProxyData::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1031231713);
}

void help_getProxyData::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getProxyData");
    s.store_class_end();
  }
}

help_getProxyData::ReturnType help_getProxyData::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<help_ProxyData>::parse(p);
#undef FAIL
}

help_getRecentMeUrls::help_getRecentMeUrls()
  : referer_()
{}

help_getRecentMeUrls::help_getRecentMeUrls(std::string const &referer_)
  : referer_(referer_)
{}

const std::int32_t help_getRecentMeUrls::ID;

void help_getRecentMeUrls::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1036054804);
  TlStoreString::store(referer_, s);
}

void help_getRecentMeUrls::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1036054804);
  TlStoreString::store(referer_, s);
}

void help_getRecentMeUrls::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getRecentMeUrls");
    s.store_field("referer", referer_);
    s.store_class_end();
  }
}

help_getRecentMeUrls::ReturnType help_getRecentMeUrls::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<help_recentMeUrls>, 235081943>::parse(p);
#undef FAIL
}

help_getSupport::help_getSupport() {
}

const std::int32_t help_getSupport::ID;

void help_getSupport::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1663104819);
}

void help_getSupport::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1663104819);
}

void help_getSupport::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getSupport");
    s.store_class_end();
  }
}

help_getSupport::ReturnType help_getSupport::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<help_support>, 398898678>::parse(p);
#undef FAIL
}

help_getTermsOfServiceUpdate::help_getTermsOfServiceUpdate() {
}

const std::int32_t help_getTermsOfServiceUpdate::ID;

void help_getTermsOfServiceUpdate::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(749019089);
}

void help_getTermsOfServiceUpdate::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(749019089);
}

void help_getTermsOfServiceUpdate::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_getTermsOfServiceUpdate");
    s.store_class_end();
  }
}

help_getTermsOfServiceUpdate::ReturnType help_getTermsOfServiceUpdate::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<help_TermsOfServiceUpdate>::parse(p);
#undef FAIL
}

help_saveAppLog::help_saveAppLog()
  : events_()
{}

help_saveAppLog::help_saveAppLog(std::vector<object_ptr<inputAppEvent>> &&events_)
  : events_(std::move(events_))
{}

const std::int32_t help_saveAppLog::ID;

void help_saveAppLog::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1862465352);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 1996904104>>, 481674261>::store(events_, s);
}

void help_saveAppLog::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1862465352);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 1996904104>>, 481674261>::store(events_, s);
}

void help_saveAppLog::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_saveAppLog");
    { const std::vector<object_ptr<inputAppEvent>> &v = events_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("events", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

help_saveAppLog::ReturnType help_saveAppLog::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

help_setBotUpdatesStatus::help_setBotUpdatesStatus()
  : pending_updates_count_()
  , message_()
{}

help_setBotUpdatesStatus::help_setBotUpdatesStatus(std::int32_t pending_updates_count_, std::string const &message_)
  : pending_updates_count_(pending_updates_count_)
  , message_(message_)
{}

const std::int32_t help_setBotUpdatesStatus::ID;

void help_setBotUpdatesStatus::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-333262899);
  TlStoreBinary::store(pending_updates_count_, s);
  TlStoreString::store(message_, s);
}

void help_setBotUpdatesStatus::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-333262899);
  TlStoreBinary::store(pending_updates_count_, s);
  TlStoreString::store(message_, s);
}

void help_setBotUpdatesStatus::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "help_setBotUpdatesStatus");
    s.store_field("pending_updates_count", pending_updates_count_);
    s.store_field("message", message_);
    s.store_class_end();
  }
}

help_setBotUpdatesStatus::ReturnType help_setBotUpdatesStatus::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

langpack_getDifference::langpack_getDifference()
  : from_version_()
{}

langpack_getDifference::langpack_getDifference(std::int32_t from_version_)
  : from_version_(from_version_)
{}

const std::int32_t langpack_getDifference::ID;

void langpack_getDifference::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(187583869);
  TlStoreBinary::store(from_version_, s);
}

void langpack_getDifference::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(187583869);
  TlStoreBinary::store(from_version_, s);
}

void langpack_getDifference::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langpack_getDifference");
    s.store_field("from_version", from_version_);
    s.store_class_end();
  }
}

langpack_getDifference::ReturnType langpack_getDifference::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<langPackDifference>, -209337866>::parse(p);
#undef FAIL
}

langpack_getLangPack::langpack_getLangPack()
  : lang_pack_()
  , lang_code_()
{}

langpack_getLangPack::langpack_getLangPack(std::string const &lang_pack_, std::string const &lang_code_)
  : lang_pack_(lang_pack_)
  , lang_code_(lang_code_)
{}

const std::int32_t langpack_getLangPack::ID;

void langpack_getLangPack::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-219008246);
  TlStoreString::store(lang_pack_, s);
  TlStoreString::store(lang_code_, s);
}

void langpack_getLangPack::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-219008246);
  TlStoreString::store(lang_pack_, s);
  TlStoreString::store(lang_code_, s);
}

void langpack_getLangPack::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langpack_getLangPack");
    s.store_field("lang_pack", lang_pack_);
    s.store_field("lang_code", lang_code_);
    s.store_class_end();
  }
}

langpack_getLangPack::ReturnType langpack_getLangPack::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<langPackDifference>, -209337866>::parse(p);
#undef FAIL
}

langpack_getLanguages::langpack_getLanguages()
  : lang_pack_()
{}

langpack_getLanguages::langpack_getLanguages(std::string const &lang_pack_)
  : lang_pack_(lang_pack_)
{}

const std::int32_t langpack_getLanguages::ID;

void langpack_getLanguages::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1120311183);
  TlStoreString::store(lang_pack_, s);
}

void langpack_getLanguages::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1120311183);
  TlStoreString::store(lang_pack_, s);
}

void langpack_getLanguages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langpack_getLanguages");
    s.store_field("lang_pack", lang_pack_);
    s.store_class_end();
  }
}

langpack_getLanguages::ReturnType langpack_getLanguages::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<langPackLanguage>, 292985073>>, 481674261>::parse(p);
#undef FAIL
}

langpack_getStrings::langpack_getStrings()
  : lang_pack_()
  , lang_code_()
  , keys_()
{}

langpack_getStrings::langpack_getStrings(std::string const &lang_pack_, std::string const &lang_code_, std::vector<std::string> &&keys_)
  : lang_pack_(lang_pack_)
  , lang_code_(lang_code_)
  , keys_(std::move(keys_))
{}

const std::int32_t langpack_getStrings::ID;

void langpack_getStrings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-269862909);
  TlStoreString::store(lang_pack_, s);
  TlStoreString::store(lang_code_, s);
  TlStoreBoxed<TlStoreVector<TlStoreString>, 481674261>::store(keys_, s);
}

void langpack_getStrings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-269862909);
  TlStoreString::store(lang_pack_, s);
  TlStoreString::store(lang_code_, s);
  TlStoreBoxed<TlStoreVector<TlStoreString>, 481674261>::store(keys_, s);
}

void langpack_getStrings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "langpack_getStrings");
    s.store_field("lang_pack", lang_pack_);
    s.store_field("lang_code", lang_code_);
    { const std::vector<std::string> &v = keys_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("keys", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

langpack_getStrings::ReturnType langpack_getStrings::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchObject<LangPackString>>, 481674261>::parse(p);
#undef FAIL
}

messages_acceptEncryption::messages_acceptEncryption()
  : peer_()
  , g_b_()
  , key_fingerprint_()
{}

messages_acceptEncryption::messages_acceptEncryption(object_ptr<inputEncryptedChat> &&peer_, BufferSlice &&g_b_, std::int64_t key_fingerprint_)
  : peer_(std::move(peer_))
  , g_b_(std::move(g_b_))
  , key_fingerprint_(key_fingerprint_)
{}

const std::int32_t messages_acceptEncryption::ID;

void messages_acceptEncryption::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1035731989);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreString::store(g_b_, s);
  TlStoreBinary::store(key_fingerprint_, s);
}

void messages_acceptEncryption::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1035731989);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreString::store(g_b_, s);
  TlStoreBinary::store(key_fingerprint_, s);
}

void messages_acceptEncryption::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_acceptEncryption");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_bytes_field("g_b", g_b_);
    s.store_field("key_fingerprint", key_fingerprint_);
    s.store_class_end();
  }
}

messages_acceptEncryption::ReturnType messages_acceptEncryption::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<EncryptedChat>::parse(p);
#undef FAIL
}

messages_addChatUser::messages_addChatUser()
  : chat_id_()
  , user_id_()
  , fwd_limit_()
{}

messages_addChatUser::messages_addChatUser(std::int32_t chat_id_, object_ptr<InputUser> &&user_id_, std::int32_t fwd_limit_)
  : chat_id_(chat_id_)
  , user_id_(std::move(user_id_))
  , fwd_limit_(fwd_limit_)
{}

const std::int32_t messages_addChatUser::ID;

void messages_addChatUser::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-106911223);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(fwd_limit_, s);
}

void messages_addChatUser::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-106911223);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(fwd_limit_, s);
}

void messages_addChatUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_addChatUser");
    s.store_field("chat_id", chat_id_);
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("fwd_limit", fwd_limit_);
    s.store_class_end();
  }
}

messages_addChatUser::ReturnType messages_addChatUser::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_checkChatInvite::messages_checkChatInvite()
  : hash_()
{}

messages_checkChatInvite::messages_checkChatInvite(std::string const &hash_)
  : hash_(hash_)
{}

const std::int32_t messages_checkChatInvite::ID;

void messages_checkChatInvite::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1051570619);
  TlStoreString::store(hash_, s);
}

void messages_checkChatInvite::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1051570619);
  TlStoreString::store(hash_, s);
}

void messages_checkChatInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_checkChatInvite");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_checkChatInvite::ReturnType messages_checkChatInvite::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<ChatInvite>::parse(p);
#undef FAIL
}

messages_clearAllDrafts::messages_clearAllDrafts() {
}

const std::int32_t messages_clearAllDrafts::ID;

void messages_clearAllDrafts::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(2119757468);
}

void messages_clearAllDrafts::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(2119757468);
}

void messages_clearAllDrafts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_clearAllDrafts");
    s.store_class_end();
  }
}

messages_clearAllDrafts::ReturnType messages_clearAllDrafts::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_clearRecentStickers::messages_clearRecentStickers()
  : flags_()
  , attached_()
{}

messages_clearRecentStickers::messages_clearRecentStickers(std::int32_t flags_, bool attached_)
  : flags_(flags_)
  , attached_(attached_)
{}

const std::int32_t messages_clearRecentStickers::ID;

void messages_clearRecentStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1986437075);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(attached_, s); }
}

void messages_clearRecentStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1986437075);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(attached_, s); }
}

void messages_clearRecentStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_clearRecentStickers");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_class_end();
  }
}

messages_clearRecentStickers::ReturnType messages_clearRecentStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_createChat::messages_createChat()
  : users_()
  , title_()
{}

messages_createChat::messages_createChat(std::vector<object_ptr<InputUser>> &&users_, std::string const &title_)
  : users_(std::move(users_))
  , title_(title_)
{}

const std::int32_t messages_createChat::ID;

void messages_createChat::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(164303470);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(users_, s);
  TlStoreString::store(title_, s);
}

void messages_createChat::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(164303470);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(users_, s);
  TlStoreString::store(title_, s);
}

void messages_createChat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_createChat");
    { const std::vector<object_ptr<InputUser>> &v = users_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("users", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("title", title_);
    s.store_class_end();
  }
}

messages_createChat::ReturnType messages_createChat::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_deleteChatUser::messages_deleteChatUser()
  : chat_id_()
  , user_id_()
{}

messages_deleteChatUser::messages_deleteChatUser(std::int32_t chat_id_, object_ptr<InputUser> &&user_id_)
  : chat_id_(chat_id_)
  , user_id_(std::move(user_id_))
{}

const std::int32_t messages_deleteChatUser::ID;

void messages_deleteChatUser::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-530505962);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void messages_deleteChatUser::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-530505962);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void messages_deleteChatUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_deleteChatUser");
    s.store_field("chat_id", chat_id_);
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_class_end();
  }
}

messages_deleteChatUser::ReturnType messages_deleteChatUser::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_deleteHistory::messages_deleteHistory()
  : flags_()
  , just_clear_()
  , peer_()
  , max_id_()
{}

messages_deleteHistory::messages_deleteHistory(std::int32_t flags_, bool just_clear_, object_ptr<InputPeer> &&peer_, std::int32_t max_id_)
  : flags_(flags_)
  , just_clear_(just_clear_)
  , peer_(std::move(peer_))
  , max_id_(max_id_)
{}

const std::int32_t messages_deleteHistory::ID;

void messages_deleteHistory::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(469850889);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(just_clear_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(max_id_, s);
}

void messages_deleteHistory::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(469850889);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(just_clear_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(max_id_, s);
}

void messages_deleteHistory::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_deleteHistory");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("max_id", max_id_);
    s.store_class_end();
  }
}

messages_deleteHistory::ReturnType messages_deleteHistory::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_affectedHistory>, -1269012015>::parse(p);
#undef FAIL
}

messages_deleteMessages::messages_deleteMessages()
  : flags_()
  , revoke_()
  , id_()
{}

messages_deleteMessages::messages_deleteMessages(std::int32_t flags_, bool revoke_, std::vector<std::int32_t> &&id_)
  : flags_(flags_)
  , revoke_(revoke_)
  , id_(std::move(id_))
{}

const std::int32_t messages_deleteMessages::ID;

void messages_deleteMessages::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-443640366);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(revoke_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void messages_deleteMessages::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-443640366);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(revoke_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void messages_deleteMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_deleteMessages");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_deleteMessages::ReturnType messages_deleteMessages::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_affectedMessages>, -2066640507>::parse(p);
#undef FAIL
}

messages_discardEncryption::messages_discardEncryption()
  : chat_id_()
{}

messages_discardEncryption::messages_discardEncryption(std::int32_t chat_id_)
  : chat_id_(chat_id_)
{}

const std::int32_t messages_discardEncryption::ID;

void messages_discardEncryption::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-304536635);
  TlStoreBinary::store(chat_id_, s);
}

void messages_discardEncryption::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-304536635);
  TlStoreBinary::store(chat_id_, s);
}

void messages_discardEncryption::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_discardEncryption");
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

messages_discardEncryption::ReturnType messages_discardEncryption::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_editChatAdmin::messages_editChatAdmin()
  : chat_id_()
  , user_id_()
  , is_admin_()
{}

messages_editChatAdmin::messages_editChatAdmin(std::int32_t chat_id_, object_ptr<InputUser> &&user_id_, bool is_admin_)
  : chat_id_(chat_id_)
  , user_id_(std::move(user_id_))
  , is_admin_(is_admin_)
{}

const std::int32_t messages_editChatAdmin::ID;

void messages_editChatAdmin::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1444503762);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBool::store(is_admin_, s);
}

void messages_editChatAdmin::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1444503762);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBool::store(is_admin_, s);
}

void messages_editChatAdmin::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_editChatAdmin");
    s.store_field("chat_id", chat_id_);
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("is_admin", is_admin_);
    s.store_class_end();
  }
}

messages_editChatAdmin::ReturnType messages_editChatAdmin::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_editChatPhoto::messages_editChatPhoto()
  : chat_id_()
  , photo_()
{}

messages_editChatPhoto::messages_editChatPhoto(std::int32_t chat_id_, object_ptr<InputChatPhoto> &&photo_)
  : chat_id_(chat_id_)
  , photo_(std::move(photo_))
{}

const std::int32_t messages_editChatPhoto::ID;

void messages_editChatPhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-900957736);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(photo_, s);
}

void messages_editChatPhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-900957736);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(photo_, s);
}

void messages_editChatPhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_editChatPhoto");
    s.store_field("chat_id", chat_id_);
    if (photo_ == nullptr) { s.store_field("photo", "null"); } else { photo_->store(s, "photo"); }
    s.store_class_end();
  }
}

messages_editChatPhoto::ReturnType messages_editChatPhoto::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_editChatTitle::messages_editChatTitle()
  : chat_id_()
  , title_()
{}

messages_editChatTitle::messages_editChatTitle(std::int32_t chat_id_, std::string const &title_)
  : chat_id_(chat_id_)
  , title_(title_)
{}

const std::int32_t messages_editChatTitle::ID;

void messages_editChatTitle::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-599447467);
  TlStoreBinary::store(chat_id_, s);
  TlStoreString::store(title_, s);
}

void messages_editChatTitle::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-599447467);
  TlStoreBinary::store(chat_id_, s);
  TlStoreString::store(title_, s);
}

void messages_editChatTitle::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_editChatTitle");
    s.store_field("chat_id", chat_id_);
    s.store_field("title", title_);
    s.store_class_end();
  }
}

messages_editChatTitle::ReturnType messages_editChatTitle::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_editInlineBotMessage::messages_editInlineBotMessage()
  : flags_()
  , no_webpage_()
  , stop_geo_live_()
  , id_()
  , message_()
  , media_()
  , reply_markup_()
  , entities_()
  , geo_point_()
{}

messages_editInlineBotMessage::messages_editInlineBotMessage(std::int32_t flags_, bool no_webpage_, bool stop_geo_live_, object_ptr<inputBotInlineMessageID> &&id_, std::string const &message_, object_ptr<InputMedia> &&media_, object_ptr<ReplyMarkup> &&reply_markup_, std::vector<object_ptr<MessageEntity>> &&entities_, object_ptr<InputGeoPoint> &&geo_point_)
  : flags_(flags_)
  , no_webpage_(no_webpage_)
  , stop_geo_live_(stop_geo_live_)
  , id_(std::move(id_))
  , message_(message_)
  , media_(std::move(media_))
  , reply_markup_(std::move(reply_markup_))
  , entities_(std::move(entities_))
  , geo_point_(std::move(geo_point_))
{}

const std::int32_t messages_editInlineBotMessage::ID;

void messages_editInlineBotMessage::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1379669976);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(no_webpage_, s); }
  if (var0 & 4096) { TlStoreTrue::store(stop_geo_live_, s); }
  TlStoreBoxed<TlStoreObject, -1995686519>::store(id_, s);
  if (var0 & 2048) { TlStoreString::store(message_, s); }
  if (var0 & 16384) { TlStoreBoxedUnknown<TlStoreObject>::store(media_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
  if (var0 & 8192) { TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s); }
}

void messages_editInlineBotMessage::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1379669976);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(no_webpage_, s); }
  if (var0 & 4096) { TlStoreTrue::store(stop_geo_live_, s); }
  TlStoreBoxed<TlStoreObject, -1995686519>::store(id_, s);
  if (var0 & 2048) { TlStoreString::store(message_, s); }
  if (var0 & 16384) { TlStoreBoxedUnknown<TlStoreObject>::store(media_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
  if (var0 & 8192) { TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s); }
}

void messages_editInlineBotMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_editInlineBotMessage");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 4096) {  }
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    if (var0 & 2048) { s.store_field("message", message_); }
    if (var0 & 16384) { if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); } }
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    if (var0 & 8) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 8192) { if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); } }
    s.store_class_end();
  }
}

messages_editInlineBotMessage::ReturnType messages_editInlineBotMessage::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_editMessage::messages_editMessage()
  : flags_()
  , no_webpage_()
  , stop_geo_live_()
  , peer_()
  , id_()
  , message_()
  , media_()
  , reply_markup_()
  , entities_()
  , geo_point_()
{}

messages_editMessage::messages_editMessage(std::int32_t flags_, bool no_webpage_, bool stop_geo_live_, object_ptr<InputPeer> &&peer_, std::int32_t id_, std::string const &message_, object_ptr<InputMedia> &&media_, object_ptr<ReplyMarkup> &&reply_markup_, std::vector<object_ptr<MessageEntity>> &&entities_, object_ptr<InputGeoPoint> &&geo_point_)
  : flags_(flags_)
  , no_webpage_(no_webpage_)
  , stop_geo_live_(stop_geo_live_)
  , peer_(std::move(peer_))
  , id_(id_)
  , message_(message_)
  , media_(std::move(media_))
  , reply_markup_(std::move(reply_markup_))
  , entities_(std::move(entities_))
  , geo_point_(std::move(geo_point_))
{}

const std::int32_t messages_editMessage::ID;

void messages_editMessage::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1073683256);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(no_webpage_, s); }
  if (var0 & 4096) { TlStoreTrue::store(stop_geo_live_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(id_, s);
  if (var0 & 2048) { TlStoreString::store(message_, s); }
  if (var0 & 16384) { TlStoreBoxedUnknown<TlStoreObject>::store(media_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
  if (var0 & 8192) { TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s); }
}

void messages_editMessage::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1073683256);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(no_webpage_, s); }
  if (var0 & 4096) { TlStoreTrue::store(stop_geo_live_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(id_, s);
  if (var0 & 2048) { TlStoreString::store(message_, s); }
  if (var0 & 16384) { TlStoreBoxedUnknown<TlStoreObject>::store(media_, s); }
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
  if (var0 & 8192) { TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s); }
}

void messages_editMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_editMessage");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 4096) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("id", id_);
    if (var0 & 2048) { s.store_field("message", message_); }
    if (var0 & 16384) { if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); } }
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    if (var0 & 8) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    if (var0 & 8192) { if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); } }
    s.store_class_end();
  }
}

messages_editMessage::ReturnType messages_editMessage::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_exportChatInvite::messages_exportChatInvite()
  : chat_id_()
{}

messages_exportChatInvite::messages_exportChatInvite(std::int32_t chat_id_)
  : chat_id_(chat_id_)
{}

const std::int32_t messages_exportChatInvite::ID;

void messages_exportChatInvite::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(2106086025);
  TlStoreBinary::store(chat_id_, s);
}

void messages_exportChatInvite::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(2106086025);
  TlStoreBinary::store(chat_id_, s);
}

void messages_exportChatInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_exportChatInvite");
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

messages_exportChatInvite::ReturnType messages_exportChatInvite::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<ExportedChatInvite>::parse(p);
#undef FAIL
}

messages_faveSticker::messages_faveSticker()
  : id_()
  , unfave_()
{}

messages_faveSticker::messages_faveSticker(object_ptr<InputDocument> &&id_, bool unfave_)
  : id_(std::move(id_))
  , unfave_(unfave_)
{}

const std::int32_t messages_faveSticker::ID;

void messages_faveSticker::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1174420133);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  TlStoreBool::store(unfave_, s);
}

void messages_faveSticker::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1174420133);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  TlStoreBool::store(unfave_, s);
}

void messages_faveSticker::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_faveSticker");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_field("unfave", unfave_);
    s.store_class_end();
  }
}

messages_faveSticker::ReturnType messages_faveSticker::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_forwardMessages::messages_forwardMessages()
  : flags_()
  , silent_()
  , background_()
  , with_my_score_()
  , grouped_()
  , from_peer_()
  , id_()
  , random_id_()
  , to_peer_()
{}

messages_forwardMessages::messages_forwardMessages(std::int32_t flags_, bool silent_, bool background_, bool with_my_score_, bool grouped_, object_ptr<InputPeer> &&from_peer_, std::vector<std::int32_t> &&id_, std::vector<std::int64_t> &&random_id_, object_ptr<InputPeer> &&to_peer_)
  : flags_(flags_)
  , silent_(silent_)
  , background_(background_)
  , with_my_score_(with_my_score_)
  , grouped_(grouped_)
  , from_peer_(std::move(from_peer_))
  , id_(std::move(id_))
  , random_id_(std::move(random_id_))
  , to_peer_(std::move(to_peer_))
{}

const std::int32_t messages_forwardMessages::ID;

void messages_forwardMessages::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1888354709);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 256) { TlStoreTrue::store(with_my_score_, s); }
  if (var0 & 512) { TlStoreTrue::store(grouped_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(from_peer_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(random_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(to_peer_, s);
}

void messages_forwardMessages::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1888354709);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 256) { TlStoreTrue::store(with_my_score_, s); }
  if (var0 & 512) { TlStoreTrue::store(grouped_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(from_peer_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(random_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(to_peer_, s);
}

void messages_forwardMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_forwardMessages");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 256) {  }
    if (var0 & 512) {  }
    if (from_peer_ == nullptr) { s.store_field("from_peer", "null"); } else { from_peer_->store(s, "from_peer"); }
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    { const std::vector<std::int64_t> &v = random_id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("random_id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    if (to_peer_ == nullptr) { s.store_field("to_peer", "null"); } else { to_peer_->store(s, "to_peer"); }
    s.store_class_end();
  }
}

messages_forwardMessages::ReturnType messages_forwardMessages::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_getAllChats::messages_getAllChats()
  : except_ids_()
{}

messages_getAllChats::messages_getAllChats(std::vector<std::int32_t> &&except_ids_)
  : except_ids_(std::move(except_ids_))
{}

const std::int32_t messages_getAllChats::ID;

void messages_getAllChats::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-341307408);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(except_ids_, s);
}

void messages_getAllChats::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-341307408);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(except_ids_, s);
}

void messages_getAllChats::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getAllChats");
    { const std::vector<std::int32_t> &v = except_ids_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("except_ids", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_getAllChats::ReturnType messages_getAllChats::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Chats>::parse(p);
#undef FAIL
}

messages_getAllDrafts::messages_getAllDrafts() {
}

const std::int32_t messages_getAllDrafts::ID;

void messages_getAllDrafts::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1782549861);
}

void messages_getAllDrafts::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1782549861);
}

void messages_getAllDrafts::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getAllDrafts");
    s.store_class_end();
  }
}

messages_getAllDrafts::ReturnType messages_getAllDrafts::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_getAllStickers::messages_getAllStickers()
  : hash_()
{}

messages_getAllStickers::messages_getAllStickers(std::int32_t hash_)
  : hash_(hash_)
{}

const std::int32_t messages_getAllStickers::ID;

void messages_getAllStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(479598769);
  TlStoreBinary::store(hash_, s);
}

void messages_getAllStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(479598769);
  TlStoreBinary::store(hash_, s);
}

void messages_getAllStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getAllStickers");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getAllStickers::ReturnType messages_getAllStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_AllStickers>::parse(p);
#undef FAIL
}

messages_getArchivedStickers::messages_getArchivedStickers()
  : flags_()
  , masks_()
  , offset_id_()
  , limit_()
{}

messages_getArchivedStickers::messages_getArchivedStickers(std::int32_t flags_, bool masks_, std::int64_t offset_id_, std::int32_t limit_)
  : flags_(flags_)
  , masks_(masks_)
  , offset_id_(offset_id_)
  , limit_(limit_)
{}

const std::int32_t messages_getArchivedStickers::ID;

void messages_getArchivedStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1475442322);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(masks_, s); }
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(limit_, s);
}

void messages_getArchivedStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1475442322);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(masks_, s); }
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(limit_, s);
}

void messages_getArchivedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getArchivedStickers");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("offset_id", offset_id_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

messages_getArchivedStickers::ReturnType messages_getArchivedStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_archivedStickers>, 1338747336>::parse(p);
#undef FAIL
}

messages_getAttachedStickers::messages_getAttachedStickers()
  : media_()
{}

messages_getAttachedStickers::messages_getAttachedStickers(object_ptr<InputStickeredMedia> &&media_)
  : media_(std::move(media_))
{}

const std::int32_t messages_getAttachedStickers::ID;

void messages_getAttachedStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-866424884);
  TlStoreBoxedUnknown<TlStoreObject>::store(media_, s);
}

void messages_getAttachedStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-866424884);
  TlStoreBoxedUnknown<TlStoreObject>::store(media_, s);
}

void messages_getAttachedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getAttachedStickers");
    if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); }
    s.store_class_end();
  }
}

messages_getAttachedStickers::ReturnType messages_getAttachedStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchObject<StickerSetCovered>>, 481674261>::parse(p);
#undef FAIL
}

messages_getBotCallbackAnswer::messages_getBotCallbackAnswer()
  : flags_()
  , game_()
  , peer_()
  , msg_id_()
  , data_()
{}

messages_getBotCallbackAnswer::messages_getBotCallbackAnswer(std::int32_t flags_, bool game_, object_ptr<InputPeer> &&peer_, std::int32_t msg_id_, BufferSlice &&data_)
  : flags_(flags_)
  , game_(game_)
  , peer_(std::move(peer_))
  , msg_id_(msg_id_)
  , data_(std::move(data_))
{}

const std::int32_t messages_getBotCallbackAnswer::ID;

void messages_getBotCallbackAnswer::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2130010132);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(game_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(msg_id_, s);
  if (var0 & 1) { TlStoreString::store(data_, s); }
}

void messages_getBotCallbackAnswer::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2130010132);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(game_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(msg_id_, s);
  if (var0 & 1) { TlStoreString::store(data_, s); }
}

void messages_getBotCallbackAnswer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getBotCallbackAnswer");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("msg_id", msg_id_);
    if (var0 & 1) { s.store_bytes_field("data", data_); }
    s.store_class_end();
  }
}

messages_getBotCallbackAnswer::ReturnType messages_getBotCallbackAnswer::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_botCallbackAnswer>, 911761060>::parse(p);
#undef FAIL
}

messages_getChats::messages_getChats()
  : id_()
{}

messages_getChats::messages_getChats(std::vector<std::int32_t> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t messages_getChats::ID;

void messages_getChats::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1013621127);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void messages_getChats::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1013621127);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void messages_getChats::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getChats");
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_getChats::ReturnType messages_getChats::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Chats>::parse(p);
#undef FAIL
}

messages_getCommonChats::messages_getCommonChats()
  : user_id_()
  , max_id_()
  , limit_()
{}

messages_getCommonChats::messages_getCommonChats(object_ptr<InputUser> &&user_id_, std::int32_t max_id_, std::int32_t limit_)
  : user_id_(std::move(user_id_))
  , max_id_(max_id_)
  , limit_(limit_)
{}

const std::int32_t messages_getCommonChats::ID;

void messages_getCommonChats::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(218777796);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(limit_, s);
}

void messages_getCommonChats::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(218777796);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(limit_, s);
}

void messages_getCommonChats::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getCommonChats");
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("max_id", max_id_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

messages_getCommonChats::ReturnType messages_getCommonChats::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Chats>::parse(p);
#undef FAIL
}

messages_getDhConfig::messages_getDhConfig()
  : version_()
  , random_length_()
{}

messages_getDhConfig::messages_getDhConfig(std::int32_t version_, std::int32_t random_length_)
  : version_(version_)
  , random_length_(random_length_)
{}

const std::int32_t messages_getDhConfig::ID;

void messages_getDhConfig::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(651135312);
  TlStoreBinary::store(version_, s);
  TlStoreBinary::store(random_length_, s);
}

void messages_getDhConfig::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(651135312);
  TlStoreBinary::store(version_, s);
  TlStoreBinary::store(random_length_, s);
}

void messages_getDhConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getDhConfig");
    s.store_field("version", version_);
    s.store_field("random_length", random_length_);
    s.store_class_end();
  }
}

messages_getDhConfig::ReturnType messages_getDhConfig::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_DhConfig>::parse(p);
#undef FAIL
}

messages_getDialogUnreadMarks::messages_getDialogUnreadMarks() {
}

const std::int32_t messages_getDialogUnreadMarks::ID;

void messages_getDialogUnreadMarks::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(585256482);
}

void messages_getDialogUnreadMarks::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(585256482);
}

void messages_getDialogUnreadMarks::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getDialogUnreadMarks");
    s.store_class_end();
  }
}

messages_getDialogUnreadMarks::ReturnType messages_getDialogUnreadMarks::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<dialogPeer>, -445792507>>, 481674261>::parse(p);
#undef FAIL
}

messages_getDialogs::messages_getDialogs()
  : flags_()
  , exclude_pinned_()
  , offset_date_()
  , offset_id_()
  , offset_peer_()
  , limit_()
  , hash_()
{}

messages_getDialogs::messages_getDialogs(std::int32_t flags_, bool exclude_pinned_, std::int32_t offset_date_, std::int32_t offset_id_, object_ptr<InputPeer> &&offset_peer_, std::int32_t limit_, std::int32_t hash_)
  : flags_(flags_)
  , exclude_pinned_(exclude_pinned_)
  , offset_date_(offset_date_)
  , offset_id_(offset_id_)
  , offset_peer_(std::move(offset_peer_))
  , limit_(limit_)
  , hash_(hash_)
{}

const std::int32_t messages_getDialogs::ID;

void messages_getDialogs::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1332171034);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(exclude_pinned_, s); }
  TlStoreBinary::store(offset_date_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(offset_peer_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getDialogs::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1332171034);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(exclude_pinned_, s); }
  TlStoreBinary::store(offset_date_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(offset_peer_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getDialogs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getDialogs");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("offset_date", offset_date_);
    s.store_field("offset_id", offset_id_);
    if (offset_peer_ == nullptr) { s.store_field("offset_peer", "null"); } else { offset_peer_->store(s, "offset_peer"); }
    s.store_field("limit", limit_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getDialogs::ReturnType messages_getDialogs::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Dialogs>::parse(p);
#undef FAIL
}

messages_getDocumentByHash::messages_getDocumentByHash()
  : sha256_()
  , size_()
  , mime_type_()
{}

messages_getDocumentByHash::messages_getDocumentByHash(BufferSlice &&sha256_, std::int32_t size_, std::string const &mime_type_)
  : sha256_(std::move(sha256_))
  , size_(size_)
  , mime_type_(mime_type_)
{}

const std::int32_t messages_getDocumentByHash::ID;

void messages_getDocumentByHash::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(864953444);
  TlStoreString::store(sha256_, s);
  TlStoreBinary::store(size_, s);
  TlStoreString::store(mime_type_, s);
}

void messages_getDocumentByHash::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(864953444);
  TlStoreString::store(sha256_, s);
  TlStoreBinary::store(size_, s);
  TlStoreString::store(mime_type_, s);
}

void messages_getDocumentByHash::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getDocumentByHash");
    s.store_bytes_field("sha256", sha256_);
    s.store_field("size", size_);
    s.store_field("mime_type", mime_type_);
    s.store_class_end();
  }
}

messages_getDocumentByHash::ReturnType messages_getDocumentByHash::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Document>::parse(p);
#undef FAIL
}

messages_getFavedStickers::messages_getFavedStickers()
  : hash_()
{}

messages_getFavedStickers::messages_getFavedStickers(std::int32_t hash_)
  : hash_(hash_)
{}

const std::int32_t messages_getFavedStickers::ID;

void messages_getFavedStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(567151374);
  TlStoreBinary::store(hash_, s);
}

void messages_getFavedStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(567151374);
  TlStoreBinary::store(hash_, s);
}

void messages_getFavedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getFavedStickers");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getFavedStickers::ReturnType messages_getFavedStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_FavedStickers>::parse(p);
#undef FAIL
}

messages_getFeaturedStickers::messages_getFeaturedStickers()
  : hash_()
{}

messages_getFeaturedStickers::messages_getFeaturedStickers(std::int32_t hash_)
  : hash_(hash_)
{}

const std::int32_t messages_getFeaturedStickers::ID;

void messages_getFeaturedStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(766298703);
  TlStoreBinary::store(hash_, s);
}

void messages_getFeaturedStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(766298703);
  TlStoreBinary::store(hash_, s);
}

void messages_getFeaturedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getFeaturedStickers");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getFeaturedStickers::ReturnType messages_getFeaturedStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_FeaturedStickers>::parse(p);
#undef FAIL
}

messages_getFullChat::messages_getFullChat()
  : chat_id_()
{}

messages_getFullChat::messages_getFullChat(std::int32_t chat_id_)
  : chat_id_(chat_id_)
{}

const std::int32_t messages_getFullChat::ID;

void messages_getFullChat::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(998448230);
  TlStoreBinary::store(chat_id_, s);
}

void messages_getFullChat::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(998448230);
  TlStoreBinary::store(chat_id_, s);
}

void messages_getFullChat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getFullChat");
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

messages_getFullChat::ReturnType messages_getFullChat::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_chatFull>, -438840932>::parse(p);
#undef FAIL
}

messages_getGameHighScores::messages_getGameHighScores()
  : peer_()
  , id_()
  , user_id_()
{}

messages_getGameHighScores::messages_getGameHighScores(object_ptr<InputPeer> &&peer_, std::int32_t id_, object_ptr<InputUser> &&user_id_)
  : peer_(std::move(peer_))
  , id_(id_)
  , user_id_(std::move(user_id_))
{}

const std::int32_t messages_getGameHighScores::ID;

void messages_getGameHighScores::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-400399203);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void messages_getGameHighScores::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-400399203);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void messages_getGameHighScores::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getGameHighScores");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("id", id_);
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_class_end();
  }
}

messages_getGameHighScores::ReturnType messages_getGameHighScores::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_highScores>, -1707344487>::parse(p);
#undef FAIL
}

messages_getHistory::messages_getHistory()
  : peer_()
  , offset_id_()
  , offset_date_()
  , add_offset_()
  , limit_()
  , max_id_()
  , min_id_()
  , hash_()
{}

messages_getHistory::messages_getHistory(object_ptr<InputPeer> &&peer_, std::int32_t offset_id_, std::int32_t offset_date_, std::int32_t add_offset_, std::int32_t limit_, std::int32_t max_id_, std::int32_t min_id_, std::int32_t hash_)
  : peer_(std::move(peer_))
  , offset_id_(offset_id_)
  , offset_date_(offset_date_)
  , add_offset_(add_offset_)
  , limit_(limit_)
  , max_id_(max_id_)
  , min_id_(min_id_)
  , hash_(hash_)
{}

const std::int32_t messages_getHistory::ID;

void messages_getHistory::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-591691168);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(offset_date_, s);
  TlStoreBinary::store(add_offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(min_id_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getHistory::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-591691168);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(offset_date_, s);
  TlStoreBinary::store(add_offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(min_id_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getHistory::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getHistory");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("offset_id", offset_id_);
    s.store_field("offset_date", offset_date_);
    s.store_field("add_offset", add_offset_);
    s.store_field("limit", limit_);
    s.store_field("max_id", max_id_);
    s.store_field("min_id", min_id_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getHistory::ReturnType messages_getHistory::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Messages>::parse(p);
#undef FAIL
}

messages_getInlineBotResults::messages_getInlineBotResults()
  : flags_()
  , bot_()
  , peer_()
  , geo_point_()
  , query_()
  , offset_()
{}

messages_getInlineBotResults::messages_getInlineBotResults(std::int32_t flags_, object_ptr<InputUser> &&bot_, object_ptr<InputPeer> &&peer_, object_ptr<InputGeoPoint> &&geo_point_, std::string const &query_, std::string const &offset_)
  : flags_(flags_)
  , bot_(std::move(bot_))
  , peer_(std::move(peer_))
  , geo_point_(std::move(geo_point_))
  , query_(query_)
  , offset_(offset_)
{}

const std::int32_t messages_getInlineBotResults::ID;

void messages_getInlineBotResults::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1364105629);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(bot_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s); }
  TlStoreString::store(query_, s);
  TlStoreString::store(offset_, s);
}

void messages_getInlineBotResults::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1364105629);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(bot_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBoxedUnknown<TlStoreObject>::store(geo_point_, s); }
  TlStoreString::store(query_, s);
  TlStoreString::store(offset_, s);
}

void messages_getInlineBotResults::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getInlineBotResults");
    s.store_field("flags", (var0 = flags_));
    if (bot_ == nullptr) { s.store_field("bot", "null"); } else { bot_->store(s, "bot"); }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (var0 & 1) { if (geo_point_ == nullptr) { s.store_field("geo_point", "null"); } else { geo_point_->store(s, "geo_point"); } }
    s.store_field("query", query_);
    s.store_field("offset", offset_);
    s.store_class_end();
  }
}

messages_getInlineBotResults::ReturnType messages_getInlineBotResults::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_botResults>, -1803769784>::parse(p);
#undef FAIL
}

messages_getInlineGameHighScores::messages_getInlineGameHighScores()
  : id_()
  , user_id_()
{}

messages_getInlineGameHighScores::messages_getInlineGameHighScores(object_ptr<inputBotInlineMessageID> &&id_, object_ptr<InputUser> &&user_id_)
  : id_(std::move(id_))
  , user_id_(std::move(user_id_))
{}

const std::int32_t messages_getInlineGameHighScores::ID;

void messages_getInlineGameHighScores::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(258170395);
  TlStoreBoxed<TlStoreObject, -1995686519>::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void messages_getInlineGameHighScores::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(258170395);
  TlStoreBoxed<TlStoreObject, -1995686519>::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
}

void messages_getInlineGameHighScores::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getInlineGameHighScores");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_class_end();
  }
}

messages_getInlineGameHighScores::ReturnType messages_getInlineGameHighScores::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_highScores>, -1707344487>::parse(p);
#undef FAIL
}

messages_getMaskStickers::messages_getMaskStickers()
  : hash_()
{}

messages_getMaskStickers::messages_getMaskStickers(std::int32_t hash_)
  : hash_(hash_)
{}

const std::int32_t messages_getMaskStickers::ID;

void messages_getMaskStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1706608543);
  TlStoreBinary::store(hash_, s);
}

void messages_getMaskStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1706608543);
  TlStoreBinary::store(hash_, s);
}

void messages_getMaskStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getMaskStickers");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getMaskStickers::ReturnType messages_getMaskStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_AllStickers>::parse(p);
#undef FAIL
}

messages_getMessageEditData::messages_getMessageEditData()
  : peer_()
  , id_()
{}

messages_getMessageEditData::messages_getMessageEditData(object_ptr<InputPeer> &&peer_, std::int32_t id_)
  : peer_(std::move(peer_))
  , id_(id_)
{}

const std::int32_t messages_getMessageEditData::ID;

void messages_getMessageEditData::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-39416522);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(id_, s);
}

void messages_getMessageEditData::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-39416522);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(id_, s);
}

void messages_getMessageEditData::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getMessageEditData");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("id", id_);
    s.store_class_end();
  }
}

messages_getMessageEditData::ReturnType messages_getMessageEditData::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_messageEditData>, 649453030>::parse(p);
#undef FAIL
}

messages_getMessages::messages_getMessages()
  : id_()
{}

messages_getMessages::messages_getMessages(std::vector<object_ptr<InputMessage>> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t messages_getMessages::ID;

void messages_getMessages::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1673946374);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void messages_getMessages::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1673946374);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void messages_getMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getMessages");
    { const std::vector<object_ptr<InputMessage>> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_getMessages::ReturnType messages_getMessages::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Messages>::parse(p);
#undef FAIL
}

messages_getMessagesViews::messages_getMessagesViews()
  : peer_()
  , id_()
  , increment_()
{}

messages_getMessagesViews::messages_getMessagesViews(object_ptr<InputPeer> &&peer_, std::vector<std::int32_t> &&id_, bool increment_)
  : peer_(std::move(peer_))
  , id_(std::move(id_))
  , increment_(increment_)
{}

const std::int32_t messages_getMessagesViews::ID;

void messages_getMessagesViews::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-993483427);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
  TlStoreBool::store(increment_, s);
}

void messages_getMessagesViews::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-993483427);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
  TlStoreBool::store(increment_, s);
}

void messages_getMessagesViews::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getMessagesViews");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_field("increment", increment_);
    s.store_class_end();
  }
}

messages_getMessagesViews::ReturnType messages_getMessagesViews::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchInt>, 481674261>::parse(p);
#undef FAIL
}

messages_getPeerDialogs::messages_getPeerDialogs()
  : peers_()
{}

messages_getPeerDialogs::messages_getPeerDialogs(std::vector<object_ptr<inputDialogPeer>> &&peers_)
  : peers_(std::move(peers_))
{}

const std::int32_t messages_getPeerDialogs::ID;

void messages_getPeerDialogs::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-462373635);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -55902537>>, 481674261>::store(peers_, s);
}

void messages_getPeerDialogs::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-462373635);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -55902537>>, 481674261>::store(peers_, s);
}

void messages_getPeerDialogs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getPeerDialogs");
    { const std::vector<object_ptr<inputDialogPeer>> &v = peers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("peers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_getPeerDialogs::ReturnType messages_getPeerDialogs::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_peerDialogs>, 863093588>::parse(p);
#undef FAIL
}

messages_getPeerSettings::messages_getPeerSettings()
  : peer_()
{}

messages_getPeerSettings::messages_getPeerSettings(object_ptr<InputPeer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t messages_getPeerSettings::ID;

void messages_getPeerSettings::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(913498268);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void messages_getPeerSettings::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(913498268);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void messages_getPeerSettings::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getPeerSettings");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

messages_getPeerSettings::ReturnType messages_getPeerSettings::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<peerSettings>, -2122045747>::parse(p);
#undef FAIL
}

messages_getPinnedDialogs::messages_getPinnedDialogs() {
}

const std::int32_t messages_getPinnedDialogs::ID;

void messages_getPinnedDialogs::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-497756594);
}

void messages_getPinnedDialogs::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-497756594);
}

void messages_getPinnedDialogs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getPinnedDialogs");
    s.store_class_end();
  }
}

messages_getPinnedDialogs::ReturnType messages_getPinnedDialogs::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_peerDialogs>, 863093588>::parse(p);
#undef FAIL
}

messages_getRecentLocations::messages_getRecentLocations()
  : peer_()
  , limit_()
  , hash_()
{}

messages_getRecentLocations::messages_getRecentLocations(object_ptr<InputPeer> &&peer_, std::int32_t limit_, std::int32_t hash_)
  : peer_(std::move(peer_))
  , limit_(limit_)
  , hash_(hash_)
{}

const std::int32_t messages_getRecentLocations::ID;

void messages_getRecentLocations::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1144759543);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getRecentLocations::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1144759543);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getRecentLocations::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getRecentLocations");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("limit", limit_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getRecentLocations::ReturnType messages_getRecentLocations::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Messages>::parse(p);
#undef FAIL
}

messages_getRecentStickers::messages_getRecentStickers()
  : flags_()
  , attached_()
  , hash_()
{}

messages_getRecentStickers::messages_getRecentStickers(std::int32_t flags_, bool attached_, std::int32_t hash_)
  : flags_(flags_)
  , attached_(attached_)
  , hash_(hash_)
{}

const std::int32_t messages_getRecentStickers::ID;

void messages_getRecentStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1587647177);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(attached_, s); }
  TlStoreBinary::store(hash_, s);
}

void messages_getRecentStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1587647177);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(attached_, s); }
  TlStoreBinary::store(hash_, s);
}

void messages_getRecentStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getRecentStickers");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getRecentStickers::ReturnType messages_getRecentStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_RecentStickers>::parse(p);
#undef FAIL
}

messages_getSavedGifs::messages_getSavedGifs()
  : hash_()
{}

messages_getSavedGifs::messages_getSavedGifs(std::int32_t hash_)
  : hash_(hash_)
{}

const std::int32_t messages_getSavedGifs::ID;

void messages_getSavedGifs::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2084618926);
  TlStoreBinary::store(hash_, s);
}

void messages_getSavedGifs::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2084618926);
  TlStoreBinary::store(hash_, s);
}

void messages_getSavedGifs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getSavedGifs");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getSavedGifs::ReturnType messages_getSavedGifs::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_SavedGifs>::parse(p);
#undef FAIL
}

messages_getSplitRanges::messages_getSplitRanges() {
}

const std::int32_t messages_getSplitRanges::ID;

void messages_getSplitRanges::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(486505992);
}

void messages_getSplitRanges::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(486505992);
}

void messages_getSplitRanges::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getSplitRanges");
    s.store_class_end();
  }
}

messages_getSplitRanges::ReturnType messages_getSplitRanges::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<messageRange>, 182649427>>, 481674261>::parse(p);
#undef FAIL
}

messages_getStickerSet::messages_getStickerSet()
  : stickerset_()
{}

messages_getStickerSet::messages_getStickerSet(object_ptr<InputStickerSet> &&stickerset_)
  : stickerset_(std::move(stickerset_))
{}

const std::int32_t messages_getStickerSet::ID;

void messages_getStickerSet::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(639215886);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
}

void messages_getStickerSet::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(639215886);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
}

void messages_getStickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getStickerSet");
    if (stickerset_ == nullptr) { s.store_field("stickerset", "null"); } else { stickerset_->store(s, "stickerset"); }
    s.store_class_end();
  }
}

messages_getStickerSet::ReturnType messages_getStickerSet::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_stickerSet>, -1240849242>::parse(p);
#undef FAIL
}

messages_getStickers::messages_getStickers()
  : emoticon_()
  , hash_()
{}

messages_getStickers::messages_getStickers(std::string const &emoticon_, std::int32_t hash_)
  : emoticon_(emoticon_)
  , hash_(hash_)
{}

const std::int32_t messages_getStickers::ID;

void messages_getStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(71126828);
  TlStoreString::store(emoticon_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(71126828);
  TlStoreString::store(emoticon_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getStickers");
    s.store_field("emoticon", emoticon_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getStickers::ReturnType messages_getStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Stickers>::parse(p);
#undef FAIL
}

messages_getUnreadMentions::messages_getUnreadMentions()
  : peer_()
  , offset_id_()
  , add_offset_()
  , limit_()
  , max_id_()
  , min_id_()
{}

messages_getUnreadMentions::messages_getUnreadMentions(object_ptr<InputPeer> &&peer_, std::int32_t offset_id_, std::int32_t add_offset_, std::int32_t limit_, std::int32_t max_id_, std::int32_t min_id_)
  : peer_(std::move(peer_))
  , offset_id_(offset_id_)
  , add_offset_(add_offset_)
  , limit_(limit_)
  , max_id_(max_id_)
  , min_id_(min_id_)
{}

const std::int32_t messages_getUnreadMentions::ID;

void messages_getUnreadMentions::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1180140658);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(add_offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(min_id_, s);
}

void messages_getUnreadMentions::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1180140658);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(add_offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(min_id_, s);
}

void messages_getUnreadMentions::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getUnreadMentions");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("offset_id", offset_id_);
    s.store_field("add_offset", add_offset_);
    s.store_field("limit", limit_);
    s.store_field("max_id", max_id_);
    s.store_field("min_id", min_id_);
    s.store_class_end();
  }
}

messages_getUnreadMentions::ReturnType messages_getUnreadMentions::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Messages>::parse(p);
#undef FAIL
}

messages_getWebPage::messages_getWebPage()
  : url_()
  , hash_()
{}

messages_getWebPage::messages_getWebPage(std::string const &url_, std::int32_t hash_)
  : url_(url_)
  , hash_(hash_)
{}

const std::int32_t messages_getWebPage::ID;

void messages_getWebPage::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(852135825);
  TlStoreString::store(url_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getWebPage::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(852135825);
  TlStoreString::store(url_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_getWebPage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getWebPage");
    s.store_field("url", url_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_getWebPage::ReturnType messages_getWebPage::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<WebPage>::parse(p);
#undef FAIL
}

messages_getWebPagePreview::messages_getWebPagePreview()
  : flags_()
  , message_()
  , entities_()
{}

messages_getWebPagePreview::messages_getWebPagePreview(std::int32_t flags_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , message_(message_)
  , entities_(std::move(entities_))
{}

const std::int32_t messages_getWebPagePreview::ID;

void messages_getWebPagePreview::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1956073268);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(message_, s);
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void messages_getWebPagePreview::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1956073268);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreString::store(message_, s);
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void messages_getWebPagePreview::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_getWebPagePreview");
    s.store_field("flags", (var0 = flags_));
    s.store_field("message", message_);
    if (var0 & 8) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

messages_getWebPagePreview::ReturnType messages_getWebPagePreview::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<MessageMedia>::parse(p);
#undef FAIL
}

messages_hideReportSpam::messages_hideReportSpam()
  : peer_()
{}

messages_hideReportSpam::messages_hideReportSpam(object_ptr<InputPeer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t messages_hideReportSpam::ID;

void messages_hideReportSpam::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1460572005);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void messages_hideReportSpam::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1460572005);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void messages_hideReportSpam::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_hideReportSpam");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

messages_hideReportSpam::ReturnType messages_hideReportSpam::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_importChatInvite::messages_importChatInvite()
  : hash_()
{}

messages_importChatInvite::messages_importChatInvite(std::string const &hash_)
  : hash_(hash_)
{}

const std::int32_t messages_importChatInvite::ID;

void messages_importChatInvite::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1817183516);
  TlStoreString::store(hash_, s);
}

void messages_importChatInvite::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1817183516);
  TlStoreString::store(hash_, s);
}

void messages_importChatInvite::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_importChatInvite");
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_importChatInvite::ReturnType messages_importChatInvite::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_installStickerSet::messages_installStickerSet()
  : stickerset_()
  , archived_()
{}

messages_installStickerSet::messages_installStickerSet(object_ptr<InputStickerSet> &&stickerset_, bool archived_)
  : stickerset_(std::move(stickerset_))
  , archived_(archived_)
{}

const std::int32_t messages_installStickerSet::ID;

void messages_installStickerSet::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-946871200);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
  TlStoreBool::store(archived_, s);
}

void messages_installStickerSet::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-946871200);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
  TlStoreBool::store(archived_, s);
}

void messages_installStickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_installStickerSet");
    if (stickerset_ == nullptr) { s.store_field("stickerset", "null"); } else { stickerset_->store(s, "stickerset"); }
    s.store_field("archived", archived_);
    s.store_class_end();
  }
}

messages_installStickerSet::ReturnType messages_installStickerSet::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_StickerSetInstallResult>::parse(p);
#undef FAIL
}

messages_markDialogUnread::messages_markDialogUnread()
  : flags_()
  , unread_()
  , peer_()
{}

messages_markDialogUnread::messages_markDialogUnread(std::int32_t flags_, bool unread_, object_ptr<inputDialogPeer> &&peer_)
  : flags_(flags_)
  , unread_(unread_)
  , peer_(std::move(peer_))
{}

const std::int32_t messages_markDialogUnread::ID;

void messages_markDialogUnread::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1031349873);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(unread_, s); }
  TlStoreBoxed<TlStoreObject, -55902537>::store(peer_, s);
}

void messages_markDialogUnread::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1031349873);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(unread_, s); }
  TlStoreBoxed<TlStoreObject, -55902537>::store(peer_, s);
}

void messages_markDialogUnread::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_markDialogUnread");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

messages_markDialogUnread::ReturnType messages_markDialogUnread::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_migrateChat::messages_migrateChat()
  : chat_id_()
{}

messages_migrateChat::messages_migrateChat(std::int32_t chat_id_)
  : chat_id_(chat_id_)
{}

const std::int32_t messages_migrateChat::ID;

void messages_migrateChat::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(363051235);
  TlStoreBinary::store(chat_id_, s);
}

void messages_migrateChat::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(363051235);
  TlStoreBinary::store(chat_id_, s);
}

void messages_migrateChat::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_migrateChat");
    s.store_field("chat_id", chat_id_);
    s.store_class_end();
  }
}

messages_migrateChat::ReturnType messages_migrateChat::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_readEncryptedHistory::messages_readEncryptedHistory()
  : peer_()
  , max_date_()
{}

messages_readEncryptedHistory::messages_readEncryptedHistory(object_ptr<inputEncryptedChat> &&peer_, std::int32_t max_date_)
  : peer_(std::move(peer_))
  , max_date_(max_date_)
{}

const std::int32_t messages_readEncryptedHistory::ID;

void messages_readEncryptedHistory::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(2135648522);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBinary::store(max_date_, s);
}

void messages_readEncryptedHistory::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(2135648522);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBinary::store(max_date_, s);
}

void messages_readEncryptedHistory::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_readEncryptedHistory");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("max_date", max_date_);
    s.store_class_end();
  }
}

messages_readEncryptedHistory::ReturnType messages_readEncryptedHistory::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_readFeaturedStickers::messages_readFeaturedStickers()
  : id_()
{}

messages_readFeaturedStickers::messages_readFeaturedStickers(std::vector<std::int64_t> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t messages_readFeaturedStickers::ID;

void messages_readFeaturedStickers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1527873830);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void messages_readFeaturedStickers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1527873830);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void messages_readFeaturedStickers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_readFeaturedStickers");
    { const std::vector<std::int64_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_readFeaturedStickers::ReturnType messages_readFeaturedStickers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_readHistory::messages_readHistory()
  : peer_()
  , max_id_()
{}

messages_readHistory::messages_readHistory(object_ptr<InputPeer> &&peer_, std::int32_t max_id_)
  : peer_(std::move(peer_))
  , max_id_(max_id_)
{}

const std::int32_t messages_readHistory::ID;

void messages_readHistory::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(238054714);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(max_id_, s);
}

void messages_readHistory::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(238054714);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(max_id_, s);
}

void messages_readHistory::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_readHistory");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("max_id", max_id_);
    s.store_class_end();
  }
}

messages_readHistory::ReturnType messages_readHistory::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_affectedMessages>, -2066640507>::parse(p);
#undef FAIL
}

messages_readMentions::messages_readMentions()
  : peer_()
{}

messages_readMentions::messages_readMentions(object_ptr<InputPeer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t messages_readMentions::ID;

void messages_readMentions::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(251759059);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void messages_readMentions::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(251759059);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void messages_readMentions::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_readMentions");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

messages_readMentions::ReturnType messages_readMentions::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_affectedHistory>, -1269012015>::parse(p);
#undef FAIL
}

messages_readMessageContents::messages_readMessageContents()
  : id_()
{}

messages_readMessageContents::messages_readMessageContents(std::vector<std::int32_t> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t messages_readMessageContents::ID;

void messages_readMessageContents::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(916930423);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void messages_readMessageContents::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(916930423);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
}

void messages_readMessageContents::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_readMessageContents");
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_readMessageContents::ReturnType messages_readMessageContents::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_affectedMessages>, -2066640507>::parse(p);
#undef FAIL
}

messages_receivedMessages::messages_receivedMessages()
  : max_id_()
{}

messages_receivedMessages::messages_receivedMessages(std::int32_t max_id_)
  : max_id_(max_id_)
{}

const std::int32_t messages_receivedMessages::ID;

void messages_receivedMessages::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(94983360);
  TlStoreBinary::store(max_id_, s);
}

void messages_receivedMessages::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(94983360);
  TlStoreBinary::store(max_id_, s);
}

void messages_receivedMessages::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_receivedMessages");
    s.store_field("max_id", max_id_);
    s.store_class_end();
  }
}

messages_receivedMessages::ReturnType messages_receivedMessages::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<receivedNotifyMessage>, -1551583367>>, 481674261>::parse(p);
#undef FAIL
}

messages_receivedQueue::messages_receivedQueue()
  : max_qts_()
{}

messages_receivedQueue::messages_receivedQueue(std::int32_t max_qts_)
  : max_qts_(max_qts_)
{}

const std::int32_t messages_receivedQueue::ID;

void messages_receivedQueue::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1436924774);
  TlStoreBinary::store(max_qts_, s);
}

void messages_receivedQueue::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1436924774);
  TlStoreBinary::store(max_qts_, s);
}

void messages_receivedQueue::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_receivedQueue");
    s.store_field("max_qts", max_qts_);
    s.store_class_end();
  }
}

messages_receivedQueue::ReturnType messages_receivedQueue::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchLong>, 481674261>::parse(p);
#undef FAIL
}

messages_reorderPinnedDialogs::messages_reorderPinnedDialogs()
  : flags_()
  , force_()
  , order_()
{}

messages_reorderPinnedDialogs::messages_reorderPinnedDialogs(std::int32_t flags_, bool force_, std::vector<object_ptr<inputDialogPeer>> &&order_)
  : flags_(flags_)
  , force_(force_)
  , order_(std::move(order_))
{}

const std::int32_t messages_reorderPinnedDialogs::ID;

void messages_reorderPinnedDialogs::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1532089919);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(force_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -55902537>>, 481674261>::store(order_, s);
}

void messages_reorderPinnedDialogs::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1532089919);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(force_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -55902537>>, 481674261>::store(order_, s);
}

void messages_reorderPinnedDialogs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_reorderPinnedDialogs");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    { const std::vector<object_ptr<inputDialogPeer>> &v = order_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("order", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_reorderPinnedDialogs::ReturnType messages_reorderPinnedDialogs::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_reorderStickerSets::messages_reorderStickerSets()
  : flags_()
  , masks_()
  , order_()
{}

messages_reorderStickerSets::messages_reorderStickerSets(std::int32_t flags_, bool masks_, std::vector<std::int64_t> &&order_)
  : flags_(flags_)
  , masks_(masks_)
  , order_(std::move(order_))
{}

const std::int32_t messages_reorderStickerSets::ID;

void messages_reorderStickerSets::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(2016638777);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(masks_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(order_, s);
}

void messages_reorderStickerSets::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(2016638777);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(masks_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(order_, s);
}

void messages_reorderStickerSets::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_reorderStickerSets");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    { const std::vector<std::int64_t> &v = order_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("order", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_reorderStickerSets::ReturnType messages_reorderStickerSets::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_report::messages_report()
  : peer_()
  , id_()
  , reason_()
{}

messages_report::messages_report(object_ptr<InputPeer> &&peer_, std::vector<std::int32_t> &&id_, object_ptr<ReportReason> &&reason_)
  : peer_(std::move(peer_))
  , id_(std::move(id_))
  , reason_(std::move(reason_))
{}

const std::int32_t messages_report::ID;

void messages_report::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1115507112);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(reason_, s);
}

void messages_report::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1115507112);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBinary>, 481674261>::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(reason_, s);
}

void messages_report::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_report");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    { const std::vector<std::int32_t> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { s.store_field("", v[i]); } s.store_class_end(); }
    if (reason_ == nullptr) { s.store_field("reason", "null"); } else { reason_->store(s, "reason"); }
    s.store_class_end();
  }
}

messages_report::ReturnType messages_report::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_reportEncryptedSpam::messages_reportEncryptedSpam()
  : peer_()
{}

messages_reportEncryptedSpam::messages_reportEncryptedSpam(object_ptr<inputEncryptedChat> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t messages_reportEncryptedSpam::ID;

void messages_reportEncryptedSpam::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1259113487);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
}

void messages_reportEncryptedSpam::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1259113487);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
}

void messages_reportEncryptedSpam::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_reportEncryptedSpam");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

messages_reportEncryptedSpam::ReturnType messages_reportEncryptedSpam::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_reportSpam::messages_reportSpam()
  : peer_()
{}

messages_reportSpam::messages_reportSpam(object_ptr<InputPeer> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t messages_reportSpam::ID;

void messages_reportSpam::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-820669733);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void messages_reportSpam::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-820669733);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
}

void messages_reportSpam::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_reportSpam");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

messages_reportSpam::ReturnType messages_reportSpam::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_requestEncryption::messages_requestEncryption()
  : user_id_()
  , random_id_()
  , g_a_()
{}

messages_requestEncryption::messages_requestEncryption(object_ptr<InputUser> &&user_id_, std::int32_t random_id_, BufferSlice &&g_a_)
  : user_id_(std::move(user_id_))
  , random_id_(random_id_)
  , g_a_(std::move(g_a_))
{}

const std::int32_t messages_requestEncryption::ID;

void messages_requestEncryption::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-162681021);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(g_a_, s);
}

void messages_requestEncryption::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-162681021);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(g_a_, s);
}

void messages_requestEncryption::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_requestEncryption");
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("random_id", random_id_);
    s.store_bytes_field("g_a", g_a_);
    s.store_class_end();
  }
}

messages_requestEncryption::ReturnType messages_requestEncryption::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<EncryptedChat>::parse(p);
#undef FAIL
}

messages_saveDraft::messages_saveDraft()
  : flags_()
  , no_webpage_()
  , reply_to_msg_id_()
  , peer_()
  , message_()
  , entities_()
{}

messages_saveDraft::messages_saveDraft(std::int32_t flags_, bool no_webpage_, std::int32_t reply_to_msg_id_, object_ptr<InputPeer> &&peer_, std::string const &message_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , no_webpage_(no_webpage_)
  , reply_to_msg_id_(reply_to_msg_id_)
  , peer_(std::move(peer_))
  , message_(message_)
  , entities_(std::move(entities_))
{}

const std::int32_t messages_saveDraft::ID;

void messages_saveDraft::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1137057461);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(no_webpage_, s); }
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreString::store(message_, s);
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void messages_saveDraft::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1137057461);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(no_webpage_, s); }
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreString::store(message_, s);
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void messages_saveDraft::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_saveDraft");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 1) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("message", message_);
    if (var0 & 8) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

messages_saveDraft::ReturnType messages_saveDraft::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_saveGif::messages_saveGif()
  : id_()
  , unsave_()
{}

messages_saveGif::messages_saveGif(object_ptr<InputDocument> &&id_, bool unsave_)
  : id_(std::move(id_))
  , unsave_(unsave_)
{}

const std::int32_t messages_saveGif::ID;

void messages_saveGif::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(846868683);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  TlStoreBool::store(unsave_, s);
}

void messages_saveGif::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(846868683);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  TlStoreBool::store(unsave_, s);
}

void messages_saveGif::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_saveGif");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_field("unsave", unsave_);
    s.store_class_end();
  }
}

messages_saveGif::ReturnType messages_saveGif::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_saveRecentSticker::messages_saveRecentSticker()
  : flags_()
  , attached_()
  , id_()
  , unsave_()
{}

messages_saveRecentSticker::messages_saveRecentSticker(std::int32_t flags_, bool attached_, object_ptr<InputDocument> &&id_, bool unsave_)
  : flags_(flags_)
  , attached_(attached_)
  , id_(std::move(id_))
  , unsave_(unsave_)
{}

const std::int32_t messages_saveRecentSticker::ID;

void messages_saveRecentSticker::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(958863608);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(attached_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  TlStoreBool::store(unsave_, s);
}

void messages_saveRecentSticker::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(958863608);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(attached_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  TlStoreBool::store(unsave_, s);
}

void messages_saveRecentSticker::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_saveRecentSticker");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_field("unsave", unsave_);
    s.store_class_end();
  }
}

messages_saveRecentSticker::ReturnType messages_saveRecentSticker::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_search::messages_search()
  : flags_()
  , peer_()
  , q_()
  , from_id_()
  , filter_()
  , min_date_()
  , max_date_()
  , offset_id_()
  , add_offset_()
  , limit_()
  , max_id_()
  , min_id_()
  , hash_()
{}

messages_search::messages_search(std::int32_t flags_, object_ptr<InputPeer> &&peer_, std::string const &q_, object_ptr<InputUser> &&from_id_, object_ptr<MessagesFilter> &&filter_, std::int32_t min_date_, std::int32_t max_date_, std::int32_t offset_id_, std::int32_t add_offset_, std::int32_t limit_, std::int32_t max_id_, std::int32_t min_id_, std::int32_t hash_)
  : flags_(flags_)
  , peer_(std::move(peer_))
  , q_(q_)
  , from_id_(std::move(from_id_))
  , filter_(std::move(filter_))
  , min_date_(min_date_)
  , max_date_(max_date_)
  , offset_id_(offset_id_)
  , add_offset_(add_offset_)
  , limit_(limit_)
  , max_id_(max_id_)
  , min_id_(min_id_)
  , hash_(hash_)
{}

const std::int32_t messages_search::ID;

void messages_search::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2045448344);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreString::store(q_, s);
  if (var0 & 1) { TlStoreBoxedUnknown<TlStoreObject>::store(from_id_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(filter_, s);
  TlStoreBinary::store(min_date_, s);
  TlStoreBinary::store(max_date_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(add_offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(min_id_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_search::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2045448344);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreString::store(q_, s);
  if (var0 & 1) { TlStoreBoxedUnknown<TlStoreObject>::store(from_id_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(filter_, s);
  TlStoreBinary::store(min_date_, s);
  TlStoreBinary::store(max_date_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(add_offset_, s);
  TlStoreBinary::store(limit_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(min_id_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_search::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_search");
    s.store_field("flags", (var0 = flags_));
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("q", q_);
    if (var0 & 1) { if (from_id_ == nullptr) { s.store_field("from_id", "null"); } else { from_id_->store(s, "from_id"); } }
    if (filter_ == nullptr) { s.store_field("filter", "null"); } else { filter_->store(s, "filter"); }
    s.store_field("min_date", min_date_);
    s.store_field("max_date", max_date_);
    s.store_field("offset_id", offset_id_);
    s.store_field("add_offset", add_offset_);
    s.store_field("limit", limit_);
    s.store_field("max_id", max_id_);
    s.store_field("min_id", min_id_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_search::ReturnType messages_search::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Messages>::parse(p);
#undef FAIL
}

messages_searchGifs::messages_searchGifs()
  : q_()
  , offset_()
{}

messages_searchGifs::messages_searchGifs(std::string const &q_, std::int32_t offset_)
  : q_(q_)
  , offset_(offset_)
{}

const std::int32_t messages_searchGifs::ID;

void messages_searchGifs::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1080395925);
  TlStoreString::store(q_, s);
  TlStoreBinary::store(offset_, s);
}

void messages_searchGifs::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1080395925);
  TlStoreString::store(q_, s);
  TlStoreBinary::store(offset_, s);
}

void messages_searchGifs::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_searchGifs");
    s.store_field("q", q_);
    s.store_field("offset", offset_);
    s.store_class_end();
  }
}

messages_searchGifs::ReturnType messages_searchGifs::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_foundGifs>, 1158290442>::parse(p);
#undef FAIL
}

messages_searchGlobal::messages_searchGlobal()
  : q_()
  , offset_date_()
  , offset_peer_()
  , offset_id_()
  , limit_()
{}

messages_searchGlobal::messages_searchGlobal(std::string const &q_, std::int32_t offset_date_, object_ptr<InputPeer> &&offset_peer_, std::int32_t offset_id_, std::int32_t limit_)
  : q_(q_)
  , offset_date_(offset_date_)
  , offset_peer_(std::move(offset_peer_))
  , offset_id_(offset_id_)
  , limit_(limit_)
{}

const std::int32_t messages_searchGlobal::ID;

void messages_searchGlobal::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1640190800);
  TlStoreString::store(q_, s);
  TlStoreBinary::store(offset_date_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(offset_peer_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(limit_, s);
}

void messages_searchGlobal::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1640190800);
  TlStoreString::store(q_, s);
  TlStoreBinary::store(offset_date_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(offset_peer_, s);
  TlStoreBinary::store(offset_id_, s);
  TlStoreBinary::store(limit_, s);
}

void messages_searchGlobal::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_searchGlobal");
    s.store_field("q", q_);
    s.store_field("offset_date", offset_date_);
    if (offset_peer_ == nullptr) { s.store_field("offset_peer", "null"); } else { offset_peer_->store(s, "offset_peer"); }
    s.store_field("offset_id", offset_id_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

messages_searchGlobal::ReturnType messages_searchGlobal::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_Messages>::parse(p);
#undef FAIL
}

messages_searchStickerSets::messages_searchStickerSets()
  : flags_()
  , exclude_featured_()
  , q_()
  , hash_()
{}

messages_searchStickerSets::messages_searchStickerSets(std::int32_t flags_, bool exclude_featured_, std::string const &q_, std::int32_t hash_)
  : flags_(flags_)
  , exclude_featured_(exclude_featured_)
  , q_(q_)
  , hash_(hash_)
{}

const std::int32_t messages_searchStickerSets::ID;

void messages_searchStickerSets::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1028140917);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(exclude_featured_, s); }
  TlStoreString::store(q_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_searchStickerSets::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1028140917);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(exclude_featured_, s); }
  TlStoreString::store(q_, s);
  TlStoreBinary::store(hash_, s);
}

void messages_searchStickerSets::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_searchStickerSets");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("q", q_);
    s.store_field("hash", hash_);
    s.store_class_end();
  }
}

messages_searchStickerSets::ReturnType messages_searchStickerSets::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_FoundStickerSets>::parse(p);
#undef FAIL
}

messages_sendEncrypted::messages_sendEncrypted()
  : peer_()
  , random_id_()
  , data_()
{}

messages_sendEncrypted::messages_sendEncrypted(object_ptr<inputEncryptedChat> &&peer_, std::int64_t random_id_, BufferSlice &&data_)
  : peer_(std::move(peer_))
  , random_id_(random_id_)
  , data_(std::move(data_))
{}

const std::int32_t messages_sendEncrypted::ID;

void messages_sendEncrypted::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1451792525);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(data_, s);
}

void messages_sendEncrypted::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1451792525);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(data_, s);
}

void messages_sendEncrypted::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sendEncrypted");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("random_id", random_id_);
    s.store_bytes_field("data", data_);
    s.store_class_end();
  }
}

messages_sendEncrypted::ReturnType messages_sendEncrypted::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_SentEncryptedMessage>::parse(p);
#undef FAIL
}

messages_sendEncryptedFile::messages_sendEncryptedFile()
  : peer_()
  , random_id_()
  , data_()
  , file_()
{}

messages_sendEncryptedFile::messages_sendEncryptedFile(object_ptr<inputEncryptedChat> &&peer_, std::int64_t random_id_, BufferSlice &&data_, object_ptr<InputEncryptedFile> &&file_)
  : peer_(std::move(peer_))
  , random_id_(random_id_)
  , data_(std::move(data_))
  , file_(std::move(file_))
{}

const std::int32_t messages_sendEncryptedFile::ID;

void messages_sendEncryptedFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1701831834);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(data_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
}

void messages_sendEncryptedFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1701831834);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(data_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
}

void messages_sendEncryptedFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sendEncryptedFile");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("random_id", random_id_);
    s.store_bytes_field("data", data_);
    if (file_ == nullptr) { s.store_field("file", "null"); } else { file_->store(s, "file"); }
    s.store_class_end();
  }
}

messages_sendEncryptedFile::ReturnType messages_sendEncryptedFile::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_SentEncryptedMessage>::parse(p);
#undef FAIL
}

messages_sendEncryptedService::messages_sendEncryptedService()
  : peer_()
  , random_id_()
  , data_()
{}

messages_sendEncryptedService::messages_sendEncryptedService(object_ptr<inputEncryptedChat> &&peer_, std::int64_t random_id_, BufferSlice &&data_)
  : peer_(std::move(peer_))
  , random_id_(random_id_)
  , data_(std::move(data_))
{}

const std::int32_t messages_sendEncryptedService::ID;

void messages_sendEncryptedService::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(852769188);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(data_, s);
}

void messages_sendEncryptedService::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(852769188);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(data_, s);
}

void messages_sendEncryptedService::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sendEncryptedService");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("random_id", random_id_);
    s.store_bytes_field("data", data_);
    s.store_class_end();
  }
}

messages_sendEncryptedService::ReturnType messages_sendEncryptedService::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<messages_SentEncryptedMessage>::parse(p);
#undef FAIL
}

messages_sendInlineBotResult::messages_sendInlineBotResult()
  : flags_()
  , silent_()
  , background_()
  , clear_draft_()
  , peer_()
  , reply_to_msg_id_()
  , random_id_()
  , query_id_()
  , id_()
{}

messages_sendInlineBotResult::messages_sendInlineBotResult(std::int32_t flags_, bool silent_, bool background_, bool clear_draft_, object_ptr<InputPeer> &&peer_, std::int32_t reply_to_msg_id_, std::int64_t random_id_, std::int64_t query_id_, std::string const &id_)
  : flags_(flags_)
  , silent_(silent_)
  , background_(background_)
  , clear_draft_(clear_draft_)
  , peer_(std::move(peer_))
  , reply_to_msg_id_(reply_to_msg_id_)
  , random_id_(random_id_)
  , query_id_(query_id_)
  , id_(id_)
{}

const std::int32_t messages_sendInlineBotResult::ID;

void messages_sendInlineBotResult::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1318189314);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 128) { TlStoreTrue::store(clear_draft_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreBinary::store(random_id_, s);
  TlStoreBinary::store(query_id_, s);
  TlStoreString::store(id_, s);
}

void messages_sendInlineBotResult::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1318189314);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 128) { TlStoreTrue::store(clear_draft_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreBinary::store(random_id_, s);
  TlStoreBinary::store(query_id_, s);
  TlStoreString::store(id_, s);
}

void messages_sendInlineBotResult::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sendInlineBotResult");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (var0 & 1) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    s.store_field("random_id", random_id_);
    s.store_field("query_id", query_id_);
    s.store_field("id", id_);
    s.store_class_end();
  }
}

messages_sendInlineBotResult::ReturnType messages_sendInlineBotResult::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_sendMedia::messages_sendMedia()
  : flags_()
  , silent_()
  , background_()
  , clear_draft_()
  , peer_()
  , reply_to_msg_id_()
  , media_()
  , message_()
  , random_id_()
  , reply_markup_()
  , entities_()
{}

messages_sendMedia::messages_sendMedia(std::int32_t flags_, bool silent_, bool background_, bool clear_draft_, object_ptr<InputPeer> &&peer_, std::int32_t reply_to_msg_id_, object_ptr<InputMedia> &&media_, std::string const &message_, std::int64_t random_id_, object_ptr<ReplyMarkup> &&reply_markup_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , silent_(silent_)
  , background_(background_)
  , clear_draft_(clear_draft_)
  , peer_(std::move(peer_))
  , reply_to_msg_id_(reply_to_msg_id_)
  , media_(std::move(media_))
  , message_(message_)
  , random_id_(random_id_)
  , reply_markup_(std::move(reply_markup_))
  , entities_(std::move(entities_))
{}

const std::int32_t messages_sendMedia::ID;

void messages_sendMedia::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1194252757);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 128) { TlStoreTrue::store(clear_draft_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(media_, s);
  TlStoreString::store(message_, s);
  TlStoreBinary::store(random_id_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void messages_sendMedia::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1194252757);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 128) { TlStoreTrue::store(clear_draft_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(media_, s);
  TlStoreString::store(message_, s);
  TlStoreBinary::store(random_id_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void messages_sendMedia::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sendMedia");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (var0 & 1) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); }
    s.store_field("message", message_);
    s.store_field("random_id", random_id_);
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    if (var0 & 8) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

messages_sendMedia::ReturnType messages_sendMedia::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_sendMessage::messages_sendMessage()
  : flags_()
  , no_webpage_()
  , silent_()
  , background_()
  , clear_draft_()
  , peer_()
  , reply_to_msg_id_()
  , message_()
  , random_id_()
  , reply_markup_()
  , entities_()
{}

messages_sendMessage::messages_sendMessage(std::int32_t flags_, bool no_webpage_, bool silent_, bool background_, bool clear_draft_, object_ptr<InputPeer> &&peer_, std::int32_t reply_to_msg_id_, std::string const &message_, std::int64_t random_id_, object_ptr<ReplyMarkup> &&reply_markup_, std::vector<object_ptr<MessageEntity>> &&entities_)
  : flags_(flags_)
  , no_webpage_(no_webpage_)
  , silent_(silent_)
  , background_(background_)
  , clear_draft_(clear_draft_)
  , peer_(std::move(peer_))
  , reply_to_msg_id_(reply_to_msg_id_)
  , message_(message_)
  , random_id_(random_id_)
  , reply_markup_(std::move(reply_markup_))
  , entities_(std::move(entities_))
{}

const std::int32_t messages_sendMessage::ID;

void messages_sendMessage::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-91733382);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(no_webpage_, s); }
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 128) { TlStoreTrue::store(clear_draft_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreString::store(message_, s);
  TlStoreBinary::store(random_id_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void messages_sendMessage::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-91733382);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(no_webpage_, s); }
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 128) { TlStoreTrue::store(clear_draft_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreString::store(message_, s);
  TlStoreBinary::store(random_id_, s);
  if (var0 & 4) { TlStoreBoxedUnknown<TlStoreObject>::store(reply_markup_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(entities_, s); }
}

void messages_sendMessage::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sendMessage");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (var0 & 1) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    s.store_field("message", message_);
    s.store_field("random_id", random_id_);
    if (var0 & 4) { if (reply_markup_ == nullptr) { s.store_field("reply_markup", "null"); } else { reply_markup_->store(s, "reply_markup"); } }
    if (var0 & 8) { { const std::vector<object_ptr<MessageEntity>> &v = entities_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("entities", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

messages_sendMessage::ReturnType messages_sendMessage::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_sendMultiMedia::messages_sendMultiMedia()
  : flags_()
  , silent_()
  , background_()
  , clear_draft_()
  , peer_()
  , reply_to_msg_id_()
  , multi_media_()
{}

messages_sendMultiMedia::messages_sendMultiMedia(std::int32_t flags_, bool silent_, bool background_, bool clear_draft_, object_ptr<InputPeer> &&peer_, std::int32_t reply_to_msg_id_, std::vector<object_ptr<inputSingleMedia>> &&multi_media_)
  : flags_(flags_)
  , silent_(silent_)
  , background_(background_)
  , clear_draft_(clear_draft_)
  , peer_(std::move(peer_))
  , reply_to_msg_id_(reply_to_msg_id_)
  , multi_media_(std::move(multi_media_))
{}

const std::int32_t messages_sendMultiMedia::ID;

void messages_sendMultiMedia::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(546656559);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 128) { TlStoreTrue::store(clear_draft_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 482797855>>, 481674261>::store(multi_media_, s);
}

void messages_sendMultiMedia::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(546656559);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 32) { TlStoreTrue::store(silent_, s); }
  if (var0 & 64) { TlStoreTrue::store(background_, s); }
  if (var0 & 128) { TlStoreTrue::store(clear_draft_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  if (var0 & 1) { TlStoreBinary::store(reply_to_msg_id_, s); }
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, 482797855>>, 481674261>::store(multi_media_, s);
}

void messages_sendMultiMedia::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sendMultiMedia");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 32) {  }
    if (var0 & 64) {  }
    if (var0 & 128) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (var0 & 1) { s.store_field("reply_to_msg_id", reply_to_msg_id_); }
    { const std::vector<object_ptr<inputSingleMedia>> &v = multi_media_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("multi_media", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

messages_sendMultiMedia::ReturnType messages_sendMultiMedia::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_sendScreenshotNotification::messages_sendScreenshotNotification()
  : peer_()
  , reply_to_msg_id_()
  , random_id_()
{}

messages_sendScreenshotNotification::messages_sendScreenshotNotification(object_ptr<InputPeer> &&peer_, std::int32_t reply_to_msg_id_, std::int64_t random_id_)
  : peer_(std::move(peer_))
  , reply_to_msg_id_(reply_to_msg_id_)
  , random_id_(random_id_)
{}

const std::int32_t messages_sendScreenshotNotification::ID;

void messages_sendScreenshotNotification::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-914493408);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(reply_to_msg_id_, s);
  TlStoreBinary::store(random_id_, s);
}

void messages_sendScreenshotNotification::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-914493408);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(reply_to_msg_id_, s);
  TlStoreBinary::store(random_id_, s);
}

void messages_sendScreenshotNotification::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_sendScreenshotNotification");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("reply_to_msg_id", reply_to_msg_id_);
    s.store_field("random_id", random_id_);
    s.store_class_end();
  }
}

messages_sendScreenshotNotification::ReturnType messages_sendScreenshotNotification::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_setBotCallbackAnswer::messages_setBotCallbackAnswer()
  : flags_()
  , alert_()
  , query_id_()
  , message_()
  , url_()
  , cache_time_()
{}

messages_setBotCallbackAnswer::messages_setBotCallbackAnswer(std::int32_t flags_, bool alert_, std::int64_t query_id_, std::string const &message_, std::string const &url_, std::int32_t cache_time_)
  : flags_(flags_)
  , alert_(alert_)
  , query_id_(query_id_)
  , message_(message_)
  , url_(url_)
  , cache_time_(cache_time_)
{}

const std::int32_t messages_setBotCallbackAnswer::ID;

void messages_setBotCallbackAnswer::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-712043766);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(alert_, s); }
  TlStoreBinary::store(query_id_, s);
  if (var0 & 1) { TlStoreString::store(message_, s); }
  if (var0 & 4) { TlStoreString::store(url_, s); }
  TlStoreBinary::store(cache_time_, s);
}

void messages_setBotCallbackAnswer::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-712043766);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(alert_, s); }
  TlStoreBinary::store(query_id_, s);
  if (var0 & 1) { TlStoreString::store(message_, s); }
  if (var0 & 4) { TlStoreString::store(url_, s); }
  TlStoreBinary::store(cache_time_, s);
}

void messages_setBotCallbackAnswer::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_setBotCallbackAnswer");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    s.store_field("query_id", query_id_);
    if (var0 & 1) { s.store_field("message", message_); }
    if (var0 & 4) { s.store_field("url", url_); }
    s.store_field("cache_time", cache_time_);
    s.store_class_end();
  }
}

messages_setBotCallbackAnswer::ReturnType messages_setBotCallbackAnswer::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_setBotPrecheckoutResults::messages_setBotPrecheckoutResults()
  : flags_()
  , success_()
  , query_id_()
  , error_()
{}

messages_setBotPrecheckoutResults::messages_setBotPrecheckoutResults(std::int32_t flags_, bool success_, std::int64_t query_id_, std::string const &error_)
  : flags_(flags_)
  , success_(success_)
  , query_id_(query_id_)
  , error_(error_)
{}

const std::int32_t messages_setBotPrecheckoutResults::ID;

void messages_setBotPrecheckoutResults::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(163765653);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(success_, s); }
  TlStoreBinary::store(query_id_, s);
  if (var0 & 1) { TlStoreString::store(error_, s); }
}

void messages_setBotPrecheckoutResults::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(163765653);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 2) { TlStoreTrue::store(success_, s); }
  TlStoreBinary::store(query_id_, s);
  if (var0 & 1) { TlStoreString::store(error_, s); }
}

void messages_setBotPrecheckoutResults::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_setBotPrecheckoutResults");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 2) {  }
    s.store_field("query_id", query_id_);
    if (var0 & 1) { s.store_field("error", error_); }
    s.store_class_end();
  }
}

messages_setBotPrecheckoutResults::ReturnType messages_setBotPrecheckoutResults::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_setBotShippingResults::messages_setBotShippingResults()
  : flags_()
  , query_id_()
  , error_()
  , shipping_options_()
{}

messages_setBotShippingResults::messages_setBotShippingResults(std::int32_t flags_, std::int64_t query_id_, std::string const &error_, std::vector<object_ptr<shippingOption>> &&shipping_options_)
  : flags_(flags_)
  , query_id_(query_id_)
  , error_(error_)
  , shipping_options_(std::move(shipping_options_))
{}

const std::int32_t messages_setBotShippingResults::ID;

void messages_setBotShippingResults::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-436833542);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBinary::store(query_id_, s);
  if (var0 & 1) { TlStoreString::store(error_, s); }
  if (var0 & 2) { TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -1239335713>>, 481674261>::store(shipping_options_, s); }
}

void messages_setBotShippingResults::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-436833542);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBinary::store(query_id_, s);
  if (var0 & 1) { TlStoreString::store(error_, s); }
  if (var0 & 2) { TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -1239335713>>, 481674261>::store(shipping_options_, s); }
}

void messages_setBotShippingResults::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_setBotShippingResults");
    s.store_field("flags", (var0 = flags_));
    s.store_field("query_id", query_id_);
    if (var0 & 1) { s.store_field("error", error_); }
    if (var0 & 2) { { const std::vector<object_ptr<shippingOption>> &v = shipping_options_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("shipping_options", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); } }
    s.store_class_end();
  }
}

messages_setBotShippingResults::ReturnType messages_setBotShippingResults::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_setEncryptedTyping::messages_setEncryptedTyping()
  : peer_()
  , typing_()
{}

messages_setEncryptedTyping::messages_setEncryptedTyping(object_ptr<inputEncryptedChat> &&peer_, bool typing_)
  : peer_(std::move(peer_))
  , typing_(typing_)
{}

const std::int32_t messages_setEncryptedTyping::ID;

void messages_setEncryptedTyping::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(2031374829);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBool::store(typing_, s);
}

void messages_setEncryptedTyping::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(2031374829);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBool::store(typing_, s);
}

void messages_setEncryptedTyping::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_setEncryptedTyping");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("typing", typing_);
    s.store_class_end();
  }
}

messages_setEncryptedTyping::ReturnType messages_setEncryptedTyping::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_setGameScore::messages_setGameScore()
  : flags_()
  , edit_message_()
  , force_()
  , peer_()
  , id_()
  , user_id_()
  , score_()
{}

messages_setGameScore::messages_setGameScore(std::int32_t flags_, bool edit_message_, bool force_, object_ptr<InputPeer> &&peer_, std::int32_t id_, object_ptr<InputUser> &&user_id_, std::int32_t score_)
  : flags_(flags_)
  , edit_message_(edit_message_)
  , force_(force_)
  , peer_(std::move(peer_))
  , id_(id_)
  , user_id_(std::move(user_id_))
  , score_(score_)
{}

const std::int32_t messages_setGameScore::ID;

void messages_setGameScore::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1896289088);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(edit_message_, s); }
  if (var0 & 2) { TlStoreTrue::store(force_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(score_, s);
}

void messages_setGameScore::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1896289088);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(edit_message_, s); }
  if (var0 & 2) { TlStoreTrue::store(force_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(score_, s);
}

void messages_setGameScore::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_setGameScore");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("id", id_);
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("score", score_);
    s.store_class_end();
  }
}

messages_setGameScore::ReturnType messages_setGameScore::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_setInlineBotResults::messages_setInlineBotResults()
  : flags_()
  , gallery_()
  , private_()
  , query_id_()
  , results_()
  , cache_time_()
  , next_offset_()
  , switch_pm_()
{}

messages_setInlineBotResults::messages_setInlineBotResults(std::int32_t flags_, bool gallery_, bool private_, std::int64_t query_id_, std::vector<object_ptr<InputBotInlineResult>> &&results_, std::int32_t cache_time_, std::string const &next_offset_, object_ptr<inlineBotSwitchPM> &&switch_pm_)
  : flags_(flags_)
  , gallery_(gallery_)
  , private_(private_)
  , query_id_(query_id_)
  , results_(std::move(results_))
  , cache_time_(cache_time_)
  , next_offset_(next_offset_)
  , switch_pm_(std::move(switch_pm_))
{}

const std::int32_t messages_setInlineBotResults::ID;

void messages_setInlineBotResults::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-346119674);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(gallery_, s); }
  if (var0 & 2) { TlStoreTrue::store(private_, s); }
  TlStoreBinary::store(query_id_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(results_, s);
  TlStoreBinary::store(cache_time_, s);
  if (var0 & 4) { TlStoreString::store(next_offset_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreObject, 1008755359>::store(switch_pm_, s); }
}

void messages_setInlineBotResults::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-346119674);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(gallery_, s); }
  if (var0 & 2) { TlStoreTrue::store(private_, s); }
  TlStoreBinary::store(query_id_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(results_, s);
  TlStoreBinary::store(cache_time_, s);
  if (var0 & 4) { TlStoreString::store(next_offset_, s); }
  if (var0 & 8) { TlStoreBoxed<TlStoreObject, 1008755359>::store(switch_pm_, s); }
}

void messages_setInlineBotResults::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_setInlineBotResults");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    s.store_field("query_id", query_id_);
    { const std::vector<object_ptr<InputBotInlineResult>> &v = results_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("results", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_field("cache_time", cache_time_);
    if (var0 & 4) { s.store_field("next_offset", next_offset_); }
    if (var0 & 8) { if (switch_pm_ == nullptr) { s.store_field("switch_pm", "null"); } else { switch_pm_->store(s, "switch_pm"); } }
    s.store_class_end();
  }
}

messages_setInlineBotResults::ReturnType messages_setInlineBotResults::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_setInlineGameScore::messages_setInlineGameScore()
  : flags_()
  , edit_message_()
  , force_()
  , id_()
  , user_id_()
  , score_()
{}

messages_setInlineGameScore::messages_setInlineGameScore(std::int32_t flags_, bool edit_message_, bool force_, object_ptr<inputBotInlineMessageID> &&id_, object_ptr<InputUser> &&user_id_, std::int32_t score_)
  : flags_(flags_)
  , edit_message_(edit_message_)
  , force_(force_)
  , id_(std::move(id_))
  , user_id_(std::move(user_id_))
  , score_(score_)
{}

const std::int32_t messages_setInlineGameScore::ID;

void messages_setInlineGameScore::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(363700068);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(edit_message_, s); }
  if (var0 & 2) { TlStoreTrue::store(force_, s); }
  TlStoreBoxed<TlStoreObject, -1995686519>::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(score_, s);
}

void messages_setInlineGameScore::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(363700068);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(edit_message_, s); }
  if (var0 & 2) { TlStoreTrue::store(force_, s); }
  TlStoreBoxed<TlStoreObject, -1995686519>::store(id_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(score_, s);
}

void messages_setInlineGameScore::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_setInlineGameScore");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("score", score_);
    s.store_class_end();
  }
}

messages_setInlineGameScore::ReturnType messages_setInlineGameScore::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_setTyping::messages_setTyping()
  : peer_()
  , action_()
{}

messages_setTyping::messages_setTyping(object_ptr<InputPeer> &&peer_, object_ptr<SendMessageAction> &&action_)
  : peer_(std::move(peer_))
  , action_(std::move(action_))
{}

const std::int32_t messages_setTyping::ID;

void messages_setTyping::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1551737264);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(action_, s);
}

void messages_setTyping::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1551737264);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(action_, s);
}

void messages_setTyping::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_setTyping");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (action_ == nullptr) { s.store_field("action", "null"); } else { action_->store(s, "action"); }
    s.store_class_end();
  }
}

messages_setTyping::ReturnType messages_setTyping::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_startBot::messages_startBot()
  : bot_()
  , peer_()
  , random_id_()
  , start_param_()
{}

messages_startBot::messages_startBot(object_ptr<InputUser> &&bot_, object_ptr<InputPeer> &&peer_, std::int64_t random_id_, std::string const &start_param_)
  : bot_(std::move(bot_))
  , peer_(std::move(peer_))
  , random_id_(random_id_)
  , start_param_(start_param_)
{}

const std::int32_t messages_startBot::ID;

void messages_startBot::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-421563528);
  TlStoreBoxedUnknown<TlStoreObject>::store(bot_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(start_param_, s);
}

void messages_startBot::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-421563528);
  TlStoreBoxedUnknown<TlStoreObject>::store(bot_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(start_param_, s);
}

void messages_startBot::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_startBot");
    if (bot_ == nullptr) { s.store_field("bot", "null"); } else { bot_->store(s, "bot"); }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("random_id", random_id_);
    s.store_field("start_param", start_param_);
    s.store_class_end();
  }
}

messages_startBot::ReturnType messages_startBot::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_toggleChatAdmins::messages_toggleChatAdmins()
  : chat_id_()
  , enabled_()
{}

messages_toggleChatAdmins::messages_toggleChatAdmins(std::int32_t chat_id_, bool enabled_)
  : chat_id_(chat_id_)
  , enabled_(enabled_)
{}

const std::int32_t messages_toggleChatAdmins::ID;

void messages_toggleChatAdmins::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-326379039);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBool::store(enabled_, s);
}

void messages_toggleChatAdmins::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-326379039);
  TlStoreBinary::store(chat_id_, s);
  TlStoreBool::store(enabled_, s);
}

void messages_toggleChatAdmins::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_toggleChatAdmins");
    s.store_field("chat_id", chat_id_);
    s.store_field("enabled", enabled_);
    s.store_class_end();
  }
}

messages_toggleChatAdmins::ReturnType messages_toggleChatAdmins::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

messages_toggleDialogPin::messages_toggleDialogPin()
  : flags_()
  , pinned_()
  , peer_()
{}

messages_toggleDialogPin::messages_toggleDialogPin(std::int32_t flags_, bool pinned_, object_ptr<inputDialogPeer> &&peer_)
  : flags_(flags_)
  , pinned_(pinned_)
  , peer_(std::move(peer_))
{}

const std::int32_t messages_toggleDialogPin::ID;

void messages_toggleDialogPin::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1489903017);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(pinned_, s); }
  TlStoreBoxed<TlStoreObject, -55902537>::store(peer_, s);
}

void messages_toggleDialogPin::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1489903017);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(pinned_, s); }
  TlStoreBoxed<TlStoreObject, -55902537>::store(peer_, s);
}

void messages_toggleDialogPin::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_toggleDialogPin");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

messages_toggleDialogPin::ReturnType messages_toggleDialogPin::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_uninstallStickerSet::messages_uninstallStickerSet()
  : stickerset_()
{}

messages_uninstallStickerSet::messages_uninstallStickerSet(object_ptr<InputStickerSet> &&stickerset_)
  : stickerset_(std::move(stickerset_))
{}

const std::int32_t messages_uninstallStickerSet::ID;

void messages_uninstallStickerSet::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-110209570);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
}

void messages_uninstallStickerSet::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-110209570);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
}

void messages_uninstallStickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_uninstallStickerSet");
    if (stickerset_ == nullptr) { s.store_field("stickerset", "null"); } else { stickerset_->store(s, "stickerset"); }
    s.store_class_end();
  }
}

messages_uninstallStickerSet::ReturnType messages_uninstallStickerSet::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

messages_uploadEncryptedFile::messages_uploadEncryptedFile()
  : peer_()
  , file_()
{}

messages_uploadEncryptedFile::messages_uploadEncryptedFile(object_ptr<inputEncryptedChat> &&peer_, object_ptr<InputEncryptedFile> &&file_)
  : peer_(std::move(peer_))
  , file_(std::move(file_))
{}

const std::int32_t messages_uploadEncryptedFile::ID;

void messages_uploadEncryptedFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1347929239);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
}

void messages_uploadEncryptedFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1347929239);
  TlStoreBoxed<TlStoreObject, -247351839>::store(peer_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
}

void messages_uploadEncryptedFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_uploadEncryptedFile");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (file_ == nullptr) { s.store_field("file", "null"); } else { file_->store(s, "file"); }
    s.store_class_end();
  }
}

messages_uploadEncryptedFile::ReturnType messages_uploadEncryptedFile::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<EncryptedFile>::parse(p);
#undef FAIL
}

messages_uploadMedia::messages_uploadMedia()
  : peer_()
  , media_()
{}

messages_uploadMedia::messages_uploadMedia(object_ptr<InputPeer> &&peer_, object_ptr<InputMedia> &&media_)
  : peer_(std::move(peer_))
  , media_(std::move(media_))
{}

const std::int32_t messages_uploadMedia::ID;

void messages_uploadMedia::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1369162417);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(media_, s);
}

void messages_uploadMedia::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1369162417);
  TlStoreBoxedUnknown<TlStoreObject>::store(peer_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(media_, s);
}

void messages_uploadMedia::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "messages_uploadMedia");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (media_ == nullptr) { s.store_field("media", "null"); } else { media_->store(s, "media"); }
    s.store_class_end();
  }
}

messages_uploadMedia::ReturnType messages_uploadMedia::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<MessageMedia>::parse(p);
#undef FAIL
}

payments_clearSavedInfo::payments_clearSavedInfo()
  : flags_()
  , credentials_()
  , info_()
{}

payments_clearSavedInfo::payments_clearSavedInfo(std::int32_t flags_, bool credentials_, bool info_)
  : flags_(flags_)
  , credentials_(credentials_)
  , info_(info_)
{}

const std::int32_t payments_clearSavedInfo::ID;

void payments_clearSavedInfo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-667062079);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(credentials_, s); }
  if (var0 & 2) { TlStoreTrue::store(info_, s); }
}

void payments_clearSavedInfo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-667062079);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(credentials_, s); }
  if (var0 & 2) { TlStoreTrue::store(info_, s); }
}

void payments_clearSavedInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_clearSavedInfo");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (var0 & 2) {  }
    s.store_class_end();
  }
}

payments_clearSavedInfo::ReturnType payments_clearSavedInfo::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

payments_getPaymentForm::payments_getPaymentForm()
  : msg_id_()
{}

payments_getPaymentForm::payments_getPaymentForm(std::int32_t msg_id_)
  : msg_id_(msg_id_)
{}

const std::int32_t payments_getPaymentForm::ID;

void payments_getPaymentForm::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1712285883);
  TlStoreBinary::store(msg_id_, s);
}

void payments_getPaymentForm::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1712285883);
  TlStoreBinary::store(msg_id_, s);
}

void payments_getPaymentForm::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_getPaymentForm");
    s.store_field("msg_id", msg_id_);
    s.store_class_end();
  }
}

payments_getPaymentForm::ReturnType payments_getPaymentForm::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<payments_paymentForm>, 1062645411>::parse(p);
#undef FAIL
}

payments_getPaymentReceipt::payments_getPaymentReceipt()
  : msg_id_()
{}

payments_getPaymentReceipt::payments_getPaymentReceipt(std::int32_t msg_id_)
  : msg_id_(msg_id_)
{}

const std::int32_t payments_getPaymentReceipt::ID;

void payments_getPaymentReceipt::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1601001088);
  TlStoreBinary::store(msg_id_, s);
}

void payments_getPaymentReceipt::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1601001088);
  TlStoreBinary::store(msg_id_, s);
}

void payments_getPaymentReceipt::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_getPaymentReceipt");
    s.store_field("msg_id", msg_id_);
    s.store_class_end();
  }
}

payments_getPaymentReceipt::ReturnType payments_getPaymentReceipt::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<payments_paymentReceipt>, 1342771681>::parse(p);
#undef FAIL
}

payments_getSavedInfo::payments_getSavedInfo() {
}

const std::int32_t payments_getSavedInfo::ID;

void payments_getSavedInfo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(578650699);
}

void payments_getSavedInfo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(578650699);
}

void payments_getSavedInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_getSavedInfo");
    s.store_class_end();
  }
}

payments_getSavedInfo::ReturnType payments_getSavedInfo::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<payments_savedInfo>, -74456004>::parse(p);
#undef FAIL
}

payments_sendPaymentForm::payments_sendPaymentForm()
  : flags_()
  , msg_id_()
  , requested_info_id_()
  , shipping_option_id_()
  , credentials_()
{}

payments_sendPaymentForm::payments_sendPaymentForm(std::int32_t flags_, std::int32_t msg_id_, std::string const &requested_info_id_, std::string const &shipping_option_id_, object_ptr<InputPaymentCredentials> &&credentials_)
  : flags_(flags_)
  , msg_id_(msg_id_)
  , requested_info_id_(requested_info_id_)
  , shipping_option_id_(shipping_option_id_)
  , credentials_(std::move(credentials_))
{}

const std::int32_t payments_sendPaymentForm::ID;

void payments_sendPaymentForm::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(730364339);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBinary::store(msg_id_, s);
  if (var0 & 1) { TlStoreString::store(requested_info_id_, s); }
  if (var0 & 2) { TlStoreString::store(shipping_option_id_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(credentials_, s);
}

void payments_sendPaymentForm::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(730364339);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBinary::store(msg_id_, s);
  if (var0 & 1) { TlStoreString::store(requested_info_id_, s); }
  if (var0 & 2) { TlStoreString::store(shipping_option_id_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(credentials_, s);
}

void payments_sendPaymentForm::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_sendPaymentForm");
    s.store_field("flags", (var0 = flags_));
    s.store_field("msg_id", msg_id_);
    if (var0 & 1) { s.store_field("requested_info_id", requested_info_id_); }
    if (var0 & 2) { s.store_field("shipping_option_id", shipping_option_id_); }
    if (credentials_ == nullptr) { s.store_field("credentials", "null"); } else { credentials_->store(s, "credentials"); }
    s.store_class_end();
  }
}

payments_sendPaymentForm::ReturnType payments_sendPaymentForm::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<payments_PaymentResult>::parse(p);
#undef FAIL
}

payments_validateRequestedInfo::payments_validateRequestedInfo()
  : flags_()
  , save_()
  , msg_id_()
  , info_()
{}

payments_validateRequestedInfo::payments_validateRequestedInfo(std::int32_t flags_, bool save_, std::int32_t msg_id_, object_ptr<paymentRequestedInfo> &&info_)
  : flags_(flags_)
  , save_(save_)
  , msg_id_(msg_id_)
  , info_(std::move(info_))
{}

const std::int32_t payments_validateRequestedInfo::ID;

void payments_validateRequestedInfo::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1997180532);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(save_, s); }
  TlStoreBinary::store(msg_id_, s);
  TlStoreBoxed<TlStoreObject, -1868808300>::store(info_, s);
}

void payments_validateRequestedInfo::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1997180532);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(save_, s); }
  TlStoreBinary::store(msg_id_, s);
  TlStoreBoxed<TlStoreObject, -1868808300>::store(info_, s);
}

void payments_validateRequestedInfo::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "payments_validateRequestedInfo");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    s.store_field("msg_id", msg_id_);
    if (info_ == nullptr) { s.store_field("info", "null"); } else { info_->store(s, "info"); }
    s.store_class_end();
  }
}

payments_validateRequestedInfo::ReturnType payments_validateRequestedInfo::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<payments_validatedRequestedInfo>, -784000893>::parse(p);
#undef FAIL
}

phone_acceptCall::phone_acceptCall()
  : peer_()
  , g_b_()
  , protocol_()
{}

phone_acceptCall::phone_acceptCall(object_ptr<inputPhoneCall> &&peer_, BufferSlice &&g_b_, object_ptr<phoneCallProtocol> &&protocol_)
  : peer_(std::move(peer_))
  , g_b_(std::move(g_b_))
  , protocol_(std::move(protocol_))
{}

const std::int32_t phone_acceptCall::ID;

void phone_acceptCall::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1003664544);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreString::store(g_b_, s);
  TlStoreBoxed<TlStoreObject, -1564789301>::store(protocol_, s);
}

void phone_acceptCall::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1003664544);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreString::store(g_b_, s);
  TlStoreBoxed<TlStoreObject, -1564789301>::store(protocol_, s);
}

void phone_acceptCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_acceptCall");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_bytes_field("g_b", g_b_);
    if (protocol_ == nullptr) { s.store_field("protocol", "null"); } else { protocol_->store(s, "protocol"); }
    s.store_class_end();
  }
}

phone_acceptCall::ReturnType phone_acceptCall::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<phone_phoneCall>, -326966976>::parse(p);
#undef FAIL
}

phone_confirmCall::phone_confirmCall()
  : peer_()
  , g_a_()
  , key_fingerprint_()
  , protocol_()
{}

phone_confirmCall::phone_confirmCall(object_ptr<inputPhoneCall> &&peer_, BufferSlice &&g_a_, std::int64_t key_fingerprint_, object_ptr<phoneCallProtocol> &&protocol_)
  : peer_(std::move(peer_))
  , g_a_(std::move(g_a_))
  , key_fingerprint_(key_fingerprint_)
  , protocol_(std::move(protocol_))
{}

const std::int32_t phone_confirmCall::ID;

void phone_confirmCall::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(788404002);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreString::store(g_a_, s);
  TlStoreBinary::store(key_fingerprint_, s);
  TlStoreBoxed<TlStoreObject, -1564789301>::store(protocol_, s);
}

void phone_confirmCall::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(788404002);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreString::store(g_a_, s);
  TlStoreBinary::store(key_fingerprint_, s);
  TlStoreBoxed<TlStoreObject, -1564789301>::store(protocol_, s);
}

void phone_confirmCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_confirmCall");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_bytes_field("g_a", g_a_);
    s.store_field("key_fingerprint", key_fingerprint_);
    if (protocol_ == nullptr) { s.store_field("protocol", "null"); } else { protocol_->store(s, "protocol"); }
    s.store_class_end();
  }
}

phone_confirmCall::ReturnType phone_confirmCall::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<phone_phoneCall>, -326966976>::parse(p);
#undef FAIL
}

phone_discardCall::phone_discardCall()
  : peer_()
  , duration_()
  , reason_()
  , connection_id_()
{}

phone_discardCall::phone_discardCall(object_ptr<inputPhoneCall> &&peer_, std::int32_t duration_, object_ptr<PhoneCallDiscardReason> &&reason_, std::int64_t connection_id_)
  : peer_(std::move(peer_))
  , duration_(duration_)
  , reason_(std::move(reason_))
  , connection_id_(connection_id_)
{}

const std::int32_t phone_discardCall::ID;

void phone_discardCall::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(2027164582);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreBinary::store(duration_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(reason_, s);
  TlStoreBinary::store(connection_id_, s);
}

void phone_discardCall::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(2027164582);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreBinary::store(duration_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(reason_, s);
  TlStoreBinary::store(connection_id_, s);
}

void phone_discardCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_discardCall");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("duration", duration_);
    if (reason_ == nullptr) { s.store_field("reason", "null"); } else { reason_->store(s, "reason"); }
    s.store_field("connection_id", connection_id_);
    s.store_class_end();
  }
}

phone_discardCall::ReturnType phone_discardCall::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

phone_getCallConfig::phone_getCallConfig() {
}

const std::int32_t phone_getCallConfig::ID;

void phone_getCallConfig::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1430593449);
}

void phone_getCallConfig::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1430593449);
}

void phone_getCallConfig::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_getCallConfig");
    s.store_class_end();
  }
}

phone_getCallConfig::ReturnType phone_getCallConfig::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<dataJSON>, 2104790276>::parse(p);
#undef FAIL
}

phone_receivedCall::phone_receivedCall()
  : peer_()
{}

phone_receivedCall::phone_receivedCall(object_ptr<inputPhoneCall> &&peer_)
  : peer_(std::move(peer_))
{}

const std::int32_t phone_receivedCall::ID;

void phone_receivedCall::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(399855457);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
}

void phone_receivedCall::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(399855457);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
}

void phone_receivedCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_receivedCall");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_class_end();
  }
}

phone_receivedCall::ReturnType phone_receivedCall::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

phone_requestCall::phone_requestCall()
  : user_id_()
  , random_id_()
  , g_a_hash_()
  , protocol_()
{}

phone_requestCall::phone_requestCall(object_ptr<InputUser> &&user_id_, std::int32_t random_id_, BufferSlice &&g_a_hash_, object_ptr<phoneCallProtocol> &&protocol_)
  : user_id_(std::move(user_id_))
  , random_id_(random_id_)
  , g_a_hash_(std::move(g_a_hash_))
  , protocol_(std::move(protocol_))
{}

const std::int32_t phone_requestCall::ID;

void phone_requestCall::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1536537556);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(g_a_hash_, s);
  TlStoreBoxed<TlStoreObject, -1564789301>::store(protocol_, s);
}

void phone_requestCall::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1536537556);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(random_id_, s);
  TlStoreString::store(g_a_hash_, s);
  TlStoreBoxed<TlStoreObject, -1564789301>::store(protocol_, s);
}

void phone_requestCall::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_requestCall");
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("random_id", random_id_);
    s.store_bytes_field("g_a_hash", g_a_hash_);
    if (protocol_ == nullptr) { s.store_field("protocol", "null"); } else { protocol_->store(s, "protocol"); }
    s.store_class_end();
  }
}

phone_requestCall::ReturnType phone_requestCall::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<phone_phoneCall>, -326966976>::parse(p);
#undef FAIL
}

phone_saveCallDebug::phone_saveCallDebug()
  : peer_()
  , debug_()
{}

phone_saveCallDebug::phone_saveCallDebug(object_ptr<inputPhoneCall> &&peer_, object_ptr<dataJSON> &&debug_)
  : peer_(std::move(peer_))
  , debug_(std::move(debug_))
{}

const std::int32_t phone_saveCallDebug::ID;

void phone_saveCallDebug::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(662363518);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(debug_, s);
}

void phone_saveCallDebug::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(662363518);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreBoxed<TlStoreObject, 2104790276>::store(debug_, s);
}

void phone_saveCallDebug::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_saveCallDebug");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    if (debug_ == nullptr) { s.store_field("debug", "null"); } else { debug_->store(s, "debug"); }
    s.store_class_end();
  }
}

phone_saveCallDebug::ReturnType phone_saveCallDebug::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

phone_setCallRating::phone_setCallRating()
  : peer_()
  , rating_()
  , comment_()
{}

phone_setCallRating::phone_setCallRating(object_ptr<inputPhoneCall> &&peer_, std::int32_t rating_, std::string const &comment_)
  : peer_(std::move(peer_))
  , rating_(rating_)
  , comment_(comment_)
{}

const std::int32_t phone_setCallRating::ID;

void phone_setCallRating::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(475228724);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreBinary::store(rating_, s);
  TlStoreString::store(comment_, s);
}

void phone_setCallRating::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(475228724);
  TlStoreBoxed<TlStoreObject, 506920429>::store(peer_, s);
  TlStoreBinary::store(rating_, s);
  TlStoreString::store(comment_, s);
}

void phone_setCallRating::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "phone_setCallRating");
    if (peer_ == nullptr) { s.store_field("peer", "null"); } else { peer_->store(s, "peer"); }
    s.store_field("rating", rating_);
    s.store_field("comment", comment_);
    s.store_class_end();
  }
}

phone_setCallRating::ReturnType phone_setCallRating::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<Updates>::parse(p);
#undef FAIL
}

photos_deletePhotos::photos_deletePhotos()
  : id_()
{}

photos_deletePhotos::photos_deletePhotos(std::vector<object_ptr<InputPhoto>> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t photos_deletePhotos::ID;

void photos_deletePhotos::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2016444625);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void photos_deletePhotos::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2016444625);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void photos_deletePhotos::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photos_deletePhotos");
    { const std::vector<object_ptr<InputPhoto>> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

photos_deletePhotos::ReturnType photos_deletePhotos::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchLong>, 481674261>::parse(p);
#undef FAIL
}

photos_getUserPhotos::photos_getUserPhotos()
  : user_id_()
  , offset_()
  , max_id_()
  , limit_()
{}

photos_getUserPhotos::photos_getUserPhotos(object_ptr<InputUser> &&user_id_, std::int32_t offset_, std::int64_t max_id_, std::int32_t limit_)
  : user_id_(std::move(user_id_))
  , offset_(offset_)
  , max_id_(max_id_)
  , limit_(limit_)
{}

const std::int32_t photos_getUserPhotos::ID;

void photos_getUserPhotos::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1848823128);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(limit_, s);
}

void photos_getUserPhotos::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1848823128);
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(max_id_, s);
  TlStoreBinary::store(limit_, s);
}

void photos_getUserPhotos::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photos_getUserPhotos");
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("offset", offset_);
    s.store_field("max_id", max_id_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

photos_getUserPhotos::ReturnType photos_getUserPhotos::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<photos_Photos>::parse(p);
#undef FAIL
}

photos_updateProfilePhoto::photos_updateProfilePhoto()
  : id_()
{}

photos_updateProfilePhoto::photos_updateProfilePhoto(object_ptr<InputPhoto> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t photos_updateProfilePhoto::ID;

void photos_updateProfilePhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-256159406);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void photos_updateProfilePhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-256159406);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void photos_updateProfilePhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photos_updateProfilePhoto");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

photos_updateProfilePhoto::ReturnType photos_updateProfilePhoto::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<UserProfilePhoto>::parse(p);
#undef FAIL
}

photos_uploadProfilePhoto::photos_uploadProfilePhoto()
  : file_()
{}

photos_uploadProfilePhoto::photos_uploadProfilePhoto(object_ptr<InputFile> &&file_)
  : file_(std::move(file_))
{}

const std::int32_t photos_uploadProfilePhoto::ID;

void photos_uploadProfilePhoto::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1328726168);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
}

void photos_uploadProfilePhoto::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1328726168);
  TlStoreBoxedUnknown<TlStoreObject>::store(file_, s);
}

void photos_uploadProfilePhoto::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "photos_uploadProfilePhoto");
    if (file_ == nullptr) { s.store_field("file", "null"); } else { file_->store(s, "file"); }
    s.store_class_end();
  }
}

photos_uploadProfilePhoto::ReturnType photos_uploadProfilePhoto::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<photos_photo>, 539045032>::parse(p);
#undef FAIL
}

stickers_addStickerToSet::stickers_addStickerToSet()
  : stickerset_()
  , sticker_()
{}

stickers_addStickerToSet::stickers_addStickerToSet(object_ptr<InputStickerSet> &&stickerset_, object_ptr<inputStickerSetItem> &&sticker_)
  : stickerset_(std::move(stickerset_))
  , sticker_(std::move(sticker_))
{}

const std::int32_t stickers_addStickerToSet::ID;

void stickers_addStickerToSet::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-2041315650);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
  TlStoreBoxed<TlStoreObject, -6249322>::store(sticker_, s);
}

void stickers_addStickerToSet::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-2041315650);
  TlStoreBoxedUnknown<TlStoreObject>::store(stickerset_, s);
  TlStoreBoxed<TlStoreObject, -6249322>::store(sticker_, s);
}

void stickers_addStickerToSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "stickers_addStickerToSet");
    if (stickerset_ == nullptr) { s.store_field("stickerset", "null"); } else { stickerset_->store(s, "stickerset"); }
    if (sticker_ == nullptr) { s.store_field("sticker", "null"); } else { sticker_->store(s, "sticker"); }
    s.store_class_end();
  }
}

stickers_addStickerToSet::ReturnType stickers_addStickerToSet::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_stickerSet>, -1240849242>::parse(p);
#undef FAIL
}

stickers_changeStickerPosition::stickers_changeStickerPosition()
  : sticker_()
  , position_()
{}

stickers_changeStickerPosition::stickers_changeStickerPosition(object_ptr<InputDocument> &&sticker_, std::int32_t position_)
  : sticker_(std::move(sticker_))
  , position_(position_)
{}

const std::int32_t stickers_changeStickerPosition::ID;

void stickers_changeStickerPosition::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-4795190);
  TlStoreBoxedUnknown<TlStoreObject>::store(sticker_, s);
  TlStoreBinary::store(position_, s);
}

void stickers_changeStickerPosition::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-4795190);
  TlStoreBoxedUnknown<TlStoreObject>::store(sticker_, s);
  TlStoreBinary::store(position_, s);
}

void stickers_changeStickerPosition::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "stickers_changeStickerPosition");
    if (sticker_ == nullptr) { s.store_field("sticker", "null"); } else { sticker_->store(s, "sticker"); }
    s.store_field("position", position_);
    s.store_class_end();
  }
}

stickers_changeStickerPosition::ReturnType stickers_changeStickerPosition::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_stickerSet>, -1240849242>::parse(p);
#undef FAIL
}

stickers_createStickerSet::stickers_createStickerSet()
  : flags_()
  , masks_()
  , user_id_()
  , title_()
  , short_name_()
  , stickers_()
{}

stickers_createStickerSet::stickers_createStickerSet(std::int32_t flags_, bool masks_, object_ptr<InputUser> &&user_id_, std::string const &title_, std::string const &short_name_, std::vector<object_ptr<inputStickerSetItem>> &&stickers_)
  : flags_(flags_)
  , masks_(masks_)
  , user_id_(std::move(user_id_))
  , title_(title_)
  , short_name_(short_name_)
  , stickers_(std::move(stickers_))
{}

const std::int32_t stickers_createStickerSet::ID;

void stickers_createStickerSet::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1680314774);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(masks_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreString::store(title_, s);
  TlStoreString::store(short_name_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -6249322>>, 481674261>::store(stickers_, s);
}

void stickers_createStickerSet::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1680314774);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(masks_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(user_id_, s);
  TlStoreString::store(title_, s);
  TlStoreString::store(short_name_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxed<TlStoreObject, -6249322>>, 481674261>::store(stickers_, s);
}

void stickers_createStickerSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "stickers_createStickerSet");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (user_id_ == nullptr) { s.store_field("user_id", "null"); } else { user_id_->store(s, "user_id"); }
    s.store_field("title", title_);
    s.store_field("short_name", short_name_);
    { const std::vector<object_ptr<inputStickerSetItem>> &v = stickers_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("stickers", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

stickers_createStickerSet::ReturnType stickers_createStickerSet::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_stickerSet>, -1240849242>::parse(p);
#undef FAIL
}

stickers_removeStickerFromSet::stickers_removeStickerFromSet()
  : sticker_()
{}

stickers_removeStickerFromSet::stickers_removeStickerFromSet(object_ptr<InputDocument> &&sticker_)
  : sticker_(std::move(sticker_))
{}

const std::int32_t stickers_removeStickerFromSet::ID;

void stickers_removeStickerFromSet::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-143257775);
  TlStoreBoxedUnknown<TlStoreObject>::store(sticker_, s);
}

void stickers_removeStickerFromSet::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-143257775);
  TlStoreBoxedUnknown<TlStoreObject>::store(sticker_, s);
}

void stickers_removeStickerFromSet::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "stickers_removeStickerFromSet");
    if (sticker_ == nullptr) { s.store_field("sticker", "null"); } else { sticker_->store(s, "sticker"); }
    s.store_class_end();
  }
}

stickers_removeStickerFromSet::ReturnType stickers_removeStickerFromSet::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<messages_stickerSet>, -1240849242>::parse(p);
#undef FAIL
}

test_useConfigSimple::test_useConfigSimple() {
}

const std::int32_t test_useConfigSimple::ID;

void test_useConfigSimple::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-105401795);
}

void test_useConfigSimple::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-105401795);
}

void test_useConfigSimple::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "test_useConfigSimple");
    s.store_class_end();
  }
}

test_useConfigSimple::ReturnType test_useConfigSimple::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<help_configSimple>, 1515793004>::parse(p);
#undef FAIL
}

test_useError::test_useError() {
}

const std::int32_t test_useError::ID;

void test_useError::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-294277375);
}

void test_useError::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-294277375);
}

void test_useError::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "test_useError");
    s.store_class_end();
  }
}

test_useError::ReturnType test_useError::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<error>, -994444869>::parse(p);
#undef FAIL
}

updates_getChannelDifference::updates_getChannelDifference()
  : flags_()
  , force_()
  , channel_()
  , filter_()
  , pts_()
  , limit_()
{}

updates_getChannelDifference::updates_getChannelDifference(std::int32_t flags_, bool force_, object_ptr<InputChannel> &&channel_, object_ptr<ChannelMessagesFilter> &&filter_, std::int32_t pts_, std::int32_t limit_)
  : flags_(flags_)
  , force_(force_)
  , channel_(std::move(channel_))
  , filter_(std::move(filter_))
  , pts_(pts_)
  , limit_(limit_)
{}

const std::int32_t updates_getChannelDifference::ID;

void updates_getChannelDifference::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(51854712);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(force_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(filter_, s);
  TlStoreBinary::store(pts_, s);
  TlStoreBinary::store(limit_, s);
}

void updates_getChannelDifference::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(51854712);
  TlStoreBinary::store((var0 = flags_), s);
  if (var0 & 1) { TlStoreTrue::store(force_, s); }
  TlStoreBoxedUnknown<TlStoreObject>::store(channel_, s);
  TlStoreBoxedUnknown<TlStoreObject>::store(filter_, s);
  TlStoreBinary::store(pts_, s);
  TlStoreBinary::store(limit_, s);
}

void updates_getChannelDifference::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_getChannelDifference");
    s.store_field("flags", (var0 = flags_));
    if (var0 & 1) {  }
    if (channel_ == nullptr) { s.store_field("channel", "null"); } else { channel_->store(s, "channel"); }
    if (filter_ == nullptr) { s.store_field("filter", "null"); } else { filter_->store(s, "filter"); }
    s.store_field("pts", pts_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

updates_getChannelDifference::ReturnType updates_getChannelDifference::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<updates_ChannelDifference>::parse(p);
#undef FAIL
}

updates_getDifference::updates_getDifference()
  : flags_()
  , pts_()
  , pts_total_limit_()
  , date_()
  , qts_()
{}

updates_getDifference::updates_getDifference(std::int32_t flags_, std::int32_t pts_, std::int32_t pts_total_limit_, std::int32_t date_, std::int32_t qts_)
  : flags_(flags_)
  , pts_(pts_)
  , pts_total_limit_(pts_total_limit_)
  , date_(date_)
  , qts_(qts_)
{}

const std::int32_t updates_getDifference::ID;

void updates_getDifference::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(630429265);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBinary::store(pts_, s);
  if (var0 & 1) { TlStoreBinary::store(pts_total_limit_, s); }
  TlStoreBinary::store(date_, s);
  TlStoreBinary::store(qts_, s);
}

void updates_getDifference::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(630429265);
  TlStoreBinary::store((var0 = flags_), s);
  TlStoreBinary::store(pts_, s);
  if (var0 & 1) { TlStoreBinary::store(pts_total_limit_, s); }
  TlStoreBinary::store(date_, s);
  TlStoreBinary::store(qts_, s);
}

void updates_getDifference::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_getDifference");
    s.store_field("flags", (var0 = flags_));
    s.store_field("pts", pts_);
    if (var0 & 1) { s.store_field("pts_total_limit", pts_total_limit_); }
    s.store_field("date", date_);
    s.store_field("qts", qts_);
    s.store_class_end();
  }
}

updates_getDifference::ReturnType updates_getDifference::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<updates_Difference>::parse(p);
#undef FAIL
}

updates_getState::updates_getState() {
}

const std::int32_t updates_getState::ID;

void updates_getState::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-304838614);
}

void updates_getState::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-304838614);
}

void updates_getState::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "updates_getState");
    s.store_class_end();
  }
}

updates_getState::ReturnType updates_getState::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<updates_state>, -1519637954>::parse(p);
#undef FAIL
}

upload_getCdnFile::upload_getCdnFile()
  : file_token_()
  , offset_()
  , limit_()
{}

upload_getCdnFile::upload_getCdnFile(BufferSlice &&file_token_, std::int32_t offset_, std::int32_t limit_)
  : file_token_(std::move(file_token_))
  , offset_(offset_)
  , limit_(limit_)
{}

const std::int32_t upload_getCdnFile::ID;

void upload_getCdnFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(536919235);
  TlStoreString::store(file_token_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
}

void upload_getCdnFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(536919235);
  TlStoreString::store(file_token_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
}

void upload_getCdnFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_getCdnFile");
    s.store_bytes_field("file_token", file_token_);
    s.store_field("offset", offset_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

upload_getCdnFile::ReturnType upload_getCdnFile::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<upload_CdnFile>::parse(p);
#undef FAIL
}

upload_getCdnFileHashes::upload_getCdnFileHashes()
  : file_token_()
  , offset_()
{}

upload_getCdnFileHashes::upload_getCdnFileHashes(BufferSlice &&file_token_, std::int32_t offset_)
  : file_token_(std::move(file_token_))
  , offset_(offset_)
{}

const std::int32_t upload_getCdnFileHashes::ID;

void upload_getCdnFileHashes::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(1302676017);
  TlStoreString::store(file_token_, s);
  TlStoreBinary::store(offset_, s);
}

void upload_getCdnFileHashes::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(1302676017);
  TlStoreString::store(file_token_, s);
  TlStoreBinary::store(offset_, s);
}

void upload_getCdnFileHashes::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_getCdnFileHashes");
    s.store_bytes_field("file_token", file_token_);
    s.store_field("offset", offset_);
    s.store_class_end();
  }
}

upload_getCdnFileHashes::ReturnType upload_getCdnFileHashes::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<fileHash>, 1648543603>>, 481674261>::parse(p);
#undef FAIL
}

upload_getFile::upload_getFile()
  : location_()
  , offset_()
  , limit_()
{}

upload_getFile::upload_getFile(object_ptr<InputFileLocation> &&location_, std::int32_t offset_, std::int32_t limit_)
  : location_(std::move(location_))
  , offset_(offset_)
  , limit_(limit_)
{}

const std::int32_t upload_getFile::ID;

void upload_getFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-475607115);
  TlStoreBoxedUnknown<TlStoreObject>::store(location_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
}

void upload_getFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-475607115);
  TlStoreBoxedUnknown<TlStoreObject>::store(location_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
}

void upload_getFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_getFile");
    if (location_ == nullptr) { s.store_field("location", "null"); } else { location_->store(s, "location"); }
    s.store_field("offset", offset_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

upload_getFile::ReturnType upload_getFile::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchObject<upload_File>::parse(p);
#undef FAIL
}

upload_getFileHashes::upload_getFileHashes()
  : location_()
  , offset_()
{}

upload_getFileHashes::upload_getFileHashes(object_ptr<InputFileLocation> &&location_, std::int32_t offset_)
  : location_(std::move(location_))
  , offset_(offset_)
{}

const std::int32_t upload_getFileHashes::ID;

void upload_getFileHashes::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-956147407);
  TlStoreBoxedUnknown<TlStoreObject>::store(location_, s);
  TlStoreBinary::store(offset_, s);
}

void upload_getFileHashes::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-956147407);
  TlStoreBoxedUnknown<TlStoreObject>::store(location_, s);
  TlStoreBinary::store(offset_, s);
}

void upload_getFileHashes::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_getFileHashes");
    if (location_ == nullptr) { s.store_field("location", "null"); } else { location_->store(s, "location"); }
    s.store_field("offset", offset_);
    s.store_class_end();
  }
}

upload_getFileHashes::ReturnType upload_getFileHashes::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<fileHash>, 1648543603>>, 481674261>::parse(p);
#undef FAIL
}

upload_getWebFile::upload_getWebFile()
  : location_()
  , offset_()
  , limit_()
{}

upload_getWebFile::upload_getWebFile(object_ptr<InputWebFileLocation> &&location_, std::int32_t offset_, std::int32_t limit_)
  : location_(std::move(location_))
  , offset_(offset_)
  , limit_(limit_)
{}

const std::int32_t upload_getWebFile::ID;

void upload_getWebFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(619086221);
  TlStoreBoxedUnknown<TlStoreObject>::store(location_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
}

void upload_getWebFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(619086221);
  TlStoreBoxedUnknown<TlStoreObject>::store(location_, s);
  TlStoreBinary::store(offset_, s);
  TlStoreBinary::store(limit_, s);
}

void upload_getWebFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_getWebFile");
    if (location_ == nullptr) { s.store_field("location", "null"); } else { location_->store(s, "location"); }
    s.store_field("offset", offset_);
    s.store_field("limit", limit_);
    s.store_class_end();
  }
}

upload_getWebFile::ReturnType upload_getWebFile::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<upload_webFile>, 568808380>::parse(p);
#undef FAIL
}

upload_reuploadCdnFile::upload_reuploadCdnFile()
  : file_token_()
  , request_token_()
{}

upload_reuploadCdnFile::upload_reuploadCdnFile(BufferSlice &&file_token_, BufferSlice &&request_token_)
  : file_token_(std::move(file_token_))
  , request_token_(std::move(request_token_))
{}

const std::int32_t upload_reuploadCdnFile::ID;

void upload_reuploadCdnFile::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1691921240);
  TlStoreString::store(file_token_, s);
  TlStoreString::store(request_token_, s);
}

void upload_reuploadCdnFile::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1691921240);
  TlStoreString::store(file_token_, s);
  TlStoreString::store(request_token_, s);
}

void upload_reuploadCdnFile::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_reuploadCdnFile");
    s.store_bytes_field("file_token", file_token_);
    s.store_bytes_field("request_token", request_token_);
    s.store_class_end();
  }
}

upload_reuploadCdnFile::ReturnType upload_reuploadCdnFile::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchBoxed<TlFetchObject<fileHash>, 1648543603>>, 481674261>::parse(p);
#undef FAIL
}

upload_saveBigFilePart::upload_saveBigFilePart()
  : file_id_()
  , file_part_()
  , file_total_parts_()
  , bytes_()
{}

upload_saveBigFilePart::upload_saveBigFilePart(std::int64_t file_id_, std::int32_t file_part_, std::int32_t file_total_parts_, BufferSlice &&bytes_)
  : file_id_(file_id_)
  , file_part_(file_part_)
  , file_total_parts_(file_total_parts_)
  , bytes_(std::move(bytes_))
{}

const std::int32_t upload_saveBigFilePart::ID;

void upload_saveBigFilePart::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-562337987);
  TlStoreBinary::store(file_id_, s);
  TlStoreBinary::store(file_part_, s);
  TlStoreBinary::store(file_total_parts_, s);
  TlStoreString::store(bytes_, s);
}

void upload_saveBigFilePart::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-562337987);
  TlStoreBinary::store(file_id_, s);
  TlStoreBinary::store(file_part_, s);
  TlStoreBinary::store(file_total_parts_, s);
  TlStoreString::store(bytes_, s);
}

void upload_saveBigFilePart::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_saveBigFilePart");
    s.store_field("file_id", file_id_);
    s.store_field("file_part", file_part_);
    s.store_field("file_total_parts", file_total_parts_);
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

upload_saveBigFilePart::ReturnType upload_saveBigFilePart::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

upload_saveFilePart::upload_saveFilePart()
  : file_id_()
  , file_part_()
  , bytes_()
{}

upload_saveFilePart::upload_saveFilePart(std::int64_t file_id_, std::int32_t file_part_, BufferSlice &&bytes_)
  : file_id_(file_id_)
  , file_part_(file_part_)
  , bytes_(std::move(bytes_))
{}

const std::int32_t upload_saveFilePart::ID;

void upload_saveFilePart::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1291540959);
  TlStoreBinary::store(file_id_, s);
  TlStoreBinary::store(file_part_, s);
  TlStoreString::store(bytes_, s);
}

void upload_saveFilePart::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1291540959);
  TlStoreBinary::store(file_id_, s);
  TlStoreBinary::store(file_part_, s);
  TlStoreString::store(bytes_, s);
}

void upload_saveFilePart::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "upload_saveFilePart");
    s.store_field("file_id", file_id_);
    s.store_field("file_part", file_part_);
    s.store_bytes_field("bytes", bytes_);
    s.store_class_end();
  }
}

upload_saveFilePart::ReturnType upload_saveFilePart::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}

users_getFullUser::users_getFullUser()
  : id_()
{}

users_getFullUser::users_getFullUser(object_ptr<InputUser> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t users_getFullUser::ID;

void users_getFullUser::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-902781519);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void users_getFullUser::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-902781519);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
}

void users_getFullUser::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "users_getFullUser");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    s.store_class_end();
  }
}

users_getFullUser::ReturnType users_getFullUser::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchObject<userFull>, 253890367>::parse(p);
#undef FAIL
}

users_getUsers::users_getUsers()
  : id_()
{}

users_getUsers::users_getUsers(std::vector<object_ptr<InputUser>> &&id_)
  : id_(std::move(id_))
{}

const std::int32_t users_getUsers::ID;

void users_getUsers::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(227648840);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void users_getUsers::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(227648840);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(id_, s);
}

void users_getUsers::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "users_getUsers");
    { const std::vector<object_ptr<InputUser>> &v = id_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("id", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

users_getUsers::ReturnType users_getUsers::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBoxed<TlFetchVector<TlFetchObject<User>>, 481674261>::parse(p);
#undef FAIL
}

users_setSecureValueErrors::users_setSecureValueErrors()
  : id_()
  , errors_()
{}

users_setSecureValueErrors::users_setSecureValueErrors(object_ptr<InputUser> &&id_, std::vector<object_ptr<SecureValueError>> &&errors_)
  : id_(std::move(id_))
  , errors_(std::move(errors_))
{}

const std::int32_t users_setSecureValueErrors::ID;

void users_setSecureValueErrors::store(TlStorerCalcLength &s) const {
  (void)sizeof(s);
  s.store_binary(-1865902923);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(errors_, s);
}

void users_setSecureValueErrors::store(TlStorerUnsafe &s) const {
  (void)sizeof(s);
  s.store_binary(-1865902923);
  TlStoreBoxedUnknown<TlStoreObject>::store(id_, s);
  TlStoreBoxed<TlStoreVector<TlStoreBoxedUnknown<TlStoreObject>>, 481674261>::store(errors_, s);
}

void users_setSecureValueErrors::store(TlStorerToString &s, const char *field_name) const {
  if (!LOG_IS_STRIPPED(ERROR)) {
    s.store_class_begin(field_name, "users_setSecureValueErrors");
    if (id_ == nullptr) { s.store_field("id", "null"); } else { id_->store(s, "id"); }
    { const std::vector<object_ptr<SecureValueError>> &v = errors_; const std::uint32_t multiplicity = static_cast<std::uint32_t>(v.size()); const auto vector_name = "vector[" + td::to_string(multiplicity)+ "]"; s.store_class_begin("errors", vector_name.c_str()); for (std::uint32_t i = 0; i < multiplicity; i++) { if (v[i] == nullptr) { s.store_field("", "null"); } else { v[i]->store(s, ""); } } s.store_class_end(); }
    s.store_class_end();
  }
}

users_setSecureValueErrors::ReturnType users_setSecureValueErrors::fetch_result(TlBufferParser &p) {
#define FAIL(error) p.set_error(error); return ReturnType()
  return TlFetchBool::parse(p);
#undef FAIL
}
}  // namespace telegram_api
}  // namespace td
